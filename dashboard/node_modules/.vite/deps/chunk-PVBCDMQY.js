import {
  require_node_http
} from "./chunk-IW3LQANO.js";
import {
  require_node_https
} from "./chunk-6IMP2RGD.js";
import {
  require_resolve
} from "./chunk-XKRNXR2R.js";
import {
  require_node_module,
  require_node_path,
  require_node_url
} from "./chunk-UCNWLDIN.js";
import {
  require_url
} from "./chunk-CCFGRLTF.js";
import {
  require_os
} from "./chunk-OWJ62KFV.js";
import {
  require_fs,
  require_path
} from "./chunk-E6DHKMSI.js";
import {
  __commonJS,
  __require,
  __toESM
} from "./chunk-62VDRKYJ.js";

// browser-external:node:fs
var require_node_fs = __commonJS({
  "browser-external:node:fs"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "node:fs" has been externalized for browser compatibility. Cannot access "node:fs.${key2}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:node:perf_hooks
var require_node_perf_hooks = __commonJS({
  "browser-external:node:perf_hooks"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "node:perf_hooks" has been externalized for browser compatibility. Cannot access "node:perf_hooks.${key2}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:tty
var require_tty = __commonJS({
  "browser-external:tty"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "tty" has been externalized for browser compatibility. Cannot access "tty.${key2}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:child_process
var require_child_process = __commonJS({
  "browser-external:child_process"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "child_process" has been externalized for browser compatibility. Cannot access "child_process.${key2}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key2}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:worker_threads
var require_worker_threads = __commonJS({
  "browser-external:worker_threads"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "worker_threads" has been externalized for browser compatibility. Cannot access "worker_threads.${key2}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/esbuild/lib/main.js
var require_main = __commonJS({
  "node_modules/esbuild/lib/main.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key2 of __getOwnPropNames(from))
          if (!__hasOwnProp2.call(to, key2) && key2 !== except)
            __defProp2(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
    var node_exports = {};
    __export(node_exports, {
      analyzeMetafile: () => analyzeMetafile,
      analyzeMetafileSync: () => analyzeMetafileSync,
      build: () => build2,
      buildSync: () => buildSync,
      default: () => node_default,
      formatMessages: () => formatMessages2,
      formatMessagesSync: () => formatMessagesSync,
      initialize: () => initialize,
      serve: () => serve,
      transform: () => transform2,
      transformSync: () => transformSync,
      version: () => version3
    });
    module2.exports = __toCommonJS(node_exports);
    function encodePacket(packet) {
      let visit2 = (value2) => {
        if (value2 === null) {
          bb.write8(0);
        } else if (typeof value2 === "boolean") {
          bb.write8(1);
          bb.write8(+value2);
        } else if (typeof value2 === "number") {
          bb.write8(2);
          bb.write32(value2 | 0);
        } else if (typeof value2 === "string") {
          bb.write8(3);
          bb.write(encodeUTF8(value2));
        } else if (value2 instanceof Uint8Array) {
          bb.write8(4);
          bb.write(value2);
        } else if (value2 instanceof Array) {
          bb.write8(5);
          bb.write32(value2.length);
          for (let item of value2) {
            visit2(item);
          }
        } else {
          let keys = Object.keys(value2);
          bb.write8(6);
          bb.write32(keys.length);
          for (let key2 of keys) {
            bb.write(encodeUTF8(key2));
            visit2(value2[key2]);
          }
        }
      };
      let bb = new ByteBuffer();
      bb.write32(0);
      bb.write32(packet.id << 1 | +!packet.isRequest);
      visit2(packet.value);
      writeUInt32LE(bb.buf, bb.len - 4, 0);
      return bb.buf.subarray(0, bb.len);
    }
    function decodePacket(bytes) {
      let visit2 = () => {
        switch (bb.read8()) {
          case 0:
            return null;
          case 1:
            return !!bb.read8();
          case 2:
            return bb.read32();
          case 3:
            return decodeUTF8(bb.read());
          case 4:
            return bb.read();
          case 5: {
            let count = bb.read32();
            let value22 = [];
            for (let i = 0; i < count; i++) {
              value22.push(visit2());
            }
            return value22;
          }
          case 6: {
            let count = bb.read32();
            let value22 = {};
            for (let i = 0; i < count; i++) {
              value22[decodeUTF8(bb.read())] = visit2();
            }
            return value22;
          }
          default:
            throw new Error("Invalid packet");
        }
      };
      let bb = new ByteBuffer(bytes);
      let id = bb.read32();
      let isRequest = (id & 1) === 0;
      id >>>= 1;
      let value2 = visit2();
      if (bb.ptr !== bytes.length) {
        throw new Error("Invalid packet");
      }
      return { id, isRequest, value: value2 };
    }
    var ByteBuffer = class {
      constructor(buf = new Uint8Array(1024)) {
        this.buf = buf;
        this.len = 0;
        this.ptr = 0;
      }
      _write(delta) {
        if (this.len + delta > this.buf.length) {
          let clone = new Uint8Array((this.len + delta) * 2);
          clone.set(this.buf);
          this.buf = clone;
        }
        this.len += delta;
        return this.len - delta;
      }
      write8(value2) {
        let offset3 = this._write(1);
        this.buf[offset3] = value2;
      }
      write32(value2) {
        let offset3 = this._write(4);
        writeUInt32LE(this.buf, value2, offset3);
      }
      write(bytes) {
        let offset3 = this._write(4 + bytes.length);
        writeUInt32LE(this.buf, bytes.length, offset3);
        this.buf.set(bytes, offset3 + 4);
      }
      _read(delta) {
        if (this.ptr + delta > this.buf.length) {
          throw new Error("Invalid packet");
        }
        this.ptr += delta;
        return this.ptr - delta;
      }
      read8() {
        return this.buf[this._read(1)];
      }
      read32() {
        return readUInt32LE(this.buf, this._read(4));
      }
      read() {
        let length = this.read32();
        let bytes = new Uint8Array(length);
        let ptr = this._read(bytes.length);
        bytes.set(this.buf.subarray(ptr, ptr + length));
        return bytes;
      }
    };
    var encodeUTF8;
    var decodeUTF8;
    if (typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined") {
      let encoder = new TextEncoder();
      let decoder = new TextDecoder();
      encodeUTF8 = (text) => encoder.encode(text);
      decodeUTF8 = (bytes) => decoder.decode(bytes);
    } else if (typeof Buffer !== "undefined") {
      encodeUTF8 = (text) => {
        let buffer2 = Buffer.from(text);
        if (!(buffer2 instanceof Uint8Array)) {
          buffer2 = new Uint8Array(buffer2);
        }
        return buffer2;
      };
      decodeUTF8 = (bytes) => {
        let { buffer: buffer2, byteOffset, byteLength } = bytes;
        return Buffer.from(buffer2, byteOffset, byteLength).toString();
      };
    } else {
      throw new Error("No UTF-8 codec found");
    }
    function readUInt32LE(buffer2, offset3) {
      return buffer2[offset3++] | buffer2[offset3++] << 8 | buffer2[offset3++] << 16 | buffer2[offset3++] << 24;
    }
    function writeUInt32LE(buffer2, value2, offset3) {
      buffer2[offset3++] = value2;
      buffer2[offset3++] = value2 >> 8;
      buffer2[offset3++] = value2 >> 16;
      buffer2[offset3++] = value2 >> 24;
    }
    var buildLogLevelDefault = "warning";
    var transformLogLevelDefault = "silent";
    function validateTarget(target) {
      target += "";
      if (target.indexOf(",") >= 0)
        throw new Error(`Invalid target: ${target}`);
      return target;
    }
    var canBeAnything = () => null;
    var mustBeBoolean = (value2) => typeof value2 === "boolean" ? null : "a boolean";
    var mustBeBooleanOrObject = (value2) => typeof value2 === "boolean" || typeof value2 === "object" && !Array.isArray(value2) ? null : "a boolean or an object";
    var mustBeString = (value2) => typeof value2 === "string" ? null : "a string";
    var mustBeRegExp = (value2) => value2 instanceof RegExp ? null : "a RegExp object";
    var mustBeInteger = (value2) => typeof value2 === "number" && value2 === (value2 | 0) ? null : "an integer";
    var mustBeFunction = (value2) => typeof value2 === "function" ? null : "a function";
    var mustBeArray = (value2) => Array.isArray(value2) ? null : "an array";
    var mustBeObject = (value2) => typeof value2 === "object" && value2 !== null && !Array.isArray(value2) ? null : "an object";
    var mustBeWebAssemblyModule = (value2) => value2 instanceof WebAssembly.Module ? null : "a WebAssembly.Module";
    var mustBeArrayOrRecord = (value2) => typeof value2 === "object" && value2 !== null ? null : "an array or an object";
    var mustBeObjectOrNull = (value2) => typeof value2 === "object" && !Array.isArray(value2) ? null : "an object or null";
    var mustBeStringOrBoolean = (value2) => typeof value2 === "string" || typeof value2 === "boolean" ? null : "a string or a boolean";
    var mustBeStringOrObject = (value2) => typeof value2 === "string" || typeof value2 === "object" && value2 !== null && !Array.isArray(value2) ? null : "a string or an object";
    var mustBeStringOrArray = (value2) => typeof value2 === "string" || Array.isArray(value2) ? null : "a string or an array";
    var mustBeStringOrUint8Array = (value2) => typeof value2 === "string" || value2 instanceof Uint8Array ? null : "a string or a Uint8Array";
    function getFlag(object, keys, key2, mustBeFn) {
      let value2 = object[key2];
      keys[key2 + ""] = true;
      if (value2 === void 0)
        return void 0;
      let mustBe = mustBeFn(value2);
      if (mustBe !== null)
        throw new Error(`"${key2}" must be ${mustBe}`);
      return value2;
    }
    function checkForInvalidFlags(object, keys, where) {
      for (let key2 in object) {
        if (!(key2 in keys)) {
          throw new Error(`Invalid option ${where}: "${key2}"`);
        }
      }
    }
    function validateInitializeOptions(options3) {
      let keys = /* @__PURE__ */ Object.create(null);
      let wasmURL = getFlag(options3, keys, "wasmURL", mustBeString);
      let wasmModule = getFlag(options3, keys, "wasmModule", mustBeWebAssemblyModule);
      let worker = getFlag(options3, keys, "worker", mustBeBoolean);
      checkForInvalidFlags(options3, keys, "in initialize() call");
      return {
        wasmURL,
        wasmModule,
        worker
      };
    }
    function validateMangleCache(mangleCache) {
      let validated;
      if (mangleCache !== void 0) {
        validated = /* @__PURE__ */ Object.create(null);
        for (let key2 of Object.keys(mangleCache)) {
          let value2 = mangleCache[key2];
          if (typeof value2 === "string" || value2 === false) {
            validated[key2] = value2;
          } else {
            throw new Error(`Expected ${JSON.stringify(key2)} in mangle cache to map to either a string or false`);
          }
        }
      }
      return validated;
    }
    function pushLogFlags(flags, options3, keys, isTTY2, logLevelDefault) {
      let color = getFlag(options3, keys, "color", mustBeBoolean);
      let logLevel = getFlag(options3, keys, "logLevel", mustBeString);
      let logLimit = getFlag(options3, keys, "logLimit", mustBeInteger);
      if (color !== void 0)
        flags.push(`--color=${color}`);
      else if (isTTY2)
        flags.push(`--color=true`);
      flags.push(`--log-level=${logLevel || logLevelDefault}`);
      flags.push(`--log-limit=${logLimit || 0}`);
    }
    function pushCommonFlags(flags, options3, keys) {
      let legalComments = getFlag(options3, keys, "legalComments", mustBeString);
      let sourceRoot = getFlag(options3, keys, "sourceRoot", mustBeString);
      let sourcesContent = getFlag(options3, keys, "sourcesContent", mustBeBoolean);
      let target = getFlag(options3, keys, "target", mustBeStringOrArray);
      let format2 = getFlag(options3, keys, "format", mustBeString);
      let globalName = getFlag(options3, keys, "globalName", mustBeString);
      let mangleProps = getFlag(options3, keys, "mangleProps", mustBeRegExp);
      let reserveProps = getFlag(options3, keys, "reserveProps", mustBeRegExp);
      let mangleQuoted = getFlag(options3, keys, "mangleQuoted", mustBeBoolean);
      let minify = getFlag(options3, keys, "minify", mustBeBoolean);
      let minifySyntax = getFlag(options3, keys, "minifySyntax", mustBeBoolean);
      let minifyWhitespace = getFlag(options3, keys, "minifyWhitespace", mustBeBoolean);
      let minifyIdentifiers = getFlag(options3, keys, "minifyIdentifiers", mustBeBoolean);
      let drop = getFlag(options3, keys, "drop", mustBeArray);
      let charset = getFlag(options3, keys, "charset", mustBeString);
      let treeShaking = getFlag(options3, keys, "treeShaking", mustBeBoolean);
      let ignoreAnnotations = getFlag(options3, keys, "ignoreAnnotations", mustBeBoolean);
      let jsx = getFlag(options3, keys, "jsx", mustBeString);
      let jsxFactory = getFlag(options3, keys, "jsxFactory", mustBeString);
      let jsxFragment = getFlag(options3, keys, "jsxFragment", mustBeString);
      let jsxImportSource = getFlag(options3, keys, "jsxImportSource", mustBeString);
      let jsxDev = getFlag(options3, keys, "jsxDev", mustBeBoolean);
      let jsxSideEffects = getFlag(options3, keys, "jsxSideEffects", mustBeBoolean);
      let define = getFlag(options3, keys, "define", mustBeObject);
      let logOverride = getFlag(options3, keys, "logOverride", mustBeObject);
      let supported = getFlag(options3, keys, "supported", mustBeObject);
      let pure = getFlag(options3, keys, "pure", mustBeArray);
      let keepNames = getFlag(options3, keys, "keepNames", mustBeBoolean);
      let platform2 = getFlag(options3, keys, "platform", mustBeString);
      if (legalComments)
        flags.push(`--legal-comments=${legalComments}`);
      if (sourceRoot !== void 0)
        flags.push(`--source-root=${sourceRoot}`);
      if (sourcesContent !== void 0)
        flags.push(`--sources-content=${sourcesContent}`);
      if (target) {
        if (Array.isArray(target))
          flags.push(`--target=${Array.from(target).map(validateTarget).join(",")}`);
        else
          flags.push(`--target=${validateTarget(target)}`);
      }
      if (format2)
        flags.push(`--format=${format2}`);
      if (globalName)
        flags.push(`--global-name=${globalName}`);
      if (platform2)
        flags.push(`--platform=${platform2}`);
      if (minify)
        flags.push("--minify");
      if (minifySyntax)
        flags.push("--minify-syntax");
      if (minifyWhitespace)
        flags.push("--minify-whitespace");
      if (minifyIdentifiers)
        flags.push("--minify-identifiers");
      if (charset)
        flags.push(`--charset=${charset}`);
      if (treeShaking !== void 0)
        flags.push(`--tree-shaking=${treeShaking}`);
      if (ignoreAnnotations)
        flags.push(`--ignore-annotations`);
      if (drop)
        for (let what of drop)
          flags.push(`--drop:${what}`);
      if (mangleProps)
        flags.push(`--mangle-props=${mangleProps.source}`);
      if (reserveProps)
        flags.push(`--reserve-props=${reserveProps.source}`);
      if (mangleQuoted !== void 0)
        flags.push(`--mangle-quoted=${mangleQuoted}`);
      if (jsx)
        flags.push(`--jsx=${jsx}`);
      if (jsxFactory)
        flags.push(`--jsx-factory=${jsxFactory}`);
      if (jsxFragment)
        flags.push(`--jsx-fragment=${jsxFragment}`);
      if (jsxImportSource)
        flags.push(`--jsx-import-source=${jsxImportSource}`);
      if (jsxDev)
        flags.push(`--jsx-dev`);
      if (jsxSideEffects)
        flags.push(`--jsx-side-effects`);
      if (define) {
        for (let key2 in define) {
          if (key2.indexOf("=") >= 0)
            throw new Error(`Invalid define: ${key2}`);
          flags.push(`--define:${key2}=${define[key2]}`);
        }
      }
      if (logOverride) {
        for (let key2 in logOverride) {
          if (key2.indexOf("=") >= 0)
            throw new Error(`Invalid log override: ${key2}`);
          flags.push(`--log-override:${key2}=${logOverride[key2]}`);
        }
      }
      if (supported) {
        for (let key2 in supported) {
          if (key2.indexOf("=") >= 0)
            throw new Error(`Invalid supported: ${key2}`);
          flags.push(`--supported:${key2}=${supported[key2]}`);
        }
      }
      if (pure)
        for (let fn of pure)
          flags.push(`--pure:${fn}`);
      if (keepNames)
        flags.push(`--keep-names`);
    }
    function flagsForBuildOptions(callName, options3, isTTY2, logLevelDefault, writeDefault) {
      var _a2;
      let flags = [];
      let entries = [];
      let keys = /* @__PURE__ */ Object.create(null);
      let stdinContents = null;
      let stdinResolveDir = null;
      let watchMode = null;
      pushLogFlags(flags, options3, keys, isTTY2, logLevelDefault);
      pushCommonFlags(flags, options3, keys);
      let sourcemap = getFlag(options3, keys, "sourcemap", mustBeStringOrBoolean);
      let bundle = getFlag(options3, keys, "bundle", mustBeBoolean);
      let watch2 = getFlag(options3, keys, "watch", mustBeBooleanOrObject);
      let splitting = getFlag(options3, keys, "splitting", mustBeBoolean);
      let preserveSymlinks = getFlag(options3, keys, "preserveSymlinks", mustBeBoolean);
      let metafile = getFlag(options3, keys, "metafile", mustBeBoolean);
      let outfile = getFlag(options3, keys, "outfile", mustBeString);
      let outdir = getFlag(options3, keys, "outdir", mustBeString);
      let outbase = getFlag(options3, keys, "outbase", mustBeString);
      let tsconfig = getFlag(options3, keys, "tsconfig", mustBeString);
      let resolveExtensions2 = getFlag(options3, keys, "resolveExtensions", mustBeArray);
      let nodePathsInput = getFlag(options3, keys, "nodePaths", mustBeArray);
      let mainFields = getFlag(options3, keys, "mainFields", mustBeArray);
      let conditions = getFlag(options3, keys, "conditions", mustBeArray);
      let external = getFlag(options3, keys, "external", mustBeArray);
      let loader = getFlag(options3, keys, "loader", mustBeObject);
      let outExtension = getFlag(options3, keys, "outExtension", mustBeObject);
      let publicPath = getFlag(options3, keys, "publicPath", mustBeString);
      let entryNames = getFlag(options3, keys, "entryNames", mustBeString);
      let chunkNames = getFlag(options3, keys, "chunkNames", mustBeString);
      let assetNames = getFlag(options3, keys, "assetNames", mustBeString);
      let inject = getFlag(options3, keys, "inject", mustBeArray);
      let banner = getFlag(options3, keys, "banner", mustBeObject);
      let footer = getFlag(options3, keys, "footer", mustBeObject);
      let entryPoints = getFlag(options3, keys, "entryPoints", mustBeArrayOrRecord);
      let absWorkingDir = getFlag(options3, keys, "absWorkingDir", mustBeString);
      let stdin = getFlag(options3, keys, "stdin", mustBeObject);
      let write = (_a2 = getFlag(options3, keys, "write", mustBeBoolean)) != null ? _a2 : writeDefault;
      let allowOverwrite = getFlag(options3, keys, "allowOverwrite", mustBeBoolean);
      let incremental = getFlag(options3, keys, "incremental", mustBeBoolean) === true;
      let mangleCache = getFlag(options3, keys, "mangleCache", mustBeObject);
      keys.plugins = true;
      checkForInvalidFlags(options3, keys, `in ${callName}() call`);
      if (sourcemap)
        flags.push(`--sourcemap${sourcemap === true ? "" : `=${sourcemap}`}`);
      if (bundle)
        flags.push("--bundle");
      if (allowOverwrite)
        flags.push("--allow-overwrite");
      if (watch2) {
        flags.push("--watch");
        if (typeof watch2 === "boolean") {
          watchMode = {};
        } else {
          let watchKeys = /* @__PURE__ */ Object.create(null);
          let onRebuild = getFlag(watch2, watchKeys, "onRebuild", mustBeFunction);
          checkForInvalidFlags(watch2, watchKeys, `on "watch" in ${callName}() call`);
          watchMode = { onRebuild };
        }
      }
      if (splitting)
        flags.push("--splitting");
      if (preserveSymlinks)
        flags.push("--preserve-symlinks");
      if (metafile)
        flags.push(`--metafile`);
      if (outfile)
        flags.push(`--outfile=${outfile}`);
      if (outdir)
        flags.push(`--outdir=${outdir}`);
      if (outbase)
        flags.push(`--outbase=${outbase}`);
      if (tsconfig)
        flags.push(`--tsconfig=${tsconfig}`);
      if (resolveExtensions2) {
        let values = [];
        for (let value2 of resolveExtensions2) {
          value2 += "";
          if (value2.indexOf(",") >= 0)
            throw new Error(`Invalid resolve extension: ${value2}`);
          values.push(value2);
        }
        flags.push(`--resolve-extensions=${values.join(",")}`);
      }
      if (publicPath)
        flags.push(`--public-path=${publicPath}`);
      if (entryNames)
        flags.push(`--entry-names=${entryNames}`);
      if (chunkNames)
        flags.push(`--chunk-names=${chunkNames}`);
      if (assetNames)
        flags.push(`--asset-names=${assetNames}`);
      if (mainFields) {
        let values = [];
        for (let value2 of mainFields) {
          value2 += "";
          if (value2.indexOf(",") >= 0)
            throw new Error(`Invalid main field: ${value2}`);
          values.push(value2);
        }
        flags.push(`--main-fields=${values.join(",")}`);
      }
      if (conditions) {
        let values = [];
        for (let value2 of conditions) {
          value2 += "";
          if (value2.indexOf(",") >= 0)
            throw new Error(`Invalid condition: ${value2}`);
          values.push(value2);
        }
        flags.push(`--conditions=${values.join(",")}`);
      }
      if (external)
        for (let name of external)
          flags.push(`--external:${name}`);
      if (banner) {
        for (let type in banner) {
          if (type.indexOf("=") >= 0)
            throw new Error(`Invalid banner file type: ${type}`);
          flags.push(`--banner:${type}=${banner[type]}`);
        }
      }
      if (footer) {
        for (let type in footer) {
          if (type.indexOf("=") >= 0)
            throw new Error(`Invalid footer file type: ${type}`);
          flags.push(`--footer:${type}=${footer[type]}`);
        }
      }
      if (inject)
        for (let path32 of inject)
          flags.push(`--inject:${path32}`);
      if (loader) {
        for (let ext2 in loader) {
          if (ext2.indexOf("=") >= 0)
            throw new Error(`Invalid loader extension: ${ext2}`);
          flags.push(`--loader:${ext2}=${loader[ext2]}`);
        }
      }
      if (outExtension) {
        for (let ext2 in outExtension) {
          if (ext2.indexOf("=") >= 0)
            throw new Error(`Invalid out extension: ${ext2}`);
          flags.push(`--out-extension:${ext2}=${outExtension[ext2]}`);
        }
      }
      if (entryPoints) {
        if (Array.isArray(entryPoints)) {
          for (let entryPoint of entryPoints) {
            entries.push(["", entryPoint + ""]);
          }
        } else {
          for (let [key2, value2] of Object.entries(entryPoints)) {
            entries.push([key2 + "", value2 + ""]);
          }
        }
      }
      if (stdin) {
        let stdinKeys = /* @__PURE__ */ Object.create(null);
        let contents = getFlag(stdin, stdinKeys, "contents", mustBeStringOrUint8Array);
        let resolveDir = getFlag(stdin, stdinKeys, "resolveDir", mustBeString);
        let sourcefile = getFlag(stdin, stdinKeys, "sourcefile", mustBeString);
        let loader2 = getFlag(stdin, stdinKeys, "loader", mustBeString);
        checkForInvalidFlags(stdin, stdinKeys, 'in "stdin" object');
        if (sourcefile)
          flags.push(`--sourcefile=${sourcefile}`);
        if (loader2)
          flags.push(`--loader=${loader2}`);
        if (resolveDir)
          stdinResolveDir = resolveDir + "";
        if (typeof contents === "string")
          stdinContents = encodeUTF8(contents);
        else if (contents instanceof Uint8Array)
          stdinContents = contents;
      }
      let nodePaths = [];
      if (nodePathsInput) {
        for (let value2 of nodePathsInput) {
          value2 += "";
          nodePaths.push(value2);
        }
      }
      return {
        entries,
        flags,
        write,
        stdinContents,
        stdinResolveDir,
        absWorkingDir,
        incremental,
        nodePaths,
        watch: watchMode,
        mangleCache: validateMangleCache(mangleCache)
      };
    }
    function flagsForTransformOptions(callName, options3, isTTY2, logLevelDefault) {
      let flags = [];
      let keys = /* @__PURE__ */ Object.create(null);
      pushLogFlags(flags, options3, keys, isTTY2, logLevelDefault);
      pushCommonFlags(flags, options3, keys);
      let sourcemap = getFlag(options3, keys, "sourcemap", mustBeStringOrBoolean);
      let tsconfigRaw = getFlag(options3, keys, "tsconfigRaw", mustBeStringOrObject);
      let sourcefile = getFlag(options3, keys, "sourcefile", mustBeString);
      let loader = getFlag(options3, keys, "loader", mustBeString);
      let banner = getFlag(options3, keys, "banner", mustBeString);
      let footer = getFlag(options3, keys, "footer", mustBeString);
      let mangleCache = getFlag(options3, keys, "mangleCache", mustBeObject);
      checkForInvalidFlags(options3, keys, `in ${callName}() call`);
      if (sourcemap)
        flags.push(`--sourcemap=${sourcemap === true ? "external" : sourcemap}`);
      if (tsconfigRaw)
        flags.push(`--tsconfig-raw=${typeof tsconfigRaw === "string" ? tsconfigRaw : JSON.stringify(tsconfigRaw)}`);
      if (sourcefile)
        flags.push(`--sourcefile=${sourcefile}`);
      if (loader)
        flags.push(`--loader=${loader}`);
      if (banner)
        flags.push(`--banner=${banner}`);
      if (footer)
        flags.push(`--footer=${footer}`);
      return {
        flags,
        mangleCache: validateMangleCache(mangleCache)
      };
    }
    function createChannel(streamIn) {
      const requestCallbacksByKey = {};
      const closeData = { didClose: false, reason: "" };
      let responseCallbacks = {};
      let nextRequestID = 0;
      let nextBuildKey = 0;
      let stdout = new Uint8Array(16 * 1024);
      let stdoutUsed = 0;
      let readFromStdout = (chunk) => {
        let limit = stdoutUsed + chunk.length;
        if (limit > stdout.length) {
          let swap = new Uint8Array(limit * 2);
          swap.set(stdout);
          stdout = swap;
        }
        stdout.set(chunk, stdoutUsed);
        stdoutUsed += chunk.length;
        let offset3 = 0;
        while (offset3 + 4 <= stdoutUsed) {
          let length = readUInt32LE(stdout, offset3);
          if (offset3 + 4 + length > stdoutUsed) {
            break;
          }
          offset3 += 4;
          handleIncomingPacket(stdout.subarray(offset3, offset3 + length));
          offset3 += length;
        }
        if (offset3 > 0) {
          stdout.copyWithin(0, offset3, stdoutUsed);
          stdoutUsed -= offset3;
        }
      };
      let afterClose = (error2) => {
        closeData.didClose = true;
        if (error2)
          closeData.reason = ": " + (error2.message || error2);
        const text = "The service was stopped" + closeData.reason;
        for (let id in responseCallbacks) {
          responseCallbacks[id](text, null);
        }
        responseCallbacks = {};
      };
      let sendRequest = (refs, value2, callback) => {
        if (closeData.didClose)
          return callback("The service is no longer running" + closeData.reason, null);
        let id = nextRequestID++;
        responseCallbacks[id] = (error2, response) => {
          try {
            callback(error2, response);
          } finally {
            if (refs)
              refs.unref();
          }
        };
        if (refs)
          refs.ref();
        streamIn.writeToStdin(encodePacket({ id, isRequest: true, value: value2 }));
      };
      let sendResponse = (id, value2) => {
        if (closeData.didClose)
          throw new Error("The service is no longer running" + closeData.reason);
        streamIn.writeToStdin(encodePacket({ id, isRequest: false, value: value2 }));
      };
      let handleRequest = async (id, request) => {
        try {
          if (request.command === "ping") {
            sendResponse(id, {});
            return;
          }
          if (typeof request.key === "number") {
            const requestCallbacks = requestCallbacksByKey[request.key];
            if (requestCallbacks) {
              const callback = requestCallbacks[request.command];
              if (callback) {
                await callback(id, request);
                return;
              }
            }
          }
          throw new Error(`Invalid command: ` + request.command);
        } catch (e) {
          sendResponse(id, { errors: [extractErrorMessageV8(e, streamIn, null, void 0, "")] });
        }
      };
      let isFirstPacket = true;
      let handleIncomingPacket = (bytes) => {
        if (isFirstPacket) {
          isFirstPacket = false;
          let binaryVersion = String.fromCharCode(...bytes);
          if (binaryVersion !== "0.15.12") {
            throw new Error(`Cannot start service: Host version "${"0.15.12"}" does not match binary version ${JSON.stringify(binaryVersion)}`);
          }
          return;
        }
        let packet = decodePacket(bytes);
        if (packet.isRequest) {
          handleRequest(packet.id, packet.value);
        } else {
          let callback = responseCallbacks[packet.id];
          delete responseCallbacks[packet.id];
          if (packet.value.error)
            callback(packet.value.error, {});
          else
            callback(null, packet.value);
        }
      };
      let buildOrServe = ({ callName, refs, serveOptions, options: options3, isTTY: isTTY2, defaultWD: defaultWD2, callback }) => {
        let refCount = 0;
        const buildKey = nextBuildKey++;
        const requestCallbacks = {};
        const buildRefs = {
          ref() {
            if (++refCount === 1) {
              if (refs)
                refs.ref();
            }
          },
          unref() {
            if (--refCount === 0) {
              delete requestCallbacksByKey[buildKey];
              if (refs)
                refs.unref();
            }
          }
        };
        requestCallbacksByKey[buildKey] = requestCallbacks;
        buildRefs.ref();
        buildOrServeImpl(
          callName,
          buildKey,
          sendRequest,
          sendResponse,
          buildRefs,
          streamIn,
          requestCallbacks,
          options3,
          serveOptions,
          isTTY2,
          defaultWD2,
          closeData,
          (err, res) => {
            try {
              callback(err, res);
            } finally {
              buildRefs.unref();
            }
          }
        );
      };
      let transform22 = ({ callName, refs, input, options: options3, isTTY: isTTY2, fs: fs3, callback }) => {
        const details = createObjectStash();
        let start = (inputPath) => {
          try {
            if (typeof input !== "string" && !(input instanceof Uint8Array))
              throw new Error('The input to "transform" must be a string or a Uint8Array');
            let {
              flags,
              mangleCache
            } = flagsForTransformOptions(callName, options3, isTTY2, transformLogLevelDefault);
            let request = {
              command: "transform",
              flags,
              inputFS: inputPath !== null,
              input: inputPath !== null ? encodeUTF8(inputPath) : typeof input === "string" ? encodeUTF8(input) : input
            };
            if (mangleCache)
              request.mangleCache = mangleCache;
            sendRequest(refs, request, (error2, response) => {
              if (error2)
                return callback(new Error(error2), null);
              let errors = replaceDetailsInMessages(response.errors, details);
              let warnings = replaceDetailsInMessages(response.warnings, details);
              let outstanding = 1;
              let next = () => {
                if (--outstanding === 0) {
                  let result = { warnings, code: response.code, map: response.map };
                  if (response.mangleCache)
                    result.mangleCache = response == null ? void 0 : response.mangleCache;
                  callback(null, result);
                }
              };
              if (errors.length > 0)
                return callback(failureErrorWithLog("Transform failed", errors, warnings), null);
              if (response.codeFS) {
                outstanding++;
                fs3.readFile(response.code, (err, contents) => {
                  if (err !== null) {
                    callback(err, null);
                  } else {
                    response.code = contents;
                    next();
                  }
                });
              }
              if (response.mapFS) {
                outstanding++;
                fs3.readFile(response.map, (err, contents) => {
                  if (err !== null) {
                    callback(err, null);
                  } else {
                    response.map = contents;
                    next();
                  }
                });
              }
              next();
            });
          } catch (e) {
            let flags = [];
            try {
              pushLogFlags(flags, options3, {}, isTTY2, transformLogLevelDefault);
            } catch {
            }
            const error2 = extractErrorMessageV8(e, streamIn, details, void 0, "");
            sendRequest(refs, { command: "error", flags, error: error2 }, () => {
              error2.detail = details.load(error2.detail);
              callback(failureErrorWithLog("Transform failed", [error2], []), null);
            });
          }
        };
        if ((typeof input === "string" || input instanceof Uint8Array) && input.length > 1024 * 1024) {
          let next = start;
          start = () => fs3.writeFile(input, next);
        }
        start(null);
      };
      let formatMessages22 = ({ callName, refs, messages: messages2, options: options3, callback }) => {
        let result = sanitizeMessages(messages2, "messages", null, "");
        if (!options3)
          throw new Error(`Missing second argument in ${callName}() call`);
        let keys = {};
        let kind = getFlag(options3, keys, "kind", mustBeString);
        let color = getFlag(options3, keys, "color", mustBeBoolean);
        let terminalWidth = getFlag(options3, keys, "terminalWidth", mustBeInteger);
        checkForInvalidFlags(options3, keys, `in ${callName}() call`);
        if (kind === void 0)
          throw new Error(`Missing "kind" in ${callName}() call`);
        if (kind !== "error" && kind !== "warning")
          throw new Error(`Expected "kind" to be "error" or "warning" in ${callName}() call`);
        let request = {
          command: "format-msgs",
          messages: result,
          isWarning: kind === "warning"
        };
        if (color !== void 0)
          request.color = color;
        if (terminalWidth !== void 0)
          request.terminalWidth = terminalWidth;
        sendRequest(refs, request, (error2, response) => {
          if (error2)
            return callback(new Error(error2), null);
          callback(null, response.messages);
        });
      };
      let analyzeMetafile2 = ({ callName, refs, metafile, options: options3, callback }) => {
        if (options3 === void 0)
          options3 = {};
        let keys = {};
        let color = getFlag(options3, keys, "color", mustBeBoolean);
        let verbose = getFlag(options3, keys, "verbose", mustBeBoolean);
        checkForInvalidFlags(options3, keys, `in ${callName}() call`);
        let request = {
          command: "analyze-metafile",
          metafile
        };
        if (color !== void 0)
          request.color = color;
        if (verbose !== void 0)
          request.verbose = verbose;
        sendRequest(refs, request, (error2, response) => {
          if (error2)
            return callback(new Error(error2), null);
          callback(null, response.result);
        });
      };
      return {
        readFromStdout,
        afterClose,
        service: {
          buildOrServe,
          transform: transform22,
          formatMessages: formatMessages22,
          analyzeMetafile: analyzeMetafile2
        }
      };
    }
    function buildOrServeImpl(callName, buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, options3, serveOptions, isTTY2, defaultWD2, closeData, callback) {
      const details = createObjectStash();
      const logPluginError = (e, pluginName, note, done) => {
        const flags = [];
        try {
          pushLogFlags(flags, options3, {}, isTTY2, buildLogLevelDefault);
        } catch {
        }
        const message = extractErrorMessageV8(e, streamIn, details, note, pluginName);
        sendRequest(refs, { command: "error", flags, error: message }, () => {
          message.detail = details.load(message.detail);
          done(message);
        });
      };
      const handleError = (e, pluginName) => {
        logPluginError(e, pluginName, void 0, (error2) => {
          callback(failureErrorWithLog("Build failed", [error2], []), null);
        });
      };
      let plugins2;
      if (typeof options3 === "object") {
        const value2 = options3.plugins;
        if (value2 !== void 0) {
          if (!Array.isArray(value2))
            throw new Error(`"plugins" must be an array`);
          plugins2 = value2;
        }
      }
      if (plugins2 && plugins2.length > 0) {
        if (streamIn.isSync) {
          handleError(new Error("Cannot use plugins in synchronous API calls"), "");
          return;
        }
        handlePlugins(
          buildKey,
          sendRequest,
          sendResponse,
          refs,
          streamIn,
          requestCallbacks,
          options3,
          plugins2,
          details
        ).then(
          (result) => {
            if (!result.ok) {
              handleError(result.error, result.pluginName);
              return;
            }
            try {
              buildOrServeContinue(result.requestPlugins, result.runOnEndCallbacks);
            } catch (e) {
              handleError(e, "");
            }
          },
          (e) => handleError(e, "")
        );
        return;
      }
      try {
        buildOrServeContinue(null, (result, logPluginError2, done) => done());
      } catch (e) {
        handleError(e, "");
      }
      function buildOrServeContinue(requestPlugins, runOnEndCallbacks) {
        let writeDefault = !streamIn.isWriteUnavailable;
        let {
          entries,
          flags,
          write,
          stdinContents,
          stdinResolveDir,
          absWorkingDir,
          incremental,
          nodePaths,
          watch: watch2,
          mangleCache
        } = flagsForBuildOptions(callName, options3, isTTY2, buildLogLevelDefault, writeDefault);
        let request = {
          command: "build",
          key: buildKey,
          entries,
          flags,
          write,
          stdinContents,
          stdinResolveDir,
          absWorkingDir: absWorkingDir || defaultWD2,
          incremental,
          nodePaths
        };
        if (requestPlugins)
          request.plugins = requestPlugins;
        if (mangleCache)
          request.mangleCache = mangleCache;
        let serve2 = serveOptions && buildServeData(buildKey, sendRequest, sendResponse, refs, requestCallbacks, serveOptions, request);
        let rebuild;
        let stop;
        let copyResponseToResult = (response, result) => {
          if (response.outputFiles)
            result.outputFiles = response.outputFiles.map(convertOutputFiles);
          if (response.metafile)
            result.metafile = JSON.parse(response.metafile);
          if (response.mangleCache)
            result.mangleCache = response.mangleCache;
          if (response.writeToStdout !== void 0)
            console.log(decodeUTF8(response.writeToStdout).replace(/\n$/, ""));
        };
        let buildResponseToResult = (response, callback2) => {
          let result = {
            errors: replaceDetailsInMessages(response.errors, details),
            warnings: replaceDetailsInMessages(response.warnings, details)
          };
          copyResponseToResult(response, result);
          runOnEndCallbacks(result, logPluginError, () => {
            if (result.errors.length > 0) {
              return callback2(failureErrorWithLog("Build failed", result.errors, result.warnings), null);
            }
            if (response.rebuild) {
              if (!rebuild) {
                let isDisposed = false;
                rebuild = () => new Promise((resolve3, reject) => {
                  if (isDisposed || closeData.didClose)
                    throw new Error("Cannot rebuild");
                  sendRequest(
                    refs,
                    { command: "rebuild", key: buildKey },
                    (error2, response2) => {
                      if (error2) {
                        const message = { id: "", pluginName: "", text: error2, location: null, notes: [], detail: void 0 };
                        return callback2(failureErrorWithLog("Build failed", [message], []), null);
                      }
                      buildResponseToResult(response2, (error3, result3) => {
                        if (error3)
                          reject(error3);
                        else
                          resolve3(result3);
                      });
                    }
                  );
                });
                refs.ref();
                rebuild.dispose = () => {
                  if (isDisposed)
                    return;
                  isDisposed = true;
                  sendRequest(refs, { command: "rebuild-dispose", key: buildKey }, () => {
                  });
                  refs.unref();
                };
              }
              result.rebuild = rebuild;
            }
            if (response.watch) {
              if (!stop) {
                let isStopped = false;
                refs.ref();
                stop = () => {
                  if (isStopped)
                    return;
                  isStopped = true;
                  delete requestCallbacks["watch-rebuild"];
                  sendRequest(refs, { command: "watch-stop", key: buildKey }, () => {
                  });
                  refs.unref();
                };
                if (watch2) {
                  requestCallbacks["watch-rebuild"] = (id, request2) => {
                    try {
                      let watchResponse = request2.args;
                      let result2 = {
                        errors: replaceDetailsInMessages(watchResponse.errors, details),
                        warnings: replaceDetailsInMessages(watchResponse.warnings, details)
                      };
                      copyResponseToResult(watchResponse, result2);
                      runOnEndCallbacks(result2, logPluginError, () => {
                        if (result2.errors.length > 0) {
                          if (watch2.onRebuild)
                            watch2.onRebuild(failureErrorWithLog("Build failed", result2.errors, result2.warnings), null);
                          return;
                        }
                        result2.stop = stop;
                        if (watch2.onRebuild)
                          watch2.onRebuild(null, result2);
                      });
                    } catch (err) {
                      console.error(err);
                    }
                    sendResponse(id, {});
                  };
                }
              }
              result.stop = stop;
            }
            callback2(null, result);
          });
        };
        if (write && streamIn.isWriteUnavailable)
          throw new Error(`The "write" option is unavailable in this environment`);
        if (incremental && streamIn.isSync)
          throw new Error(`Cannot use "incremental" with a synchronous build`);
        if (watch2 && streamIn.isSync)
          throw new Error(`Cannot use "watch" with a synchronous build`);
        sendRequest(refs, request, (error2, response) => {
          if (error2)
            return callback(new Error(error2), null);
          if (serve2) {
            let serveResponse = response;
            let isStopped = false;
            refs.ref();
            let result = {
              port: serveResponse.port,
              host: serveResponse.host,
              wait: serve2.wait,
              stop() {
                if (isStopped)
                  return;
                isStopped = true;
                serve2.stop();
                refs.unref();
              }
            };
            refs.ref();
            serve2.wait.then(refs.unref, refs.unref);
            return callback(null, result);
          }
          return buildResponseToResult(response, callback);
        });
      }
    }
    var buildServeData = (buildKey, sendRequest, sendResponse, refs, requestCallbacks, options3, request) => {
      let keys = {};
      let port = getFlag(options3, keys, "port", mustBeInteger);
      let host = getFlag(options3, keys, "host", mustBeString);
      let servedir = getFlag(options3, keys, "servedir", mustBeString);
      let onRequest = getFlag(options3, keys, "onRequest", mustBeFunction);
      let wait = new Promise((resolve3, reject) => {
        requestCallbacks["serve-wait"] = (id, request2) => {
          if (request2.error !== null)
            reject(new Error(request2.error));
          else
            resolve3();
          sendResponse(id, {});
        };
      });
      request.serve = {};
      checkForInvalidFlags(options3, keys, `in serve() call`);
      if (port !== void 0)
        request.serve.port = port;
      if (host !== void 0)
        request.serve.host = host;
      if (servedir !== void 0)
        request.serve.servedir = servedir;
      requestCallbacks["serve-request"] = (id, request2) => {
        if (onRequest)
          onRequest(request2.args);
        sendResponse(id, {});
      };
      return {
        wait,
        stop() {
          sendRequest(refs, { command: "serve-stop", key: buildKey }, () => {
          });
        }
      };
    };
    var handlePlugins = async (buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, initialOptions, plugins2, details) => {
      let onStartCallbacks = [];
      let onEndCallbacks = [];
      let onResolveCallbacks = {};
      let onLoadCallbacks = {};
      let nextCallbackID = 0;
      let i = 0;
      let requestPlugins = [];
      let isSetupDone = false;
      plugins2 = [...plugins2];
      for (let item of plugins2) {
        let keys = {};
        if (typeof item !== "object")
          throw new Error(`Plugin at index ${i} must be an object`);
        const name = getFlag(item, keys, "name", mustBeString);
        if (typeof name !== "string" || name === "")
          throw new Error(`Plugin at index ${i} is missing a name`);
        try {
          let setup = getFlag(item, keys, "setup", mustBeFunction);
          if (typeof setup !== "function")
            throw new Error(`Plugin is missing a setup function`);
          checkForInvalidFlags(item, keys, `on plugin ${JSON.stringify(name)}`);
          let plugin = {
            name,
            onResolve: [],
            onLoad: []
          };
          i++;
          let resolve3 = (path32, options3 = {}) => {
            if (!isSetupDone)
              throw new Error('Cannot call "resolve" before plugin setup has completed');
            if (typeof path32 !== "string")
              throw new Error(`The path to resolve must be a string`);
            let keys2 = /* @__PURE__ */ Object.create(null);
            let pluginName = getFlag(options3, keys2, "pluginName", mustBeString);
            let importer = getFlag(options3, keys2, "importer", mustBeString);
            let namespace = getFlag(options3, keys2, "namespace", mustBeString);
            let resolveDir = getFlag(options3, keys2, "resolveDir", mustBeString);
            let kind = getFlag(options3, keys2, "kind", mustBeString);
            let pluginData = getFlag(options3, keys2, "pluginData", canBeAnything);
            checkForInvalidFlags(options3, keys2, "in resolve() call");
            return new Promise((resolve22, reject) => {
              const request = {
                command: "resolve",
                path: path32,
                key: buildKey,
                pluginName: name
              };
              if (pluginName != null)
                request.pluginName = pluginName;
              if (importer != null)
                request.importer = importer;
              if (namespace != null)
                request.namespace = namespace;
              if (resolveDir != null)
                request.resolveDir = resolveDir;
              if (kind != null)
                request.kind = kind;
              if (pluginData != null)
                request.pluginData = details.store(pluginData);
              sendRequest(refs, request, (error2, response) => {
                if (error2 !== null)
                  reject(new Error(error2));
                else
                  resolve22({
                    errors: replaceDetailsInMessages(response.errors, details),
                    warnings: replaceDetailsInMessages(response.warnings, details),
                    path: response.path,
                    external: response.external,
                    sideEffects: response.sideEffects,
                    namespace: response.namespace,
                    suffix: response.suffix,
                    pluginData: details.load(response.pluginData)
                  });
              });
            });
          };
          let promise2 = setup({
            initialOptions,
            resolve: resolve3,
            onStart(callback) {
              let registeredText = `This error came from the "onStart" callback registered here:`;
              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onStart");
              onStartCallbacks.push({ name, callback, note: registeredNote });
            },
            onEnd(callback) {
              let registeredText = `This error came from the "onEnd" callback registered here:`;
              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onEnd");
              onEndCallbacks.push({ name, callback, note: registeredNote });
            },
            onResolve(options3, callback) {
              let registeredText = `This error came from the "onResolve" callback registered here:`;
              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onResolve");
              let keys2 = {};
              let filter2 = getFlag(options3, keys2, "filter", mustBeRegExp);
              let namespace = getFlag(options3, keys2, "namespace", mustBeString);
              checkForInvalidFlags(options3, keys2, `in onResolve() call for plugin ${JSON.stringify(name)}`);
              if (filter2 == null)
                throw new Error(`onResolve() call is missing a filter`);
              let id = nextCallbackID++;
              onResolveCallbacks[id] = { name, callback, note: registeredNote };
              plugin.onResolve.push({ id, filter: filter2.source, namespace: namespace || "" });
            },
            onLoad(options3, callback) {
              let registeredText = `This error came from the "onLoad" callback registered here:`;
              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onLoad");
              let keys2 = {};
              let filter2 = getFlag(options3, keys2, "filter", mustBeRegExp);
              let namespace = getFlag(options3, keys2, "namespace", mustBeString);
              checkForInvalidFlags(options3, keys2, `in onLoad() call for plugin ${JSON.stringify(name)}`);
              if (filter2 == null)
                throw new Error(`onLoad() call is missing a filter`);
              let id = nextCallbackID++;
              onLoadCallbacks[id] = { name, callback, note: registeredNote };
              plugin.onLoad.push({ id, filter: filter2.source, namespace: namespace || "" });
            },
            esbuild: streamIn.esbuild
          });
          if (promise2)
            await promise2;
          requestPlugins.push(plugin);
        } catch (e) {
          return { ok: false, error: e, pluginName: name };
        }
      }
      requestCallbacks["on-start"] = async (id, request) => {
        let response = { errors: [], warnings: [] };
        await Promise.all(onStartCallbacks.map(async ({ name, callback, note }) => {
          try {
            let result = await callback();
            if (result != null) {
              if (typeof result !== "object")
                throw new Error(`Expected onStart() callback in plugin ${JSON.stringify(name)} to return an object`);
              let keys = {};
              let errors = getFlag(result, keys, "errors", mustBeArray);
              let warnings = getFlag(result, keys, "warnings", mustBeArray);
              checkForInvalidFlags(result, keys, `from onStart() callback in plugin ${JSON.stringify(name)}`);
              if (errors != null)
                response.errors.push(...sanitizeMessages(errors, "errors", details, name));
              if (warnings != null)
                response.warnings.push(...sanitizeMessages(warnings, "warnings", details, name));
            }
          } catch (e) {
            response.errors.push(extractErrorMessageV8(e, streamIn, details, note && note(), name));
          }
        }));
        sendResponse(id, response);
      };
      requestCallbacks["on-resolve"] = async (id, request) => {
        let response = {}, name = "", callback, note;
        for (let id2 of request.ids) {
          try {
            ({ name, callback, note } = onResolveCallbacks[id2]);
            let result = await callback({
              path: request.path,
              importer: request.importer,
              namespace: request.namespace,
              resolveDir: request.resolveDir,
              kind: request.kind,
              pluginData: details.load(request.pluginData)
            });
            if (result != null) {
              if (typeof result !== "object")
                throw new Error(`Expected onResolve() callback in plugin ${JSON.stringify(name)} to return an object`);
              let keys = {};
              let pluginName = getFlag(result, keys, "pluginName", mustBeString);
              let path32 = getFlag(result, keys, "path", mustBeString);
              let namespace = getFlag(result, keys, "namespace", mustBeString);
              let suffix = getFlag(result, keys, "suffix", mustBeString);
              let external = getFlag(result, keys, "external", mustBeBoolean);
              let sideEffects = getFlag(result, keys, "sideEffects", mustBeBoolean);
              let pluginData = getFlag(result, keys, "pluginData", canBeAnything);
              let errors = getFlag(result, keys, "errors", mustBeArray);
              let warnings = getFlag(result, keys, "warnings", mustBeArray);
              let watchFiles = getFlag(result, keys, "watchFiles", mustBeArray);
              let watchDirs = getFlag(result, keys, "watchDirs", mustBeArray);
              checkForInvalidFlags(result, keys, `from onResolve() callback in plugin ${JSON.stringify(name)}`);
              response.id = id2;
              if (pluginName != null)
                response.pluginName = pluginName;
              if (path32 != null)
                response.path = path32;
              if (namespace != null)
                response.namespace = namespace;
              if (suffix != null)
                response.suffix = suffix;
              if (external != null)
                response.external = external;
              if (sideEffects != null)
                response.sideEffects = sideEffects;
              if (pluginData != null)
                response.pluginData = details.store(pluginData);
              if (errors != null)
                response.errors = sanitizeMessages(errors, "errors", details, name);
              if (warnings != null)
                response.warnings = sanitizeMessages(warnings, "warnings", details, name);
              if (watchFiles != null)
                response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
              if (watchDirs != null)
                response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
              break;
            }
          } catch (e) {
            response = { id: id2, errors: [extractErrorMessageV8(e, streamIn, details, note && note(), name)] };
            break;
          }
        }
        sendResponse(id, response);
      };
      requestCallbacks["on-load"] = async (id, request) => {
        let response = {}, name = "", callback, note;
        for (let id2 of request.ids) {
          try {
            ({ name, callback, note } = onLoadCallbacks[id2]);
            let result = await callback({
              path: request.path,
              namespace: request.namespace,
              suffix: request.suffix,
              pluginData: details.load(request.pluginData)
            });
            if (result != null) {
              if (typeof result !== "object")
                throw new Error(`Expected onLoad() callback in plugin ${JSON.stringify(name)} to return an object`);
              let keys = {};
              let pluginName = getFlag(result, keys, "pluginName", mustBeString);
              let contents = getFlag(result, keys, "contents", mustBeStringOrUint8Array);
              let resolveDir = getFlag(result, keys, "resolveDir", mustBeString);
              let pluginData = getFlag(result, keys, "pluginData", canBeAnything);
              let loader = getFlag(result, keys, "loader", mustBeString);
              let errors = getFlag(result, keys, "errors", mustBeArray);
              let warnings = getFlag(result, keys, "warnings", mustBeArray);
              let watchFiles = getFlag(result, keys, "watchFiles", mustBeArray);
              let watchDirs = getFlag(result, keys, "watchDirs", mustBeArray);
              checkForInvalidFlags(result, keys, `from onLoad() callback in plugin ${JSON.stringify(name)}`);
              response.id = id2;
              if (pluginName != null)
                response.pluginName = pluginName;
              if (contents instanceof Uint8Array)
                response.contents = contents;
              else if (contents != null)
                response.contents = encodeUTF8(contents);
              if (resolveDir != null)
                response.resolveDir = resolveDir;
              if (pluginData != null)
                response.pluginData = details.store(pluginData);
              if (loader != null)
                response.loader = loader;
              if (errors != null)
                response.errors = sanitizeMessages(errors, "errors", details, name);
              if (warnings != null)
                response.warnings = sanitizeMessages(warnings, "warnings", details, name);
              if (watchFiles != null)
                response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
              if (watchDirs != null)
                response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
              break;
            }
          } catch (e) {
            response = { id: id2, errors: [extractErrorMessageV8(e, streamIn, details, note && note(), name)] };
            break;
          }
        }
        sendResponse(id, response);
      };
      let runOnEndCallbacks = (result, logPluginError, done) => done();
      if (onEndCallbacks.length > 0) {
        runOnEndCallbacks = (result, logPluginError, done) => {
          (async () => {
            for (const { name, callback, note } of onEndCallbacks) {
              try {
                await callback(result);
              } catch (e) {
                result.errors.push(await new Promise((resolve3) => logPluginError(e, name, note && note(), resolve3)));
              }
            }
          })().then(done);
        };
      }
      isSetupDone = true;
      return {
        ok: true,
        requestPlugins,
        runOnEndCallbacks
      };
    };
    function createObjectStash() {
      const map2 = /* @__PURE__ */ new Map();
      let nextID = 0;
      return {
        load(id) {
          return map2.get(id);
        },
        store(value2) {
          if (value2 === void 0)
            return -1;
          const id = nextID++;
          map2.set(id, value2);
          return id;
        }
      };
    }
    function extractCallerV8(e, streamIn, ident) {
      let note;
      let tried = false;
      return () => {
        if (tried)
          return note;
        tried = true;
        try {
          let lines = (e.stack + "").split("\n");
          lines.splice(1, 1);
          let location = parseStackLinesV8(streamIn, lines, ident);
          if (location) {
            note = { text: e.message, location };
            return note;
          }
        } catch {
        }
      };
    }
    function extractErrorMessageV8(e, streamIn, stash, note, pluginName) {
      let text = "Internal error";
      let location = null;
      try {
        text = (e && e.message || e) + "";
      } catch {
      }
      try {
        location = parseStackLinesV8(streamIn, (e.stack + "").split("\n"), "");
      } catch {
      }
      return { id: "", pluginName, text, location, notes: note ? [note] : [], detail: stash ? stash.store(e) : -1 };
    }
    function parseStackLinesV8(streamIn, lines, ident) {
      let at2 = "    at ";
      if (streamIn.readFileSync && !lines[0].startsWith(at2) && lines[1].startsWith(at2)) {
        for (let i = 1; i < lines.length; i++) {
          let line2 = lines[i];
          if (!line2.startsWith(at2))
            continue;
          line2 = line2.slice(at2.length);
          while (true) {
            let match = /^(?:new |async )?\S+ \((.*)\)$/.exec(line2);
            if (match) {
              line2 = match[1];
              continue;
            }
            match = /^eval at \S+ \((.*)\)(?:, \S+:\d+:\d+)?$/.exec(line2);
            if (match) {
              line2 = match[1];
              continue;
            }
            match = /^(\S+):(\d+):(\d+)$/.exec(line2);
            if (match) {
              let contents;
              try {
                contents = streamIn.readFileSync(match[1], "utf8");
              } catch {
                break;
              }
              let lineText = contents.split(/\r\n|\r|\n|\u2028|\u2029/)[+match[2] - 1] || "";
              let column2 = +match[3] - 1;
              let length = lineText.slice(column2, column2 + ident.length) === ident ? ident.length : 0;
              return {
                file: match[1],
                namespace: "file",
                line: +match[2],
                column: encodeUTF8(lineText.slice(0, column2)).length,
                length: encodeUTF8(lineText.slice(column2, column2 + length)).length,
                lineText: lineText + "\n" + lines.slice(1).join("\n"),
                suggestion: ""
              };
            }
            break;
          }
        }
      }
      return null;
    }
    function failureErrorWithLog(text, errors, warnings) {
      let limit = 5;
      let summary = errors.length < 1 ? "" : ` with ${errors.length} error${errors.length < 2 ? "" : "s"}:` + errors.slice(0, limit + 1).map((e, i) => {
        if (i === limit)
          return "\n...";
        if (!e.location)
          return `
error: ${e.text}`;
        let { file, line: line2, column: column2 } = e.location;
        let pluginText = e.pluginName ? `[plugin: ${e.pluginName}] ` : "";
        return `
${file}:${line2}:${column2}: ERROR: ${pluginText}${e.text}`;
      }).join("");
      let error2 = new Error(`${text}${summary}`);
      error2.errors = errors;
      error2.warnings = warnings;
      return error2;
    }
    function replaceDetailsInMessages(messages2, stash) {
      for (const message of messages2) {
        message.detail = stash.load(message.detail);
      }
      return messages2;
    }
    function sanitizeLocation(location, where) {
      if (location == null)
        return null;
      let keys = {};
      let file = getFlag(location, keys, "file", mustBeString);
      let namespace = getFlag(location, keys, "namespace", mustBeString);
      let line2 = getFlag(location, keys, "line", mustBeInteger);
      let column2 = getFlag(location, keys, "column", mustBeInteger);
      let length = getFlag(location, keys, "length", mustBeInteger);
      let lineText = getFlag(location, keys, "lineText", mustBeString);
      let suggestion = getFlag(location, keys, "suggestion", mustBeString);
      checkForInvalidFlags(location, keys, where);
      return {
        file: file || "",
        namespace: namespace || "",
        line: line2 || 0,
        column: column2 || 0,
        length: length || 0,
        lineText: lineText || "",
        suggestion: suggestion || ""
      };
    }
    function sanitizeMessages(messages2, property, stash, fallbackPluginName) {
      let messagesClone = [];
      let index2 = 0;
      for (const message of messages2) {
        let keys = {};
        let id = getFlag(message, keys, "id", mustBeString);
        let pluginName = getFlag(message, keys, "pluginName", mustBeString);
        let text = getFlag(message, keys, "text", mustBeString);
        let location = getFlag(message, keys, "location", mustBeObjectOrNull);
        let notes = getFlag(message, keys, "notes", mustBeArray);
        let detail = getFlag(message, keys, "detail", canBeAnything);
        let where = `in element ${index2} of "${property}"`;
        checkForInvalidFlags(message, keys, where);
        let notesClone = [];
        if (notes) {
          for (const note of notes) {
            let noteKeys = {};
            let noteText = getFlag(note, noteKeys, "text", mustBeString);
            let noteLocation = getFlag(note, noteKeys, "location", mustBeObjectOrNull);
            checkForInvalidFlags(note, noteKeys, where);
            notesClone.push({
              text: noteText || "",
              location: sanitizeLocation(noteLocation, where)
            });
          }
        }
        messagesClone.push({
          id: id || "",
          pluginName: pluginName || fallbackPluginName,
          text: text || "",
          location: sanitizeLocation(location, where),
          notes: notesClone,
          detail: stash ? stash.store(detail) : -1
        });
        index2++;
      }
      return messagesClone;
    }
    function sanitizeStringArray(values, property) {
      const result = [];
      for (const value2 of values) {
        if (typeof value2 !== "string")
          throw new Error(`${JSON.stringify(property)} must be an array of strings`);
        result.push(value2);
      }
      return result;
    }
    function convertOutputFiles({ path: path32, contents }) {
      let text = null;
      return {
        path: path32,
        contents,
        get text() {
          const binary2 = this.contents;
          if (text === null || binary2 !== contents) {
            contents = binary2;
            text = decodeUTF8(binary2);
          }
          return text;
        }
      };
    }
    var fs2 = require_fs();
    var os2 = require_os();
    var path4 = require_path();
    var ESBUILD_BINARY_PATH = process.env.ESBUILD_BINARY_PATH || ESBUILD_BINARY_PATH;
    var packageDarwin_arm64 = "esbuild-darwin-arm64";
    var packageDarwin_x64 = "esbuild-darwin-64";
    var knownWindowsPackages = {
      "win32 arm64 LE": "esbuild-windows-arm64",
      "win32 ia32 LE": "esbuild-windows-32",
      "win32 x64 LE": "esbuild-windows-64"
    };
    var knownUnixlikePackages = {
      "android arm64 LE": "esbuild-android-arm64",
      "darwin arm64 LE": "esbuild-darwin-arm64",
      "darwin x64 LE": "esbuild-darwin-64",
      "freebsd arm64 LE": "esbuild-freebsd-arm64",
      "freebsd x64 LE": "esbuild-freebsd-64",
      "linux arm LE": "esbuild-linux-arm",
      "linux arm64 LE": "esbuild-linux-arm64",
      "linux ia32 LE": "esbuild-linux-32",
      "linux mips64el LE": "esbuild-linux-mips64le",
      "linux ppc64 LE": "esbuild-linux-ppc64le",
      "linux riscv64 LE": "esbuild-linux-riscv64",
      "linux s390x BE": "esbuild-linux-s390x",
      "linux x64 LE": "esbuild-linux-64",
      "linux loong64 LE": "@esbuild/linux-loong64",
      "netbsd x64 LE": "esbuild-netbsd-64",
      "openbsd x64 LE": "esbuild-openbsd-64",
      "sunos x64 LE": "esbuild-sunos-64"
    };
    var knownWebAssemblyFallbackPackages = {
      "android arm LE": "@esbuild/android-arm",
      "android x64 LE": "esbuild-android-64"
    };
    function pkgAndSubpathForCurrentPlatform() {
      let pkg;
      let subpath;
      let isWASM = false;
      let platformKey = `${process.platform} ${os2.arch()} ${os2.endianness()}`;
      if (platformKey in knownWindowsPackages) {
        pkg = knownWindowsPackages[platformKey];
        subpath = "esbuild.exe";
      } else if (platformKey in knownUnixlikePackages) {
        pkg = knownUnixlikePackages[platformKey];
        subpath = "bin/esbuild";
      } else if (platformKey in knownWebAssemblyFallbackPackages) {
        pkg = knownWebAssemblyFallbackPackages[platformKey];
        subpath = "bin/esbuild";
        isWASM = true;
      } else {
        throw new Error(`Unsupported platform: ${platformKey}`);
      }
      return { pkg, subpath, isWASM };
    }
    function pkgForSomeOtherPlatform() {
      const libMainJS = __require.resolve("esbuild");
      const nodeModulesDirectory = path4.dirname(path4.dirname(path4.dirname(libMainJS)));
      if (path4.basename(nodeModulesDirectory) === "node_modules") {
        for (const unixKey in knownUnixlikePackages) {
          try {
            const pkg = knownUnixlikePackages[unixKey];
            if (fs2.existsSync(path4.join(nodeModulesDirectory, pkg)))
              return pkg;
          } catch {
          }
        }
        for (const windowsKey in knownWindowsPackages) {
          try {
            const pkg = knownWindowsPackages[windowsKey];
            if (fs2.existsSync(path4.join(nodeModulesDirectory, pkg)))
              return pkg;
          } catch {
          }
        }
      }
      return null;
    }
    function downloadedBinPath(pkg, subpath) {
      const esbuildLibDir = path4.dirname(__require.resolve("esbuild"));
      return path4.join(esbuildLibDir, `downloaded-${pkg}-${path4.basename(subpath)}`);
    }
    function generateBinPath() {
      if (ESBUILD_BINARY_PATH) {
        return { binPath: ESBUILD_BINARY_PATH, isWASM: false };
      }
      const { pkg, subpath, isWASM } = pkgAndSubpathForCurrentPlatform();
      let binPath;
      try {
        binPath = __require.resolve(`${pkg}/${subpath}`);
      } catch (e) {
        binPath = downloadedBinPath(pkg, subpath);
        if (!fs2.existsSync(binPath)) {
          try {
            __require.resolve(pkg);
          } catch {
            const otherPkg = pkgForSomeOtherPlatform();
            if (otherPkg) {
              let suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild on Windows or macOS and copying "node_modules"
into a Docker image that runs Linux, or by copying "node_modules" between
Windows and WSL environments.

If you are installing with npm, you can try not copying the "node_modules"
directory when you copy the files over, and running "npm ci" or "npm install"
on the destination platform after the copy. Or you could consider using yarn
instead of npm which has built-in support for installing a package on multiple
platforms simultaneously.

If you are installing with yarn, you can try listing both this platform and the
other platform in your ".yarnrc.yml" file using the "supportedArchitectures"
feature: https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
              if (pkg === packageDarwin_x64 && otherPkg === packageDarwin_arm64 || pkg === packageDarwin_arm64 && otherPkg === packageDarwin_x64) {
                suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild with npm running inside of Rosetta 2 and then
trying to use it with node running outside of Rosetta 2, or vice versa (Rosetta
2 is Apple's on-the-fly x86_64-to-arm64 translation service).

If you are installing with npm, you can try ensuring that both npm and node are
not running under Rosetta 2 and then reinstalling esbuild. This likely involves
changing how you installed npm and/or node. For example, installing node with
the universal installer here should work: https://nodejs.org/en/download/. Or
you could consider using yarn instead of npm which has built-in support for
installing a package on multiple platforms simultaneously.

If you are installing with yarn, you can try listing both "arm64" and "x64"
in your ".yarnrc.yml" file using the "supportedArchitectures" feature:
https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
              }
              throw new Error(`
You installed esbuild for another platform than the one you're currently using.
This won't work because esbuild is written with native code and needs to
install a platform-specific binary executable.
${suggestions}
Another alternative is to use the "esbuild-wasm" package instead, which works
the same way on all platforms. But it comes with a heavy performance cost and
can sometimes be 10x slower than the "esbuild" package, so you may also not
want to do that.
`);
            }
            throw new Error(`The package "${pkg}" could not be found, and is needed by esbuild.

If you are installing esbuild with npm, make sure that you don't specify the
"--no-optional" or "--omit=optional" flags. The "optionalDependencies" feature
of "package.json" is used by esbuild to install the correct binary executable
for your current platform.`);
          }
          throw e;
        }
      }
      let pnpapi;
      try {
        pnpapi = __require("pnpapi");
      } catch (e) {
      }
      if (pnpapi) {
        const root2 = pnpapi.getPackageInformation(pnpapi.topLevel).packageLocation;
        const binTargetPath = path4.join(
          root2,
          "node_modules",
          ".cache",
          "esbuild",
          `pnpapi-${pkg}-${"0.15.12"}-${path4.basename(subpath)}`
        );
        if (!fs2.existsSync(binTargetPath)) {
          fs2.mkdirSync(path4.dirname(binTargetPath), { recursive: true });
          fs2.copyFileSync(binPath, binTargetPath);
          fs2.chmodSync(binTargetPath, 493);
        }
        return { binPath: binTargetPath, isWASM };
      }
      return { binPath, isWASM };
    }
    var child_process = require_child_process();
    var crypto2 = require_crypto();
    var path22 = require_path();
    var fs22 = require_fs();
    var os22 = require_os();
    var tty2 = require_tty();
    var worker_threads;
    if (process.env.ESBUILD_WORKER_THREADS !== "0") {
      try {
        worker_threads = require_worker_threads();
      } catch {
      }
      let [major, minor] = process.versions.node.split(".");
      if (+major < 12 || +major === 12 && +minor < 17 || +major === 13 && +minor < 13) {
        worker_threads = void 0;
      }
    }
    var _a;
    var isInternalWorkerThread = ((_a = worker_threads == null ? void 0 : worker_threads.workerData) == null ? void 0 : _a.esbuildVersion) === "0.15.12";
    var esbuildCommandAndArgs = () => {
      if ((!ESBUILD_BINARY_PATH || false) && (path22.basename(__filename) !== "main.js" || path22.basename(__dirname) !== "lib")) {
        throw new Error(
          `The esbuild JavaScript API cannot be bundled. Please mark the "esbuild" package as external so it's not included in the bundle.

More information: The file containing the code for esbuild's JavaScript API (${__filename}) does not appear to be inside the esbuild package on the file system, which usually means that the esbuild package was bundled into another file. This is problematic because the API needs to run a binary executable inside the esbuild package which is located using a relative path from the API code to the executable. If the esbuild package is bundled, the relative path will be incorrect and the executable won't be found.`
        );
      }
      if (false) {
        return ["node", [path22.join(__dirname, "..", "bin", "esbuild")]];
      } else {
        const { binPath, isWASM } = generateBinPath();
        if (isWASM) {
          return ["node", [binPath]];
        } else {
          return [binPath, []];
        }
      }
    };
    var isTTY = () => tty2.isatty(2);
    var fsSync = {
      readFile(tempFile, callback) {
        try {
          let contents = fs22.readFileSync(tempFile, "utf8");
          try {
            fs22.unlinkSync(tempFile);
          } catch {
          }
          callback(null, contents);
        } catch (err) {
          callback(err, null);
        }
      },
      writeFile(contents, callback) {
        try {
          let tempFile = randomFileName();
          fs22.writeFileSync(tempFile, contents);
          callback(tempFile);
        } catch {
          callback(null);
        }
      }
    };
    var fsAsync = {
      readFile(tempFile, callback) {
        try {
          fs22.readFile(tempFile, "utf8", (err, contents) => {
            try {
              fs22.unlink(tempFile, () => callback(err, contents));
            } catch {
              callback(err, contents);
            }
          });
        } catch (err) {
          callback(err, null);
        }
      },
      writeFile(contents, callback) {
        try {
          let tempFile = randomFileName();
          fs22.writeFile(tempFile, contents, (err) => err !== null ? callback(null) : callback(tempFile));
        } catch {
          callback(null);
        }
      }
    };
    var version3 = "0.15.12";
    var build2 = (options3) => ensureServiceIsRunning().build(options3);
    var serve = (serveOptions, buildOptions) => ensureServiceIsRunning().serve(serveOptions, buildOptions);
    var transform2 = (input, options3) => ensureServiceIsRunning().transform(input, options3);
    var formatMessages2 = (messages2, options3) => ensureServiceIsRunning().formatMessages(messages2, options3);
    var analyzeMetafile = (messages2, options3) => ensureServiceIsRunning().analyzeMetafile(messages2, options3);
    var buildSync = (options3) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService)
          workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.buildSync(options3);
      }
      let result;
      runServiceSync((service) => service.buildOrServe({
        callName: "buildSync",
        refs: null,
        serveOptions: null,
        options: options3,
        isTTY: isTTY(),
        defaultWD,
        callback: (err, res) => {
          if (err)
            throw err;
          result = res;
        }
      }));
      return result;
    };
    var transformSync = (input, options3) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService)
          workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.transformSync(input, options3);
      }
      let result;
      runServiceSync((service) => service.transform({
        callName: "transformSync",
        refs: null,
        input,
        options: options3 || {},
        isTTY: isTTY(),
        fs: fsSync,
        callback: (err, res) => {
          if (err)
            throw err;
          result = res;
        }
      }));
      return result;
    };
    var formatMessagesSync = (messages2, options3) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService)
          workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.formatMessagesSync(messages2, options3);
      }
      let result;
      runServiceSync((service) => service.formatMessages({
        callName: "formatMessagesSync",
        refs: null,
        messages: messages2,
        options: options3,
        callback: (err, res) => {
          if (err)
            throw err;
          result = res;
        }
      }));
      return result;
    };
    var analyzeMetafileSync = (metafile, options3) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService)
          workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.analyzeMetafileSync(metafile, options3);
      }
      let result;
      runServiceSync((service) => service.analyzeMetafile({
        callName: "analyzeMetafileSync",
        refs: null,
        metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
        options: options3,
        callback: (err, res) => {
          if (err)
            throw err;
          result = res;
        }
      }));
      return result;
    };
    var initializeWasCalled = false;
    var initialize = (options3) => {
      options3 = validateInitializeOptions(options3 || {});
      if (options3.wasmURL)
        throw new Error(`The "wasmURL" option only works in the browser`);
      if (options3.wasmModule)
        throw new Error(`The "wasmModule" option only works in the browser`);
      if (options3.worker)
        throw new Error(`The "worker" option only works in the browser`);
      if (initializeWasCalled)
        throw new Error('Cannot call "initialize" more than once');
      ensureServiceIsRunning();
      initializeWasCalled = true;
      return Promise.resolve();
    };
    var defaultWD = process.cwd();
    var longLivedService;
    var ensureServiceIsRunning = () => {
      if (longLivedService)
        return longLivedService;
      let [command, args] = esbuildCommandAndArgs();
      let child = child_process.spawn(command, args.concat(`--service=${"0.15.12"}`, "--ping"), {
        windowsHide: true,
        stdio: ["pipe", "pipe", "inherit"],
        cwd: defaultWD
      });
      let { readFromStdout, afterClose, service } = createChannel({
        writeToStdin(bytes) {
          child.stdin.write(bytes, (err) => {
            if (err)
              afterClose(err);
          });
        },
        readFileSync: fs22.readFileSync,
        isSync: false,
        isWriteUnavailable: false,
        esbuild: node_exports
      });
      child.stdin.on("error", afterClose);
      child.on("error", afterClose);
      const stdin = child.stdin;
      const stdout = child.stdout;
      stdout.on("data", readFromStdout);
      stdout.on("end", afterClose);
      let refCount = 0;
      child.unref();
      if (stdin.unref) {
        stdin.unref();
      }
      if (stdout.unref) {
        stdout.unref();
      }
      const refs = {
        ref() {
          if (++refCount === 1)
            child.ref();
        },
        unref() {
          if (--refCount === 0)
            child.unref();
        }
      };
      longLivedService = {
        build: (options3) => {
          return new Promise((resolve3, reject) => {
            service.buildOrServe({
              callName: "build",
              refs,
              serveOptions: null,
              options: options3,
              isTTY: isTTY(),
              defaultWD,
              callback: (err, res) => err ? reject(err) : resolve3(res)
            });
          });
        },
        serve: (serveOptions, buildOptions) => {
          if (serveOptions === null || typeof serveOptions !== "object")
            throw new Error("The first argument must be an object");
          return new Promise((resolve3, reject) => service.buildOrServe({
            callName: "serve",
            refs,
            serveOptions,
            options: buildOptions,
            isTTY: isTTY(),
            defaultWD,
            callback: (err, res) => err ? reject(err) : resolve3(res)
          }));
        },
        transform: (input, options3) => {
          return new Promise((resolve3, reject) => service.transform({
            callName: "transform",
            refs,
            input,
            options: options3 || {},
            isTTY: isTTY(),
            fs: fsAsync,
            callback: (err, res) => err ? reject(err) : resolve3(res)
          }));
        },
        formatMessages: (messages2, options3) => {
          return new Promise((resolve3, reject) => service.formatMessages({
            callName: "formatMessages",
            refs,
            messages: messages2,
            options: options3,
            callback: (err, res) => err ? reject(err) : resolve3(res)
          }));
        },
        analyzeMetafile: (metafile, options3) => {
          return new Promise((resolve3, reject) => service.analyzeMetafile({
            callName: "analyzeMetafile",
            refs,
            metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
            options: options3,
            callback: (err, res) => err ? reject(err) : resolve3(res)
          }));
        }
      };
      return longLivedService;
    };
    var runServiceSync = (callback) => {
      let [command, args] = esbuildCommandAndArgs();
      let stdin = new Uint8Array();
      let { readFromStdout, afterClose, service } = createChannel({
        writeToStdin(bytes) {
          if (stdin.length !== 0)
            throw new Error("Must run at most one command");
          stdin = bytes;
        },
        isSync: true,
        isWriteUnavailable: false,
        esbuild: node_exports
      });
      callback(service);
      let stdout = child_process.execFileSync(command, args.concat(`--service=${"0.15.12"}`), {
        cwd: defaultWD,
        windowsHide: true,
        input: stdin,
        maxBuffer: +process.env.ESBUILD_MAX_BUFFER || 16 * 1024 * 1024
      });
      readFromStdout(stdout);
      afterClose(null);
    };
    var randomFileName = () => {
      return path22.join(os22.tmpdir(), `esbuild-${crypto2.randomBytes(32).toString("hex")}`);
    };
    var workerThreadService = null;
    var startWorkerThreadService = (worker_threads2) => {
      let { port1: mainPort, port2: workerPort } = new worker_threads2.MessageChannel();
      let worker = new worker_threads2.Worker(__filename, {
        workerData: { workerPort, defaultWD, esbuildVersion: "0.15.12" },
        transferList: [workerPort],
        execArgv: []
      });
      let nextID = 0;
      let fakeBuildError = (text) => {
        let error2 = new Error(`Build failed with 1 error:
error: ${text}`);
        let errors = [{ id: "", pluginName: "", text, location: null, notes: [], detail: void 0 }];
        error2.errors = errors;
        error2.warnings = [];
        return error2;
      };
      let validateBuildSyncOptions = (options3) => {
        if (!options3)
          return;
        let plugins2 = options3.plugins;
        let incremental = options3.incremental;
        let watch2 = options3.watch;
        if (plugins2 && plugins2.length > 0)
          throw fakeBuildError(`Cannot use plugins in synchronous API calls`);
        if (incremental)
          throw fakeBuildError(`Cannot use "incremental" with a synchronous build`);
        if (watch2)
          throw fakeBuildError(`Cannot use "watch" with a synchronous build`);
      };
      let applyProperties = (object, properties) => {
        for (let key2 in properties) {
          object[key2] = properties[key2];
        }
      };
      let runCallSync = (command, args) => {
        let id = nextID++;
        let sharedBuffer = new SharedArrayBuffer(8);
        let sharedBufferView = new Int32Array(sharedBuffer);
        let msg = { sharedBuffer, id, command, args };
        worker.postMessage(msg);
        let status2 = Atomics.wait(sharedBufferView, 0, 0);
        if (status2 !== "ok" && status2 !== "not-equal")
          throw new Error("Internal error: Atomics.wait() failed: " + status2);
        let { message: { id: id2, resolve: resolve3, reject, properties } } = worker_threads2.receiveMessageOnPort(mainPort);
        if (id !== id2)
          throw new Error(`Internal error: Expected id ${id} but got id ${id2}`);
        if (reject) {
          applyProperties(reject, properties);
          throw reject;
        }
        return resolve3;
      };
      worker.unref();
      return {
        buildSync(options3) {
          validateBuildSyncOptions(options3);
          return runCallSync("build", [options3]);
        },
        transformSync(input, options3) {
          return runCallSync("transform", [input, options3]);
        },
        formatMessagesSync(messages2, options3) {
          return runCallSync("formatMessages", [messages2, options3]);
        },
        analyzeMetafileSync(metafile, options3) {
          return runCallSync("analyzeMetafile", [metafile, options3]);
        }
      };
    };
    var startSyncServiceWorker = () => {
      let workerPort = worker_threads.workerData.workerPort;
      let parentPort = worker_threads.parentPort;
      let extractProperties = (object) => {
        let properties = {};
        if (object && typeof object === "object") {
          for (let key2 in object) {
            properties[key2] = object[key2];
          }
        }
        return properties;
      };
      try {
        let service = ensureServiceIsRunning();
        defaultWD = worker_threads.workerData.defaultWD;
        parentPort.on("message", (msg) => {
          (async () => {
            let { sharedBuffer, id, command, args } = msg;
            let sharedBufferView = new Int32Array(sharedBuffer);
            try {
              switch (command) {
                case "build":
                  workerPort.postMessage({ id, resolve: await service.build(args[0]) });
                  break;
                case "transform":
                  workerPort.postMessage({ id, resolve: await service.transform(args[0], args[1]) });
                  break;
                case "formatMessages":
                  workerPort.postMessage({ id, resolve: await service.formatMessages(args[0], args[1]) });
                  break;
                case "analyzeMetafile":
                  workerPort.postMessage({ id, resolve: await service.analyzeMetafile(args[0], args[1]) });
                  break;
                default:
                  throw new Error(`Invalid command: ${command}`);
              }
            } catch (reject) {
              workerPort.postMessage({ id, reject, properties: extractProperties(reject) });
            }
            Atomics.add(sharedBufferView, 0, 1);
            Atomics.notify(sharedBufferView, 0, Infinity);
          })();
        });
      } catch (reject) {
        parentPort.on("message", (msg) => {
          let { sharedBuffer, id } = msg;
          let sharedBufferView = new Int32Array(sharedBuffer);
          workerPort.postMessage({ id, reject, properties: extractProperties(reject) });
          Atomics.add(sharedBufferView, 0, 1);
          Atomics.notify(sharedBufferView, 0, Infinity);
        });
      }
    };
    if (isInternalWorkerThread) {
      startSyncServiceWorker();
    }
    var node_default = node_exports;
  }
});

// browser-external:events
var require_events = __commonJS({
  "browser-external:events"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "events" has been externalized for browser compatibility. Cannot access "events.${key2}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:assert
var require_assert = __commonJS({
  "browser-external:assert"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "assert" has been externalized for browser compatibility. Cannot access "assert.${key2}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key2}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:net
var require_net = __commonJS({
  "browser-external:net"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "net" has been externalized for browser compatibility. Cannot access "net.${key2}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:http
var require_http = __commonJS({
  "browser-external:http"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "http" has been externalized for browser compatibility. Cannot access "http.${key2}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:stream
var require_stream = __commonJS({
  "browser-external:stream"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key2}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:node:os
var require_node_os = __commonJS({
  "browser-external:node:os"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "node:os" has been externalized for browser compatibility. Cannot access "node:os.${key2}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:node:crypto
var require_node_crypto = __commonJS({
  "browser-external:node:crypto"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "node:crypto" has been externalized for browser compatibility. Cannot access "node:crypto.${key2}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:node:util
var require_node_util = __commonJS({
  "browser-external:node:util"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "node:util" has been externalized for browser compatibility. Cannot access "node:util.${key2}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:node:dns
var require_node_dns = __commonJS({
  "browser-external:node:dns"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "node:dns" has been externalized for browser compatibility. Cannot access "node:dns.${key2}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:node:buffer
var require_node_buffer = __commonJS({
  "browser-external:node:buffer"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "node:buffer" has been externalized for browser compatibility. Cannot access "node:buffer.${key2}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:module
var require_module = __commonJS({
  "browser-external:module"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "module" has been externalized for browser compatibility. Cannot access "module.${key2}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:zlib
var require_zlib = __commonJS({
  "browser-external:zlib"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "zlib" has been externalized for browser compatibility. Cannot access "zlib.${key2}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:https
var require_https = __commonJS({
  "browser-external:https"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "https" has been externalized for browser compatibility. Cannot access "https.${key2}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:tls
var require_tls = __commonJS({
  "browser-external:tls"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "tls" has been externalized for browser compatibility. Cannot access "tls.${key2}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:querystring
var require_querystring = __commonJS({
  "browser-external:querystring"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "querystring" has been externalized for browser compatibility. Cannot access "querystring.${key2}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:node:readline
var require_node_readline = __commonJS({
  "browser-external:node:readline"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "node:readline" has been externalized for browser compatibility. Cannot access "node:readline.${key2}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:node:child_process
var require_node_child_process = __commonJS({
  "browser-external:node:child_process"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "node:child_process" has been externalized for browser compatibility. Cannot access "node:child_process.${key2}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:node:zlib
var require_node_zlib = __commonJS({
  "browser-external:node:zlib"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "node:zlib" has been externalized for browser compatibility. Cannot access "node:zlib.${key2}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/vite/dist/node/constants.js
var import_node_path = __toESM(require_node_path(), 1);
var import_node_url = __toESM(require_node_url(), 1);
var version = "3.2.5";
var VERSION = version;
var DEFAULT_MAIN_FIELDS = [
  "module",
  "jsnext:main",
  "jsnext"
];
var ESBUILD_MODULES_TARGET = [
  "es2020",
  "edge88",
  "firefox78",
  "chrome87",
  "safari13"
];
var DEFAULT_EXTENSIONS = [
  ".mjs",
  ".js",
  ".mts",
  ".ts",
  ".jsx",
  ".tsx",
  ".json"
];
var DEFAULT_CONFIG_FILES = [
  "vite.config.js",
  "vite.config.mjs",
  "vite.config.ts",
  "vite.config.cjs",
  "vite.config.mts",
  "vite.config.cts"
];
var JS_TYPES_RE = /\.(?:j|t)sx?$|\.mjs$/;
var OPTIMIZABLE_ENTRY_RE = /\.(?:[cm]?[jt]s)$/;
var SPECIAL_QUERY_RE = /[\?&](?:worker|sharedworker|raw|url)\b/;
var FS_PREFIX = `/@fs/`;
var VALID_ID_PREFIX = `/@id/`;
var NULL_BYTE_PLACEHOLDER = `__x00__`;
var CLIENT_PUBLIC_PATH = `/@vite/client`;
var ENV_PUBLIC_PATH = `/@vite/env`;
var VITE_PACKAGE_DIR = (0, import_node_path.resolve)(
  (0, import_node_url.fileURLToPath)(import.meta.url),
  "../../.."
);
var CLIENT_ENTRY = (0, import_node_path.resolve)(VITE_PACKAGE_DIR, "dist/client/client.mjs");
var ENV_ENTRY = (0, import_node_path.resolve)(VITE_PACKAGE_DIR, "dist/client/env.mjs");
var CLIENT_DIR = import_node_path.default.dirname(CLIENT_ENTRY);
var KNOWN_ASSET_TYPES = [
  "png",
  "jpe?g",
  "jfif",
  "pjpeg",
  "pjp",
  "gif",
  "svg",
  "ico",
  "webp",
  "avif",
  "mp4",
  "webm",
  "ogg",
  "mp3",
  "wav",
  "flac",
  "aac",
  "woff2?",
  "eot",
  "ttf",
  "otf",
  "webmanifest",
  "pdf",
  "txt"
];
var DEFAULT_ASSETS_RE = new RegExp(`\\.(` + KNOWN_ASSET_TYPES.join("|") + `)(\\?.*)?$`);
var DEP_VERSION_RE = /[\?&](v=[\w\.-]+)\b/;
var loopbackHosts = /* @__PURE__ */ new Set([
  "localhost",
  "127.0.0.1",
  "::1",
  "0000:0000:0000:0000:0000:0000:0000:0001"
]);
var wildcardHosts = /* @__PURE__ */ new Set([
  "0.0.0.0",
  "::",
  "0000:0000:0000:0000:0000:0000:0000:0000"
]);

// node_modules/vite/dist/node/chunks/dep-5605cfa4.js
var import_node_fs = __toESM(require_node_fs(), 1);
var import_node_path2 = __toESM(require_node_path(), 1);
var import_node_url2 = __toESM(require_node_url(), 1);
var import_node_perf_hooks = __toESM(require_node_perf_hooks(), 1);
var import_node_module = __toESM(require_node_module(), 1);
var import_tty = __toESM(require_tty(), 1);
var import_esbuild = __toESM(require_main(), 1);
var import_path = __toESM(require_path(), 1);
var require$$0$2 = __toESM(require_fs(), 1);
var import_fs = __toESM(require_fs(), 1);
var import_events = __toESM(require_events(), 1);
var import_assert = __toESM(require_assert(), 1);
var import_util = __toESM(require_util(), 1);
var import_net = __toESM(require_net(), 1);
var import_url = __toESM(require_url(), 1);
var import_http = __toESM(require_http(), 1);
var import_stream = __toESM(require_stream(), 1);
var import_os = __toESM(require_os(), 1);
var import_child_process = __toESM(require_child_process(), 1);
var import_node_os = __toESM(require_node_os(), 1);
var import_node_crypto = __toESM(require_node_crypto(), 1);
var import_node_util = __toESM(require_node_util(), 1);
var import_node_dns = __toESM(require_node_dns(), 1);
var import_resolve = __toESM(require_resolve(), 1);
var import_crypto = __toESM(require_crypto(), 1);
var import_node_buffer = __toESM(require_node_buffer(), 1);
var import_module = __toESM(require_module(), 1);
var import_worker_threads = __toESM(require_worker_threads(), 1);
var import_zlib = __toESM(require_zlib(), 1);
var import_https = __toESM(require_https(), 1);
var import_tls = __toESM(require_tls(), 1);
var import_node_http = __toESM(require_node_http(), 1);
var import_node_https = __toESM(require_node_https(), 1);
var qs = __toESM(require_querystring(), 1);
var import_node_readline = __toESM(require_node_readline(), 1);
var import_node_child_process = __toESM(require_node_child_process(), 1);
var import_node_zlib = __toESM(require_node_zlib(), 1);
var import_node_url3 = __toESM(require_node_url(), 1);
var import_node_path3 = __toESM(require_node_path(), 1);
var import_node_module2 = __toESM(require_node_module(), 1);
var __filename2 = (0, import_node_url3.fileURLToPath)(import.meta.url);
var __dirname2 = (0, import_node_path3.dirname)(__filename2);
var require2 = (0, import_node_module2.createRequire)(import.meta.url);
var __require2 = require2;
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n2) {
  var f = n2.default;
  if (typeof f == "function") {
    var a = function() {
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n2, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n2[k];
      }
    });
  });
  return a;
}
var picocolors = { exports: {} };
var tty = import_tty.default;
var isColorSupported = !("NO_COLOR" in process.env || process.argv.includes("--no-color")) && ("FORCE_COLOR" in process.env || process.argv.includes("--color") || process.platform === "win32" || tty.isatty(1) && process.env.TERM !== "dumb" || "CI" in process.env);
var formatter = (open2, close2, replace = open2) => (input) => {
  let string2 = "" + input;
  let index2 = string2.indexOf(close2, open2.length);
  return ~index2 ? open2 + replaceClose(string2, close2, replace, index2) + close2 : open2 + string2 + close2;
};
var replaceClose = (string2, close2, replace, index2) => {
  let start = string2.substring(0, index2) + replace;
  let end = string2.substring(index2 + close2.length);
  let nextIndex2 = end.indexOf(close2);
  return ~nextIndex2 ? start + replaceClose(end, close2, replace, nextIndex2) : start + end;
};
var createColors = (enabled = isColorSupported) => ({
  isColorSupported: enabled,
  reset: enabled ? (s) => `\x1B[0m${s}\x1B[0m` : String,
  bold: enabled ? formatter("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m") : String,
  dim: enabled ? formatter("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m") : String,
  italic: enabled ? formatter("\x1B[3m", "\x1B[23m") : String,
  underline: enabled ? formatter("\x1B[4m", "\x1B[24m") : String,
  inverse: enabled ? formatter("\x1B[7m", "\x1B[27m") : String,
  hidden: enabled ? formatter("\x1B[8m", "\x1B[28m") : String,
  strikethrough: enabled ? formatter("\x1B[9m", "\x1B[29m") : String,
  black: enabled ? formatter("\x1B[30m", "\x1B[39m") : String,
  red: enabled ? formatter("\x1B[31m", "\x1B[39m") : String,
  green: enabled ? formatter("\x1B[32m", "\x1B[39m") : String,
  yellow: enabled ? formatter("\x1B[33m", "\x1B[39m") : String,
  blue: enabled ? formatter("\x1B[34m", "\x1B[39m") : String,
  magenta: enabled ? formatter("\x1B[35m", "\x1B[39m") : String,
  cyan: enabled ? formatter("\x1B[36m", "\x1B[39m") : String,
  white: enabled ? formatter("\x1B[37m", "\x1B[39m") : String,
  gray: enabled ? formatter("\x1B[90m", "\x1B[39m") : String,
  bgBlack: enabled ? formatter("\x1B[40m", "\x1B[49m") : String,
  bgRed: enabled ? formatter("\x1B[41m", "\x1B[49m") : String,
  bgGreen: enabled ? formatter("\x1B[42m", "\x1B[49m") : String,
  bgYellow: enabled ? formatter("\x1B[43m", "\x1B[49m") : String,
  bgBlue: enabled ? formatter("\x1B[44m", "\x1B[49m") : String,
  bgMagenta: enabled ? formatter("\x1B[45m", "\x1B[49m") : String,
  bgCyan: enabled ? formatter("\x1B[46m", "\x1B[49m") : String,
  bgWhite: enabled ? formatter("\x1B[47m", "\x1B[49m") : String
});
picocolors.exports = createColors();
picocolors.exports.createColors = createColors;
function matches$1(pattern2, importee) {
  if (pattern2 instanceof RegExp) {
    return pattern2.test(importee);
  }
  if (importee.length < pattern2.length) {
    return false;
  }
  if (importee === pattern2) {
    return true;
  }
  return importee.startsWith(pattern2 + "/");
}
function getEntries({ entries, customResolver }) {
  if (!entries) {
    return [];
  }
  const resolverFunctionFromOptions = resolveCustomResolver(customResolver);
  if (Array.isArray(entries)) {
    return entries.map((entry2) => {
      return {
        find: entry2.find,
        replacement: entry2.replacement,
        resolverFunction: resolveCustomResolver(entry2.customResolver) || resolverFunctionFromOptions
      };
    });
  }
  return Object.entries(entries).map(([key2, value2]) => {
    return { find: key2, replacement: value2, resolverFunction: resolverFunctionFromOptions };
  });
}
function getHookFunction(hook) {
  if (typeof hook === "function") {
    return hook;
  }
  if (hook && "handler" in hook && typeof hook.handler === "function") {
    return hook.handler;
  }
  return null;
}
function resolveCustomResolver(customResolver) {
  if (typeof customResolver === "function") {
    return customResolver;
  }
  if (customResolver) {
    return getHookFunction(customResolver.resolveId);
  }
  return null;
}
function alias$1(options3 = {}) {
  const entries = getEntries(options3);
  if (entries.length === 0) {
    return {
      name: "alias",
      resolveId: () => null
    };
  }
  return {
    name: "alias",
    async buildStart(inputOptions) {
      await Promise.all([...Array.isArray(options3.entries) ? options3.entries : [], options3].map(({ customResolver }) => {
        var _a;
        return customResolver && ((_a = getHookFunction(customResolver.buildStart)) === null || _a === void 0 ? void 0 : _a.call(this, inputOptions));
      }));
    },
    resolveId(importee, importer, resolveOptions) {
      if (!importer) {
        return null;
      }
      const matchedEntry = entries.find((entry2) => matches$1(entry2.find, importee));
      if (!matchedEntry) {
        return null;
      }
      const updatedId = importee.replace(matchedEntry.find, matchedEntry.replacement);
      if (matchedEntry.resolverFunction) {
        return matchedEntry.resolverFunction.call(this, updatedId, importer, resolveOptions);
      }
      return this.resolve(updatedId, importer, Object.assign({ skipSelf: true }, resolveOptions)).then((resolved) => resolved || { id: updatedId });
    }
  };
}
var WalkerBase$1 = class {
  constructor() {
    this.should_skip = false;
    this.should_remove = false;
    this.replacement = null;
    this.context = {
      skip: () => this.should_skip = true,
      remove: () => this.should_remove = true,
      replace: (node2) => this.replacement = node2
    };
  }
  replace(parent, prop, index2, node2) {
    if (parent) {
      if (index2 !== null) {
        parent[prop][index2] = node2;
      } else {
        parent[prop] = node2;
      }
    }
  }
  remove(parent, prop, index2) {
    if (parent) {
      if (index2 !== null) {
        parent[prop].splice(index2, 1);
      } else {
        delete parent[prop];
      }
    }
  }
};
var SyncWalker$1 = class extends WalkerBase$1 {
  constructor(enter, leave) {
    super();
    this.enter = enter;
    this.leave = leave;
  }
  visit(node2, parent, prop, index2) {
    if (node2) {
      if (this.enter) {
        const _should_skip = this.should_skip;
        const _should_remove = this.should_remove;
        const _replacement = this.replacement;
        this.should_skip = false;
        this.should_remove = false;
        this.replacement = null;
        this.enter.call(this.context, node2, parent, prop, index2);
        if (this.replacement) {
          node2 = this.replacement;
          this.replace(parent, prop, index2, node2);
        }
        if (this.should_remove) {
          this.remove(parent, prop, index2);
        }
        const skipped = this.should_skip;
        const removed = this.should_remove;
        this.should_skip = _should_skip;
        this.should_remove = _should_remove;
        this.replacement = _replacement;
        if (skipped)
          return node2;
        if (removed)
          return null;
      }
      for (const key2 in node2) {
        const value2 = node2[key2];
        if (typeof value2 !== "object") {
          continue;
        } else if (Array.isArray(value2)) {
          for (let i = 0; i < value2.length; i += 1) {
            if (value2[i] !== null && typeof value2[i].type === "string") {
              if (!this.visit(value2[i], node2, key2, i)) {
                i--;
              }
            }
          }
        } else if (value2 !== null && typeof value2.type === "string") {
          this.visit(value2, node2, key2, null);
        }
      }
      if (this.leave) {
        const _replacement = this.replacement;
        const _should_remove = this.should_remove;
        this.replacement = null;
        this.should_remove = false;
        this.leave.call(this.context, node2, parent, prop, index2);
        if (this.replacement) {
          node2 = this.replacement;
          this.replace(parent, prop, index2, node2);
        }
        if (this.should_remove) {
          this.remove(parent, prop, index2);
        }
        const removed = this.should_remove;
        this.replacement = _replacement;
        this.should_remove = _should_remove;
        if (removed)
          return null;
      }
    }
    return node2;
  }
};
function walk$3(ast, { enter, leave }) {
  const instance = new SyncWalker$1(enter, leave);
  return instance.visit(ast, null);
}
var picomatch$5 = { exports: {} };
var utils$k = {};
var path$n = import_path.default;
var WIN_SLASH = "\\\\/";
var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
var DOT_LITERAL = "\\.";
var PLUS_LITERAL = "\\+";
var QMARK_LITERAL = "\\?";
var SLASH_LITERAL = "\\/";
var ONE_CHAR = "(?=.)";
var QMARK = "[^/]";
var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
var NO_DOT = `(?!${DOT_LITERAL})`;
var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
var STAR$1 = `${QMARK}*?`;
var POSIX_CHARS = {
  DOT_LITERAL,
  PLUS_LITERAL,
  QMARK_LITERAL,
  SLASH_LITERAL,
  ONE_CHAR,
  QMARK,
  END_ANCHOR,
  DOTS_SLASH,
  NO_DOT,
  NO_DOTS,
  NO_DOT_SLASH,
  NO_DOTS_SLASH,
  QMARK_NO_DOT,
  STAR: STAR$1,
  START_ANCHOR
};
var WINDOWS_CHARS = {
  ...POSIX_CHARS,
  SLASH_LITERAL: `[${WIN_SLASH}]`,
  QMARK: WIN_NO_SLASH,
  STAR: `${WIN_NO_SLASH}*?`,
  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
  NO_DOT: `(?!${DOT_LITERAL})`,
  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
};
var POSIX_REGEX_SOURCE$1 = {
  alnum: "a-zA-Z0-9",
  alpha: "a-zA-Z",
  ascii: "\\x00-\\x7F",
  blank: " \\t",
  cntrl: "\\x00-\\x1F\\x7F",
  digit: "0-9",
  graph: "\\x21-\\x7E",
  lower: "a-z",
  print: "\\x20-\\x7E ",
  punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
  space: " \\t\\r\\n\\v\\f",
  upper: "A-Z",
  word: "A-Za-z0-9_",
  xdigit: "A-Fa-f0-9"
};
var constants$6 = {
  MAX_LENGTH: 1024 * 64,
  POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$1,
  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
  REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
  REPLACEMENTS: {
    "***": "*",
    "**/**": "**",
    "**/**/**": "**"
  },
  CHAR_0: 48,
  CHAR_9: 57,
  CHAR_UPPERCASE_A: 65,
  CHAR_LOWERCASE_A: 97,
  CHAR_UPPERCASE_Z: 90,
  CHAR_LOWERCASE_Z: 122,
  CHAR_LEFT_PARENTHESES: 40,
  CHAR_RIGHT_PARENTHESES: 41,
  CHAR_ASTERISK: 42,
  CHAR_AMPERSAND: 38,
  CHAR_AT: 64,
  CHAR_BACKWARD_SLASH: 92,
  CHAR_CARRIAGE_RETURN: 13,
  CHAR_CIRCUMFLEX_ACCENT: 94,
  CHAR_COLON: 58,
  CHAR_COMMA: 44,
  CHAR_DOT: 46,
  CHAR_DOUBLE_QUOTE: 34,
  CHAR_EQUAL: 61,
  CHAR_EXCLAMATION_MARK: 33,
  CHAR_FORM_FEED: 12,
  CHAR_FORWARD_SLASH: 47,
  CHAR_GRAVE_ACCENT: 96,
  CHAR_HASH: 35,
  CHAR_HYPHEN_MINUS: 45,
  CHAR_LEFT_ANGLE_BRACKET: 60,
  CHAR_LEFT_CURLY_BRACE: 123,
  CHAR_LEFT_SQUARE_BRACKET: 91,
  CHAR_LINE_FEED: 10,
  CHAR_NO_BREAK_SPACE: 160,
  CHAR_PERCENT: 37,
  CHAR_PLUS: 43,
  CHAR_QUESTION_MARK: 63,
  CHAR_RIGHT_ANGLE_BRACKET: 62,
  CHAR_RIGHT_CURLY_BRACE: 125,
  CHAR_RIGHT_SQUARE_BRACKET: 93,
  CHAR_SEMICOLON: 59,
  CHAR_SINGLE_QUOTE: 39,
  CHAR_SPACE: 32,
  CHAR_TAB: 9,
  CHAR_UNDERSCORE: 95,
  CHAR_VERTICAL_LINE: 124,
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
  SEP: path$n.sep,
  extglobChars(chars2) {
    return {
      "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars2.STAR})` },
      "?": { type: "qmark", open: "(?:", close: ")?" },
      "+": { type: "plus", open: "(?:", close: ")+" },
      "*": { type: "star", open: "(?:", close: ")*" },
      "@": { type: "at", open: "(?:", close: ")" }
    };
  },
  globChars(win322) {
    return win322 === true ? WINDOWS_CHARS : POSIX_CHARS;
  }
};
(function(exports) {
  const path4 = import_path.default;
  const win322 = process.platform === "win32";
  const {
    REGEX_BACKSLASH,
    REGEX_REMOVE_BACKSLASH,
    REGEX_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_GLOBAL
  } = constants$6;
  exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
  exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
  exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
  exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
  exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
  exports.removeBackslashes = (str) => {
    return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
      return match === "\\" ? "" : match;
    });
  };
  exports.supportsLookbehinds = () => {
    const segs = process.version.slice(1).split(".").map(Number);
    if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
      return true;
    }
    return false;
  };
  exports.isWindows = (options3) => {
    if (options3 && typeof options3.windows === "boolean") {
      return options3.windows;
    }
    return win322 === true || path4.sep === "\\";
  };
  exports.escapeLast = (input, char, lastIdx) => {
    const idx = input.lastIndexOf(char, lastIdx);
    if (idx === -1)
      return input;
    if (input[idx - 1] === "\\")
      return exports.escapeLast(input, char, idx - 1);
    return `${input.slice(0, idx)}\\${input.slice(idx)}`;
  };
  exports.removePrefix = (input, state = {}) => {
    let output = input;
    if (output.startsWith("./")) {
      output = output.slice(2);
      state.prefix = "./";
    }
    return output;
  };
  exports.wrapOutput = (input, state = {}, options3 = {}) => {
    const prepend = options3.contains ? "" : "^";
    const append2 = options3.contains ? "" : "$";
    let output = `${prepend}(?:${input})${append2}`;
    if (state.negated === true) {
      output = `(?:^(?!${output}).*$)`;
    }
    return output;
  };
})(utils$k);
var utils$j = utils$k;
var {
  CHAR_ASTERISK,
  CHAR_AT,
  CHAR_BACKWARD_SLASH,
  CHAR_COMMA: CHAR_COMMA$1,
  CHAR_DOT: CHAR_DOT$1,
  CHAR_EXCLAMATION_MARK,
  CHAR_FORWARD_SLASH,
  CHAR_LEFT_CURLY_BRACE: CHAR_LEFT_CURLY_BRACE$1,
  CHAR_LEFT_PARENTHESES: CHAR_LEFT_PARENTHESES$1,
  CHAR_LEFT_SQUARE_BRACKET: CHAR_LEFT_SQUARE_BRACKET$1,
  CHAR_PLUS,
  CHAR_QUESTION_MARK,
  CHAR_RIGHT_CURLY_BRACE: CHAR_RIGHT_CURLY_BRACE$1,
  CHAR_RIGHT_PARENTHESES: CHAR_RIGHT_PARENTHESES$1,
  CHAR_RIGHT_SQUARE_BRACKET: CHAR_RIGHT_SQUARE_BRACKET$1
} = constants$6;
var isPathSeparator = (code) => {
  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
};
var depth = (token2) => {
  if (token2.isPrefix !== true) {
    token2.depth = token2.isGlobstar ? Infinity : 1;
  }
};
var scan$2 = (input, options3) => {
  const opts = options3 || {};
  const length = input.length - 1;
  const scanToEnd = opts.parts === true || opts.scanToEnd === true;
  const slashes = [];
  const tokens = [];
  const parts = [];
  let str = input;
  let index2 = -1;
  let start = 0;
  let lastIndex = 0;
  let isBrace = false;
  let isBracket = false;
  let isGlob3 = false;
  let isExtglob3 = false;
  let isGlobstar = false;
  let braceEscaped = false;
  let backslashes = false;
  let negated = false;
  let negatedExtglob = false;
  let finished = false;
  let braces2 = 0;
  let prev;
  let code;
  let token2 = { value: "", depth: 0, isGlob: false };
  const eos = () => index2 >= length;
  const peek2 = () => str.charCodeAt(index2 + 1);
  const advance2 = () => {
    prev = code;
    return str.charCodeAt(++index2);
  };
  while (index2 < length) {
    code = advance2();
    let next;
    if (code === CHAR_BACKWARD_SLASH) {
      backslashes = token2.backslashes = true;
      code = advance2();
      if (code === CHAR_LEFT_CURLY_BRACE$1) {
        braceEscaped = true;
      }
      continue;
    }
    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE$1) {
      braces2++;
      while (eos() !== true && (code = advance2())) {
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token2.backslashes = true;
          advance2();
          continue;
        }
        if (code === CHAR_LEFT_CURLY_BRACE$1) {
          braces2++;
          continue;
        }
        if (braceEscaped !== true && code === CHAR_DOT$1 && (code = advance2()) === CHAR_DOT$1) {
          isBrace = token2.isBrace = true;
          isGlob3 = token2.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (braceEscaped !== true && code === CHAR_COMMA$1) {
          isBrace = token2.isBrace = true;
          isGlob3 = token2.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_RIGHT_CURLY_BRACE$1) {
          braces2--;
          if (braces2 === 0) {
            braceEscaped = false;
            isBrace = token2.isBrace = true;
            finished = true;
            break;
          }
        }
      }
      if (scanToEnd === true) {
        continue;
      }
      break;
    }
    if (code === CHAR_FORWARD_SLASH) {
      slashes.push(index2);
      tokens.push(token2);
      token2 = { value: "", depth: 0, isGlob: false };
      if (finished === true)
        continue;
      if (prev === CHAR_DOT$1 && index2 === start + 1) {
        start += 2;
        continue;
      }
      lastIndex = index2 + 1;
      continue;
    }
    if (opts.noext !== true) {
      const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
      if (isExtglobChar === true && peek2() === CHAR_LEFT_PARENTHESES$1) {
        isGlob3 = token2.isGlob = true;
        isExtglob3 = token2.isExtglob = true;
        finished = true;
        if (code === CHAR_EXCLAMATION_MARK && index2 === start) {
          negatedExtglob = true;
        }
        if (scanToEnd === true) {
          while (eos() !== true && (code = advance2())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token2.backslashes = true;
              code = advance2();
              continue;
            }
            if (code === CHAR_RIGHT_PARENTHESES$1) {
              isGlob3 = token2.isGlob = true;
              finished = true;
              break;
            }
          }
          continue;
        }
        break;
      }
    }
    if (code === CHAR_ASTERISK) {
      if (prev === CHAR_ASTERISK)
        isGlobstar = token2.isGlobstar = true;
      isGlob3 = token2.isGlob = true;
      finished = true;
      if (scanToEnd === true) {
        continue;
      }
      break;
    }
    if (code === CHAR_QUESTION_MARK) {
      isGlob3 = token2.isGlob = true;
      finished = true;
      if (scanToEnd === true) {
        continue;
      }
      break;
    }
    if (code === CHAR_LEFT_SQUARE_BRACKET$1) {
      while (eos() !== true && (next = advance2())) {
        if (next === CHAR_BACKWARD_SLASH) {
          backslashes = token2.backslashes = true;
          advance2();
          continue;
        }
        if (next === CHAR_RIGHT_SQUARE_BRACKET$1) {
          isBracket = token2.isBracket = true;
          isGlob3 = token2.isGlob = true;
          finished = true;
          break;
        }
      }
      if (scanToEnd === true) {
        continue;
      }
      break;
    }
    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index2 === start) {
      negated = token2.negated = true;
      start++;
      continue;
    }
    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES$1) {
      isGlob3 = token2.isGlob = true;
      if (scanToEnd === true) {
        while (eos() !== true && (code = advance2())) {
          if (code === CHAR_LEFT_PARENTHESES$1) {
            backslashes = token2.backslashes = true;
            code = advance2();
            continue;
          }
          if (code === CHAR_RIGHT_PARENTHESES$1) {
            finished = true;
            break;
          }
        }
        continue;
      }
      break;
    }
    if (isGlob3 === true) {
      finished = true;
      if (scanToEnd === true) {
        continue;
      }
      break;
    }
  }
  if (opts.noext === true) {
    isExtglob3 = false;
    isGlob3 = false;
  }
  let base2 = str;
  let prefix = "";
  let glob = "";
  if (start > 0) {
    prefix = str.slice(0, start);
    str = str.slice(start);
    lastIndex -= start;
  }
  if (base2 && isGlob3 === true && lastIndex > 0) {
    base2 = str.slice(0, lastIndex);
    glob = str.slice(lastIndex);
  } else if (isGlob3 === true) {
    base2 = "";
    glob = str;
  } else {
    base2 = str;
  }
  if (base2 && base2 !== "" && base2 !== "/" && base2 !== str) {
    if (isPathSeparator(base2.charCodeAt(base2.length - 1))) {
      base2 = base2.slice(0, -1);
    }
  }
  if (opts.unescape === true) {
    if (glob)
      glob = utils$j.removeBackslashes(glob);
    if (base2 && backslashes === true) {
      base2 = utils$j.removeBackslashes(base2);
    }
  }
  const state = {
    prefix,
    input,
    start,
    base: base2,
    glob,
    isBrace,
    isBracket,
    isGlob: isGlob3,
    isExtglob: isExtglob3,
    isGlobstar,
    negated,
    negatedExtglob
  };
  if (opts.tokens === true) {
    state.maxDepth = 0;
    if (!isPathSeparator(code)) {
      tokens.push(token2);
    }
    state.tokens = tokens;
  }
  if (opts.parts === true || opts.tokens === true) {
    let prevIndex;
    for (let idx = 0; idx < slashes.length; idx++) {
      const n2 = prevIndex ? prevIndex + 1 : start;
      const i = slashes[idx];
      const value2 = input.slice(n2, i);
      if (opts.tokens) {
        if (idx === 0 && start !== 0) {
          tokens[idx].isPrefix = true;
          tokens[idx].value = prefix;
        } else {
          tokens[idx].value = value2;
        }
        depth(tokens[idx]);
        state.maxDepth += tokens[idx].depth;
      }
      if (idx !== 0 || value2 !== "") {
        parts.push(value2);
      }
      prevIndex = i;
    }
    if (prevIndex && prevIndex + 1 < input.length) {
      const value2 = input.slice(prevIndex + 1);
      parts.push(value2);
      if (opts.tokens) {
        tokens[tokens.length - 1].value = value2;
        depth(tokens[tokens.length - 1]);
        state.maxDepth += tokens[tokens.length - 1].depth;
      }
    }
    state.slashes = slashes;
    state.parts = parts;
  }
  return state;
};
var scan_1 = scan$2;
var constants$5 = constants$6;
var utils$i = utils$k;
var {
  MAX_LENGTH: MAX_LENGTH$1,
  POSIX_REGEX_SOURCE,
  REGEX_NON_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_BACKREF,
  REPLACEMENTS
} = constants$5;
var expandRange = (args, options3) => {
  if (typeof options3.expandRange === "function") {
    return options3.expandRange(...args, options3);
  }
  args.sort();
  const value2 = `[${args.join("-")}]`;
  return value2;
};
var syntaxError$1 = (type, char) => {
  return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
};
var parse$i = (input, options3) => {
  if (typeof input !== "string") {
    throw new TypeError("Expected a string");
  }
  input = REPLACEMENTS[input] || input;
  const opts = { ...options3 };
  const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;
  let len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }
  const bos = { type: "bos", value: "", output: opts.prepend || "" };
  const tokens = [bos];
  const capture = opts.capture ? "" : "?:";
  const win322 = utils$i.isWindows(options3);
  const PLATFORM_CHARS = constants$5.globChars(win322);
  const EXTGLOB_CHARS = constants$5.extglobChars(PLATFORM_CHARS);
  const {
    DOT_LITERAL: DOT_LITERAL2,
    PLUS_LITERAL: PLUS_LITERAL2,
    SLASH_LITERAL: SLASH_LITERAL2,
    ONE_CHAR: ONE_CHAR2,
    DOTS_SLASH: DOTS_SLASH2,
    NO_DOT: NO_DOT2,
    NO_DOT_SLASH: NO_DOT_SLASH2,
    NO_DOTS_SLASH: NO_DOTS_SLASH2,
    QMARK: QMARK2,
    QMARK_NO_DOT: QMARK_NO_DOT2,
    STAR: STAR2,
    START_ANCHOR: START_ANCHOR2
  } = PLATFORM_CHARS;
  const globstar = (opts2) => {
    return `(${capture}(?:(?!${START_ANCHOR2}${opts2.dot ? DOTS_SLASH2 : DOT_LITERAL2}).)*?)`;
  };
  const nodot = opts.dot ? "" : NO_DOT2;
  const qmarkNoDot = opts.dot ? QMARK2 : QMARK_NO_DOT2;
  let star2 = opts.bash === true ? globstar(opts) : STAR2;
  if (opts.capture) {
    star2 = `(${star2})`;
  }
  if (typeof opts.noext === "boolean") {
    opts.noextglob = opts.noext;
  }
  const state = {
    input,
    index: -1,
    start: 0,
    dot: opts.dot === true,
    consumed: "",
    output: "",
    prefix: "",
    backtrack: false,
    negated: false,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    globstar: false,
    tokens
  };
  input = utils$i.removePrefix(input, state);
  len = input.length;
  const extglobs = [];
  const braces2 = [];
  const stack2 = [];
  let prev = bos;
  let value2;
  const eos = () => state.index === len - 1;
  const peek2 = state.peek = (n2 = 1) => input[state.index + n2];
  const advance2 = state.advance = () => input[++state.index] || "";
  const remaining = () => input.slice(state.index + 1);
  const consume = (value3 = "", num = 0) => {
    state.consumed += value3;
    state.index += num;
  };
  const append2 = (token2) => {
    state.output += token2.output != null ? token2.output : token2.value;
    consume(token2.value);
  };
  const negate = () => {
    let count = 1;
    while (peek2() === "!" && (peek2(2) !== "(" || peek2(3) === "?")) {
      advance2();
      state.start++;
      count++;
    }
    if (count % 2 === 0) {
      return false;
    }
    state.negated = true;
    state.start++;
    return true;
  };
  const increment = (type) => {
    state[type]++;
    stack2.push(type);
  };
  const decrement = (type) => {
    state[type]--;
    stack2.pop();
  };
  const push2 = (tok) => {
    if (prev.type === "globstar") {
      const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
      const isExtglob3 = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
      if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob3) {
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = "star";
        prev.value = "*";
        prev.output = star2;
        state.output += prev.output;
      }
    }
    if (extglobs.length && tok.type !== "paren") {
      extglobs[extglobs.length - 1].inner += tok.value;
    }
    if (tok.value || tok.output)
      append2(tok);
    if (prev && prev.type === "text" && tok.type === "text") {
      prev.value += tok.value;
      prev.output = (prev.output || "") + tok.value;
      return;
    }
    tok.prev = prev;
    tokens.push(tok);
    prev = tok;
  };
  const extglobOpen = (type, value3) => {
    const token2 = { ...EXTGLOB_CHARS[value3], conditions: 1, inner: "" };
    token2.prev = prev;
    token2.parens = state.parens;
    token2.output = state.output;
    const output = (opts.capture ? "(" : "") + token2.open;
    increment("parens");
    push2({ type, value: value3, output: state.output ? "" : ONE_CHAR2 });
    push2({ type: "paren", extglob: true, value: advance2(), output });
    extglobs.push(token2);
  };
  const extglobClose = (token2) => {
    let output = token2.close + (opts.capture ? ")" : "");
    let rest;
    if (token2.type === "negate") {
      let extglobStar = star2;
      if (token2.inner && token2.inner.length > 1 && token2.inner.includes("/")) {
        extglobStar = globstar(opts);
      }
      if (extglobStar !== star2 || eos() || /^\)+$/.test(remaining())) {
        output = token2.close = `)$))${extglobStar}`;
      }
      if (token2.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
        const expression = parse$i(rest, { ...options3, fastpaths: false }).output;
        output = token2.close = `)${expression})${extglobStar})`;
      }
      if (token2.prev.type === "bos") {
        state.negatedExtglob = true;
      }
    }
    push2({ type: "paren", extglob: true, value: value2, output });
    decrement("parens");
  };
  if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
    let backslashes = false;
    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars2, first2, rest, index2) => {
      if (first2 === "\\") {
        backslashes = true;
        return m;
      }
      if (first2 === "?") {
        if (esc) {
          return esc + first2 + (rest ? QMARK2.repeat(rest.length) : "");
        }
        if (index2 === 0) {
          return qmarkNoDot + (rest ? QMARK2.repeat(rest.length) : "");
        }
        return QMARK2.repeat(chars2.length);
      }
      if (first2 === ".") {
        return DOT_LITERAL2.repeat(chars2.length);
      }
      if (first2 === "*") {
        if (esc) {
          return esc + first2 + (rest ? star2 : "");
        }
        return star2;
      }
      return esc ? m : `\\${m}`;
    });
    if (backslashes === true) {
      if (opts.unescape === true) {
        output = output.replace(/\\/g, "");
      } else {
        output = output.replace(/\\+/g, (m) => {
          return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
        });
      }
    }
    if (output === input && opts.contains === true) {
      state.output = input;
      return state;
    }
    state.output = utils$i.wrapOutput(output, state, options3);
    return state;
  }
  while (!eos()) {
    value2 = advance2();
    if (value2 === "\0") {
      continue;
    }
    if (value2 === "\\") {
      const next = peek2();
      if (next === "/" && opts.bash !== true) {
        continue;
      }
      if (next === "." || next === ";") {
        continue;
      }
      if (!next) {
        value2 += "\\";
        push2({ type: "text", value: value2 });
        continue;
      }
      const match = /^\\+/.exec(remaining());
      let slashes = 0;
      if (match && match[0].length > 2) {
        slashes = match[0].length;
        state.index += slashes;
        if (slashes % 2 !== 0) {
          value2 += "\\";
        }
      }
      if (opts.unescape === true) {
        value2 = advance2();
      } else {
        value2 += advance2();
      }
      if (state.brackets === 0) {
        push2({ type: "text", value: value2 });
        continue;
      }
    }
    if (state.brackets > 0 && (value2 !== "]" || prev.value === "[" || prev.value === "[^")) {
      if (opts.posix !== false && value2 === ":") {
        const inner = prev.value.slice(1);
        if (inner.includes("[")) {
          prev.posix = true;
          if (inner.includes(":")) {
            const idx = prev.value.lastIndexOf("[");
            const pre = prev.value.slice(0, idx);
            const rest2 = prev.value.slice(idx + 2);
            const posix2 = POSIX_REGEX_SOURCE[rest2];
            if (posix2) {
              prev.value = pre + posix2;
              state.backtrack = true;
              advance2();
              if (!bos.output && tokens.indexOf(prev) === 1) {
                bos.output = ONE_CHAR2;
              }
              continue;
            }
          }
        }
      }
      if (value2 === "[" && peek2() !== ":" || value2 === "-" && peek2() === "]") {
        value2 = `\\${value2}`;
      }
      if (value2 === "]" && (prev.value === "[" || prev.value === "[^")) {
        value2 = `\\${value2}`;
      }
      if (opts.posix === true && value2 === "!" && prev.value === "[") {
        value2 = "^";
      }
      prev.value += value2;
      append2({ value: value2 });
      continue;
    }
    if (state.quotes === 1 && value2 !== '"') {
      value2 = utils$i.escapeRegex(value2);
      prev.value += value2;
      append2({ value: value2 });
      continue;
    }
    if (value2 === '"') {
      state.quotes = state.quotes === 1 ? 0 : 1;
      if (opts.keepQuotes === true) {
        push2({ type: "text", value: value2 });
      }
      continue;
    }
    if (value2 === "(") {
      increment("parens");
      push2({ type: "paren", value: value2 });
      continue;
    }
    if (value2 === ")") {
      if (state.parens === 0 && opts.strictBrackets === true) {
        throw new SyntaxError(syntaxError$1("opening", "("));
      }
      const extglob = extglobs[extglobs.length - 1];
      if (extglob && state.parens === extglob.parens + 1) {
        extglobClose(extglobs.pop());
        continue;
      }
      push2({ type: "paren", value: value2, output: state.parens ? ")" : "\\)" });
      decrement("parens");
      continue;
    }
    if (value2 === "[") {
      if (opts.nobracket === true || !remaining().includes("]")) {
        if (opts.nobracket !== true && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError$1("closing", "]"));
        }
        value2 = `\\${value2}`;
      } else {
        increment("brackets");
      }
      push2({ type: "bracket", value: value2 });
      continue;
    }
    if (value2 === "]") {
      if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
        push2({ type: "text", value: value2, output: `\\${value2}` });
        continue;
      }
      if (state.brackets === 0) {
        if (opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError$1("opening", "["));
        }
        push2({ type: "text", value: value2, output: `\\${value2}` });
        continue;
      }
      decrement("brackets");
      const prevValue = prev.value.slice(1);
      if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
        value2 = `/${value2}`;
      }
      prev.value += value2;
      append2({ value: value2 });
      if (opts.literalBrackets === false || utils$i.hasRegexChars(prevValue)) {
        continue;
      }
      const escaped2 = utils$i.escapeRegex(prev.value);
      state.output = state.output.slice(0, -prev.value.length);
      if (opts.literalBrackets === true) {
        state.output += escaped2;
        prev.value = escaped2;
        continue;
      }
      prev.value = `(${capture}${escaped2}|${prev.value})`;
      state.output += prev.value;
      continue;
    }
    if (value2 === "{" && opts.nobrace !== true) {
      increment("braces");
      const open2 = {
        type: "brace",
        value: value2,
        output: "(",
        outputIndex: state.output.length,
        tokensIndex: state.tokens.length
      };
      braces2.push(open2);
      push2(open2);
      continue;
    }
    if (value2 === "}") {
      const brace = braces2[braces2.length - 1];
      if (opts.nobrace === true || !brace) {
        push2({ type: "text", value: value2, output: value2 });
        continue;
      }
      let output = ")";
      if (brace.dots === true) {
        const arr = tokens.slice();
        const range2 = [];
        for (let i = arr.length - 1; i >= 0; i--) {
          tokens.pop();
          if (arr[i].type === "brace") {
            break;
          }
          if (arr[i].type !== "dots") {
            range2.unshift(arr[i].value);
          }
        }
        output = expandRange(range2, opts);
        state.backtrack = true;
      }
      if (brace.comma !== true && brace.dots !== true) {
        const out2 = state.output.slice(0, brace.outputIndex);
        const toks = state.tokens.slice(brace.tokensIndex);
        brace.value = brace.output = "\\{";
        value2 = output = "\\}";
        state.output = out2;
        for (const t of toks) {
          state.output += t.output || t.value;
        }
      }
      push2({ type: "brace", value: value2, output });
      decrement("braces");
      braces2.pop();
      continue;
    }
    if (value2 === "|") {
      if (extglobs.length > 0) {
        extglobs[extglobs.length - 1].conditions++;
      }
      push2({ type: "text", value: value2 });
      continue;
    }
    if (value2 === ",") {
      let output = value2;
      const brace = braces2[braces2.length - 1];
      if (brace && stack2[stack2.length - 1] === "braces") {
        brace.comma = true;
        output = "|";
      }
      push2({ type: "comma", value: value2, output });
      continue;
    }
    if (value2 === "/") {
      if (prev.type === "dot" && state.index === state.start + 1) {
        state.start = state.index + 1;
        state.consumed = "";
        state.output = "";
        tokens.pop();
        prev = bos;
        continue;
      }
      push2({ type: "slash", value: value2, output: SLASH_LITERAL2 });
      continue;
    }
    if (value2 === ".") {
      if (state.braces > 0 && prev.type === "dot") {
        if (prev.value === ".")
          prev.output = DOT_LITERAL2;
        const brace = braces2[braces2.length - 1];
        prev.type = "dots";
        prev.output += value2;
        prev.value += value2;
        brace.dots = true;
        continue;
      }
      if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
        push2({ type: "text", value: value2, output: DOT_LITERAL2 });
        continue;
      }
      push2({ type: "dot", value: value2, output: DOT_LITERAL2 });
      continue;
    }
    if (value2 === "?") {
      const isGroup = prev && prev.value === "(";
      if (!isGroup && opts.noextglob !== true && peek2() === "(" && peek2(2) !== "?") {
        extglobOpen("qmark", value2);
        continue;
      }
      if (prev && prev.type === "paren") {
        const next = peek2();
        let output = value2;
        if (next === "<" && !utils$i.supportsLookbehinds()) {
          throw new Error("Node.js v10 or higher is required for regex lookbehinds");
        }
        if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
          output = `\\${value2}`;
        }
        push2({ type: "text", value: value2, output });
        continue;
      }
      if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
        push2({ type: "qmark", value: value2, output: QMARK_NO_DOT2 });
        continue;
      }
      push2({ type: "qmark", value: value2, output: QMARK2 });
      continue;
    }
    if (value2 === "!") {
      if (opts.noextglob !== true && peek2() === "(") {
        if (peek2(2) !== "?" || !/[!=<:]/.test(peek2(3))) {
          extglobOpen("negate", value2);
          continue;
        }
      }
      if (opts.nonegate !== true && state.index === 0) {
        negate();
        continue;
      }
    }
    if (value2 === "+") {
      if (opts.noextglob !== true && peek2() === "(" && peek2(2) !== "?") {
        extglobOpen("plus", value2);
        continue;
      }
      if (prev && prev.value === "(" || opts.regex === false) {
        push2({ type: "plus", value: value2, output: PLUS_LITERAL2 });
        continue;
      }
      if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
        push2({ type: "plus", value: value2 });
        continue;
      }
      push2({ type: "plus", value: PLUS_LITERAL2 });
      continue;
    }
    if (value2 === "@") {
      if (opts.noextglob !== true && peek2() === "(" && peek2(2) !== "?") {
        push2({ type: "at", extglob: true, value: value2, output: "" });
        continue;
      }
      push2({ type: "text", value: value2 });
      continue;
    }
    if (value2 !== "*") {
      if (value2 === "$" || value2 === "^") {
        value2 = `\\${value2}`;
      }
      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
      if (match) {
        value2 += match[0];
        state.index += match[0].length;
      }
      push2({ type: "text", value: value2 });
      continue;
    }
    if (prev && (prev.type === "globstar" || prev.star === true)) {
      prev.type = "star";
      prev.star = true;
      prev.value += value2;
      prev.output = star2;
      state.backtrack = true;
      state.globstar = true;
      consume(value2);
      continue;
    }
    let rest = remaining();
    if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
      extglobOpen("star", value2);
      continue;
    }
    if (prev.type === "star") {
      if (opts.noglobstar === true) {
        consume(value2);
        continue;
      }
      const prior = prev.prev;
      const before = prior.prev;
      const isStart = prior.type === "slash" || prior.type === "bos";
      const afterStar = before && (before.type === "star" || before.type === "globstar");
      if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
        push2({ type: "star", value: value2, output: "" });
        continue;
      }
      const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
      const isExtglob3 = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
      if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob3) {
        push2({ type: "star", value: value2, output: "" });
        continue;
      }
      while (rest.slice(0, 3) === "/**") {
        const after = input[state.index + 4];
        if (after && after !== "/") {
          break;
        }
        rest = rest.slice(3);
        consume("/**", 3);
      }
      if (prior.type === "bos" && eos()) {
        prev.type = "globstar";
        prev.value += value2;
        prev.output = globstar(opts);
        state.output = prev.output;
        state.globstar = true;
        consume(value2);
        continue;
      }
      if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;
        prev.type = "globstar";
        prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
        prev.value += value2;
        state.globstar = true;
        state.output += prior.output + prev.output;
        consume(value2);
        continue;
      }
      if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
        const end = rest[1] !== void 0 ? "|$" : "";
        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;
        prev.type = "globstar";
        prev.output = `${globstar(opts)}${SLASH_LITERAL2}|${SLASH_LITERAL2}${end})`;
        prev.value += value2;
        state.output += prior.output + prev.output;
        state.globstar = true;
        consume(value2 + advance2());
        push2({ type: "slash", value: "/", output: "" });
        continue;
      }
      if (prior.type === "bos" && rest[0] === "/") {
        prev.type = "globstar";
        prev.value += value2;
        prev.output = `(?:^|${SLASH_LITERAL2}|${globstar(opts)}${SLASH_LITERAL2})`;
        state.output = prev.output;
        state.globstar = true;
        consume(value2 + advance2());
        push2({ type: "slash", value: "/", output: "" });
        continue;
      }
      state.output = state.output.slice(0, -prev.output.length);
      prev.type = "globstar";
      prev.output = globstar(opts);
      prev.value += value2;
      state.output += prev.output;
      state.globstar = true;
      consume(value2);
      continue;
    }
    const token2 = { type: "star", value: value2, output: star2 };
    if (opts.bash === true) {
      token2.output = ".*?";
      if (prev.type === "bos" || prev.type === "slash") {
        token2.output = nodot + token2.output;
      }
      push2(token2);
      continue;
    }
    if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
      token2.output = value2;
      push2(token2);
      continue;
    }
    if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
      if (prev.type === "dot") {
        state.output += NO_DOT_SLASH2;
        prev.output += NO_DOT_SLASH2;
      } else if (opts.dot === true) {
        state.output += NO_DOTS_SLASH2;
        prev.output += NO_DOTS_SLASH2;
      } else {
        state.output += nodot;
        prev.output += nodot;
      }
      if (peek2() !== "*") {
        state.output += ONE_CHAR2;
        prev.output += ONE_CHAR2;
      }
    }
    push2(token2);
  }
  while (state.brackets > 0) {
    if (opts.strictBrackets === true)
      throw new SyntaxError(syntaxError$1("closing", "]"));
    state.output = utils$i.escapeLast(state.output, "[");
    decrement("brackets");
  }
  while (state.parens > 0) {
    if (opts.strictBrackets === true)
      throw new SyntaxError(syntaxError$1("closing", ")"));
    state.output = utils$i.escapeLast(state.output, "(");
    decrement("parens");
  }
  while (state.braces > 0) {
    if (opts.strictBrackets === true)
      throw new SyntaxError(syntaxError$1("closing", "}"));
    state.output = utils$i.escapeLast(state.output, "{");
    decrement("braces");
  }
  if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
    push2({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL2}?` });
  }
  if (state.backtrack === true) {
    state.output = "";
    for (const token2 of state.tokens) {
      state.output += token2.output != null ? token2.output : token2.value;
      if (token2.suffix) {
        state.output += token2.suffix;
      }
    }
  }
  return state;
};
parse$i.fastpaths = (input, options3) => {
  const opts = { ...options3 };
  const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;
  const len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }
  input = REPLACEMENTS[input] || input;
  const win322 = utils$i.isWindows(options3);
  const {
    DOT_LITERAL: DOT_LITERAL2,
    SLASH_LITERAL: SLASH_LITERAL2,
    ONE_CHAR: ONE_CHAR2,
    DOTS_SLASH: DOTS_SLASH2,
    NO_DOT: NO_DOT2,
    NO_DOTS: NO_DOTS2,
    NO_DOTS_SLASH: NO_DOTS_SLASH2,
    STAR: STAR2,
    START_ANCHOR: START_ANCHOR2
  } = constants$5.globChars(win322);
  const nodot = opts.dot ? NO_DOTS2 : NO_DOT2;
  const slashDot = opts.dot ? NO_DOTS_SLASH2 : NO_DOT2;
  const capture = opts.capture ? "" : "?:";
  const state = { negated: false, prefix: "" };
  let star2 = opts.bash === true ? ".*?" : STAR2;
  if (opts.capture) {
    star2 = `(${star2})`;
  }
  const globstar = (opts2) => {
    if (opts2.noglobstar === true)
      return star2;
    return `(${capture}(?:(?!${START_ANCHOR2}${opts2.dot ? DOTS_SLASH2 : DOT_LITERAL2}).)*?)`;
  };
  const create = (str) => {
    switch (str) {
      case "*":
        return `${nodot}${ONE_CHAR2}${star2}`;
      case ".*":
        return `${DOT_LITERAL2}${ONE_CHAR2}${star2}`;
      case "*.*":
        return `${nodot}${star2}${DOT_LITERAL2}${ONE_CHAR2}${star2}`;
      case "*/*":
        return `${nodot}${star2}${SLASH_LITERAL2}${ONE_CHAR2}${slashDot}${star2}`;
      case "**":
        return nodot + globstar(opts);
      case "**/*":
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${slashDot}${ONE_CHAR2}${star2}`;
      case "**/*.*":
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${slashDot}${star2}${DOT_LITERAL2}${ONE_CHAR2}${star2}`;
      case "**/.*":
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${DOT_LITERAL2}${ONE_CHAR2}${star2}`;
      default: {
        const match = /^(.*?)\.(\w+)$/.exec(str);
        if (!match)
          return;
        const source3 = create(match[1]);
        if (!source3)
          return;
        return source3 + DOT_LITERAL2 + match[2];
      }
    }
  };
  const output = utils$i.removePrefix(input, state);
  let source2 = create(output);
  if (source2 && opts.strictSlashes !== true) {
    source2 += `${SLASH_LITERAL2}?`;
  }
  return source2;
};
var parse_1$2 = parse$i;
var path$m = import_path.default;
var scan$1 = scan_1;
var parse$h = parse_1$2;
var utils$h = utils$k;
var constants$4 = constants$6;
var isObject$3 = (val) => val && typeof val === "object" && !Array.isArray(val);
var picomatch$4 = (glob, options3, returnState = false) => {
  if (Array.isArray(glob)) {
    const fns = glob.map((input) => picomatch$4(input, options3, returnState));
    const arrayMatcher = (str) => {
      for (const isMatch2 of fns) {
        const state2 = isMatch2(str);
        if (state2)
          return state2;
      }
      return false;
    };
    return arrayMatcher;
  }
  const isState = isObject$3(glob) && glob.tokens && glob.input;
  if (glob === "" || typeof glob !== "string" && !isState) {
    throw new TypeError("Expected pattern to be a non-empty string");
  }
  const opts = options3 || {};
  const posix2 = utils$h.isWindows(options3);
  const regex = isState ? picomatch$4.compileRe(glob, options3) : picomatch$4.makeRe(glob, options3, false, true);
  const state = regex.state;
  delete regex.state;
  let isIgnored2 = () => false;
  if (opts.ignore) {
    const ignoreOpts = { ...options3, ignore: null, onMatch: null, onResult: null };
    isIgnored2 = picomatch$4(opts.ignore, ignoreOpts, returnState);
  }
  const matcher2 = (input, returnObject = false) => {
    const { isMatch: isMatch2, match, output } = picomatch$4.test(input, regex, options3, { glob, posix: posix2 });
    const result = { glob, state, regex, posix: posix2, input, output, match, isMatch: isMatch2 };
    if (typeof opts.onResult === "function") {
      opts.onResult(result);
    }
    if (isMatch2 === false) {
      result.isMatch = false;
      return returnObject ? result : false;
    }
    if (isIgnored2(input)) {
      if (typeof opts.onIgnore === "function") {
        opts.onIgnore(result);
      }
      result.isMatch = false;
      return returnObject ? result : false;
    }
    if (typeof opts.onMatch === "function") {
      opts.onMatch(result);
    }
    return returnObject ? result : true;
  };
  if (returnState) {
    matcher2.state = state;
  }
  return matcher2;
};
picomatch$4.test = (input, regex, options3, { glob, posix: posix2 } = {}) => {
  if (typeof input !== "string") {
    throw new TypeError("Expected input to be a string");
  }
  if (input === "") {
    return { isMatch: false, output: "" };
  }
  const opts = options3 || {};
  const format2 = opts.format || (posix2 ? utils$h.toPosixSlashes : null);
  let match = input === glob;
  let output = match && format2 ? format2(input) : input;
  if (match === false) {
    output = format2 ? format2(input) : input;
    match = output === glob;
  }
  if (match === false || opts.capture === true) {
    if (opts.matchBase === true || opts.basename === true) {
      match = picomatch$4.matchBase(input, regex, options3, posix2);
    } else {
      match = regex.exec(output);
    }
  }
  return { isMatch: Boolean(match), match, output };
};
picomatch$4.matchBase = (input, glob, options3, posix2 = utils$h.isWindows(options3)) => {
  const regex = glob instanceof RegExp ? glob : picomatch$4.makeRe(glob, options3);
  return regex.test(path$m.basename(input));
};
picomatch$4.isMatch = (str, patterns2, options3) => picomatch$4(patterns2, options3)(str);
picomatch$4.parse = (pattern2, options3) => {
  if (Array.isArray(pattern2))
    return pattern2.map((p) => picomatch$4.parse(p, options3));
  return parse$h(pattern2, { ...options3, fastpaths: false });
};
picomatch$4.scan = (input, options3) => scan$1(input, options3);
picomatch$4.compileRe = (state, options3, returnOutput = false, returnState = false) => {
  if (returnOutput === true) {
    return state.output;
  }
  const opts = options3 || {};
  const prepend = opts.contains ? "" : "^";
  const append2 = opts.contains ? "" : "$";
  let source2 = `${prepend}(?:${state.output})${append2}`;
  if (state && state.negated === true) {
    source2 = `^(?!${source2}).*$`;
  }
  const regex = picomatch$4.toRegex(source2, options3);
  if (returnState === true) {
    regex.state = state;
  }
  return regex;
};
picomatch$4.makeRe = (input, options3 = {}, returnOutput = false, returnState = false) => {
  if (!input || typeof input !== "string") {
    throw new TypeError("Expected a non-empty string");
  }
  let parsed = { negated: false, fastpaths: true };
  if (options3.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
    parsed.output = parse$h.fastpaths(input, options3);
  }
  if (!parsed.output) {
    parsed = parse$h(input, options3);
  }
  return picomatch$4.compileRe(parsed, options3, returnOutput, returnState);
};
picomatch$4.toRegex = (source2, options3) => {
  try {
    const opts = options3 || {};
    return new RegExp(source2, opts.flags || (opts.nocase ? "i" : ""));
  } catch (err) {
    if (options3 && options3.debug === true)
      throw err;
    return /$^/;
  }
};
picomatch$4.constants = constants$4;
var picomatch_1 = picomatch$4;
(function(module2) {
  module2.exports = picomatch_1;
})(picomatch$5);
var picomatch$3 = getDefaultExportFromCjs(picomatch$5.exports);
var extractors = {
  ArrayPattern(names, param) {
    for (const element of param.elements) {
      if (element)
        extractors[element.type](names, element);
    }
  },
  AssignmentPattern(names, param) {
    extractors[param.left.type](names, param.left);
  },
  Identifier(names, param) {
    names.push(param.name);
  },
  MemberExpression() {
  },
  ObjectPattern(names, param) {
    for (const prop of param.properties) {
      if (prop.type === "RestElement") {
        extractors.RestElement(names, prop);
      } else {
        extractors[prop.value.type](names, prop.value);
      }
    }
  },
  RestElement(names, param) {
    extractors[param.argument.type](names, param.argument);
  }
};
var extractAssignedNames = function extractAssignedNames2(param) {
  const names = [];
  extractors[param.type](names, param);
  return names;
};
var blockDeclarations = {
  const: true,
  let: true
};
var Scope$1 = class {
  constructor(options3 = {}) {
    this.parent = options3.parent;
    this.isBlockScope = !!options3.block;
    this.declarations = /* @__PURE__ */ Object.create(null);
    if (options3.params) {
      options3.params.forEach((param) => {
        extractAssignedNames(param).forEach((name) => {
          this.declarations[name] = true;
        });
      });
    }
  }
  addDeclaration(node2, isBlockDeclaration, isVar) {
    if (!isBlockDeclaration && this.isBlockScope) {
      this.parent.addDeclaration(node2, isBlockDeclaration, isVar);
    } else if (node2.id) {
      extractAssignedNames(node2.id).forEach((name) => {
        this.declarations[name] = true;
      });
    }
  }
  contains(name) {
    return this.declarations[name] || (this.parent ? this.parent.contains(name) : false);
  }
};
var attachScopes = function attachScopes2(ast, propertyName = "scope") {
  let scope = new Scope$1();
  walk$3(ast, {
    enter(n2, parent) {
      const node2 = n2;
      if (/(Function|Class)Declaration/.test(node2.type)) {
        scope.addDeclaration(node2, false, false);
      }
      if (node2.type === "VariableDeclaration") {
        const { kind } = node2;
        const isBlockDeclaration = blockDeclarations[kind];
        node2.declarations.forEach((declaration) => {
          scope.addDeclaration(declaration, isBlockDeclaration, true);
        });
      }
      let newScope;
      if (/Function/.test(node2.type)) {
        const func = node2;
        newScope = new Scope$1({
          parent: scope,
          block: false,
          params: func.params
        });
        if (func.type === "FunctionExpression" && func.id) {
          newScope.addDeclaration(func, false, false);
        }
      }
      if (/For(In|Of)?Statement/.test(node2.type)) {
        newScope = new Scope$1({
          parent: scope,
          block: true
        });
      }
      if (node2.type === "BlockStatement" && !/Function/.test(parent.type)) {
        newScope = new Scope$1({
          parent: scope,
          block: true
        });
      }
      if (node2.type === "CatchClause") {
        newScope = new Scope$1({
          parent: scope,
          params: node2.param ? [node2.param] : [],
          block: true
        });
      }
      if (newScope) {
        Object.defineProperty(node2, propertyName, {
          value: newScope,
          configurable: true
        });
        scope = newScope;
      }
    },
    leave(n2) {
      const node2 = n2;
      if (node2[propertyName])
        scope = scope.parent;
    }
  });
  return scope;
};
function isArray$2(arg) {
  return Array.isArray(arg);
}
function ensureArray$1(thing) {
  if (isArray$2(thing))
    return thing;
  if (thing == null)
    return [];
  return [thing];
}
var normalizePath$6 = function normalizePath(filename) {
  return filename.split(import_path.win32.sep).join(import_path.posix.sep);
};
function getMatcherString$1(id, resolutionBase) {
  if (resolutionBase === false || (0, import_path.isAbsolute)(id) || id.startsWith("*")) {
    return normalizePath$6(id);
  }
  const basePath = normalizePath$6((0, import_path.resolve)(resolutionBase || "")).replace(/[-^$*+?.()|[\]{}]/g, "\\$&");
  return import_path.posix.join(basePath, normalizePath$6(id));
}
var createFilter$2 = function createFilter(include, exclude, options3) {
  const resolutionBase = options3 && options3.resolve;
  const getMatcher = (id) => id instanceof RegExp ? id : {
    test: (what) => {
      const pattern2 = getMatcherString$1(id, resolutionBase);
      const fn = picomatch$3(pattern2, { dot: true });
      const result = fn(what);
      return result;
    }
  };
  const includeMatchers = ensureArray$1(include).map(getMatcher);
  const excludeMatchers = ensureArray$1(exclude).map(getMatcher);
  return function result(id) {
    if (typeof id !== "string")
      return false;
    if (/\0/.test(id))
      return false;
    const pathId = normalizePath$6(id);
    for (let i = 0; i < excludeMatchers.length; ++i) {
      const matcher2 = excludeMatchers[i];
      if (matcher2.test(pathId))
        return false;
    }
    for (let i = 0; i < includeMatchers.length; ++i) {
      const matcher2 = includeMatchers[i];
      if (matcher2.test(pathId))
        return true;
    }
    return !includeMatchers.length;
  };
};
var reservedWords$2 = "break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public";
var builtins$2 = "arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl";
var forbiddenIdentifiers$1 = new Set(`${reservedWords$2} ${builtins$2}`.split(" "));
forbiddenIdentifiers$1.add("");
var makeLegalIdentifier$1 = function makeLegalIdentifier(str) {
  let identifier = str.replace(/-(\w)/g, (_, letter) => letter.toUpperCase()).replace(/[^$_a-zA-Z0-9]/g, "_");
  if (/\d/.test(identifier[0]) || forbiddenIdentifiers$1.has(identifier)) {
    identifier = `_${identifier}`;
  }
  return identifier || "_";
};
var path$l = import_path.default;
var commondir = function(basedir, relfiles) {
  if (relfiles) {
    var files = relfiles.map(function(r) {
      return path$l.resolve(basedir, r);
    });
  } else {
    var files = basedir;
  }
  var res = files.slice(1).reduce(function(ps, file) {
    if (!file.match(/^([A-Za-z]:)?\/|\\/)) {
      throw new Error("relative path without a basedir");
    }
    var xs = file.split(/\/+|\\+/);
    for (var i = 0; ps[i] === xs[i] && i < Math.min(ps.length, xs.length); i++)
      ;
    return ps.slice(0, i);
  }, files[0].split(/\/+|\\+/));
  return res.length > 1 ? res.join("/") : "/";
};
var old$1 = {};
var pathModule = import_path.default;
var isWindows$6 = process.platform === "win32";
var fs$k = import_fs.default;
var DEBUG$1 = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
function rethrow() {
  var callback;
  if (DEBUG$1) {
    var backtrace = new Error();
    callback = debugCallback;
  } else
    callback = missingCallback;
  return callback;
  function debugCallback(err) {
    if (err) {
      backtrace.message = err.message;
      err = backtrace;
      missingCallback(err);
    }
  }
  function missingCallback(err) {
    if (err) {
      if (process.throwDeprecation)
        throw err;
      else if (!process.noDeprecation) {
        var msg = "fs: missing callback " + (err.stack || err.message);
        if (process.traceDeprecation)
          console.trace(msg);
        else
          console.error(msg);
      }
    }
  }
}
function maybeCallback(cb) {
  return typeof cb === "function" ? cb : rethrow();
}
if (isWindows$6) {
  nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
} else {
  nextPartRe = /(.*?)(?:[\/]+|$)/g;
}
var nextPartRe;
if (isWindows$6) {
  splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
} else {
  splitRootRe = /^[\/]*/;
}
var splitRootRe;
old$1.realpathSync = function realpathSync(p, cache) {
  p = pathModule.resolve(p);
  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return cache[p];
  }
  var original = p, seenLinks = {}, knownHard = {};
  var pos2;
  var current2;
  var base2;
  var previous;
  start();
  function start() {
    var m = splitRootRe.exec(p);
    pos2 = m[0].length;
    current2 = m[0];
    base2 = m[0];
    previous = "";
    if (isWindows$6 && !knownHard[base2]) {
      fs$k.lstatSync(base2);
      knownHard[base2] = true;
    }
  }
  while (pos2 < p.length) {
    nextPartRe.lastIndex = pos2;
    var result = nextPartRe.exec(p);
    previous = current2;
    current2 += result[0];
    base2 = previous + result[1];
    pos2 = nextPartRe.lastIndex;
    if (knownHard[base2] || cache && cache[base2] === base2) {
      continue;
    }
    var resolvedLink;
    if (cache && Object.prototype.hasOwnProperty.call(cache, base2)) {
      resolvedLink = cache[base2];
    } else {
      var stat2 = fs$k.lstatSync(base2);
      if (!stat2.isSymbolicLink()) {
        knownHard[base2] = true;
        if (cache)
          cache[base2] = base2;
        continue;
      }
      var linkTarget = null;
      if (!isWindows$6) {
        var id = stat2.dev.toString(32) + ":" + stat2.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          linkTarget = seenLinks[id];
        }
      }
      if (linkTarget === null) {
        fs$k.statSync(base2);
        linkTarget = fs$k.readlinkSync(base2);
      }
      resolvedLink = pathModule.resolve(previous, linkTarget);
      if (cache)
        cache[base2] = resolvedLink;
      if (!isWindows$6)
        seenLinks[id] = linkTarget;
    }
    p = pathModule.resolve(resolvedLink, p.slice(pos2));
    start();
  }
  if (cache)
    cache[original] = p;
  return p;
};
old$1.realpath = function realpath(p, cache, cb) {
  if (typeof cb !== "function") {
    cb = maybeCallback(cache);
    cache = null;
  }
  p = pathModule.resolve(p);
  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return process.nextTick(cb.bind(null, null, cache[p]));
  }
  var original = p, seenLinks = {}, knownHard = {};
  var pos2;
  var current2;
  var base2;
  var previous;
  start();
  function start() {
    var m = splitRootRe.exec(p);
    pos2 = m[0].length;
    current2 = m[0];
    base2 = m[0];
    previous = "";
    if (isWindows$6 && !knownHard[base2]) {
      fs$k.lstat(base2, function(err) {
        if (err)
          return cb(err);
        knownHard[base2] = true;
        LOOP();
      });
    } else {
      process.nextTick(LOOP);
    }
  }
  function LOOP() {
    if (pos2 >= p.length) {
      if (cache)
        cache[original] = p;
      return cb(null, p);
    }
    nextPartRe.lastIndex = pos2;
    var result = nextPartRe.exec(p);
    previous = current2;
    current2 += result[0];
    base2 = previous + result[1];
    pos2 = nextPartRe.lastIndex;
    if (knownHard[base2] || cache && cache[base2] === base2) {
      return process.nextTick(LOOP);
    }
    if (cache && Object.prototype.hasOwnProperty.call(cache, base2)) {
      return gotResolvedLink(cache[base2]);
    }
    return fs$k.lstat(base2, gotStat);
  }
  function gotStat(err, stat2) {
    if (err)
      return cb(err);
    if (!stat2.isSymbolicLink()) {
      knownHard[base2] = true;
      if (cache)
        cache[base2] = base2;
      return process.nextTick(LOOP);
    }
    if (!isWindows$6) {
      var id = stat2.dev.toString(32) + ":" + stat2.ino.toString(32);
      if (seenLinks.hasOwnProperty(id)) {
        return gotTarget(null, seenLinks[id], base2);
      }
    }
    fs$k.stat(base2, function(err2) {
      if (err2)
        return cb(err2);
      fs$k.readlink(base2, function(err3, target) {
        if (!isWindows$6)
          seenLinks[id] = target;
        gotTarget(err3, target);
      });
    });
  }
  function gotTarget(err, target, base3) {
    if (err)
      return cb(err);
    var resolvedLink = pathModule.resolve(previous, target);
    if (cache)
      cache[base3] = resolvedLink;
    gotResolvedLink(resolvedLink);
  }
  function gotResolvedLink(resolvedLink) {
    p = pathModule.resolve(resolvedLink, p.slice(pos2));
    start();
  }
};
var fs_realpath = realpath$2;
realpath$2.realpath = realpath$2;
realpath$2.sync = realpathSync2;
realpath$2.realpathSync = realpathSync2;
realpath$2.monkeypatch = monkeypatch;
realpath$2.unmonkeypatch = unmonkeypatch;
var fs$j = import_fs.default;
var origRealpath = fs$j.realpath;
var origRealpathSync = fs$j.realpathSync;
var version$2 = process.version;
var ok = /^v[0-5]\./.test(version$2);
var old = old$1;
function newError(er) {
  return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
}
function realpath$2(p, cache, cb) {
  if (ok) {
    return origRealpath(p, cache, cb);
  }
  if (typeof cache === "function") {
    cb = cache;
    cache = null;
  }
  origRealpath(p, cache, function(er, result) {
    if (newError(er)) {
      old.realpath(p, cache, cb);
    } else {
      cb(er, result);
    }
  });
}
function realpathSync2(p, cache) {
  if (ok) {
    return origRealpathSync(p, cache);
  }
  try {
    return origRealpathSync(p, cache);
  } catch (er) {
    if (newError(er)) {
      return old.realpathSync(p, cache);
    } else {
      throw er;
    }
  }
}
function monkeypatch() {
  fs$j.realpath = realpath$2;
  fs$j.realpathSync = realpathSync2;
}
function unmonkeypatch() {
  fs$j.realpath = origRealpath;
  fs$j.realpathSync = origRealpathSync;
}
var isWindows$5 = typeof process === "object" && process && process.platform === "win32";
var path$k = isWindows$5 ? { sep: "\\" } : { sep: "/" };
var balancedMatch = balanced$1;
function balanced$1(a, b, str) {
  if (a instanceof RegExp)
    a = maybeMatch(a, str);
  if (b instanceof RegExp)
    b = maybeMatch(b, str);
  var r = range$1(a, b, str);
  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}
function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}
balanced$1.range = range$1;
function range$1(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;
  if (ai >= 0 && bi > 0) {
    if (a === b) {
      return [ai, bi];
    }
    begs = [];
    left = str.length;
    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [begs.pop(), bi];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }
        bi = str.indexOf(b, i + 1);
      }
      i = ai < bi && ai >= 0 ? ai : bi;
    }
    if (begs.length) {
      result = [left, right];
    }
  }
  return result;
}
var balanced = balancedMatch;
var braceExpansion = expandTop;
var escSlash = "\0SLASH" + Math.random() + "\0";
var escOpen = "\0OPEN" + Math.random() + "\0";
var escClose = "\0CLOSE" + Math.random() + "\0";
var escComma = "\0COMMA" + Math.random() + "\0";
var escPeriod = "\0PERIOD" + Math.random() + "\0";
function numeric(str) {
  return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
}
function escapeBraces(str) {
  return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
}
function unescapeBraces(str) {
  return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
}
function parseCommaParts(str) {
  if (!str)
    return [""];
  var parts = [];
  var m = balanced("{", "}", str);
  if (!m)
    return str.split(",");
  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(",");
  p[p.length - 1] += "{" + body + "}";
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length - 1] += postParts.shift();
    p.push.apply(p, postParts);
  }
  parts.push.apply(parts, p);
  return parts;
}
function expandTop(str) {
  if (!str)
    return [];
  if (str.substr(0, 2) === "{}") {
    str = "\\{\\}" + str.substr(2);
  }
  return expand$3(escapeBraces(str), true).map(unescapeBraces);
}
function embrace(str) {
  return "{" + str + "}";
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}
function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}
function expand$3(str, isTop) {
  var expansions = [];
  var m = balanced("{", "}", str);
  if (!m)
    return [str];
  var pre = m.pre;
  var post = m.post.length ? expand$3(m.post, false) : [""];
  if (/\$$/.test(m.pre)) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + "{" + m.body + "}" + post[k];
      expansions.push(expansion);
    }
  } else {
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m.post.match(/,.*\}/)) {
        str = m.pre + "{" + m.body + escClose + m.post;
        return expand$3(str);
      }
      return [str];
    }
    var n2;
    if (isSequence) {
      n2 = m.body.split(/\.\./);
    } else {
      n2 = parseCommaParts(m.body);
      if (n2.length === 1) {
        n2 = expand$3(n2[0], false).map(embrace);
        if (n2.length === 1) {
          return post.map(function(p) {
            return m.pre + n2[0] + p;
          });
        }
      }
    }
    var N;
    if (isSequence) {
      var x = numeric(n2[0]);
      var y = numeric(n2[1]);
      var width = Math.max(n2[0].length, n2[1].length);
      var incr = n2.length == 3 ? Math.abs(numeric(n2[2])) : 1;
      var test = lte;
      var reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad2 = n2.some(isPadded);
      N = [];
      for (var i = x; test(i, y); i += incr) {
        var c2;
        if (isAlphaSequence) {
          c2 = String.fromCharCode(i);
          if (c2 === "\\")
            c2 = "";
        } else {
          c2 = String(i);
          if (pad2) {
            var need = width - c2.length;
            if (need > 0) {
              var z = new Array(need + 1).join("0");
              if (i < 0)
                c2 = "-" + z + c2.slice(1);
              else
                c2 = z + c2;
            }
          }
        }
        N.push(c2);
      }
    } else {
      N = [];
      for (var j = 0; j < n2.length; j++) {
        N.push.apply(N, expand$3(n2[j], false));
      }
    }
    for (var j = 0; j < N.length; j++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
  }
  return expansions;
}
var minimatch$1 = minimatch_1 = (p, pattern2, options3 = {}) => {
  assertValidPattern(pattern2);
  if (!options3.nocomment && pattern2.charAt(0) === "#") {
    return false;
  }
  return new Minimatch$1(pattern2, options3).match(p);
};
var minimatch_1 = minimatch$1;
var path$j = path$k;
minimatch$1.sep = path$j.sep;
var GLOBSTAR$2 = Symbol("globstar **");
minimatch$1.GLOBSTAR = GLOBSTAR$2;
var expand$2 = braceExpansion;
var plTypes = {
  "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
  "?": { open: "(?:", close: ")?" },
  "+": { open: "(?:", close: ")+" },
  "*": { open: "(?:", close: ")*" },
  "@": { open: "(?:", close: ")" }
};
var qmark = "[^/]";
var star = qmark + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var charSet = (s) => s.split("").reduce((set2, c2) => {
  set2[c2] = true;
  return set2;
}, {});
var reSpecials = charSet("().*{}+?[]^$\\!");
var addPatternStartSet = charSet("[.(");
var slashSplit = /\/+/;
minimatch$1.filter = (pattern2, options3 = {}) => (p, i, list) => minimatch$1(p, pattern2, options3);
var ext = (a, b = {}) => {
  const t = {};
  Object.keys(a).forEach((k) => t[k] = a[k]);
  Object.keys(b).forEach((k) => t[k] = b[k]);
  return t;
};
minimatch$1.defaults = (def) => {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch$1;
  }
  const orig = minimatch$1;
  const m = (p, pattern2, options3) => orig(p, pattern2, ext(def, options3));
  m.Minimatch = class Minimatch extends orig.Minimatch {
    constructor(pattern2, options3) {
      super(pattern2, ext(def, options3));
    }
  };
  m.Minimatch.defaults = (options3) => orig.defaults(ext(def, options3)).Minimatch;
  m.filter = (pattern2, options3) => orig.filter(pattern2, ext(def, options3));
  m.defaults = (options3) => orig.defaults(ext(def, options3));
  m.makeRe = (pattern2, options3) => orig.makeRe(pattern2, ext(def, options3));
  m.braceExpand = (pattern2, options3) => orig.braceExpand(pattern2, ext(def, options3));
  m.match = (list, pattern2, options3) => orig.match(list, pattern2, ext(def, options3));
  return m;
};
minimatch$1.braceExpand = (pattern2, options3) => braceExpand(pattern2, options3);
var braceExpand = (pattern2, options3 = {}) => {
  assertValidPattern(pattern2);
  if (options3.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern2)) {
    return [pattern2];
  }
  return expand$2(pattern2);
};
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = (pattern2) => {
  if (typeof pattern2 !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern2.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};
var SUBPARSE = Symbol("subparse");
minimatch$1.makeRe = (pattern2, options3) => new Minimatch$1(pattern2, options3 || {}).makeRe();
minimatch$1.match = (list, pattern2, options3 = {}) => {
  const mm = new Minimatch$1(pattern2, options3);
  list = list.filter((f) => mm.match(f));
  if (mm.options.nonull && !list.length) {
    list.push(pattern2);
  }
  return list;
};
var globUnescape = (s) => s.replace(/\\(.)/g, "$1");
var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var Minimatch$1 = class {
  constructor(pattern2, options3) {
    assertValidPattern(pattern2);
    if (!options3)
      options3 = {};
    this.options = options3;
    this.set = [];
    this.pattern = pattern2;
    this.windowsPathsNoEscape = !!options3.windowsPathsNoEscape || options3.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, "/");
    }
    this.regexp = null;
    this.negate = false;
    this.comment = false;
    this.empty = false;
    this.partial = !!options3.partial;
    this.make();
  }
  debug() {
  }
  make() {
    const pattern2 = this.pattern;
    const options3 = this.options;
    if (!options3.nocomment && pattern2.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern2) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    let set2 = this.globSet = this.braceExpand();
    if (options3.debug)
      this.debug = (...args) => console.error(...args);
    this.debug(this.pattern, set2);
    set2 = this.globParts = set2.map((s) => s.split(slashSplit));
    this.debug(this.pattern, set2);
    set2 = set2.map((s, si, set3) => s.map(this.parse, this));
    this.debug(this.pattern, set2);
    set2 = set2.filter((s) => s.indexOf(false) === -1);
    this.debug(this.pattern, set2);
    this.set = set2;
  }
  parseNegate() {
    if (this.options.nonegate)
      return;
    const pattern2 = this.pattern;
    let negate = false;
    let negateOffset = 0;
    for (let i = 0; i < pattern2.length && pattern2.charAt(i) === "!"; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern2.substr(negateOffset);
    this.negate = negate;
  }
  matchOne(file, pattern2, partial2) {
    var options3 = this.options;
    this.debug(
      "matchOne",
      { "this": this, file, pattern: pattern2 }
    );
    this.debug("matchOne", file.length, pattern2.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern2.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern2[pi];
      var f = file[fi];
      this.debug(pattern2, p, f);
      if (p === false)
        return false;
      if (p === GLOBSTAR$2) {
        this.debug("GLOBSTAR", [pattern2, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options3.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern2, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern2.slice(pr), partial2)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options3.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern2, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial2) {
          this.debug("\n>>> no match, partial?", file, fr, pattern2, pr);
          if (fr === fl)
            return true;
        }
        return false;
      }
      var hit;
      if (typeof p === "string") {
        hit = f === p;
        this.debug("string match", p, f, hit);
      } else {
        hit = f.match(p);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial2;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    }
    throw new Error("wtf?");
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern2, isSub) {
    assertValidPattern(pattern2);
    const options3 = this.options;
    if (pattern2 === "**") {
      if (!options3.noglobstar)
        return GLOBSTAR$2;
      else
        pattern2 = "*";
    }
    if (pattern2 === "")
      return "";
    let re = "";
    let hasMagic = !!options3.nocase;
    let escaping = false;
    const patternListStack = [];
    const negativeLists = [];
    let stateChar;
    let inClass = false;
    let reClassStart = -1;
    let classStart = -1;
    let cs;
    let pl;
    let sp;
    const patternStart = pattern2.charAt(0) === "." ? "" : options3.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    const clearStateChar = () => {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re += star;
            hasMagic = true;
            break;
          case "?":
            re += qmark;
            hasMagic = true;
            break;
          default:
            re += "\\" + stateChar;
            break;
        }
        this.debug("clearStateChar %j %j", stateChar, re);
        stateChar = false;
      }
    };
    for (let i = 0, c2; i < pattern2.length && (c2 = pattern2.charAt(i)); i++) {
      this.debug("%s	%s %s %j", pattern2, i, re, c2);
      if (escaping) {
        if (c2 === "/") {
          return false;
        }
        if (reSpecials[c2]) {
          re += "\\";
        }
        re += c2;
        escaping = false;
        continue;
      }
      switch (c2) {
        case "/": {
          return false;
        }
        case "\\":
          clearStateChar();
          escaping = true;
          continue;
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          this.debug("%s	%s %s %j <-- stateChar", pattern2, i, re, c2);
          if (inClass) {
            this.debug("  in class");
            if (c2 === "!" && i === classStart + 1)
              c2 = "^";
            re += c2;
            continue;
          }
          this.debug("call clearStateChar %j", stateChar);
          clearStateChar();
          stateChar = c2;
          if (options3.noext)
            clearStateChar();
          continue;
        case "(":
          if (inClass) {
            re += "(";
            continue;
          }
          if (!stateChar) {
            re += "\\(";
            continue;
          }
          patternListStack.push({
            type: stateChar,
            start: i - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          });
          re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
          this.debug("plType %j %j", stateChar, re);
          stateChar = false;
          continue;
        case ")":
          if (inClass || !patternListStack.length) {
            re += "\\)";
            continue;
          }
          clearStateChar();
          hasMagic = true;
          pl = patternListStack.pop();
          re += pl.close;
          if (pl.type === "!") {
            negativeLists.push(pl);
          }
          pl.reEnd = re.length;
          continue;
        case "|":
          if (inClass || !patternListStack.length) {
            re += "\\|";
            continue;
          }
          clearStateChar();
          re += "|";
          continue;
        case "[":
          clearStateChar();
          if (inClass) {
            re += "\\" + c2;
            continue;
          }
          inClass = true;
          classStart = i;
          reClassStart = re.length;
          re += c2;
          continue;
        case "]":
          if (i === classStart + 1 || !inClass) {
            re += "\\" + c2;
            continue;
          }
          cs = pattern2.substring(classStart + 1, i);
          hasMagic = true;
          inClass = false;
          re += c2;
          continue;
        default:
          clearStateChar();
          if (reSpecials[c2] && !(c2 === "^" && inClass)) {
            re += "\\";
          }
          re += c2;
          break;
      }
    }
    if (inClass) {
      cs = pattern2.substr(classStart + 1);
      sp = this.parse(cs, SUBPARSE);
      re = re.substr(0, reClassStart) + "\\[" + sp[0];
      hasMagic = hasMagic || sp[1];
    }
    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      let tail;
      tail = re.slice(pl.reStart + pl.open.length);
      this.debug("setting tail", re, pl);
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_, $1, $2) => {
        if (!$2) {
          $2 = "\\";
        }
        return $1 + $1 + $2 + "|";
      });
      this.debug("tail=%j\n   %s", tail, tail, pl, re);
      const t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
      hasMagic = true;
      re = re.slice(0, pl.reStart) + t + "\\(" + tail;
    }
    clearStateChar();
    if (escaping) {
      re += "\\\\";
    }
    const addPatternStart = addPatternStartSet[re.charAt(0)];
    for (let n2 = negativeLists.length - 1; n2 > -1; n2--) {
      const nl = negativeLists[n2];
      const nlBefore = re.slice(0, nl.reStart);
      const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
      let nlAfter = re.slice(nl.reEnd);
      const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
      const openParensBefore = nlBefore.split("(").length - 1;
      let cleanAfter = nlAfter;
      for (let i = 0; i < openParensBefore; i++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      }
      nlAfter = cleanAfter;
      const dollar = nlAfter === "" && isSub !== SUBPARSE ? "$" : "";
      re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
    }
    if (re !== "" && hasMagic) {
      re = "(?=.)" + re;
    }
    if (addPatternStart) {
      re = patternStart + re;
    }
    if (isSub === SUBPARSE) {
      return [re, hasMagic];
    }
    if (!hasMagic) {
      return globUnescape(pattern2);
    }
    const flags = options3.nocase ? "i" : "";
    try {
      return Object.assign(new RegExp("^" + re + "$", flags), {
        _glob: pattern2,
        _src: re
      });
    } catch (er) {
      return new RegExp("$.");
    }
  }
  makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    const set2 = this.set;
    if (!set2.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options3 = this.options;
    const twoStar = options3.noglobstar ? star : options3.dot ? twoStarDot : twoStarNoDot;
    const flags = options3.nocase ? "i" : "";
    let re = set2.map((pattern2) => {
      pattern2 = pattern2.map(
        (p) => typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR$2 ? GLOBSTAR$2 : p._src
      ).reduce((set3, p) => {
        if (!(set3[set3.length - 1] === GLOBSTAR$2 && p === GLOBSTAR$2)) {
          set3.push(p);
        }
        return set3;
      }, []);
      pattern2.forEach((p, i) => {
        if (p !== GLOBSTAR$2 || pattern2[i - 1] === GLOBSTAR$2) {
          return;
        }
        if (i === 0) {
          if (pattern2.length > 1) {
            pattern2[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern2[i + 1];
          } else {
            pattern2[i] = twoStar;
          }
        } else if (i === pattern2.length - 1) {
          pattern2[i - 1] += "(?:\\/|" + twoStar + ")?";
        } else {
          pattern2[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern2[i + 1];
          pattern2[i + 1] = GLOBSTAR$2;
        }
      });
      return pattern2.filter((p) => p !== GLOBSTAR$2).join("/");
    }).join("|");
    re = "^(?:" + re + ")$";
    if (this.negate)
      re = "^(?!" + re + ").*$";
    try {
      this.regexp = new RegExp(re, flags);
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  match(f, partial2 = this.partial) {
    this.debug("match", f, this.pattern);
    if (this.comment)
      return false;
    if (this.empty)
      return f === "";
    if (f === "/" && partial2)
      return true;
    const options3 = this.options;
    if (path$j.sep !== "/") {
      f = f.split(path$j.sep).join("/");
    }
    f = f.split(slashSplit);
    this.debug(this.pattern, "split", f);
    const set2 = this.set;
    this.debug(this.pattern, "set", set2);
    let filename;
    for (let i = f.length - 1; i >= 0; i--) {
      filename = f[i];
      if (filename)
        break;
    }
    for (let i = 0; i < set2.length; i++) {
      const pattern2 = set2[i];
      let file = f;
      if (options3.matchBase && pattern2.length === 1) {
        file = [filename];
      }
      const hit = this.matchOne(file, pattern2, partial2);
      if (hit) {
        if (options3.flipNegate)
          return true;
        return !this.negate;
      }
    }
    if (options3.flipNegate)
      return false;
    return this.negate;
  }
  static defaults(def) {
    return minimatch$1.defaults(def).Minimatch;
  }
};
minimatch$1.Minimatch = Minimatch$1;
var inherits = { exports: {} };
var inherits_browser = { exports: {} };
var hasRequiredInherits_browser;
function requireInherits_browser() {
  if (hasRequiredInherits_browser)
    return inherits_browser.exports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser.exports;
}
(function(module2) {
  try {
    var util2 = require2("util");
    if (typeof util2.inherits !== "function")
      throw "";
    module2.exports = util2.inherits;
  } catch (e) {
    module2.exports = requireInherits_browser();
  }
})(inherits);
var common$c = {};
common$c.setopts = setopts;
common$c.ownProp = ownProp;
common$c.makeAbs = makeAbs;
common$c.finish = finish;
common$c.mark = mark;
common$c.isIgnored = isIgnored;
common$c.childrenIgnored = childrenIgnored;
function ownProp(obj, field) {
  return Object.prototype.hasOwnProperty.call(obj, field);
}
var fs$i = import_fs.default;
var path$i = import_path.default;
var minimatch = minimatch_1;
var isAbsolute = import_path.default.isAbsolute;
var Minimatch = minimatch.Minimatch;
function alphasort(a, b) {
  return a.localeCompare(b, "en");
}
function setupIgnores(self2, options3) {
  self2.ignore = options3.ignore || [];
  if (!Array.isArray(self2.ignore))
    self2.ignore = [self2.ignore];
  if (self2.ignore.length) {
    self2.ignore = self2.ignore.map(ignoreMap);
  }
}
function ignoreMap(pattern2) {
  var gmatcher = null;
  if (pattern2.slice(-3) === "/**") {
    var gpattern = pattern2.replace(/(\/\*\*)+$/, "");
    gmatcher = new Minimatch(gpattern, { dot: true });
  }
  return {
    matcher: new Minimatch(pattern2, { dot: true }),
    gmatcher
  };
}
function setopts(self2, pattern2, options3) {
  if (!options3)
    options3 = {};
  if (options3.matchBase && -1 === pattern2.indexOf("/")) {
    if (options3.noglobstar) {
      throw new Error("base matching requires globstar");
    }
    pattern2 = "**/" + pattern2;
  }
  self2.silent = !!options3.silent;
  self2.pattern = pattern2;
  self2.strict = options3.strict !== false;
  self2.realpath = !!options3.realpath;
  self2.realpathCache = options3.realpathCache || /* @__PURE__ */ Object.create(null);
  self2.follow = !!options3.follow;
  self2.dot = !!options3.dot;
  self2.mark = !!options3.mark;
  self2.nodir = !!options3.nodir;
  if (self2.nodir)
    self2.mark = true;
  self2.sync = !!options3.sync;
  self2.nounique = !!options3.nounique;
  self2.nonull = !!options3.nonull;
  self2.nosort = !!options3.nosort;
  self2.nocase = !!options3.nocase;
  self2.stat = !!options3.stat;
  self2.noprocess = !!options3.noprocess;
  self2.absolute = !!options3.absolute;
  self2.fs = options3.fs || fs$i;
  self2.maxLength = options3.maxLength || Infinity;
  self2.cache = options3.cache || /* @__PURE__ */ Object.create(null);
  self2.statCache = options3.statCache || /* @__PURE__ */ Object.create(null);
  self2.symlinks = options3.symlinks || /* @__PURE__ */ Object.create(null);
  setupIgnores(self2, options3);
  self2.changedCwd = false;
  var cwd = process.cwd();
  if (!ownProp(options3, "cwd"))
    self2.cwd = path$i.resolve(cwd);
  else {
    self2.cwd = path$i.resolve(options3.cwd);
    self2.changedCwd = self2.cwd !== cwd;
  }
  self2.root = options3.root || path$i.resolve(self2.cwd, "/");
  self2.root = path$i.resolve(self2.root);
  self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
  self2.nomount = !!options3.nomount;
  if (process.platform === "win32") {
    self2.root = self2.root.replace(/\\/g, "/");
    self2.cwd = self2.cwd.replace(/\\/g, "/");
    self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
  }
  options3.nonegate = true;
  options3.nocomment = true;
  options3.allowWindowsEscape = true;
  self2.minimatch = new Minimatch(pattern2, options3);
  self2.options = self2.minimatch.options;
}
function finish(self2) {
  var nou = self2.nounique;
  var all = nou ? [] : /* @__PURE__ */ Object.create(null);
  for (var i = 0, l = self2.matches.length; i < l; i++) {
    var matches2 = self2.matches[i];
    if (!matches2 || Object.keys(matches2).length === 0) {
      if (self2.nonull) {
        var literal2 = self2.minimatch.globSet[i];
        if (nou)
          all.push(literal2);
        else
          all[literal2] = true;
      }
    } else {
      var m = Object.keys(matches2);
      if (nou)
        all.push.apply(all, m);
      else
        m.forEach(function(m2) {
          all[m2] = true;
        });
    }
  }
  if (!nou)
    all = Object.keys(all);
  if (!self2.nosort)
    all = all.sort(alphasort);
  if (self2.mark) {
    for (var i = 0; i < all.length; i++) {
      all[i] = self2._mark(all[i]);
    }
    if (self2.nodir) {
      all = all.filter(function(e) {
        var notDir = !/\/$/.test(e);
        var c2 = self2.cache[e] || self2.cache[makeAbs(self2, e)];
        if (notDir && c2)
          notDir = c2 !== "DIR" && !Array.isArray(c2);
        return notDir;
      });
    }
  }
  if (self2.ignore.length)
    all = all.filter(function(m2) {
      return !isIgnored(self2, m2);
    });
  self2.found = all;
}
function mark(self2, p) {
  var abs = makeAbs(self2, p);
  var c2 = self2.cache[abs];
  var m = p;
  if (c2) {
    var isDir = c2 === "DIR" || Array.isArray(c2);
    var slash2 = p.slice(-1) === "/";
    if (isDir && !slash2)
      m += "/";
    else if (!isDir && slash2)
      m = m.slice(0, -1);
    if (m !== p) {
      var mabs = makeAbs(self2, m);
      self2.statCache[mabs] = self2.statCache[abs];
      self2.cache[mabs] = self2.cache[abs];
    }
  }
  return m;
}
function makeAbs(self2, f) {
  var abs = f;
  if (f.charAt(0) === "/") {
    abs = path$i.join(self2.root, f);
  } else if (isAbsolute(f) || f === "") {
    abs = f;
  } else if (self2.changedCwd) {
    abs = path$i.resolve(self2.cwd, f);
  } else {
    abs = path$i.resolve(f);
  }
  if (process.platform === "win32")
    abs = abs.replace(/\\/g, "/");
  return abs;
}
function isIgnored(self2, path4) {
  if (!self2.ignore.length)
    return false;
  return self2.ignore.some(function(item) {
    return item.matcher.match(path4) || !!(item.gmatcher && item.gmatcher.match(path4));
  });
}
function childrenIgnored(self2, path4) {
  if (!self2.ignore.length)
    return false;
  return self2.ignore.some(function(item) {
    return !!(item.gmatcher && item.gmatcher.match(path4));
  });
}
var sync$9;
var hasRequiredSync;
function requireSync() {
  if (hasRequiredSync)
    return sync$9;
  hasRequiredSync = 1;
  sync$9 = globSync;
  globSync.GlobSync = GlobSync;
  var rp = fs_realpath;
  var minimatch2 = minimatch_1;
  requireGlob().Glob;
  var path4 = import_path.default;
  var assert2 = import_assert.default;
  var isAbsolute2 = import_path.default.isAbsolute;
  var common2 = common$c;
  var setopts2 = common2.setopts;
  var ownProp2 = common2.ownProp;
  var childrenIgnored2 = common2.childrenIgnored;
  var isIgnored2 = common2.isIgnored;
  function globSync(pattern2, options3) {
    if (typeof options3 === "function" || arguments.length === 3)
      throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
    return new GlobSync(pattern2, options3).found;
  }
  function GlobSync(pattern2, options3) {
    if (!pattern2)
      throw new Error("must provide pattern");
    if (typeof options3 === "function" || arguments.length === 3)
      throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
    if (!(this instanceof GlobSync))
      return new GlobSync(pattern2, options3);
    setopts2(this, pattern2, options3);
    if (this.noprocess)
      return this;
    var n2 = this.minimatch.set.length;
    this.matches = new Array(n2);
    for (var i = 0; i < n2; i++) {
      this._process(this.minimatch.set[i], i, false);
    }
    this._finish();
  }
  GlobSync.prototype._finish = function() {
    assert2.ok(this instanceof GlobSync);
    if (this.realpath) {
      var self2 = this;
      this.matches.forEach(function(matchset, index2) {
        var set2 = self2.matches[index2] = /* @__PURE__ */ Object.create(null);
        for (var p in matchset) {
          try {
            p = self2._makeAbs(p);
            var real = rp.realpathSync(p, self2.realpathCache);
            set2[real] = true;
          } catch (er) {
            if (er.syscall === "stat")
              set2[self2._makeAbs(p)] = true;
            else
              throw er;
          }
        }
      });
    }
    common2.finish(this);
  };
  GlobSync.prototype._process = function(pattern2, index2, inGlobStar) {
    assert2.ok(this instanceof GlobSync);
    var n2 = 0;
    while (typeof pattern2[n2] === "string") {
      n2++;
    }
    var prefix;
    switch (n2) {
      case pattern2.length:
        this._processSimple(pattern2.join("/"), index2);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern2.slice(0, n2).join("/");
        break;
    }
    var remain = pattern2.slice(n2);
    var read2;
    if (prefix === null)
      read2 = ".";
    else if (isAbsolute2(prefix) || isAbsolute2(pattern2.map(function(p) {
      return typeof p === "string" ? p : "[*]";
    }).join("/"))) {
      if (!prefix || !isAbsolute2(prefix))
        prefix = "/" + prefix;
      read2 = prefix;
    } else
      read2 = prefix;
    var abs = this._makeAbs(read2);
    if (childrenIgnored2(this, read2))
      return;
    var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix, read2, abs, remain, index2, inGlobStar);
    else
      this._processReaddir(prefix, read2, abs, remain, index2, inGlobStar);
  };
  GlobSync.prototype._processReaddir = function(prefix, read2, abs, remain, index2, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (!entries)
      return;
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (e.charAt(0) !== "." || dotOk) {
        var m;
        if (negate && !prefix) {
          m = !e.match(pn);
        } else {
          m = e.match(pn);
        }
        if (m)
          matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return;
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index2])
        this.matches[index2] = /* @__PURE__ */ Object.create(null);
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        if (prefix) {
          if (prefix.slice(-1) !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        if (e.charAt(0) === "/" && !this.nomount) {
          e = path4.join(this.root, e);
        }
        this._emitMatch(index2, e);
      }
      return;
    }
    remain.shift();
    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      var newPattern;
      if (prefix)
        newPattern = [prefix, e];
      else
        newPattern = [e];
      this._process(newPattern.concat(remain), index2, inGlobStar);
    }
  };
  GlobSync.prototype._emitMatch = function(index2, e) {
    if (isIgnored2(this, e))
      return;
    var abs = this._makeAbs(e);
    if (this.mark)
      e = this._mark(e);
    if (this.absolute) {
      e = abs;
    }
    if (this.matches[index2][e])
      return;
    if (this.nodir) {
      var c2 = this.cache[abs];
      if (c2 === "DIR" || Array.isArray(c2))
        return;
    }
    this.matches[index2][e] = true;
    if (this.stat)
      this._stat(e);
  };
  GlobSync.prototype._readdirInGlobStar = function(abs) {
    if (this.follow)
      return this._readdir(abs, false);
    var entries;
    var lstat2;
    try {
      lstat2 = this.fs.lstatSync(abs);
    } catch (er) {
      if (er.code === "ENOENT") {
        return null;
      }
    }
    var isSym = lstat2 && lstat2.isSymbolicLink();
    this.symlinks[abs] = isSym;
    if (!isSym && lstat2 && !lstat2.isDirectory())
      this.cache[abs] = "FILE";
    else
      entries = this._readdir(abs, false);
    return entries;
  };
  GlobSync.prototype._readdir = function(abs, inGlobStar) {
    if (inGlobStar && !ownProp2(this.symlinks, abs))
      return this._readdirInGlobStar(abs);
    if (ownProp2(this.cache, abs)) {
      var c2 = this.cache[abs];
      if (!c2 || c2 === "FILE")
        return null;
      if (Array.isArray(c2))
        return c2;
    }
    try {
      return this._readdirEntries(abs, this.fs.readdirSync(abs));
    } catch (er) {
      this._readdirError(abs, er);
      return null;
    }
  };
  GlobSync.prototype._readdirEntries = function(abs, entries) {
    if (!this.mark && !this.stat) {
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (abs === "/")
          e = abs + e;
        else
          e = abs + "/" + e;
        this.cache[e] = true;
      }
    }
    this.cache[abs] = entries;
    return entries;
  };
  GlobSync.prototype._readdirError = function(f, er) {
    switch (er.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var abs = this._makeAbs(f);
        this.cache[abs] = "FILE";
        if (abs === this.cwdAbs) {
          var error2 = new Error(er.code + " invalid cwd " + this.cwd);
          error2.path = this.cwd;
          error2.code = er.code;
          throw error2;
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f)] = false;
        break;
      default:
        this.cache[this._makeAbs(f)] = false;
        if (this.strict)
          throw er;
        if (!this.silent)
          console.error("glob error", er);
        break;
    }
  };
  GlobSync.prototype._processGlobStar = function(prefix, read2, abs, remain, index2, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (!entries)
      return;
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index2, false);
    var len = entries.length;
    var isSym = this.symlinks[abs];
    if (isSym && inGlobStar)
      return;
    for (var i = 0; i < len; i++) {
      var e = entries[i];
      if (e.charAt(0) === "." && !this.dot)
        continue;
      var instead = gspref.concat(entries[i], remainWithoutGlobStar);
      this._process(instead, index2, true);
      var below = gspref.concat(entries[i], remain);
      this._process(below, index2, true);
    }
  };
  GlobSync.prototype._processSimple = function(prefix, index2) {
    var exists = this._stat(prefix);
    if (!this.matches[index2])
      this.matches[index2] = /* @__PURE__ */ Object.create(null);
    if (!exists)
      return;
    if (prefix && isAbsolute2(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      if (prefix.charAt(0) === "/") {
        prefix = path4.join(this.root, prefix);
      } else {
        prefix = path4.resolve(this.root, prefix);
        if (trail)
          prefix += "/";
      }
    }
    if (process.platform === "win32")
      prefix = prefix.replace(/\\/g, "/");
    this._emitMatch(index2, prefix);
  };
  GlobSync.prototype._stat = function(f) {
    var abs = this._makeAbs(f);
    var needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return false;
    if (!this.stat && ownProp2(this.cache, abs)) {
      var c2 = this.cache[abs];
      if (Array.isArray(c2))
        c2 = "DIR";
      if (!needDir || c2 === "DIR")
        return c2;
      if (needDir && c2 === "FILE")
        return false;
    }
    var stat2 = this.statCache[abs];
    if (!stat2) {
      var lstat2;
      try {
        lstat2 = this.fs.lstatSync(abs);
      } catch (er) {
        if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
          this.statCache[abs] = false;
          return false;
        }
      }
      if (lstat2 && lstat2.isSymbolicLink()) {
        try {
          stat2 = this.fs.statSync(abs);
        } catch (er) {
          stat2 = lstat2;
        }
      } else {
        stat2 = lstat2;
      }
    }
    this.statCache[abs] = stat2;
    var c2 = true;
    if (stat2)
      c2 = stat2.isDirectory() ? "DIR" : "FILE";
    this.cache[abs] = this.cache[abs] || c2;
    if (needDir && c2 === "FILE")
      return false;
    return c2;
  };
  GlobSync.prototype._mark = function(p) {
    return common2.mark(this, p);
  };
  GlobSync.prototype._makeAbs = function(f) {
    return common2.makeAbs(this, f);
  };
  return sync$9;
}
var wrappy_1 = wrappy$2;
function wrappy$2(fn, cb) {
  if (fn && cb)
    return wrappy$2(fn)(cb);
  if (typeof fn !== "function")
    throw new TypeError("need wrapper function");
  Object.keys(fn).forEach(function(k) {
    wrapper[k] = fn[k];
  });
  return wrapper;
  function wrapper() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    var ret = fn.apply(this, args);
    var cb2 = args[args.length - 1];
    if (typeof ret === "function" && ret !== cb2) {
      Object.keys(cb2).forEach(function(k) {
        ret[k] = cb2[k];
      });
    }
    return ret;
  }
}
var once$2 = { exports: {} };
var wrappy$1 = wrappy_1;
once$2.exports = wrappy$1(once$1);
once$2.exports.strict = wrappy$1(onceStrict);
once$1.proto = once$1(function() {
  Object.defineProperty(Function.prototype, "once", {
    value: function() {
      return once$1(this);
    },
    configurable: true
  });
  Object.defineProperty(Function.prototype, "onceStrict", {
    value: function() {
      return onceStrict(this);
    },
    configurable: true
  });
});
function once$1(fn) {
  var f = function() {
    if (f.called)
      return f.value;
    f.called = true;
    return f.value = fn.apply(this, arguments);
  };
  f.called = false;
  return f;
}
function onceStrict(fn) {
  var f = function() {
    if (f.called)
      throw new Error(f.onceError);
    f.called = true;
    return f.value = fn.apply(this, arguments);
  };
  var name = fn.name || "Function wrapped with `once`";
  f.onceError = name + " shouldn't be called more than once";
  f.called = false;
  return f;
}
var wrappy = wrappy_1;
var reqs = /* @__PURE__ */ Object.create(null);
var once = once$2.exports;
var inflight_1 = wrappy(inflight);
function inflight(key2, cb) {
  if (reqs[key2]) {
    reqs[key2].push(cb);
    return null;
  } else {
    reqs[key2] = [cb];
    return makeres(key2);
  }
}
function makeres(key2) {
  return once(function RES() {
    var cbs = reqs[key2];
    var len = cbs.length;
    var args = slice$1(arguments);
    try {
      for (var i = 0; i < len; i++) {
        cbs[i].apply(null, args);
      }
    } finally {
      if (cbs.length > len) {
        cbs.splice(0, len);
        process.nextTick(function() {
          RES.apply(null, args);
        });
      } else {
        delete reqs[key2];
      }
    }
  });
}
function slice$1(args) {
  var length = args.length;
  var array2 = [];
  for (var i = 0; i < length; i++)
    array2[i] = args[i];
  return array2;
}
var glob_1;
var hasRequiredGlob;
function requireGlob() {
  if (hasRequiredGlob)
    return glob_1;
  hasRequiredGlob = 1;
  glob_1 = glob;
  var rp = fs_realpath;
  var minimatch2 = minimatch_1;
  var inherits$1 = inherits.exports;
  var EE = import_events.default.EventEmitter;
  var path4 = import_path.default;
  var assert2 = import_assert.default;
  var isAbsolute2 = import_path.default.isAbsolute;
  var globSync = requireSync();
  var common2 = common$c;
  var setopts2 = common2.setopts;
  var ownProp2 = common2.ownProp;
  var inflight2 = inflight_1;
  var childrenIgnored2 = common2.childrenIgnored;
  var isIgnored2 = common2.isIgnored;
  var once2 = once$2.exports;
  function glob(pattern2, options3, cb) {
    if (typeof options3 === "function")
      cb = options3, options3 = {};
    if (!options3)
      options3 = {};
    if (options3.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return globSync(pattern2, options3);
    }
    return new Glob(pattern2, options3, cb);
  }
  glob.sync = globSync;
  var GlobSync = glob.GlobSync = globSync.GlobSync;
  glob.glob = glob;
  function extend2(origin, add) {
    if (add === null || typeof add !== "object") {
      return origin;
    }
    var keys = Object.keys(add);
    var i = keys.length;
    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }
    return origin;
  }
  glob.hasMagic = function(pattern2, options_) {
    var options3 = extend2({}, options_);
    options3.noprocess = true;
    var g = new Glob(pattern2, options3);
    var set2 = g.minimatch.set;
    if (!pattern2)
      return false;
    if (set2.length > 1)
      return true;
    for (var j = 0; j < set2[0].length; j++) {
      if (typeof set2[0][j] !== "string")
        return true;
    }
    return false;
  };
  glob.Glob = Glob;
  inherits$1(Glob, EE);
  function Glob(pattern2, options3, cb) {
    if (typeof options3 === "function") {
      cb = options3;
      options3 = null;
    }
    if (options3 && options3.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return new GlobSync(pattern2, options3);
    }
    if (!(this instanceof Glob))
      return new Glob(pattern2, options3, cb);
    setopts2(this, pattern2, options3);
    this._didRealPath = false;
    var n2 = this.minimatch.set.length;
    this.matches = new Array(n2);
    if (typeof cb === "function") {
      cb = once2(cb);
      this.on("error", cb);
      this.on("end", function(matches2) {
        cb(null, matches2);
      });
    }
    var self2 = this;
    this._processing = 0;
    this._emitQueue = [];
    this._processQueue = [];
    this.paused = false;
    if (this.noprocess)
      return this;
    if (n2 === 0)
      return done();
    var sync2 = true;
    for (var i = 0; i < n2; i++) {
      this._process(this.minimatch.set[i], i, false, done);
    }
    sync2 = false;
    function done() {
      --self2._processing;
      if (self2._processing <= 0) {
        if (sync2) {
          process.nextTick(function() {
            self2._finish();
          });
        } else {
          self2._finish();
        }
      }
    }
  }
  Glob.prototype._finish = function() {
    assert2(this instanceof Glob);
    if (this.aborted)
      return;
    if (this.realpath && !this._didRealpath)
      return this._realpath();
    common2.finish(this);
    this.emit("end", this.found);
  };
  Glob.prototype._realpath = function() {
    if (this._didRealpath)
      return;
    this._didRealpath = true;
    var n2 = this.matches.length;
    if (n2 === 0)
      return this._finish();
    var self2 = this;
    for (var i = 0; i < this.matches.length; i++)
      this._realpathSet(i, next);
    function next() {
      if (--n2 === 0)
        self2._finish();
    }
  };
  Glob.prototype._realpathSet = function(index2, cb) {
    var matchset = this.matches[index2];
    if (!matchset)
      return cb();
    var found2 = Object.keys(matchset);
    var self2 = this;
    var n2 = found2.length;
    if (n2 === 0)
      return cb();
    var set2 = this.matches[index2] = /* @__PURE__ */ Object.create(null);
    found2.forEach(function(p, i) {
      p = self2._makeAbs(p);
      rp.realpath(p, self2.realpathCache, function(er, real) {
        if (!er)
          set2[real] = true;
        else if (er.syscall === "stat")
          set2[p] = true;
        else
          self2.emit("error", er);
        if (--n2 === 0) {
          self2.matches[index2] = set2;
          cb();
        }
      });
    });
  };
  Glob.prototype._mark = function(p) {
    return common2.mark(this, p);
  };
  Glob.prototype._makeAbs = function(f) {
    return common2.makeAbs(this, f);
  };
  Glob.prototype.abort = function() {
    this.aborted = true;
    this.emit("abort");
  };
  Glob.prototype.pause = function() {
    if (!this.paused) {
      this.paused = true;
      this.emit("pause");
    }
  };
  Glob.prototype.resume = function() {
    if (this.paused) {
      this.emit("resume");
      this.paused = false;
      if (this._emitQueue.length) {
        var eq = this._emitQueue.slice(0);
        this._emitQueue.length = 0;
        for (var i = 0; i < eq.length; i++) {
          var e = eq[i];
          this._emitMatch(e[0], e[1]);
        }
      }
      if (this._processQueue.length) {
        var pq = this._processQueue.slice(0);
        this._processQueue.length = 0;
        for (var i = 0; i < pq.length; i++) {
          var p = pq[i];
          this._processing--;
          this._process(p[0], p[1], p[2], p[3]);
        }
      }
    }
  };
  Glob.prototype._process = function(pattern2, index2, inGlobStar, cb) {
    assert2(this instanceof Glob);
    assert2(typeof cb === "function");
    if (this.aborted)
      return;
    this._processing++;
    if (this.paused) {
      this._processQueue.push([pattern2, index2, inGlobStar, cb]);
      return;
    }
    var n2 = 0;
    while (typeof pattern2[n2] === "string") {
      n2++;
    }
    var prefix;
    switch (n2) {
      case pattern2.length:
        this._processSimple(pattern2.join("/"), index2, cb);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern2.slice(0, n2).join("/");
        break;
    }
    var remain = pattern2.slice(n2);
    var read2;
    if (prefix === null)
      read2 = ".";
    else if (isAbsolute2(prefix) || isAbsolute2(pattern2.map(function(p) {
      return typeof p === "string" ? p : "[*]";
    }).join("/"))) {
      if (!prefix || !isAbsolute2(prefix))
        prefix = "/" + prefix;
      read2 = prefix;
    } else
      read2 = prefix;
    var abs = this._makeAbs(read2);
    if (childrenIgnored2(this, read2))
      return cb();
    var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix, read2, abs, remain, index2, inGlobStar, cb);
    else
      this._processReaddir(prefix, read2, abs, remain, index2, inGlobStar, cb);
  };
  Glob.prototype._processReaddir = function(prefix, read2, abs, remain, index2, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      return self2._processReaddir2(prefix, read2, abs, remain, index2, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processReaddir2 = function(prefix, read2, abs, remain, index2, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (e.charAt(0) !== "." || dotOk) {
        var m;
        if (negate && !prefix) {
          m = !e.match(pn);
        } else {
          m = e.match(pn);
        }
        if (m)
          matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return cb();
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index2])
        this.matches[index2] = /* @__PURE__ */ Object.create(null);
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        if (e.charAt(0) === "/" && !this.nomount) {
          e = path4.join(this.root, e);
        }
        this._emitMatch(index2, e);
      }
      return cb();
    }
    remain.shift();
    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      if (prefix) {
        if (prefix !== "/")
          e = prefix + "/" + e;
        else
          e = prefix + e;
      }
      this._process([e].concat(remain), index2, inGlobStar, cb);
    }
    cb();
  };
  Glob.prototype._emitMatch = function(index2, e) {
    if (this.aborted)
      return;
    if (isIgnored2(this, e))
      return;
    if (this.paused) {
      this._emitQueue.push([index2, e]);
      return;
    }
    var abs = isAbsolute2(e) ? e : this._makeAbs(e);
    if (this.mark)
      e = this._mark(e);
    if (this.absolute)
      e = abs;
    if (this.matches[index2][e])
      return;
    if (this.nodir) {
      var c2 = this.cache[abs];
      if (c2 === "DIR" || Array.isArray(c2))
        return;
    }
    this.matches[index2][e] = true;
    var st = this.statCache[abs];
    if (st)
      this.emit("stat", e, st);
    this.emit("match", e);
  };
  Glob.prototype._readdirInGlobStar = function(abs, cb) {
    if (this.aborted)
      return;
    if (this.follow)
      return this._readdir(abs, false, cb);
    var lstatkey = "lstat\0" + abs;
    var self2 = this;
    var lstatcb = inflight2(lstatkey, lstatcb_);
    if (lstatcb)
      self2.fs.lstat(abs, lstatcb);
    function lstatcb_(er, lstat2) {
      if (er && er.code === "ENOENT")
        return cb();
      var isSym = lstat2 && lstat2.isSymbolicLink();
      self2.symlinks[abs] = isSym;
      if (!isSym && lstat2 && !lstat2.isDirectory()) {
        self2.cache[abs] = "FILE";
        cb();
      } else
        self2._readdir(abs, false, cb);
    }
  };
  Glob.prototype._readdir = function(abs, inGlobStar, cb) {
    if (this.aborted)
      return;
    cb = inflight2("readdir\0" + abs + "\0" + inGlobStar, cb);
    if (!cb)
      return;
    if (inGlobStar && !ownProp2(this.symlinks, abs))
      return this._readdirInGlobStar(abs, cb);
    if (ownProp2(this.cache, abs)) {
      var c2 = this.cache[abs];
      if (!c2 || c2 === "FILE")
        return cb();
      if (Array.isArray(c2))
        return cb(null, c2);
    }
    var self2 = this;
    self2.fs.readdir(abs, readdirCb(this, abs, cb));
  };
  function readdirCb(self2, abs, cb) {
    return function(er, entries) {
      if (er)
        self2._readdirError(abs, er, cb);
      else
        self2._readdirEntries(abs, entries, cb);
    };
  }
  Glob.prototype._readdirEntries = function(abs, entries, cb) {
    if (this.aborted)
      return;
    if (!this.mark && !this.stat) {
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (abs === "/")
          e = abs + e;
        else
          e = abs + "/" + e;
        this.cache[e] = true;
      }
    }
    this.cache[abs] = entries;
    return cb(null, entries);
  };
  Glob.prototype._readdirError = function(f, er, cb) {
    if (this.aborted)
      return;
    switch (er.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var abs = this._makeAbs(f);
        this.cache[abs] = "FILE";
        if (abs === this.cwdAbs) {
          var error2 = new Error(er.code + " invalid cwd " + this.cwd);
          error2.path = this.cwd;
          error2.code = er.code;
          this.emit("error", error2);
          this.abort();
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f)] = false;
        break;
      default:
        this.cache[this._makeAbs(f)] = false;
        if (this.strict) {
          this.emit("error", er);
          this.abort();
        }
        if (!this.silent)
          console.error("glob error", er);
        break;
    }
    return cb();
  };
  Glob.prototype._processGlobStar = function(prefix, read2, abs, remain, index2, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      self2._processGlobStar2(prefix, read2, abs, remain, index2, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processGlobStar2 = function(prefix, read2, abs, remain, index2, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index2, false, cb);
    var isSym = this.symlinks[abs];
    var len = entries.length;
    if (isSym && inGlobStar)
      return cb();
    for (var i = 0; i < len; i++) {
      var e = entries[i];
      if (e.charAt(0) === "." && !this.dot)
        continue;
      var instead = gspref.concat(entries[i], remainWithoutGlobStar);
      this._process(instead, index2, true, cb);
      var below = gspref.concat(entries[i], remain);
      this._process(below, index2, true, cb);
    }
    cb();
  };
  Glob.prototype._processSimple = function(prefix, index2, cb) {
    var self2 = this;
    this._stat(prefix, function(er, exists) {
      self2._processSimple2(prefix, index2, er, exists, cb);
    });
  };
  Glob.prototype._processSimple2 = function(prefix, index2, er, exists, cb) {
    if (!this.matches[index2])
      this.matches[index2] = /* @__PURE__ */ Object.create(null);
    if (!exists)
      return cb();
    if (prefix && isAbsolute2(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      if (prefix.charAt(0) === "/") {
        prefix = path4.join(this.root, prefix);
      } else {
        prefix = path4.resolve(this.root, prefix);
        if (trail)
          prefix += "/";
      }
    }
    if (process.platform === "win32")
      prefix = prefix.replace(/\\/g, "/");
    this._emitMatch(index2, prefix);
    cb();
  };
  Glob.prototype._stat = function(f, cb) {
    var abs = this._makeAbs(f);
    var needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return cb();
    if (!this.stat && ownProp2(this.cache, abs)) {
      var c2 = this.cache[abs];
      if (Array.isArray(c2))
        c2 = "DIR";
      if (!needDir || c2 === "DIR")
        return cb(null, c2);
      if (needDir && c2 === "FILE")
        return cb();
    }
    var stat2 = this.statCache[abs];
    if (stat2 !== void 0) {
      if (stat2 === false)
        return cb(null, stat2);
      else {
        var type = stat2.isDirectory() ? "DIR" : "FILE";
        if (needDir && type === "FILE")
          return cb();
        else
          return cb(null, type, stat2);
      }
    }
    var self2 = this;
    var statcb = inflight2("stat\0" + abs, lstatcb_);
    if (statcb)
      self2.fs.lstat(abs, statcb);
    function lstatcb_(er, lstat2) {
      if (lstat2 && lstat2.isSymbolicLink()) {
        return self2.fs.stat(abs, function(er2, stat3) {
          if (er2)
            self2._stat2(f, abs, null, lstat2, cb);
          else
            self2._stat2(f, abs, er2, stat3, cb);
        });
      } else {
        self2._stat2(f, abs, er, lstat2, cb);
      }
    }
  };
  Glob.prototype._stat2 = function(f, abs, er, stat2, cb) {
    if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
      this.statCache[abs] = false;
      return cb();
    }
    var needDir = f.slice(-1) === "/";
    this.statCache[abs] = stat2;
    if (abs.slice(-1) === "/" && stat2 && !stat2.isDirectory())
      return cb(null, false, stat2);
    var c2 = true;
    if (stat2)
      c2 = stat2.isDirectory() ? "DIR" : "FILE";
    this.cache[abs] = this.cache[abs] || c2;
    if (needDir && c2 === "FILE")
      return cb();
    return cb(null, c2, stat2);
  };
  return glob_1;
}
var globExports = requireGlob();
var chars$2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function encode$2(decoded) {
  var sourceFileIndex = 0;
  var sourceCodeLine = 0;
  var sourceCodeColumn = 0;
  var nameIndex = 0;
  var mappings = "";
  for (var i = 0; i < decoded.length; i++) {
    var line2 = decoded[i];
    if (i > 0)
      mappings += ";";
    if (line2.length === 0)
      continue;
    var generatedCodeColumn = 0;
    var lineMappings = [];
    for (var _i = 0, line_1 = line2; _i < line_1.length; _i++) {
      var segment = line_1[_i];
      var segmentMappings = encodeInteger$1(segment[0] - generatedCodeColumn);
      generatedCodeColumn = segment[0];
      if (segment.length > 1) {
        segmentMappings += encodeInteger$1(segment[1] - sourceFileIndex) + encodeInteger$1(segment[2] - sourceCodeLine) + encodeInteger$1(segment[3] - sourceCodeColumn);
        sourceFileIndex = segment[1];
        sourceCodeLine = segment[2];
        sourceCodeColumn = segment[3];
      }
      if (segment.length === 5) {
        segmentMappings += encodeInteger$1(segment[4] - nameIndex);
        nameIndex = segment[4];
      }
      lineMappings.push(segmentMappings);
    }
    mappings += lineMappings.join(",");
  }
  return mappings;
}
function encodeInteger$1(num) {
  var result = "";
  num = num < 0 ? -num << 1 | 1 : num << 1;
  do {
    var clamped = num & 31;
    num >>>= 5;
    if (num > 0) {
      clamped |= 32;
    }
    result += chars$2[clamped];
  } while (num > 0);
  return result;
}
var BitSet = class {
  constructor(arg) {
    this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
  }
  add(n2) {
    this.bits[n2 >> 5] |= 1 << (n2 & 31);
  }
  has(n2) {
    return !!(this.bits[n2 >> 5] & 1 << (n2 & 31));
  }
};
var Chunk = class {
  constructor(start, end, content) {
    this.start = start;
    this.end = end;
    this.original = content;
    this.intro = "";
    this.outro = "";
    this.content = content;
    this.storeName = false;
    this.edited = false;
    {
      this.previous = null;
      this.next = null;
    }
  }
  appendLeft(content) {
    this.outro += content;
  }
  appendRight(content) {
    this.intro = this.intro + content;
  }
  clone() {
    const chunk = new Chunk(this.start, this.end, this.original);
    chunk.intro = this.intro;
    chunk.outro = this.outro;
    chunk.content = this.content;
    chunk.storeName = this.storeName;
    chunk.edited = this.edited;
    return chunk;
  }
  contains(index2) {
    return this.start < index2 && index2 < this.end;
  }
  eachNext(fn) {
    let chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.next;
    }
  }
  eachPrevious(fn) {
    let chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.previous;
    }
  }
  edit(content, storeName, contentOnly) {
    this.content = content;
    if (!contentOnly) {
      this.intro = "";
      this.outro = "";
    }
    this.storeName = storeName;
    this.edited = true;
    return this;
  }
  prependLeft(content) {
    this.outro = content + this.outro;
  }
  prependRight(content) {
    this.intro = content + this.intro;
  }
  split(index2) {
    const sliceIndex = index2 - this.start;
    const originalBefore = this.original.slice(0, sliceIndex);
    const originalAfter = this.original.slice(sliceIndex);
    this.original = originalBefore;
    const newChunk = new Chunk(index2, this.end, originalAfter);
    newChunk.outro = this.outro;
    this.outro = "";
    this.end = index2;
    if (this.edited) {
      newChunk.edit("", false);
      this.content = "";
    } else {
      this.content = originalBefore;
    }
    newChunk.next = this.next;
    if (newChunk.next)
      newChunk.next.previous = newChunk;
    newChunk.previous = this;
    this.next = newChunk;
    return newChunk;
  }
  toString() {
    return this.intro + this.content + this.outro;
  }
  trimEnd(rx) {
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length)
      return true;
    const trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        this.split(this.start + trimmed.length).edit("", void 0, true);
      }
      return true;
    } else {
      this.edit("", void 0, true);
      this.intro = this.intro.replace(rx, "");
      if (this.intro.length)
        return true;
    }
  }
  trimStart(rx) {
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length)
      return true;
    const trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        this.split(this.end - trimmed.length);
        this.edit("", void 0, true);
      }
      return true;
    } else {
      this.edit("", void 0, true);
      this.outro = this.outro.replace(rx, "");
      if (this.outro.length)
        return true;
    }
  }
};
function getBtoa() {
  if (typeof window !== "undefined" && typeof window.btoa === "function") {
    return (str) => window.btoa(unescape(encodeURIComponent(str)));
  } else if (typeof Buffer === "function") {
    return (str) => Buffer.from(str, "utf-8").toString("base64");
  } else {
    return () => {
      throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
  }
}
var btoa$1 = getBtoa();
var SourceMap$1 = class {
  constructor(properties) {
    this.version = 3;
    this.file = properties.file;
    this.sources = properties.sources;
    this.sourcesContent = properties.sourcesContent;
    this.names = properties.names;
    this.mappings = encode$2(properties.mappings);
  }
  toString() {
    return JSON.stringify(this);
  }
  toUrl() {
    return "data:application/json;charset=utf-8;base64," + btoa$1(this.toString());
  }
};
function guessIndent(code) {
  const lines = code.split("\n");
  const tabbed = lines.filter((line2) => /^\t+/.test(line2));
  const spaced = lines.filter((line2) => /^ {2,}/.test(line2));
  if (tabbed.length === 0 && spaced.length === 0) {
    return null;
  }
  if (tabbed.length >= spaced.length) {
    return "	";
  }
  const min2 = spaced.reduce((previous, current2) => {
    const numSpaces = /^ +/.exec(current2)[0].length;
    return Math.min(numSpaces, previous);
  }, Infinity);
  return new Array(min2 + 1).join(" ");
}
function getRelativePath(from, to) {
  const fromParts = from.split(/[/\\]/);
  const toParts = to.split(/[/\\]/);
  fromParts.pop();
  while (fromParts[0] === toParts[0]) {
    fromParts.shift();
    toParts.shift();
  }
  if (fromParts.length) {
    let i = fromParts.length;
    while (i--)
      fromParts[i] = "..";
  }
  return fromParts.concat(toParts).join("/");
}
var toString$2 = Object.prototype.toString;
function isObject$2(thing) {
  return toString$2.call(thing) === "[object Object]";
}
function getLocator(source2) {
  const originalLines = source2.split("\n");
  const lineOffsets = [];
  for (let i = 0, pos2 = 0; i < originalLines.length; i++) {
    lineOffsets.push(pos2);
    pos2 += originalLines[i].length + 1;
  }
  return function locate(index2) {
    let i = 0;
    let j = lineOffsets.length;
    while (i < j) {
      const m = i + j >> 1;
      if (index2 < lineOffsets[m]) {
        j = m;
      } else {
        i = m + 1;
      }
    }
    const line2 = i - 1;
    const column2 = index2 - lineOffsets[line2];
    return { line: line2, column: column2 };
  };
}
var Mappings = class {
  constructor(hires) {
    this.hires = hires;
    this.generatedCodeLine = 0;
    this.generatedCodeColumn = 0;
    this.raw = [];
    this.rawSegments = this.raw[this.generatedCodeLine] = [];
    this.pending = null;
  }
  addEdit(sourceIndex, content, loc, nameIndex) {
    if (content.length) {
      const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
      if (nameIndex >= 0) {
        segment.push(nameIndex);
      }
      this.rawSegments.push(segment);
    } else if (this.pending) {
      this.rawSegments.push(this.pending);
    }
    this.advance(content);
    this.pending = null;
  }
  addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
    let originalCharIndex = chunk.start;
    let first2 = true;
    while (originalCharIndex < chunk.end) {
      if (this.hires || first2 || sourcemapLocations.has(originalCharIndex)) {
        this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
      }
      if (original[originalCharIndex] === "\n") {
        loc.line += 1;
        loc.column = 0;
        this.generatedCodeLine += 1;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
        first2 = true;
      } else {
        loc.column += 1;
        this.generatedCodeColumn += 1;
        first2 = false;
      }
      originalCharIndex += 1;
    }
    this.pending = null;
  }
  advance(str) {
    if (!str)
      return;
    const lines = str.split("\n");
    if (lines.length > 1) {
      for (let i = 0; i < lines.length - 1; i++) {
        this.generatedCodeLine++;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
      }
      this.generatedCodeColumn = 0;
    }
    this.generatedCodeColumn += lines[lines.length - 1].length;
  }
};
var n = "\n";
var warned = {
  insertLeft: false,
  insertRight: false,
  storeName: false
};
var MagicString = class {
  constructor(string2, options3 = {}) {
    const chunk = new Chunk(0, string2.length, string2);
    Object.defineProperties(this, {
      original: { writable: true, value: string2 },
      outro: { writable: true, value: "" },
      intro: { writable: true, value: "" },
      firstChunk: { writable: true, value: chunk },
      lastChunk: { writable: true, value: chunk },
      lastSearchedChunk: { writable: true, value: chunk },
      byStart: { writable: true, value: {} },
      byEnd: { writable: true, value: {} },
      filename: { writable: true, value: options3.filename },
      indentExclusionRanges: { writable: true, value: options3.indentExclusionRanges },
      sourcemapLocations: { writable: true, value: new BitSet() },
      storedNames: { writable: true, value: {} },
      indentStr: { writable: true, value: void 0 }
    });
    this.byStart[0] = chunk;
    this.byEnd[string2.length] = chunk;
  }
  addSourcemapLocation(char) {
    this.sourcemapLocations.add(char);
  }
  append(content) {
    if (typeof content !== "string")
      throw new TypeError("outro content must be a string");
    this.outro += content;
    return this;
  }
  appendLeft(index2, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index2);
    const chunk = this.byEnd[index2];
    if (chunk) {
      chunk.appendLeft(content);
    } else {
      this.intro += content;
    }
    return this;
  }
  appendRight(index2, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index2);
    const chunk = this.byStart[index2];
    if (chunk) {
      chunk.appendRight(content);
    } else {
      this.outro += content;
    }
    return this;
  }
  clone() {
    const cloned = new MagicString(this.original, { filename: this.filename });
    let originalChunk = this.firstChunk;
    let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
    while (originalChunk) {
      cloned.byStart[clonedChunk.start] = clonedChunk;
      cloned.byEnd[clonedChunk.end] = clonedChunk;
      const nextOriginalChunk = originalChunk.next;
      const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
      if (nextClonedChunk) {
        clonedChunk.next = nextClonedChunk;
        nextClonedChunk.previous = clonedChunk;
        clonedChunk = nextClonedChunk;
      }
      originalChunk = nextOriginalChunk;
    }
    cloned.lastChunk = clonedChunk;
    if (this.indentExclusionRanges) {
      cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
    }
    cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
    cloned.intro = this.intro;
    cloned.outro = this.outro;
    return cloned;
  }
  generateDecodedMap(options3) {
    options3 = options3 || {};
    const sourceIndex = 0;
    const names = Object.keys(this.storedNames);
    const mappings = new Mappings(options3.hires);
    const locate = getLocator(this.original);
    if (this.intro) {
      mappings.advance(this.intro);
    }
    this.firstChunk.eachNext((chunk) => {
      const loc = locate(chunk.start);
      if (chunk.intro.length)
        mappings.advance(chunk.intro);
      if (chunk.edited) {
        mappings.addEdit(
          sourceIndex,
          chunk.content,
          loc,
          chunk.storeName ? names.indexOf(chunk.original) : -1
        );
      } else {
        mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
      }
      if (chunk.outro.length)
        mappings.advance(chunk.outro);
    });
    return {
      file: options3.file ? options3.file.split(/[/\\]/).pop() : null,
      sources: [options3.source ? getRelativePath(options3.file || "", options3.source) : null],
      sourcesContent: options3.includeContent ? [this.original] : [null],
      names,
      mappings: mappings.raw
    };
  }
  generateMap(options3) {
    return new SourceMap$1(this.generateDecodedMap(options3));
  }
  _ensureindentStr() {
    if (this.indentStr === void 0) {
      this.indentStr = guessIndent(this.original);
    }
  }
  _getRawIndentString() {
    this._ensureindentStr();
    return this.indentStr;
  }
  getIndentString() {
    this._ensureindentStr();
    return this.indentStr === null ? "	" : this.indentStr;
  }
  indent(indentStr, options3) {
    const pattern2 = /^[^\r\n]/gm;
    if (isObject$2(indentStr)) {
      options3 = indentStr;
      indentStr = void 0;
    }
    if (indentStr === void 0) {
      this._ensureindentStr();
      indentStr = this.indentStr || "	";
    }
    if (indentStr === "")
      return this;
    options3 = options3 || {};
    const isExcluded = {};
    if (options3.exclude) {
      const exclusions = typeof options3.exclude[0] === "number" ? [options3.exclude] : options3.exclude;
      exclusions.forEach((exclusion) => {
        for (let i = exclusion[0]; i < exclusion[1]; i += 1) {
          isExcluded[i] = true;
        }
      });
    }
    let shouldIndentNextCharacter = options3.indentStart !== false;
    const replacer = (match) => {
      if (shouldIndentNextCharacter)
        return `${indentStr}${match}`;
      shouldIndentNextCharacter = true;
      return match;
    };
    this.intro = this.intro.replace(pattern2, replacer);
    let charIndex = 0;
    let chunk = this.firstChunk;
    while (chunk) {
      const end = chunk.end;
      if (chunk.edited) {
        if (!isExcluded[charIndex]) {
          chunk.content = chunk.content.replace(pattern2, replacer);
          if (chunk.content.length) {
            shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
          }
        }
      } else {
        charIndex = chunk.start;
        while (charIndex < end) {
          if (!isExcluded[charIndex]) {
            const char = this.original[charIndex];
            if (char === "\n") {
              shouldIndentNextCharacter = true;
            } else if (char !== "\r" && shouldIndentNextCharacter) {
              shouldIndentNextCharacter = false;
              if (charIndex === chunk.start) {
                chunk.prependRight(indentStr);
              } else {
                this._splitChunk(chunk, charIndex);
                chunk = chunk.next;
                chunk.prependRight(indentStr);
              }
            }
          }
          charIndex += 1;
        }
      }
      charIndex = chunk.end;
      chunk = chunk.next;
    }
    this.outro = this.outro.replace(pattern2, replacer);
    return this;
  }
  insert() {
    throw new Error(
      "magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)"
    );
  }
  insertLeft(index2, content) {
    if (!warned.insertLeft) {
      console.warn(
        "magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"
      );
      warned.insertLeft = true;
    }
    return this.appendLeft(index2, content);
  }
  insertRight(index2, content) {
    if (!warned.insertRight) {
      console.warn(
        "magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"
      );
      warned.insertRight = true;
    }
    return this.prependRight(index2, content);
  }
  move(start, end, index2) {
    if (index2 >= start && index2 <= end)
      throw new Error("Cannot move a selection inside itself");
    this._split(start);
    this._split(end);
    this._split(index2);
    const first2 = this.byStart[start];
    const last = this.byEnd[end];
    const oldLeft = first2.previous;
    const oldRight = last.next;
    const newRight = this.byStart[index2];
    if (!newRight && last === this.lastChunk)
      return this;
    const newLeft = newRight ? newRight.previous : this.lastChunk;
    if (oldLeft)
      oldLeft.next = oldRight;
    if (oldRight)
      oldRight.previous = oldLeft;
    if (newLeft)
      newLeft.next = first2;
    if (newRight)
      newRight.previous = last;
    if (!first2.previous)
      this.firstChunk = last.next;
    if (!last.next) {
      this.lastChunk = first2.previous;
      this.lastChunk.next = null;
    }
    first2.previous = newLeft;
    last.next = newRight || null;
    if (!newLeft)
      this.firstChunk = first2;
    if (!newRight)
      this.lastChunk = last;
    return this;
  }
  overwrite(start, end, content, options3) {
    options3 = options3 || {};
    return this.update(start, end, content, { ...options3, overwrite: !options3.contentOnly });
  }
  update(start, end, content, options3) {
    if (typeof content !== "string")
      throw new TypeError("replacement content must be a string");
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    if (end > this.original.length)
      throw new Error("end is out of bounds");
    if (start === end)
      throw new Error(
        "Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead"
      );
    this._split(start);
    this._split(end);
    if (options3 === true) {
      if (!warned.storeName) {
        console.warn(
          "The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"
        );
        warned.storeName = true;
      }
      options3 = { storeName: true };
    }
    const storeName = options3 !== void 0 ? options3.storeName : false;
    const overwrite = options3 !== void 0 ? options3.overwrite : false;
    if (storeName) {
      const original = this.original.slice(start, end);
      Object.defineProperty(this.storedNames, original, {
        writable: true,
        value: true,
        enumerable: true
      });
    }
    const first2 = this.byStart[start];
    const last = this.byEnd[end];
    if (first2) {
      let chunk = first2;
      while (chunk !== last) {
        if (chunk.next !== this.byStart[chunk.end]) {
          throw new Error("Cannot overwrite across a split point");
        }
        chunk = chunk.next;
        chunk.edit("", false);
      }
      first2.edit(content, storeName, !overwrite);
    } else {
      const newChunk = new Chunk(start, end, "").edit(content, storeName);
      last.next = newChunk;
      newChunk.previous = last;
    }
    return this;
  }
  prepend(content) {
    if (typeof content !== "string")
      throw new TypeError("outro content must be a string");
    this.intro = content + this.intro;
    return this;
  }
  prependLeft(index2, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index2);
    const chunk = this.byEnd[index2];
    if (chunk) {
      chunk.prependLeft(content);
    } else {
      this.intro = content + this.intro;
    }
    return this;
  }
  prependRight(index2, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index2);
    const chunk = this.byStart[index2];
    if (chunk) {
      chunk.prependRight(content);
    } else {
      this.outro = content + this.outro;
    }
    return this;
  }
  remove(start, end) {
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    if (start === end)
      return this;
    if (start < 0 || end > this.original.length)
      throw new Error("Character is out of bounds");
    if (start > end)
      throw new Error("end must be greater than start");
    this._split(start);
    this._split(end);
    let chunk = this.byStart[start];
    while (chunk) {
      chunk.intro = "";
      chunk.outro = "";
      chunk.edit("");
      chunk = end > chunk.end ? this.byStart[chunk.end] : null;
    }
    return this;
  }
  lastChar() {
    if (this.outro.length)
      return this.outro[this.outro.length - 1];
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length)
        return chunk.outro[chunk.outro.length - 1];
      if (chunk.content.length)
        return chunk.content[chunk.content.length - 1];
      if (chunk.intro.length)
        return chunk.intro[chunk.intro.length - 1];
    } while (chunk = chunk.previous);
    if (this.intro.length)
      return this.intro[this.intro.length - 1];
    return "";
  }
  lastLine() {
    let lineIndex = this.outro.lastIndexOf(n);
    if (lineIndex !== -1)
      return this.outro.substr(lineIndex + 1);
    let lineStr = this.outro;
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length > 0) {
        lineIndex = chunk.outro.lastIndexOf(n);
        if (lineIndex !== -1)
          return chunk.outro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.outro + lineStr;
      }
      if (chunk.content.length > 0) {
        lineIndex = chunk.content.lastIndexOf(n);
        if (lineIndex !== -1)
          return chunk.content.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.content + lineStr;
      }
      if (chunk.intro.length > 0) {
        lineIndex = chunk.intro.lastIndexOf(n);
        if (lineIndex !== -1)
          return chunk.intro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.intro + lineStr;
      }
    } while (chunk = chunk.previous);
    lineIndex = this.intro.lastIndexOf(n);
    if (lineIndex !== -1)
      return this.intro.substr(lineIndex + 1) + lineStr;
    return this.intro + lineStr;
  }
  slice(start = 0, end = this.original.length) {
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    let result = "";
    let chunk = this.firstChunk;
    while (chunk && (chunk.start > start || chunk.end <= start)) {
      if (chunk.start < end && chunk.end >= end) {
        return result;
      }
      chunk = chunk.next;
    }
    if (chunk && chunk.edited && chunk.start !== start)
      throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);
    const startChunk = chunk;
    while (chunk) {
      if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
        result += chunk.intro;
      }
      const containsEnd = chunk.start < end && chunk.end >= end;
      if (containsEnd && chunk.edited && chunk.end !== end)
        throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);
      const sliceStart = startChunk === chunk ? start - chunk.start : 0;
      const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
      result += chunk.content.slice(sliceStart, sliceEnd);
      if (chunk.outro && (!containsEnd || chunk.end === end)) {
        result += chunk.outro;
      }
      if (containsEnd) {
        break;
      }
      chunk = chunk.next;
    }
    return result;
  }
  snip(start, end) {
    const clone = this.clone();
    clone.remove(0, start);
    clone.remove(end, clone.original.length);
    return clone;
  }
  _split(index2) {
    if (this.byStart[index2] || this.byEnd[index2])
      return;
    let chunk = this.lastSearchedChunk;
    const searchForward = index2 > chunk.end;
    while (chunk) {
      if (chunk.contains(index2))
        return this._splitChunk(chunk, index2);
      chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
    }
  }
  _splitChunk(chunk, index2) {
    if (chunk.edited && chunk.content.length) {
      const loc = getLocator(this.original)(index2);
      throw new Error(
        `Cannot split a chunk that has already been edited (${loc.line}:${loc.column} \u2013 "${chunk.original}")`
      );
    }
    const newChunk = chunk.split(index2);
    this.byEnd[index2] = chunk;
    this.byStart[index2] = newChunk;
    this.byEnd[newChunk.end] = newChunk;
    if (chunk === this.lastChunk)
      this.lastChunk = newChunk;
    this.lastSearchedChunk = chunk;
    return true;
  }
  toString() {
    let str = this.intro;
    let chunk = this.firstChunk;
    while (chunk) {
      str += chunk.toString();
      chunk = chunk.next;
    }
    return str + this.outro;
  }
  isEmpty() {
    let chunk = this.firstChunk;
    do {
      if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim())
        return false;
    } while (chunk = chunk.next);
    return true;
  }
  length() {
    let chunk = this.firstChunk;
    let length = 0;
    do {
      length += chunk.intro.length + chunk.content.length + chunk.outro.length;
    } while (chunk = chunk.next);
    return length;
  }
  trimLines() {
    return this.trim("[\\r\\n]");
  }
  trim(charType) {
    return this.trimStart(charType).trimEnd(charType);
  }
  trimEndAborted(charType) {
    const rx = new RegExp((charType || "\\s") + "+$");
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length)
      return true;
    let chunk = this.lastChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimEnd(rx);
      if (chunk.end !== end) {
        if (this.lastChunk === chunk) {
          this.lastChunk = chunk.next;
        }
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted)
        return true;
      chunk = chunk.previous;
    } while (chunk);
    return false;
  }
  trimEnd(charType) {
    this.trimEndAborted(charType);
    return this;
  }
  trimStartAborted(charType) {
    const rx = new RegExp("^" + (charType || "\\s") + "+");
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length)
      return true;
    let chunk = this.firstChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimStart(rx);
      if (chunk.end !== end) {
        if (chunk === this.lastChunk)
          this.lastChunk = chunk.next;
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted)
        return true;
      chunk = chunk.next;
    } while (chunk);
    return false;
  }
  trimStart(charType) {
    this.trimStartAborted(charType);
    return this;
  }
  hasChanged() {
    return this.original !== this.toString();
  }
  _replaceRegexp(searchValue, replacement) {
    function getReplacement(match, str) {
      if (typeof replacement === "string") {
        return replacement.replace(/\$(\$|&|\d+)/g, (_, i) => {
          if (i === "$")
            return "$";
          if (i === "&")
            return match[0];
          const num = +i;
          if (num < match.length)
            return match[+i];
          return `$${i}`;
        });
      } else {
        return replacement(...match, match.index, str, match.groups);
      }
    }
    function matchAll2(re, str) {
      let match;
      const matches2 = [];
      while (match = re.exec(str)) {
        matches2.push(match);
      }
      return matches2;
    }
    if (searchValue.global) {
      const matches2 = matchAll2(searchValue, this.original);
      matches2.forEach((match) => {
        if (match.index != null)
          this.overwrite(
            match.index,
            match.index + match[0].length,
            getReplacement(match, this.original)
          );
      });
    } else {
      const match = this.original.match(searchValue);
      if (match && match.index != null)
        this.overwrite(
          match.index,
          match.index + match[0].length,
          getReplacement(match, this.original)
        );
    }
    return this;
  }
  _replaceString(string2, replacement) {
    const { original } = this;
    const index2 = original.indexOf(string2);
    if (index2 !== -1) {
      this.overwrite(index2, index2 + string2.length, replacement);
    }
    return this;
  }
  replace(searchValue, replacement) {
    if (typeof searchValue === "string") {
      return this._replaceString(searchValue, replacement);
    }
    return this._replaceRegexp(searchValue, replacement);
  }
  _replaceAllString(string2, replacement) {
    const { original } = this;
    const stringLength = string2.length;
    for (let index2 = original.indexOf(string2); index2 !== -1; index2 = original.indexOf(string2, index2 + stringLength)) {
      this.overwrite(index2, index2 + stringLength, replacement);
    }
    return this;
  }
  replaceAll(searchValue, replacement) {
    if (typeof searchValue === "string") {
      return this._replaceAllString(searchValue, replacement);
    }
    if (!searchValue.global) {
      throw new TypeError(
        "MagicString.prototype.replaceAll called with a non-global RegExp argument"
      );
    }
    return this._replaceRegexp(searchValue, replacement);
  }
};
function isReference(node2, parent) {
  if (node2.type === "MemberExpression") {
    return !node2.computed && isReference(node2.object, node2);
  }
  if (node2.type === "Identifier") {
    if (!parent)
      return true;
    switch (parent.type) {
      case "MemberExpression":
        return parent.computed || node2 === parent.object;
      case "MethodDefinition":
        return parent.computed;
      case "FieldDefinition":
        return parent.computed || node2 === parent.value;
      case "Property":
        return parent.computed || node2 === parent.value;
      case "ExportSpecifier":
      case "ImportSpecifier":
        return node2 === parent.local;
      case "LabeledStatement":
      case "BreakStatement":
      case "ContinueStatement":
        return false;
      default:
        return true;
    }
  }
  return false;
}
var version$1 = "23.0.2";
var peerDependencies = {
  rollup: "^2.68.0||^3.0.0"
};
function tryParse(parse6, code, id) {
  try {
    return parse6(code, { allowReturnOutsideFunction: true });
  } catch (err) {
    err.message += ` in ${id}`;
    throw err;
  }
}
var firstpassGlobal = /\b(?:require|module|exports|global)\b/;
var firstpassNoGlobal = /\b(?:require|module|exports)\b/;
function hasCjsKeywords(code, ignoreGlobal) {
  const firstpass = ignoreGlobal ? firstpassNoGlobal : firstpassGlobal;
  return firstpass.test(code);
}
function analyzeTopLevelStatements(parse6, code, id) {
  const ast = tryParse(parse6, code, id);
  let isEsModule = false;
  let hasDefaultExport = false;
  let hasNamedExports = false;
  for (const node2 of ast.body) {
    switch (node2.type) {
      case "ExportDefaultDeclaration":
        isEsModule = true;
        hasDefaultExport = true;
        break;
      case "ExportNamedDeclaration":
        isEsModule = true;
        if (node2.declaration) {
          hasNamedExports = true;
        } else {
          for (const specifier of node2.specifiers) {
            if (specifier.exported.name === "default") {
              hasDefaultExport = true;
            } else {
              hasNamedExports = true;
            }
          }
        }
        break;
      case "ExportAllDeclaration":
        isEsModule = true;
        if (node2.exported && node2.exported.name === "default") {
          hasDefaultExport = true;
        } else {
          hasNamedExports = true;
        }
        break;
      case "ImportDeclaration":
        isEsModule = true;
        break;
    }
  }
  return { isEsModule, hasDefaultExport, hasNamedExports, ast };
}
function deconflict(scopes, globals, identifier) {
  let i = 1;
  let deconflicted = makeLegalIdentifier$1(identifier);
  const hasConflicts = () => scopes.some((scope) => scope.contains(deconflicted)) || globals.has(deconflicted);
  while (hasConflicts()) {
    deconflicted = makeLegalIdentifier$1(`${identifier}_${i}`);
    i += 1;
  }
  for (const scope of scopes) {
    scope.declarations[deconflicted] = true;
  }
  return deconflicted;
}
function getName(id) {
  const name = makeLegalIdentifier$1((0, import_path.basename)(id, (0, import_path.extname)(id)));
  if (name !== "index") {
    return name;
  }
  return makeLegalIdentifier$1((0, import_path.basename)((0, import_path.dirname)(id)));
}
function normalizePathSlashes(path4) {
  return path4.replace(/\\/g, "/");
}
var getVirtualPathForDynamicRequirePath = (path4, commonDir) => `/${normalizePathSlashes((0, import_path.relative)(commonDir, path4))}`;
function capitalize(name) {
  return name[0].toUpperCase() + name.slice(1);
}
function getStrictRequiresFilter({ strictRequires }) {
  switch (strictRequires) {
    case true:
      return { strictRequiresFilter: () => true, detectCyclesAndConditional: false };
    case void 0:
    case "auto":
    case "debug":
    case null:
      return { strictRequiresFilter: () => false, detectCyclesAndConditional: true };
    case false:
      return { strictRequiresFilter: () => false, detectCyclesAndConditional: false };
    default:
      if (typeof strictRequires === "string" || Array.isArray(strictRequires)) {
        return {
          strictRequiresFilter: createFilter$2(strictRequires),
          detectCyclesAndConditional: false
        };
      }
      throw new Error('Unexpected value for "strictRequires" option.');
  }
}
function getPackageEntryPoint(dirPath) {
  let entryPoint = "index.js";
  try {
    if ((0, import_fs.existsSync)((0, import_path.join)(dirPath, "package.json"))) {
      entryPoint = JSON.parse((0, import_fs.readFileSync)((0, import_path.join)(dirPath, "package.json"), { encoding: "utf8" })).main || entryPoint;
    }
  } catch (ignored) {
  }
  return entryPoint;
}
function isDirectory(path4) {
  try {
    if ((0, import_fs.statSync)(path4).isDirectory())
      return true;
  } catch (ignored) {
  }
  return false;
}
function getDynamicRequireModules(patterns2, dynamicRequireRoot) {
  const dynamicRequireModules = /* @__PURE__ */ new Map();
  const dirNames = /* @__PURE__ */ new Set();
  for (const pattern2 of !patterns2 || Array.isArray(patterns2) ? patterns2 || [] : [patterns2]) {
    const isNegated = pattern2.startsWith("!");
    const modifyMap = (targetPath, resolvedPath) => isNegated ? dynamicRequireModules.delete(targetPath) : dynamicRequireModules.set(targetPath, resolvedPath);
    for (const path4 of globExports.sync(isNegated ? pattern2.substr(1) : pattern2)) {
      const resolvedPath = (0, import_path.resolve)(path4);
      const requirePath = normalizePathSlashes(resolvedPath);
      if (isDirectory(resolvedPath)) {
        dirNames.add(resolvedPath);
        const modulePath = (0, import_path.resolve)((0, import_path.join)(resolvedPath, getPackageEntryPoint(path4)));
        modifyMap(requirePath, modulePath);
        modifyMap(normalizePathSlashes(modulePath), modulePath);
      } else {
        dirNames.add((0, import_path.dirname)(resolvedPath));
        modifyMap(requirePath, resolvedPath);
      }
    }
  }
  return {
    commonDir: dirNames.size ? commondir([...dirNames, dynamicRequireRoot]) : null,
    dynamicRequireModules
  };
}
var FAILED_REQUIRE_ERROR = `throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');`;
var COMMONJS_REQUIRE_EXPORT = "commonjsRequire";
var CREATE_COMMONJS_REQUIRE_EXPORT = "createCommonjsRequire";
function getDynamicModuleRegistry(isDynamicRequireModulesEnabled, dynamicRequireModules, commonDir, ignoreDynamicRequires) {
  if (!isDynamicRequireModulesEnabled) {
    return `export function ${COMMONJS_REQUIRE_EXPORT}(path) {
	${FAILED_REQUIRE_ERROR}
}`;
  }
  const dynamicModuleImports = [...dynamicRequireModules.values()].map(
    (id, index2) => `import ${id.endsWith(".json") ? `json${index2}` : `{ __require as require${index2} }`} from ${JSON.stringify(id)};`
  ).join("\n");
  const dynamicModuleProps = [...dynamicRequireModules.keys()].map(
    (id, index2) => `		${JSON.stringify(getVirtualPathForDynamicRequirePath(id, commonDir))}: ${id.endsWith(".json") ? `function () { return json${index2}; }` : `require${index2}`}`
  ).join(",\n");
  return `${dynamicModuleImports}

var dynamicModules;

function getDynamicModules() {
	return dynamicModules || (dynamicModules = {
${dynamicModuleProps}
	});
}

export function ${CREATE_COMMONJS_REQUIRE_EXPORT}(originalModuleDir) {
	function handleRequire(path) {
		var resolvedPath = commonjsResolve(path, originalModuleDir);
		if (resolvedPath !== null) {
			return getDynamicModules()[resolvedPath]();
		}
		${ignoreDynamicRequires ? "return require(path);" : FAILED_REQUIRE_ERROR}
	}
	handleRequire.resolve = function (path) {
		var resolvedPath = commonjsResolve(path, originalModuleDir);
		if (resolvedPath !== null) {
			return resolvedPath;
		}
		return require.resolve(path);
	}
	return handleRequire;
}

function commonjsResolve (path, originalModuleDir) {
	var shouldTryNodeModules = isPossibleNodeModulesPath(path);
	path = normalize(path);
	var relPath;
	if (path[0] === '/') {
		originalModuleDir = '';
	}
	var modules = getDynamicModules();
	var checkedExtensions = ['', '.js', '.json'];
	while (true) {
		if (!shouldTryNodeModules) {
			relPath = normalize(originalModuleDir + '/' + path);
		} else {
			relPath = normalize(originalModuleDir + '/node_modules/' + path);
		}

		if (relPath.endsWith('/..')) {
			break; // Travelled too far up, avoid infinite loop
		}

		for (var extensionIndex = 0; extensionIndex < checkedExtensions.length; extensionIndex++) {
			var resolvedPath = relPath + checkedExtensions[extensionIndex];
			if (modules[resolvedPath]) {
				return resolvedPath;
			}
		}
		if (!shouldTryNodeModules) break;
		var nextDir = normalize(originalModuleDir + '/..');
		if (nextDir === originalModuleDir) break;
		originalModuleDir = nextDir;
	}
	return null;
}

function isPossibleNodeModulesPath (modulePath) {
	var c0 = modulePath[0];
	if (c0 === '/' || c0 === '\\\\') return false;
	var c1 = modulePath[1], c2 = modulePath[2];
	if ((c0 === '.' && (!c1 || c1 === '/' || c1 === '\\\\')) ||
		(c0 === '.' && c1 === '.' && (!c2 || c2 === '/' || c2 === '\\\\'))) return false;
	if (c1 === ':' && (c2 === '/' || c2 === '\\\\')) return false;
	return true;
}

function normalize (path) {
	path = path.replace(/\\\\/g, '/');
	var parts = path.split('/');
	var slashed = parts[0] === '';
	for (var i = 1; i < parts.length; i++) {
		if (parts[i] === '.' || parts[i] === '') {
			parts.splice(i--, 1);
		}
	}
	for (var i = 1; i < parts.length; i++) {
		if (parts[i] !== '..') continue;
		if (i > 0 && parts[i - 1] !== '..' && parts[i - 1] !== '.') {
			parts.splice(--i, 2);
			i--;
		}
	}
	path = parts.join('/');
	if (slashed && path[0] !== '/') path = '/' + path;
	else if (path.length === 0) path = '.';
	return path;
}`;
}
var isWrappedId = (id, suffix) => id.endsWith(suffix);
var wrapId$1 = (id, suffix) => `\0${id}${suffix}`;
var unwrapId$1 = (wrappedId, suffix) => wrappedId.slice(1, -suffix.length);
var PROXY_SUFFIX = "?commonjs-proxy";
var WRAPPED_SUFFIX = "?commonjs-wrapped";
var EXTERNAL_SUFFIX = "?commonjs-external";
var EXPORTS_SUFFIX = "?commonjs-exports";
var MODULE_SUFFIX = "?commonjs-module";
var ENTRY_SUFFIX = "?commonjs-entry";
var ES_IMPORT_SUFFIX = "?commonjs-es-import";
var DYNAMIC_MODULES_ID = "\0commonjs-dynamic-modules";
var HELPERS_ID = "\0commonjsHelpers.js";
var IS_WRAPPED_COMMONJS = "withRequireFunction";
var HELPERS = `
export var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

export function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

export function getDefaultExportFromNamespaceIfPresent (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') ? n['default'] : n;
}

export function getDefaultExportFromNamespaceIfNotNamed (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') && Object.keys(n).length === 1 ? n['default'] : n;
}

export function getAugmentedNamespace(n) {
  var f = n.default;
	if (typeof f == "function") {
		var a = function () {
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}
`;
function getHelpersModule() {
  return HELPERS;
}
function getUnknownRequireProxy(id, requireReturnsDefault) {
  if (requireReturnsDefault === true || id.endsWith(".json")) {
    return `export { default } from ${JSON.stringify(id)};`;
  }
  const name = getName(id);
  const exported = requireReturnsDefault === "auto" ? `import { getDefaultExportFromNamespaceIfNotNamed } from "${HELPERS_ID}"; export default /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(${name});` : requireReturnsDefault === "preferred" ? `import { getDefaultExportFromNamespaceIfPresent } from "${HELPERS_ID}"; export default /*@__PURE__*/getDefaultExportFromNamespaceIfPresent(${name});` : !requireReturnsDefault ? `import { getAugmentedNamespace } from "${HELPERS_ID}"; export default /*@__PURE__*/getAugmentedNamespace(${name});` : `export default ${name};`;
  return `import * as ${name} from ${JSON.stringify(id)}; ${exported}`;
}
async function getStaticRequireProxy(id, requireReturnsDefault, loadModule) {
  const name = getName(id);
  const {
    meta: { commonjs: commonjsMeta }
  } = await loadModule({ id });
  if (!commonjsMeta) {
    return getUnknownRequireProxy(id, requireReturnsDefault);
  } else if (commonjsMeta.isCommonJS) {
    return `export { __moduleExports as default } from ${JSON.stringify(id)};`;
  } else if (!requireReturnsDefault) {
    return `import { getAugmentedNamespace } from "${HELPERS_ID}"; import * as ${name} from ${JSON.stringify(
      id
    )}; export default /*@__PURE__*/getAugmentedNamespace(${name});`;
  } else if (requireReturnsDefault !== true && (requireReturnsDefault === "namespace" || !commonjsMeta.hasDefaultExport || requireReturnsDefault === "auto" && commonjsMeta.hasNamedExports)) {
    return `import * as ${name} from ${JSON.stringify(id)}; export default ${name};`;
  }
  return `export { default } from ${JSON.stringify(id)};`;
}
function getEntryProxy(id, defaultIsModuleExports, getModuleInfo) {
  const {
    meta: { commonjs: commonjsMeta },
    hasDefaultExport
  } = getModuleInfo(id);
  if (!commonjsMeta || commonjsMeta.isCommonJS !== IS_WRAPPED_COMMONJS) {
    const stringifiedId = JSON.stringify(id);
    let code = `export * from ${stringifiedId};`;
    if (hasDefaultExport) {
      code += `export { default } from ${stringifiedId};`;
    }
    return code;
  }
  return getEsImportProxy(id, defaultIsModuleExports);
}
function getEsImportProxy(id, defaultIsModuleExports) {
  const name = getName(id);
  const exportsName = `${name}Exports`;
  const requireModule = `require${capitalize(name)}`;
  let code = `import { getDefaultExportFromCjs } from "${HELPERS_ID}";
import { __require as ${requireModule} } from ${JSON.stringify(id)};
var ${exportsName} = ${requireModule}();
export { ${exportsName} as __moduleExports };`;
  if (defaultIsModuleExports) {
    code += `
export { ${exportsName} as default };`;
  } else {
    code += `export default /*@__PURE__*/getDefaultExportFromCjs(${exportsName});`;
  }
  return {
    code,
    syntheticNamedExports: "__moduleExports"
  };
}
function getCandidatesForExtension(resolved, extension2) {
  return [resolved + extension2, `${resolved}${import_path.sep}index${extension2}`];
}
function getCandidates(resolved, extensions2) {
  return extensions2.reduce(
    (paths, extension2) => paths.concat(getCandidatesForExtension(resolved, extension2)),
    [resolved]
  );
}
function resolveExtensions(importee, importer, extensions2) {
  if (importee[0] !== "." || !importer)
    return void 0;
  const resolved = (0, import_path.resolve)((0, import_path.dirname)(importer), importee);
  const candidates = getCandidates(resolved, extensions2);
  for (let i = 0; i < candidates.length; i += 1) {
    try {
      const stats = (0, import_fs.statSync)(candidates[i]);
      if (stats.isFile())
        return { id: candidates[i] };
    } catch (err) {
    }
  }
  return void 0;
}
function getResolveId(extensions2, isPossibleCjsId) {
  const currentlyResolving = /* @__PURE__ */ new Map();
  return {
    currentlyResolving,
    async resolveId(importee, importer, resolveOptions) {
      const customOptions = resolveOptions.custom;
      if (customOptions && customOptions["node-resolve"] && customOptions["node-resolve"].isRequire) {
        return null;
      }
      const currentlyResolvingForParent = currentlyResolving.get(importer);
      if (currentlyResolvingForParent && currentlyResolvingForParent.has(importee)) {
        this.warn({
          code: "THIS_RESOLVE_WITHOUT_OPTIONS",
          message: 'It appears a plugin has implemented a "resolveId" hook that uses "this.resolve" without forwarding the third "options" parameter of "resolveId". This is problematic as it can lead to wrong module resolutions especially for the node-resolve plugin and in certain cases cause early exit errors for the commonjs plugin.\nIn rare cases, this warning can appear if the same file is both imported and required from the same mixed ES/CommonJS module, in which case it can be ignored.',
          url: "https://rollupjs.org/guide/en/#resolveid"
        });
        return null;
      }
      if (isWrappedId(importee, WRAPPED_SUFFIX)) {
        return unwrapId$1(importee, WRAPPED_SUFFIX);
      }
      if (importee.endsWith(ENTRY_SUFFIX) || isWrappedId(importee, MODULE_SUFFIX) || isWrappedId(importee, EXPORTS_SUFFIX) || isWrappedId(importee, PROXY_SUFFIX) || isWrappedId(importee, ES_IMPORT_SUFFIX) || isWrappedId(importee, EXTERNAL_SUFFIX) || importee.startsWith(HELPERS_ID) || importee === DYNAMIC_MODULES_ID) {
        return importee;
      }
      if (importer) {
        if (importer === DYNAMIC_MODULES_ID || isWrappedId(importer, PROXY_SUFFIX) || isWrappedId(importer, ES_IMPORT_SUFFIX) || importer.endsWith(ENTRY_SUFFIX)) {
          return importee;
        }
        if (isWrappedId(importer, EXTERNAL_SUFFIX)) {
          if (!await this.resolve(
            importee,
            importer,
            Object.assign({ skipSelf: true }, resolveOptions)
          )) {
            return null;
          }
          return { id: importee, external: true };
        }
      }
      if (importee.startsWith("\0")) {
        return null;
      }
      const resolved = await this.resolve(
        importee,
        importer,
        Object.assign({ skipSelf: true }, resolveOptions)
      ) || resolveExtensions(importee, importer, extensions2);
      if (!resolved || resolved.external || resolved.id.endsWith(ENTRY_SUFFIX) || isWrappedId(resolved.id, ES_IMPORT_SUFFIX) || !isPossibleCjsId(resolved.id)) {
        return resolved;
      }
      const moduleInfo = await this.load(resolved);
      const {
        meta: { commonjs: commonjsMeta }
      } = moduleInfo;
      if (commonjsMeta) {
        const { isCommonJS } = commonjsMeta;
        if (isCommonJS) {
          if (resolveOptions.isEntry) {
            moduleInfo.moduleSideEffects = true;
            return resolved.id + ENTRY_SUFFIX;
          }
          if (isCommonJS === IS_WRAPPED_COMMONJS) {
            return { id: wrapId$1(resolved.id, ES_IMPORT_SUFFIX), meta: { commonjs: { resolved } } };
          }
        }
      }
      return resolved;
    }
  };
}
function getRequireResolver(extensions2, detectCyclesAndConditional, currentlyResolving) {
  const knownCjsModuleTypes = /* @__PURE__ */ Object.create(null);
  const requiredIds = /* @__PURE__ */ Object.create(null);
  const unconditionallyRequiredIds = /* @__PURE__ */ Object.create(null);
  const dependencies = /* @__PURE__ */ Object.create(null);
  const getDependencies = (id) => dependencies[id] || (dependencies[id] = /* @__PURE__ */ new Set());
  const isCyclic = (id) => {
    const dependenciesToCheck = new Set(getDependencies(id));
    for (const dependency of dependenciesToCheck) {
      if (dependency === id) {
        return true;
      }
      for (const childDependency of getDependencies(dependency)) {
        dependenciesToCheck.add(childDependency);
      }
    }
    return false;
  };
  const fullyAnalyzedModules = /* @__PURE__ */ Object.create(null);
  const getTypeForFullyAnalyzedModule = (id) => {
    const knownType = knownCjsModuleTypes[id];
    if (knownType !== true || !detectCyclesAndConditional || fullyAnalyzedModules[id]) {
      return knownType;
    }
    if (isCyclic(id)) {
      return knownCjsModuleTypes[id] = IS_WRAPPED_COMMONJS;
    }
    return knownType;
  };
  const setInitialParentType = (id, initialCommonJSType) => {
    if (fullyAnalyzedModules[id]) {
      return;
    }
    knownCjsModuleTypes[id] = initialCommonJSType;
    if (detectCyclesAndConditional && knownCjsModuleTypes[id] === true && requiredIds[id] && !unconditionallyRequiredIds[id]) {
      knownCjsModuleTypes[id] = IS_WRAPPED_COMMONJS;
    }
  };
  const analyzeRequiredModule = async (parentId, resolved, isConditional, loadModule) => {
    const childId = resolved.id;
    requiredIds[childId] = true;
    if (!(isConditional || knownCjsModuleTypes[parentId] === IS_WRAPPED_COMMONJS)) {
      unconditionallyRequiredIds[childId] = true;
    }
    getDependencies(parentId).add(childId);
    if (!isCyclic(childId)) {
      await loadModule(resolved);
    }
  };
  const getTypeForImportedModule = async (resolved, loadModule) => {
    if (resolved.id in knownCjsModuleTypes) {
      return knownCjsModuleTypes[resolved.id];
    }
    const {
      meta: { commonjs: commonjs2 }
    } = await loadModule(resolved);
    return commonjs2 && commonjs2.isCommonJS || false;
  };
  return {
    getWrappedIds: () => Object.keys(knownCjsModuleTypes).filter(
      (id) => knownCjsModuleTypes[id] === IS_WRAPPED_COMMONJS
    ),
    isRequiredId: (id) => requiredIds[id],
    async shouldTransformCachedModule({
      id: parentId,
      resolvedSources,
      meta: { commonjs: parentMeta }
    }) {
      if (!(parentMeta && parentMeta.isCommonJS))
        knownCjsModuleTypes[parentId] = false;
      if (isWrappedId(parentId, ES_IMPORT_SUFFIX))
        return false;
      const parentRequires = parentMeta && parentMeta.requires;
      if (parentRequires) {
        setInitialParentType(parentId, parentMeta.initialCommonJSType);
        await Promise.all(
          parentRequires.map(
            ({ resolved, isConditional }) => analyzeRequiredModule(parentId, resolved, isConditional, this.load)
          )
        );
        if (getTypeForFullyAnalyzedModule(parentId) !== parentMeta.isCommonJS) {
          return true;
        }
        for (const {
          resolved: { id }
        } of parentRequires) {
          if (getTypeForFullyAnalyzedModule(id) !== parentMeta.isRequiredCommonJS[id]) {
            return true;
          }
        }
        fullyAnalyzedModules[parentId] = true;
        for (const {
          resolved: { id }
        } of parentRequires) {
          fullyAnalyzedModules[id] = true;
        }
      }
      const parentRequireSet = new Set((parentRequires || []).map(({ resolved: { id } }) => id));
      return (await Promise.all(
        Object.keys(resolvedSources).map((source2) => resolvedSources[source2]).filter(({ id, external }) => !(external || parentRequireSet.has(id))).map(async (resolved) => {
          if (isWrappedId(resolved.id, ES_IMPORT_SUFFIX)) {
            return await getTypeForImportedModule(
              (await this.load({ id: resolved.id })).meta.commonjs.resolved,
              this.load
            ) !== IS_WRAPPED_COMMONJS;
          }
          return await getTypeForImportedModule(resolved, this.load) === IS_WRAPPED_COMMONJS;
        })
      )).some((shouldTransform) => shouldTransform);
    },
    resolveRequireSourcesAndUpdateMeta: (rollupContext) => async (parentId, isParentCommonJS, parentMeta, sources) => {
      parentMeta.initialCommonJSType = isParentCommonJS;
      parentMeta.requires = [];
      parentMeta.isRequiredCommonJS = /* @__PURE__ */ Object.create(null);
      setInitialParentType(parentId, isParentCommonJS);
      const currentlyResolvingForParent = currentlyResolving.get(parentId) || /* @__PURE__ */ new Set();
      currentlyResolving.set(parentId, currentlyResolvingForParent);
      const requireTargets = await Promise.all(
        sources.map(async ({ source: source2, isConditional }) => {
          if (source2.startsWith("\0")) {
            return { id: source2, allowProxy: false };
          }
          currentlyResolvingForParent.add(source2);
          const resolved = await rollupContext.resolve(source2, parentId, {
            custom: { "node-resolve": { isRequire: true } }
          }) || resolveExtensions(source2, parentId, extensions2);
          currentlyResolvingForParent.delete(source2);
          if (!resolved) {
            return { id: wrapId$1(source2, EXTERNAL_SUFFIX), allowProxy: false };
          }
          const childId = resolved.id;
          if (resolved.external) {
            return { id: wrapId$1(childId, EXTERNAL_SUFFIX), allowProxy: false };
          }
          parentMeta.requires.push({ resolved, isConditional });
          await analyzeRequiredModule(parentId, resolved, isConditional, rollupContext.load);
          return { id: childId, allowProxy: true };
        })
      );
      parentMeta.isCommonJS = getTypeForFullyAnalyzedModule(parentId);
      fullyAnalyzedModules[parentId] = true;
      return requireTargets.map(({ id: dependencyId, allowProxy }, index2) => {
        const isCommonJS = parentMeta.isRequiredCommonJS[dependencyId] = getTypeForFullyAnalyzedModule(dependencyId);
        fullyAnalyzedModules[dependencyId] = true;
        return {
          source: sources[index2].source,
          id: allowProxy ? isCommonJS === IS_WRAPPED_COMMONJS ? wrapId$1(dependencyId, WRAPPED_SUFFIX) : wrapId$1(dependencyId, PROXY_SUFFIX) : dependencyId,
          isCommonJS
        };
      });
    },
    isCurrentlyResolving(source2, parentId) {
      const currentlyResolvingForParent = currentlyResolving.get(parentId);
      return currentlyResolvingForParent && currentlyResolvingForParent.has(source2);
    }
  };
}
function validateVersion(actualVersion, peerDependencyVersion, name) {
  const versionRegexp = /\^(\d+\.\d+\.\d+)/g;
  let minMajor = Infinity;
  let minMinor = Infinity;
  let minPatch = Infinity;
  let foundVersion;
  while (foundVersion = versionRegexp.exec(peerDependencyVersion)) {
    const [foundMajor, foundMinor, foundPatch] = foundVersion[1].split(".").map(Number);
    if (foundMajor < minMajor) {
      minMajor = foundMajor;
      minMinor = foundMinor;
      minPatch = foundPatch;
    }
  }
  if (!actualVersion) {
    throw new Error(
      `Insufficient ${name} version: "@rollup/plugin-commonjs" requires at least ${name}@${minMajor}.${minMinor}.${minPatch}.`
    );
  }
  const [major, minor, patch] = actualVersion.split(".").map(Number);
  if (major < minMajor || major === minMajor && (minor < minMinor || minor === minMinor && patch < minPatch)) {
    throw new Error(
      `Insufficient ${name} version: "@rollup/plugin-commonjs" requires at least ${name}@${minMajor}.${minMinor}.${minPatch} but found ${name}@${actualVersion}.`
    );
  }
}
var operators = {
  "==": (x) => equals(x.left, x.right, false),
  "!=": (x) => not(operators["=="](x)),
  "===": (x) => equals(x.left, x.right, true),
  "!==": (x) => not(operators["==="](x)),
  "!": (x) => isFalsy(x.argument),
  "&&": (x) => isTruthy(x.left) && isTruthy(x.right),
  "||": (x) => isTruthy(x.left) || isTruthy(x.right)
};
function not(value2) {
  return value2 === null ? value2 : !value2;
}
function equals(a, b, strict) {
  if (a.type !== b.type)
    return null;
  if (a.type === "Literal")
    return strict ? a.value === b.value : a.value == b.value;
  return null;
}
function isTruthy(node2) {
  if (!node2)
    return false;
  if (node2.type === "Literal")
    return !!node2.value;
  if (node2.type === "ParenthesizedExpression")
    return isTruthy(node2.expression);
  if (node2.operator in operators)
    return operators[node2.operator](node2);
  return null;
}
function isFalsy(node2) {
  return not(isTruthy(node2));
}
function getKeypath(node2) {
  const parts = [];
  while (node2.type === "MemberExpression") {
    if (node2.computed)
      return null;
    parts.unshift(node2.property.name);
    node2 = node2.object;
  }
  if (node2.type !== "Identifier")
    return null;
  const { name } = node2;
  parts.unshift(name);
  return { name, keypath: parts.join(".") };
}
var KEY_COMPILED_ESM = "__esModule";
function isDefineCompiledEsm(node2) {
  const definedProperty = getDefinePropertyCallName(node2, "exports") || getDefinePropertyCallName(node2, "module.exports");
  if (definedProperty && definedProperty.key === KEY_COMPILED_ESM) {
    return isTruthy(definedProperty.value);
  }
  return false;
}
function getDefinePropertyCallName(node2, targetName) {
  const {
    callee: { object, property }
  } = node2;
  if (!object || object.type !== "Identifier" || object.name !== "Object")
    return;
  if (!property || property.type !== "Identifier" || property.name !== "defineProperty")
    return;
  if (node2.arguments.length !== 3)
    return;
  const targetNames = targetName.split(".");
  const [target, key2, value2] = node2.arguments;
  if (targetNames.length === 1) {
    if (target.type !== "Identifier" || target.name !== targetNames[0]) {
      return;
    }
  }
  if (targetNames.length === 2) {
    if (target.type !== "MemberExpression" || target.object.name !== targetNames[0] || target.property.name !== targetNames[1]) {
      return;
    }
  }
  if (value2.type !== "ObjectExpression" || !value2.properties)
    return;
  const valueProperty = value2.properties.find((p) => p.key && p.key.name === "value");
  if (!valueProperty || !valueProperty.value)
    return;
  return { key: key2.value, value: valueProperty.value };
}
function isShorthandProperty(parent) {
  return parent && parent.type === "Property" && parent.shorthand;
}
function hasDefineEsmProperty(node2) {
  return node2.properties.some((property) => {
    if (property.type === "Property" && property.key.type === "Identifier" && property.key.name === "__esModule" && isTruthy(property.value)) {
      return true;
    }
    return false;
  });
}
function wrapCode(magicString, uses, moduleName, exportsName, indentExclusionRanges) {
  const args = [];
  const passedArgs = [];
  if (uses.module) {
    args.push("module");
    passedArgs.push(moduleName);
  }
  if (uses.exports) {
    args.push("exports");
    passedArgs.push(exportsName);
  }
  magicString.trim().indent("	", { exclude: indentExclusionRanges }).prepend(`(function (${args.join(", ")}) {
`).append(`
} (${passedArgs.join(", ")}));`);
}
function rewriteExportsAndGetExportsBlock(magicString, moduleName, exportsName, wrapped, moduleExportsAssignments, firstTopLevelModuleExportsAssignment, exportsAssignmentsByName, topLevelAssignments, defineCompiledEsmExpressions, deconflictedExportNames, code, HELPERS_NAME, exportMode, detectWrappedDefault, defaultIsModuleExports, usesRequireWrapper, requireName) {
  const exports = [];
  const exportDeclarations = [];
  if (usesRequireWrapper) {
    getExportsWhenUsingRequireWrapper(
      magicString,
      wrapped,
      exportMode,
      exports,
      moduleExportsAssignments,
      exportsAssignmentsByName,
      moduleName,
      exportsName,
      requireName,
      defineCompiledEsmExpressions
    );
  } else if (exportMode === "replace") {
    getExportsForReplacedModuleExports(
      magicString,
      exports,
      exportDeclarations,
      moduleExportsAssignments,
      firstTopLevelModuleExportsAssignment,
      exportsName
    );
  } else {
    exports.push(`${exportsName} as __moduleExports`);
    if (wrapped) {
      getExportsWhenWrapping(
        exportDeclarations,
        exportsName,
        detectWrappedDefault,
        HELPERS_NAME,
        defaultIsModuleExports
      );
    } else {
      getExports(
        magicString,
        exports,
        exportDeclarations,
        moduleExportsAssignments,
        exportsAssignmentsByName,
        deconflictedExportNames,
        topLevelAssignments,
        moduleName,
        exportsName,
        defineCompiledEsmExpressions,
        HELPERS_NAME,
        defaultIsModuleExports
      );
    }
  }
  if (exports.length) {
    exportDeclarations.push(`export { ${exports.join(", ")} };`);
  }
  return `

${exportDeclarations.join("\n")}`;
}
function getExportsWhenUsingRequireWrapper(magicString, wrapped, exportMode, exports, moduleExportsAssignments, exportsAssignmentsByName, moduleName, exportsName, requireName, defineCompiledEsmExpressions) {
  if (!wrapped) {
    if (exportMode === "replace") {
      for (const { left } of moduleExportsAssignments) {
        magicString.overwrite(left.start, left.end, exportsName);
      }
    } else {
      for (const { left } of moduleExportsAssignments) {
        magicString.overwrite(left.start, left.end, `${moduleName}.exports`);
      }
      for (const [exportName, { nodes }] of exportsAssignmentsByName) {
        for (const node2 of nodes) {
          magicString.overwrite(node2.start, node2.left.end, `${exportsName}.${exportName}`);
        }
      }
      for (const expression of defineCompiledEsmExpressions) {
        const moduleExportsExpression = expression.type === "CallExpression" ? expression.arguments[0] : expression.left.object;
        magicString.overwrite(
          moduleExportsExpression.start,
          moduleExportsExpression.end,
          exportsName
        );
      }
    }
  }
  exports.push(`${requireName} as __require`);
}
function getExportsForReplacedModuleExports(magicString, exports, exportDeclarations, moduleExportsAssignments, firstTopLevelModuleExportsAssignment, exportsName) {
  for (const { left } of moduleExportsAssignments) {
    magicString.overwrite(left.start, left.end, exportsName);
  }
  magicString.prependRight(firstTopLevelModuleExportsAssignment.left.start, "var ");
  exports.push(`${exportsName} as __moduleExports`);
  exportDeclarations.push(`export default ${exportsName};`);
}
function getExportsWhenWrapping(exportDeclarations, exportsName, detectWrappedDefault, HELPERS_NAME, defaultIsModuleExports) {
  exportDeclarations.push(
    `export default ${detectWrappedDefault && defaultIsModuleExports === "auto" ? `/*@__PURE__*/${HELPERS_NAME}.getDefaultExportFromCjs(${exportsName})` : defaultIsModuleExports === false ? `${exportsName}.default` : exportsName};`
  );
}
function getExports(magicString, exports, exportDeclarations, moduleExportsAssignments, exportsAssignmentsByName, deconflictedExportNames, topLevelAssignments, moduleName, exportsName, defineCompiledEsmExpressions, HELPERS_NAME, defaultIsModuleExports) {
  let deconflictedDefaultExportName;
  for (const { left } of moduleExportsAssignments) {
    magicString.overwrite(left.start, left.end, `${moduleName}.exports`);
  }
  for (const [exportName, { nodes }] of exportsAssignmentsByName) {
    const deconflicted = deconflictedExportNames[exportName];
    let needsDeclaration = true;
    for (const node2 of nodes) {
      let replacement = `${deconflicted} = ${exportsName}.${exportName}`;
      if (needsDeclaration && topLevelAssignments.has(node2)) {
        replacement = `var ${replacement}`;
        needsDeclaration = false;
      }
      magicString.overwrite(node2.start, node2.left.end, replacement);
    }
    if (needsDeclaration) {
      magicString.prepend(`var ${deconflicted};
`);
    }
    if (exportName === "default") {
      deconflictedDefaultExportName = deconflicted;
    } else {
      exports.push(exportName === deconflicted ? exportName : `${deconflicted} as ${exportName}`);
    }
  }
  let isRestorableCompiledEsm = false;
  for (const expression of defineCompiledEsmExpressions) {
    isRestorableCompiledEsm = true;
    const moduleExportsExpression = expression.type === "CallExpression" ? expression.arguments[0] : expression.left.object;
    magicString.overwrite(moduleExportsExpression.start, moduleExportsExpression.end, exportsName);
  }
  if (!isRestorableCompiledEsm || defaultIsModuleExports === true) {
    exports.push(`${exportsName} as default`);
  } else if (moduleExportsAssignments.length === 0 || defaultIsModuleExports === false) {
    exports.push(`${deconflictedDefaultExportName || exportsName} as default`);
  } else {
    exportDeclarations.push(
      `export default /*@__PURE__*/${HELPERS_NAME}.getDefaultExportFromCjs(${exportsName});`
    );
  }
}
function isRequireExpression(node2, scope) {
  if (!node2)
    return false;
  if (node2.type !== "CallExpression")
    return false;
  if (node2.arguments.length === 0)
    return false;
  return isRequire(node2.callee, scope);
}
function isRequire(node2, scope) {
  return node2.type === "Identifier" && node2.name === "require" && !scope.contains("require") || node2.type === "MemberExpression" && isModuleRequire(node2, scope);
}
function isModuleRequire({ object, property }, scope) {
  return object.type === "Identifier" && object.name === "module" && property.type === "Identifier" && property.name === "require" && !scope.contains("module");
}
function hasDynamicArguments(node2) {
  return node2.arguments.length > 1 || node2.arguments[0].type !== "Literal" && (node2.arguments[0].type !== "TemplateLiteral" || node2.arguments[0].expressions.length > 0);
}
var reservedMethod = { resolve: true, cache: true, main: true };
function isNodeRequirePropertyAccess(parent) {
  return parent && parent.property && reservedMethod[parent.property.name];
}
function getRequireStringArg(node2) {
  return node2.arguments[0].type === "Literal" ? node2.arguments[0].value : node2.arguments[0].quasis[0].value.cooked;
}
function getRequireHandlers() {
  const requireExpressions = [];
  function addRequireExpression(sourceId, node2, scope, usesReturnValue, isInsideTryBlock, isInsideConditional, toBeRemoved) {
    requireExpressions.push({
      sourceId,
      node: node2,
      scope,
      usesReturnValue,
      isInsideTryBlock,
      isInsideConditional,
      toBeRemoved
    });
  }
  async function rewriteRequireExpressionsAndGetImportBlock(magicString, topLevelDeclarations, reassignedNames, helpersName, dynamicRequireName, moduleName, exportsName, id, exportMode, resolveRequireSourcesAndUpdateMeta, needsRequireWrapper, isEsModule, isDynamicRequireModulesEnabled, getIgnoreTryCatchRequireStatementMode, commonjsMeta) {
    const imports = [];
    imports.push(`import * as ${helpersName} from "${HELPERS_ID}";`);
    if (dynamicRequireName) {
      imports.push(
        `import { ${isDynamicRequireModulesEnabled ? CREATE_COMMONJS_REQUIRE_EXPORT : COMMONJS_REQUIRE_EXPORT} as ${dynamicRequireName} } from "${DYNAMIC_MODULES_ID}";`
      );
    }
    if (exportMode === "module") {
      imports.push(
        `import { __module as ${moduleName}, exports as ${exportsName} } from ${JSON.stringify(
          wrapId$1(id, MODULE_SUFFIX)
        )}`
      );
    } else if (exportMode === "exports") {
      imports.push(
        `import { __exports as ${exportsName} } from ${JSON.stringify(wrapId$1(id, EXPORTS_SUFFIX))}`
      );
    }
    const requiresBySource = collectSources(requireExpressions);
    const requireTargets = await resolveRequireSourcesAndUpdateMeta(
      id,
      needsRequireWrapper ? IS_WRAPPED_COMMONJS : !isEsModule,
      commonjsMeta,
      Object.keys(requiresBySource).map((source2) => {
        return {
          source: source2,
          isConditional: requiresBySource[source2].every((require3) => require3.isInsideConditional)
        };
      })
    );
    processRequireExpressions(
      imports,
      requireTargets,
      requiresBySource,
      getIgnoreTryCatchRequireStatementMode,
      magicString
    );
    return imports.length ? `${imports.join("\n")}

` : "";
  }
  return {
    addRequireExpression,
    rewriteRequireExpressionsAndGetImportBlock
  };
}
function collectSources(requireExpressions) {
  const requiresBySource = /* @__PURE__ */ Object.create(null);
  for (const requireExpression of requireExpressions) {
    const { sourceId } = requireExpression;
    if (!requiresBySource[sourceId]) {
      requiresBySource[sourceId] = [];
    }
    const requires = requiresBySource[sourceId];
    requires.push(requireExpression);
  }
  return requiresBySource;
}
function processRequireExpressions(imports, requireTargets, requiresBySource, getIgnoreTryCatchRequireStatementMode, magicString) {
  const generateRequireName = getGenerateRequireName();
  for (const { source: source2, id: resolvedId, isCommonJS } of requireTargets) {
    const requires = requiresBySource[source2];
    const name = generateRequireName(requires);
    let usesRequired = false;
    let needsImport = false;
    for (const { node: node2, usesReturnValue, toBeRemoved, isInsideTryBlock } of requires) {
      const { canConvertRequire, shouldRemoveRequire } = isInsideTryBlock && isWrappedId(resolvedId, EXTERNAL_SUFFIX) ? getIgnoreTryCatchRequireStatementMode(source2) : { canConvertRequire: true, shouldRemoveRequire: false };
      if (shouldRemoveRequire) {
        if (usesReturnValue) {
          magicString.overwrite(node2.start, node2.end, "undefined");
        } else {
          magicString.remove(toBeRemoved.start, toBeRemoved.end);
        }
      } else if (canConvertRequire) {
        needsImport = true;
        if (isCommonJS === IS_WRAPPED_COMMONJS) {
          magicString.overwrite(node2.start, node2.end, `${name}()`);
        } else if (usesReturnValue) {
          usesRequired = true;
          magicString.overwrite(node2.start, node2.end, name);
        } else {
          magicString.remove(toBeRemoved.start, toBeRemoved.end);
        }
      }
    }
    if (needsImport) {
      if (isCommonJS === IS_WRAPPED_COMMONJS) {
        imports.push(`import { __require as ${name} } from ${JSON.stringify(resolvedId)};`);
      } else {
        imports.push(`import ${usesRequired ? `${name} from ` : ""}${JSON.stringify(resolvedId)};`);
      }
    }
  }
}
function getGenerateRequireName() {
  let uid = 0;
  return (requires) => {
    let name;
    const hasNameConflict = ({ scope }) => scope.contains(name);
    do {
      name = `require$$${uid}`;
      uid += 1;
    } while (requires.some(hasNameConflict));
    return name;
  };
}
var exportsPattern = /^(?:module\.)?exports(?:\.([a-zA-Z_$][a-zA-Z_$0-9]*))?$/;
var functionType = /^(?:FunctionDeclaration|FunctionExpression|ArrowFunctionExpression)$/;
async function transformCommonjs(parse6, code, id, isEsModule, ignoreGlobal, ignoreRequire, ignoreDynamicRequires, getIgnoreTryCatchRequireStatementMode, sourceMap, isDynamicRequireModulesEnabled, dynamicRequireModules, commonDir, astCache, defaultIsModuleExports, needsRequireWrapper, resolveRequireSourcesAndUpdateMeta, isRequired, checkDynamicRequire, commonjsMeta) {
  const ast = astCache || tryParse(parse6, code, id);
  const magicString = new MagicString(code);
  const uses = {
    module: false,
    exports: false,
    global: false,
    require: false
  };
  const virtualDynamicRequirePath = isDynamicRequireModulesEnabled && getVirtualPathForDynamicRequirePath((0, import_path.dirname)(id), commonDir);
  let scope = attachScopes(ast, "scope");
  let lexicalDepth = 0;
  let programDepth = 0;
  let currentTryBlockEnd = null;
  let shouldWrap = false;
  let reexports = false;
  const globals = /* @__PURE__ */ new Set();
  let currentConditionalNodeEnd = null;
  const conditionalNodes = /* @__PURE__ */ new Set();
  const { addRequireExpression, rewriteRequireExpressionsAndGetImportBlock } = getRequireHandlers();
  const reassignedNames = /* @__PURE__ */ new Set();
  const topLevelDeclarations = [];
  const skippedNodes = /* @__PURE__ */ new Set();
  const moduleAccessScopes = /* @__PURE__ */ new Set([scope]);
  const exportsAccessScopes = /* @__PURE__ */ new Set([scope]);
  const moduleExportsAssignments = [];
  let firstTopLevelModuleExportsAssignment = null;
  const exportsAssignmentsByName = /* @__PURE__ */ new Map();
  const topLevelAssignments = /* @__PURE__ */ new Set();
  const topLevelDefineCompiledEsmExpressions = [];
  const replacedGlobal = [];
  const replacedDynamicRequires = [];
  const importedVariables = /* @__PURE__ */ new Set();
  const indentExclusionRanges = [];
  walk$3(ast, {
    enter(node2, parent) {
      if (skippedNodes.has(node2)) {
        this.skip();
        return;
      }
      if (currentTryBlockEnd !== null && node2.start > currentTryBlockEnd) {
        currentTryBlockEnd = null;
      }
      if (currentConditionalNodeEnd !== null && node2.start > currentConditionalNodeEnd) {
        currentConditionalNodeEnd = null;
      }
      if (currentConditionalNodeEnd === null && conditionalNodes.has(node2)) {
        currentConditionalNodeEnd = node2.end;
      }
      programDepth += 1;
      if (node2.scope)
        ({ scope } = node2);
      if (functionType.test(node2.type))
        lexicalDepth += 1;
      if (sourceMap) {
        magicString.addSourcemapLocation(node2.start);
        magicString.addSourcemapLocation(node2.end);
      }
      switch (node2.type) {
        case "AssignmentExpression":
          if (node2.left.type === "MemberExpression") {
            const flattened = getKeypath(node2.left);
            if (!flattened || scope.contains(flattened.name))
              return;
            const exportsPatternMatch = exportsPattern.exec(flattened.keypath);
            if (!exportsPatternMatch || flattened.keypath === "exports")
              return;
            const [, exportName] = exportsPatternMatch;
            uses[flattened.name] = true;
            if (flattened.keypath === "module.exports") {
              moduleExportsAssignments.push(node2);
              if (programDepth > 3) {
                moduleAccessScopes.add(scope);
              } else if (!firstTopLevelModuleExportsAssignment) {
                firstTopLevelModuleExportsAssignment = node2;
              }
              if (defaultIsModuleExports === false) {
                shouldWrap = true;
              } else if (defaultIsModuleExports === "auto") {
                if (node2.right.type === "ObjectExpression") {
                  if (hasDefineEsmProperty(node2.right)) {
                    shouldWrap = true;
                  }
                } else if (isRequireExpression(node2.right, scope)) {
                  shouldWrap = true;
                  reexports = true;
                }
              }
            } else if (exportName === KEY_COMPILED_ESM) {
              if (programDepth > 3) {
                shouldWrap = true;
              } else {
                topLevelDefineCompiledEsmExpressions.push(node2);
              }
            } else {
              const exportsAssignments = exportsAssignmentsByName.get(exportName) || {
                nodes: [],
                scopes: /* @__PURE__ */ new Set()
              };
              exportsAssignments.nodes.push(node2);
              exportsAssignments.scopes.add(scope);
              exportsAccessScopes.add(scope);
              exportsAssignmentsByName.set(exportName, exportsAssignments);
              if (programDepth <= 3) {
                topLevelAssignments.add(node2);
              }
            }
            skippedNodes.add(node2.left);
          } else {
            for (const name of extractAssignedNames(node2.left)) {
              reassignedNames.add(name);
            }
          }
          return;
        case "CallExpression": {
          if (isDefineCompiledEsm(node2)) {
            if (programDepth === 3 && parent.type === "ExpressionStatement") {
              skippedNodes.add(node2.arguments[0]);
              topLevelDefineCompiledEsmExpressions.push(node2);
            } else {
              shouldWrap = true;
            }
            return;
          }
          if (isDynamicRequireModulesEnabled && node2.callee.object && isRequire(node2.callee.object, scope) && node2.callee.property.name === "resolve") {
            checkDynamicRequire(node2.start);
            uses.require = true;
            const requireNode2 = node2.callee.object;
            replacedDynamicRequires.push(requireNode2);
            return;
          }
          if (!isRequireExpression(node2, scope)) {
            const keypath = getKeypath(node2.callee);
            if (keypath && importedVariables.has(keypath.name)) {
              currentConditionalNodeEnd = Infinity;
            }
            return;
          }
          skippedNodes.add(node2.callee);
          uses.require = true;
          if (hasDynamicArguments(node2)) {
            if (isDynamicRequireModulesEnabled) {
              checkDynamicRequire(node2.start);
            }
            if (!ignoreDynamicRequires) {
              replacedDynamicRequires.push(node2.callee);
            }
            return;
          }
          const requireStringArg = getRequireStringArg(node2);
          if (!ignoreRequire(requireStringArg)) {
            const usesReturnValue = parent.type !== "ExpressionStatement";
            const toBeRemoved = parent.type === "ExpressionStatement" && (!currentConditionalNodeEnd || currentTryBlockEnd !== null && currentTryBlockEnd < currentConditionalNodeEnd) ? parent : node2;
            addRequireExpression(
              requireStringArg,
              node2,
              scope,
              usesReturnValue,
              currentTryBlockEnd !== null,
              currentConditionalNodeEnd !== null,
              toBeRemoved
            );
            if (parent.type === "VariableDeclarator" && parent.id.type === "Identifier") {
              for (const name of extractAssignedNames(parent.id)) {
                importedVariables.add(name);
              }
            }
          }
          return;
        }
        case "ConditionalExpression":
        case "IfStatement":
          if (isFalsy(node2.test)) {
            skippedNodes.add(node2.consequent);
          } else if (isTruthy(node2.test)) {
            if (node2.alternate) {
              skippedNodes.add(node2.alternate);
            }
          } else {
            conditionalNodes.add(node2.consequent);
            if (node2.alternate) {
              conditionalNodes.add(node2.alternate);
            }
          }
          return;
        case "ArrowFunctionExpression":
        case "FunctionDeclaration":
        case "FunctionExpression":
          if (currentConditionalNodeEnd === null && !(parent.type === "CallExpression" && parent.callee === node2)) {
            currentConditionalNodeEnd = node2.end;
          }
          return;
        case "Identifier": {
          const { name } = node2;
          if (!isReference(node2, parent) || scope.contains(name))
            return;
          switch (name) {
            case "require":
              uses.require = true;
              if (isNodeRequirePropertyAccess(parent)) {
                return;
              }
              if (!ignoreDynamicRequires) {
                if (isShorthandProperty(parent)) {
                  magicString.prependRight(node2.start, "require: ");
                }
                replacedDynamicRequires.push(node2);
              }
              return;
            case "module":
            case "exports":
              shouldWrap = true;
              uses[name] = true;
              return;
            case "global":
              uses.global = true;
              if (!ignoreGlobal) {
                replacedGlobal.push(node2);
              }
              return;
            case "define":
              magicString.overwrite(node2.start, node2.end, "undefined", {
                storeName: true
              });
              return;
            default:
              globals.add(name);
              return;
          }
        }
        case "LogicalExpression":
          if (node2.operator === "&&") {
            if (isFalsy(node2.left)) {
              skippedNodes.add(node2.right);
            } else if (!isTruthy(node2.left)) {
              conditionalNodes.add(node2.right);
            }
          } else if (node2.operator === "||") {
            if (isTruthy(node2.left)) {
              skippedNodes.add(node2.right);
            } else if (!isFalsy(node2.left)) {
              conditionalNodes.add(node2.right);
            }
          }
          return;
        case "MemberExpression":
          if (!isDynamicRequireModulesEnabled && isModuleRequire(node2, scope)) {
            uses.require = true;
            replacedDynamicRequires.push(node2);
            skippedNodes.add(node2.object);
            skippedNodes.add(node2.property);
          }
          return;
        case "ReturnStatement":
          if (lexicalDepth === 0) {
            shouldWrap = true;
          }
          return;
        case "ThisExpression":
          if (lexicalDepth === 0) {
            uses.global = true;
            if (!ignoreGlobal) {
              replacedGlobal.push(node2);
            }
          }
          return;
        case "TryStatement":
          if (currentTryBlockEnd === null) {
            currentTryBlockEnd = node2.block.end;
          }
          if (currentConditionalNodeEnd === null) {
            currentConditionalNodeEnd = node2.end;
          }
          return;
        case "UnaryExpression":
          if (node2.operator === "typeof") {
            const flattened = getKeypath(node2.argument);
            if (!flattened)
              return;
            if (scope.contains(flattened.name))
              return;
            if (!isEsModule && (flattened.keypath === "module.exports" || flattened.keypath === "module" || flattened.keypath === "exports")) {
              magicString.overwrite(node2.start, node2.end, `'object'`, {
                storeName: false
              });
            }
          }
          return;
        case "VariableDeclaration":
          if (!scope.parent) {
            topLevelDeclarations.push(node2);
          }
          return;
        case "TemplateElement":
          if (node2.value.raw.includes("\n")) {
            indentExclusionRanges.push([node2.start, node2.end]);
          }
      }
    },
    leave(node2) {
      programDepth -= 1;
      if (node2.scope)
        scope = scope.parent;
      if (functionType.test(node2.type))
        lexicalDepth -= 1;
    }
  });
  const nameBase = getName(id);
  const exportsName = deconflict([...exportsAccessScopes], globals, nameBase);
  const moduleName = deconflict([...moduleAccessScopes], globals, `${nameBase}Module`);
  const requireName = deconflict([scope], globals, `require${capitalize(nameBase)}`);
  const isRequiredName = deconflict([scope], globals, `hasRequired${capitalize(nameBase)}`);
  const helpersName = deconflict([scope], globals, "commonjsHelpers");
  const dynamicRequireName = replacedDynamicRequires.length > 0 && deconflict(
    [scope],
    globals,
    isDynamicRequireModulesEnabled ? CREATE_COMMONJS_REQUIRE_EXPORT : COMMONJS_REQUIRE_EXPORT
  );
  const deconflictedExportNames = /* @__PURE__ */ Object.create(null);
  for (const [exportName, { scopes }] of exportsAssignmentsByName) {
    deconflictedExportNames[exportName] = deconflict([...scopes], globals, exportName);
  }
  for (const node2 of replacedGlobal) {
    magicString.overwrite(node2.start, node2.end, `${helpersName}.commonjsGlobal`, {
      storeName: true
    });
  }
  for (const node2 of replacedDynamicRequires) {
    magicString.overwrite(
      node2.start,
      node2.end,
      isDynamicRequireModulesEnabled ? `${dynamicRequireName}(${JSON.stringify(virtualDynamicRequirePath)})` : dynamicRequireName,
      {
        contentOnly: true,
        storeName: true
      }
    );
  }
  shouldWrap = !isEsModule && (shouldWrap || uses.exports && moduleExportsAssignments.length > 0);
  const detectWrappedDefault = shouldWrap && (reexports || topLevelDefineCompiledEsmExpressions.length > 0 || code.indexOf("__esModule") >= 0);
  if (!(shouldWrap || isRequired || needsRequireWrapper || uses.module || uses.exports || uses.require || topLevelDefineCompiledEsmExpressions.length > 0) && (ignoreGlobal || !uses.global)) {
    return { meta: { commonjs: { isCommonJS: false } } };
  }
  let leadingComment = "";
  if (code.startsWith("/*")) {
    const commentEnd = code.indexOf("*/", 2) + 2;
    leadingComment = `${code.slice(0, commentEnd)}
`;
    magicString.remove(0, commentEnd).trim();
  }
  const exportMode = isEsModule ? "none" : shouldWrap ? uses.module ? "module" : "exports" : firstTopLevelModuleExportsAssignment ? exportsAssignmentsByName.size === 0 && topLevelDefineCompiledEsmExpressions.length === 0 ? "replace" : "module" : moduleExportsAssignments.length === 0 ? "exports" : "module";
  const importBlock = await rewriteRequireExpressionsAndGetImportBlock(
    magicString,
    topLevelDeclarations,
    reassignedNames,
    helpersName,
    dynamicRequireName,
    moduleName,
    exportsName,
    id,
    exportMode,
    resolveRequireSourcesAndUpdateMeta,
    needsRequireWrapper,
    isEsModule,
    isDynamicRequireModulesEnabled,
    getIgnoreTryCatchRequireStatementMode,
    commonjsMeta
  );
  const usesRequireWrapper = commonjsMeta.isCommonJS === IS_WRAPPED_COMMONJS;
  const exportBlock = isEsModule ? "" : rewriteExportsAndGetExportsBlock(
    magicString,
    moduleName,
    exportsName,
    shouldWrap,
    moduleExportsAssignments,
    firstTopLevelModuleExportsAssignment,
    exportsAssignmentsByName,
    topLevelAssignments,
    topLevelDefineCompiledEsmExpressions,
    deconflictedExportNames,
    code,
    helpersName,
    exportMode,
    detectWrappedDefault,
    defaultIsModuleExports,
    usesRequireWrapper,
    requireName
  );
  if (shouldWrap) {
    wrapCode(magicString, uses, moduleName, exportsName, indentExclusionRanges);
  }
  if (usesRequireWrapper) {
    magicString.trim().indent("	", {
      exclude: indentExclusionRanges
    });
    magicString.prepend(
      `var ${isRequiredName};

function ${requireName} () {
	if (${isRequiredName}) return ${exportsName};
	${isRequiredName} = 1;
`
    ).append(`
	return ${exportsName};
}`);
    if (exportMode === "replace") {
      magicString.prepend(`var ${exportsName};
`);
    }
  }
  magicString.trim().prepend(leadingComment + importBlock).append(exportBlock);
  return {
    code: magicString.toString(),
    map: sourceMap ? magicString.generateMap() : null,
    syntheticNamedExports: isEsModule || usesRequireWrapper ? false : "__moduleExports",
    meta: { commonjs: commonjsMeta }
  };
}
var PLUGIN_NAME = "commonjs";
function commonjs(options3 = {}) {
  const {
    ignoreGlobal,
    ignoreDynamicRequires,
    requireReturnsDefault: requireReturnsDefaultOption,
    defaultIsModuleExports: defaultIsModuleExportsOption,
    esmExternals
  } = options3;
  const extensions2 = options3.extensions || [".js"];
  const filter2 = createFilter$2(options3.include, options3.exclude);
  const isPossibleCjsId = (id) => {
    const extName = (0, import_path.extname)(id);
    return extName === ".cjs" || extensions2.includes(extName) && filter2(id);
  };
  const { strictRequiresFilter, detectCyclesAndConditional } = getStrictRequiresFilter(options3);
  const getRequireReturnsDefault = typeof requireReturnsDefaultOption === "function" ? requireReturnsDefaultOption : () => requireReturnsDefaultOption;
  let esmExternalIds;
  const isEsmExternal = typeof esmExternals === "function" ? esmExternals : Array.isArray(esmExternals) ? (esmExternalIds = new Set(esmExternals), (id) => esmExternalIds.has(id)) : () => esmExternals;
  const getDefaultIsModuleExports = typeof defaultIsModuleExportsOption === "function" ? defaultIsModuleExportsOption : () => typeof defaultIsModuleExportsOption === "boolean" ? defaultIsModuleExportsOption : "auto";
  const dynamicRequireRoot = typeof options3.dynamicRequireRoot === "string" ? (0, import_path.resolve)(options3.dynamicRequireRoot) : process.cwd();
  const { commonDir, dynamicRequireModules } = getDynamicRequireModules(
    options3.dynamicRequireTargets,
    dynamicRequireRoot
  );
  const isDynamicRequireModulesEnabled = dynamicRequireModules.size > 0;
  const ignoreRequire = typeof options3.ignore === "function" ? options3.ignore : Array.isArray(options3.ignore) ? (id) => options3.ignore.includes(id) : () => false;
  const getIgnoreTryCatchRequireStatementMode = (id) => {
    const mode2 = typeof options3.ignoreTryCatch === "function" ? options3.ignoreTryCatch(id) : Array.isArray(options3.ignoreTryCatch) ? options3.ignoreTryCatch.includes(id) : typeof options3.ignoreTryCatch !== "undefined" ? options3.ignoreTryCatch : true;
    return {
      canConvertRequire: mode2 !== "remove" && mode2 !== true,
      shouldRemoveRequire: mode2 === "remove"
    };
  };
  const { currentlyResolving, resolveId } = getResolveId(extensions2, isPossibleCjsId);
  const sourceMap = options3.sourceMap !== false;
  let requireResolver;
  function transformAndCheckExports(code, id) {
    const { isEsModule, hasDefaultExport, hasNamedExports, ast } = analyzeTopLevelStatements(
      this.parse,
      code,
      id
    );
    const commonjsMeta = this.getModuleInfo(id).meta.commonjs || {};
    if (hasDefaultExport) {
      commonjsMeta.hasDefaultExport = true;
    }
    if (hasNamedExports) {
      commonjsMeta.hasNamedExports = true;
    }
    if (!dynamicRequireModules.has(normalizePathSlashes(id)) && (!(hasCjsKeywords(code, ignoreGlobal) || requireResolver.isRequiredId(id)) || isEsModule && !options3.transformMixedEsModules)) {
      commonjsMeta.isCommonJS = false;
      return { meta: { commonjs: commonjsMeta } };
    }
    const needsRequireWrapper = !isEsModule && (dynamicRequireModules.has(normalizePathSlashes(id)) || strictRequiresFilter(id));
    const checkDynamicRequire = (position) => {
      if (id.indexOf(dynamicRequireRoot) !== 0) {
        this.error(
          {
            code: "DYNAMIC_REQUIRE_OUTSIDE_ROOT",
            id,
            dynamicRequireRoot,
            message: `"${id}" contains dynamic require statements but it is not within the current dynamicRequireRoot "${dynamicRequireRoot}". You should set dynamicRequireRoot to "${(0, import_path.dirname)(
              id
            )}" or one of its parent directories.`
          },
          position
        );
      }
    };
    return transformCommonjs(
      this.parse,
      code,
      id,
      isEsModule,
      ignoreGlobal || isEsModule,
      ignoreRequire,
      ignoreDynamicRequires && !isDynamicRequireModulesEnabled,
      getIgnoreTryCatchRequireStatementMode,
      sourceMap,
      isDynamicRequireModulesEnabled,
      dynamicRequireModules,
      commonDir,
      ast,
      getDefaultIsModuleExports(id),
      needsRequireWrapper,
      requireResolver.resolveRequireSourcesAndUpdateMeta(this),
      requireResolver.isRequiredId(id),
      checkDynamicRequire,
      commonjsMeta
    );
  }
  return {
    name: PLUGIN_NAME,
    version: version$1,
    options(rawOptions) {
      const plugins2 = Array.isArray(rawOptions.plugins) ? [...rawOptions.plugins] : rawOptions.plugins ? [rawOptions.plugins] : [];
      plugins2.unshift({
        name: "commonjs--resolver",
        resolveId
      });
      return { ...rawOptions, plugins: plugins2 };
    },
    buildStart({ plugins: plugins2 }) {
      validateVersion(this.meta.rollupVersion, peerDependencies.rollup, "rollup");
      const nodeResolve = plugins2.find(({ name }) => name === "node-resolve");
      if (nodeResolve) {
        validateVersion(nodeResolve.version, "^13.0.6", "@rollup/plugin-node-resolve");
      }
      if (options3.namedExports != null) {
        this.warn(
          'The namedExports option from "@rollup/plugin-commonjs" is deprecated. Named exports are now handled automatically.'
        );
      }
      requireResolver = getRequireResolver(
        extensions2,
        detectCyclesAndConditional,
        currentlyResolving
      );
    },
    buildEnd() {
      if (options3.strictRequires === "debug") {
        const wrappedIds = requireResolver.getWrappedIds();
        if (wrappedIds.length) {
          this.warn({
            code: "WRAPPED_IDS",
            ids: wrappedIds,
            message: `The commonjs plugin automatically wrapped the following files:
[
${wrappedIds.map((id) => `	${JSON.stringify((0, import_path.relative)(process.cwd(), id))}`).join(",\n")}
]`
          });
        } else {
          this.warn({
            code: "WRAPPED_IDS",
            ids: wrappedIds,
            message: "The commonjs plugin did not wrap any files."
          });
        }
      }
    },
    load(id) {
      if (id === HELPERS_ID) {
        return getHelpersModule();
      }
      if (isWrappedId(id, MODULE_SUFFIX)) {
        const name = getName(unwrapId$1(id, MODULE_SUFFIX));
        return {
          code: `var ${name} = {exports: {}}; export {${name} as __module}`,
          syntheticNamedExports: "__module",
          meta: { commonjs: { isCommonJS: false } }
        };
      }
      if (isWrappedId(id, EXPORTS_SUFFIX)) {
        const name = getName(unwrapId$1(id, EXPORTS_SUFFIX));
        return {
          code: `var ${name} = {}; export {${name} as __exports}`,
          meta: { commonjs: { isCommonJS: false } }
        };
      }
      if (isWrappedId(id, EXTERNAL_SUFFIX)) {
        const actualId = unwrapId$1(id, EXTERNAL_SUFFIX);
        return getUnknownRequireProxy(
          actualId,
          isEsmExternal(actualId) ? getRequireReturnsDefault(actualId) : true
        );
      }
      if (id.endsWith(ENTRY_SUFFIX)) {
        const acutalId = id.slice(0, -ENTRY_SUFFIX.length);
        return getEntryProxy(acutalId, getDefaultIsModuleExports(acutalId), this.getModuleInfo);
      }
      if (isWrappedId(id, ES_IMPORT_SUFFIX)) {
        const actualId = unwrapId$1(id, ES_IMPORT_SUFFIX);
        return getEsImportProxy(actualId, getDefaultIsModuleExports(actualId));
      }
      if (id === DYNAMIC_MODULES_ID) {
        return getDynamicModuleRegistry(
          isDynamicRequireModulesEnabled,
          dynamicRequireModules,
          commonDir,
          ignoreDynamicRequires
        );
      }
      if (isWrappedId(id, PROXY_SUFFIX)) {
        const actualId = unwrapId$1(id, PROXY_SUFFIX);
        return getStaticRequireProxy(actualId, getRequireReturnsDefault(actualId), this.load);
      }
      return null;
    },
    shouldTransformCachedModule(...args) {
      return requireResolver.shouldTransformCachedModule.call(this, ...args);
    },
    transform(code, id) {
      if (!isPossibleCjsId(id))
        return null;
      try {
        return transformAndCheckExports.call(this, code, id);
      } catch (err) {
        return this.error(err, err.loc);
      }
    }
  };
}
var comma = ",".charCodeAt(0);
var semicolon = ";".charCodeAt(0);
var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar = new Uint8Array(64);
var charToInt = new Uint8Array(128);
for (let i = 0; i < chars$1.length; i++) {
  const c2 = chars$1.charCodeAt(i);
  intToChar[i] = c2;
  charToInt[c2] = i;
}
var td = typeof TextDecoder !== "undefined" ? new TextDecoder() : typeof Buffer !== "undefined" ? {
  decode(buf) {
    const out2 = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
    return out2.toString();
  }
} : {
  decode(buf) {
    let out2 = "";
    for (let i = 0; i < buf.length; i++) {
      out2 += String.fromCharCode(buf[i]);
    }
    return out2;
  }
};
function decode(mappings) {
  const state = new Int32Array(5);
  const decoded = [];
  let index2 = 0;
  do {
    const semi = indexOf(mappings, index2);
    const line2 = [];
    let sorted = true;
    let lastCol = 0;
    state[0] = 0;
    for (let i = index2; i < semi; i++) {
      let seg;
      i = decodeInteger(mappings, i, state, 0);
      const col = state[0];
      if (col < lastCol)
        sorted = false;
      lastCol = col;
      if (hasMoreVlq(mappings, i, semi)) {
        i = decodeInteger(mappings, i, state, 1);
        i = decodeInteger(mappings, i, state, 2);
        i = decodeInteger(mappings, i, state, 3);
        if (hasMoreVlq(mappings, i, semi)) {
          i = decodeInteger(mappings, i, state, 4);
          seg = [col, state[1], state[2], state[3], state[4]];
        } else {
          seg = [col, state[1], state[2], state[3]];
        }
      } else {
        seg = [col];
      }
      line2.push(seg);
    }
    if (!sorted)
      sort(line2);
    decoded.push(line2);
    index2 = semi + 1;
  } while (index2 <= mappings.length);
  return decoded;
}
function indexOf(mappings, index2) {
  const idx = mappings.indexOf(";", index2);
  return idx === -1 ? mappings.length : idx;
}
function decodeInteger(mappings, pos2, state, j) {
  let value2 = 0;
  let shift = 0;
  let integer = 0;
  do {
    const c2 = mappings.charCodeAt(pos2++);
    integer = charToInt[c2];
    value2 |= (integer & 31) << shift;
    shift += 5;
  } while (integer & 32);
  const shouldNegate = value2 & 1;
  value2 >>>= 1;
  if (shouldNegate) {
    value2 = -2147483648 | -value2;
  }
  state[j] += value2;
  return pos2;
}
function hasMoreVlq(mappings, i, length) {
  if (i >= length)
    return false;
  return mappings.charCodeAt(i) !== comma;
}
function sort(line2) {
  line2.sort(sortComparator$1);
}
function sortComparator$1(a, b) {
  return a[0] - b[0];
}
function encode$1(decoded) {
  const state = new Int32Array(5);
  const bufLength = 1024 * 16;
  const subLength = bufLength - 36;
  const buf = new Uint8Array(bufLength);
  const sub = buf.subarray(0, subLength);
  let pos2 = 0;
  let out2 = "";
  for (let i = 0; i < decoded.length; i++) {
    const line2 = decoded[i];
    if (i > 0) {
      if (pos2 === bufLength) {
        out2 += td.decode(buf);
        pos2 = 0;
      }
      buf[pos2++] = semicolon;
    }
    if (line2.length === 0)
      continue;
    state[0] = 0;
    for (let j = 0; j < line2.length; j++) {
      const segment = line2[j];
      if (pos2 > subLength) {
        out2 += td.decode(sub);
        buf.copyWithin(0, subLength, pos2);
        pos2 -= subLength;
      }
      if (j > 0)
        buf[pos2++] = comma;
      pos2 = encodeInteger(buf, pos2, state, segment, 0);
      if (segment.length === 1)
        continue;
      pos2 = encodeInteger(buf, pos2, state, segment, 1);
      pos2 = encodeInteger(buf, pos2, state, segment, 2);
      pos2 = encodeInteger(buf, pos2, state, segment, 3);
      if (segment.length === 4)
        continue;
      pos2 = encodeInteger(buf, pos2, state, segment, 4);
    }
  }
  return out2 + td.decode(buf.subarray(0, pos2));
}
function encodeInteger(buf, pos2, state, segment, j) {
  const next = segment[j];
  let num = next - state[j];
  state[j] = next;
  num = num < 0 ? -num << 1 | 1 : num << 1;
  do {
    let clamped = num & 31;
    num >>>= 5;
    if (num > 0)
      clamped |= 32;
    buf[pos2++] = intToChar[clamped];
  } while (num > 0);
  return pos2;
}
var schemeRegex = /^[\w+.-]+:\/\//;
var urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
var fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
var UrlType;
(function(UrlType2) {
  UrlType2[UrlType2["Empty"] = 1] = "Empty";
  UrlType2[UrlType2["Hash"] = 2] = "Hash";
  UrlType2[UrlType2["Query"] = 3] = "Query";
  UrlType2[UrlType2["RelativePath"] = 4] = "RelativePath";
  UrlType2[UrlType2["AbsolutePath"] = 5] = "AbsolutePath";
  UrlType2[UrlType2["SchemeRelative"] = 6] = "SchemeRelative";
  UrlType2[UrlType2["Absolute"] = 7] = "Absolute";
})(UrlType || (UrlType = {}));
function isAbsoluteUrl(input) {
  return schemeRegex.test(input);
}
function isSchemeRelativeUrl(input) {
  return input.startsWith("//");
}
function isAbsolutePath(input) {
  return input.startsWith("/");
}
function isFileUrl(input) {
  return input.startsWith("file:");
}
function isRelative(input) {
  return /^[.?#]/.test(input);
}
function parseAbsoluteUrl(input) {
  const match = urlRegex.exec(input);
  return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
}
function parseFileUrl(input) {
  const match = fileRegex.exec(input);
  const path4 = match[2];
  return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path4) ? path4 : "/" + path4, match[3] || "", match[4] || "");
}
function makeUrl(scheme, user, host, port, path4, query, hash) {
  return {
    scheme,
    user,
    host,
    port,
    path: path4,
    query,
    hash,
    type: UrlType.Absolute
  };
}
function parseUrl$2(input) {
  if (isSchemeRelativeUrl(input)) {
    const url3 = parseAbsoluteUrl("http:" + input);
    url3.scheme = "";
    url3.type = UrlType.SchemeRelative;
    return url3;
  }
  if (isAbsolutePath(input)) {
    const url3 = parseAbsoluteUrl("http://foo.com" + input);
    url3.scheme = "";
    url3.host = "";
    url3.type = UrlType.AbsolutePath;
    return url3;
  }
  if (isFileUrl(input))
    return parseFileUrl(input);
  if (isAbsoluteUrl(input))
    return parseAbsoluteUrl(input);
  const url2 = parseAbsoluteUrl("http://foo.com/" + input);
  url2.scheme = "";
  url2.host = "";
  url2.type = input ? input.startsWith("?") ? UrlType.Query : input.startsWith("#") ? UrlType.Hash : UrlType.RelativePath : UrlType.Empty;
  return url2;
}
function stripPathFilename(path4) {
  if (path4.endsWith("/.."))
    return path4;
  const index2 = path4.lastIndexOf("/");
  return path4.slice(0, index2 + 1);
}
function mergePaths(url2, base2) {
  normalizePath$5(base2, base2.type);
  if (url2.path === "/") {
    url2.path = base2.path;
  } else {
    url2.path = stripPathFilename(base2.path) + url2.path;
  }
}
function normalizePath$5(url2, type) {
  const rel = type <= UrlType.RelativePath;
  const pieces = url2.path.split("/");
  let pointer = 1;
  let positive = 0;
  let addTrailingSlash = false;
  for (let i = 1; i < pieces.length; i++) {
    const piece = pieces[i];
    if (!piece) {
      addTrailingSlash = true;
      continue;
    }
    addTrailingSlash = false;
    if (piece === ".")
      continue;
    if (piece === "..") {
      if (positive) {
        addTrailingSlash = true;
        positive--;
        pointer--;
      } else if (rel) {
        pieces[pointer++] = piece;
      }
      continue;
    }
    pieces[pointer++] = piece;
    positive++;
  }
  let path4 = "";
  for (let i = 1; i < pointer; i++) {
    path4 += "/" + pieces[i];
  }
  if (!path4 || addTrailingSlash && !path4.endsWith("/..")) {
    path4 += "/";
  }
  url2.path = path4;
}
function resolve$3(input, base2) {
  if (!input && !base2)
    return "";
  const url2 = parseUrl$2(input);
  let inputType = url2.type;
  if (base2 && inputType !== UrlType.Absolute) {
    const baseUrl = parseUrl$2(base2);
    const baseType = baseUrl.type;
    switch (inputType) {
      case UrlType.Empty:
        url2.hash = baseUrl.hash;
      case UrlType.Hash:
        url2.query = baseUrl.query;
      case UrlType.Query:
      case UrlType.RelativePath:
        mergePaths(url2, baseUrl);
      case UrlType.AbsolutePath:
        url2.user = baseUrl.user;
        url2.host = baseUrl.host;
        url2.port = baseUrl.port;
      case UrlType.SchemeRelative:
        url2.scheme = baseUrl.scheme;
    }
    if (baseType > inputType)
      inputType = baseType;
  }
  normalizePath$5(url2, inputType);
  const queryHash = url2.query + url2.hash;
  switch (inputType) {
    case UrlType.Hash:
    case UrlType.Query:
      return queryHash;
    case UrlType.RelativePath: {
      const path4 = url2.path.slice(1);
      if (!path4)
        return queryHash || ".";
      if (isRelative(base2 || input) && !isRelative(path4)) {
        return "./" + path4 + queryHash;
      }
      return path4 + queryHash;
    }
    case UrlType.AbsolutePath:
      return url2.path + queryHash;
    default:
      return url2.scheme + "//" + url2.user + url2.host + url2.port + url2.path + queryHash;
  }
}
function resolve$2(input, base2) {
  if (base2 && !base2.endsWith("/"))
    base2 += "/";
  return resolve$3(input, base2);
}
function stripFilename(path4) {
  if (!path4)
    return "";
  const index2 = path4.lastIndexOf("/");
  return path4.slice(0, index2 + 1);
}
var COLUMN = 0;
var SOURCES_INDEX = 1;
var SOURCE_LINE = 2;
var SOURCE_COLUMN = 3;
var NAMES_INDEX = 4;
function maybeSort(mappings, owned) {
  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
  if (unsortedIndex === mappings.length)
    return mappings;
  if (!owned)
    mappings = mappings.slice();
  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
    mappings[i] = sortSegments(mappings[i], owned);
  }
  return mappings;
}
function nextUnsortedSegmentLine(mappings, start) {
  for (let i = start; i < mappings.length; i++) {
    if (!isSorted(mappings[i]))
      return i;
  }
  return mappings.length;
}
function isSorted(line2) {
  for (let j = 1; j < line2.length; j++) {
    if (line2[j][COLUMN] < line2[j - 1][COLUMN]) {
      return false;
    }
  }
  return true;
}
function sortSegments(line2, owned) {
  if (!owned)
    line2 = line2.slice();
  return line2.sort(sortComparator);
}
function sortComparator(a, b) {
  return a[COLUMN] - b[COLUMN];
}
var found = false;
function binarySearch(haystack, needle, low, high) {
  while (low <= high) {
    const mid = low + (high - low >> 1);
    const cmp = haystack[mid][COLUMN] - needle;
    if (cmp === 0) {
      found = true;
      return mid;
    }
    if (cmp < 0) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  found = false;
  return low - 1;
}
function upperBound(haystack, needle, index2) {
  for (let i = index2 + 1; i < haystack.length; index2 = i++) {
    if (haystack[i][COLUMN] !== needle)
      break;
  }
  return index2;
}
function lowerBound(haystack, needle, index2) {
  for (let i = index2 - 1; i >= 0; index2 = i--) {
    if (haystack[i][COLUMN] !== needle)
      break;
  }
  return index2;
}
function memoizedState() {
  return {
    lastKey: -1,
    lastNeedle: -1,
    lastIndex: -1
  };
}
function memoizedBinarySearch(haystack, needle, state, key2) {
  const { lastKey, lastNeedle, lastIndex } = state;
  let low = 0;
  let high = haystack.length - 1;
  if (key2 === lastKey) {
    if (needle === lastNeedle) {
      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
      return lastIndex;
    }
    if (needle >= lastNeedle) {
      low = lastIndex === -1 ? 0 : lastIndex;
    } else {
      high = lastIndex;
    }
  }
  state.lastKey = key2;
  state.lastNeedle = needle;
  return state.lastIndex = binarySearch(haystack, needle, low, high);
}
var LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
var COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
var LEAST_UPPER_BOUND = -1;
var GREATEST_LOWER_BOUND = 1;
var decodedMappings;
var traceSegment;
var originalPositionFor$1;
var TraceMap = class {
  constructor(map2, mapUrl) {
    const isString2 = typeof map2 === "string";
    if (!isString2 && map2._decodedMemo)
      return map2;
    const parsed = isString2 ? JSON.parse(map2) : map2;
    const { version: version3, file, names, sourceRoot, sources, sourcesContent } = parsed;
    this.version = version3;
    this.file = file;
    this.names = names;
    this.sourceRoot = sourceRoot;
    this.sources = sources;
    this.sourcesContent = sourcesContent;
    const from = resolve$2(sourceRoot || "", stripFilename(mapUrl));
    this.resolvedSources = sources.map((s) => resolve$2(s || "", from));
    const { mappings } = parsed;
    if (typeof mappings === "string") {
      this._encoded = mappings;
      this._decoded = void 0;
    } else {
      this._encoded = void 0;
      this._decoded = maybeSort(mappings, isString2);
    }
    this._decodedMemo = memoizedState();
    this._bySources = void 0;
    this._bySourceMemos = void 0;
  }
};
(() => {
  decodedMappings = (map2) => {
    return map2._decoded || (map2._decoded = decode(map2._encoded));
  };
  traceSegment = (map2, line2, column2) => {
    const decoded = decodedMappings(map2);
    if (line2 >= decoded.length)
      return null;
    const segments = decoded[line2];
    const index2 = traceSegmentInternal(segments, map2._decodedMemo, line2, column2, GREATEST_LOWER_BOUND);
    return index2 === -1 ? null : segments[index2];
  };
  originalPositionFor$1 = (map2, { line: line2, column: column2, bias }) => {
    line2--;
    if (line2 < 0)
      throw new Error(LINE_GTR_ZERO);
    if (column2 < 0)
      throw new Error(COL_GTR_EQ_ZERO);
    const decoded = decodedMappings(map2);
    if (line2 >= decoded.length)
      return OMapping(null, null, null, null);
    const segments = decoded[line2];
    const index2 = traceSegmentInternal(segments, map2._decodedMemo, line2, column2, bias || GREATEST_LOWER_BOUND);
    if (index2 === -1)
      return OMapping(null, null, null, null);
    const segment = segments[index2];
    if (segment.length === 1)
      return OMapping(null, null, null, null);
    const { names, resolvedSources } = map2;
    return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
  };
})();
function OMapping(source2, line2, column2, name) {
  return { source: source2, line: line2, column: column2, name };
}
function traceSegmentInternal(segments, memo, line2, column2, bias) {
  let index2 = memoizedBinarySearch(segments, column2, memo, line2);
  if (found) {
    index2 = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column2, index2);
  } else if (bias === LEAST_UPPER_BOUND)
    index2++;
  if (index2 === -1 || index2 === segments.length)
    return -1;
  return index2;
}
var get;
var put;
var SetArray = class {
  constructor() {
    this._indexes = { __proto__: null };
    this.array = [];
  }
};
(() => {
  get = (strarr, key2) => strarr._indexes[key2];
  put = (strarr, key2) => {
    const index2 = get(strarr, key2);
    if (index2 !== void 0)
      return index2;
    const { array: array2, _indexes: indexes } = strarr;
    return indexes[key2] = array2.push(key2) - 1;
  };
})();
var addSegment;
var setSourceContent;
var decodedMap;
var encodedMap;
var GenMapping = class {
  constructor({ file, sourceRoot } = {}) {
    this._names = new SetArray();
    this._sources = new SetArray();
    this._sourcesContent = [];
    this._mappings = [];
    this.file = file;
    this.sourceRoot = sourceRoot;
  }
};
(() => {
  addSegment = (map2, genLine, genColumn, source2, sourceLine, sourceColumn, name) => {
    const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map2;
    const line2 = getLine(mappings, genLine);
    if (source2 == null) {
      const seg2 = [genColumn];
      const index3 = getColumnIndex(line2, genColumn, seg2);
      return insert(line2, index3, seg2);
    }
    const sourcesIndex = put(sources, source2);
    const seg = name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, put(names, name)] : [genColumn, sourcesIndex, sourceLine, sourceColumn];
    const index2 = getColumnIndex(line2, genColumn, seg);
    if (sourcesIndex === sourcesContent.length)
      sourcesContent[sourcesIndex] = null;
    insert(line2, index2, seg);
  };
  setSourceContent = (map2, source2, content) => {
    const { _sources: sources, _sourcesContent: sourcesContent } = map2;
    sourcesContent[put(sources, source2)] = content;
  };
  decodedMap = (map2) => {
    const { file, sourceRoot, _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map2;
    return {
      version: 3,
      file,
      names: names.array,
      sourceRoot: sourceRoot || void 0,
      sources: sources.array,
      sourcesContent,
      mappings
    };
  };
  encodedMap = (map2) => {
    const decoded = decodedMap(map2);
    return Object.assign(Object.assign({}, decoded), { mappings: encode$1(decoded.mappings) });
  };
})();
function getLine(mappings, index2) {
  for (let i = mappings.length; i <= index2; i++) {
    mappings[i] = [];
  }
  return mappings[index2];
}
function getColumnIndex(line2, column2, seg) {
  let index2 = line2.length;
  for (let i = index2 - 1; i >= 0; i--, index2--) {
    const current2 = line2[i];
    const col = current2[0];
    if (col > column2)
      continue;
    if (col < column2)
      break;
    const cmp = compare$1(current2, seg);
    if (cmp === 0)
      return index2;
    if (cmp < 0)
      break;
  }
  return index2;
}
function compare$1(a, b) {
  let cmp = compareNum(a.length, b.length);
  if (cmp !== 0)
    return cmp;
  if (a.length === 1)
    return 0;
  cmp = compareNum(a[1], b[1]);
  if (cmp !== 0)
    return cmp;
  cmp = compareNum(a[2], b[2]);
  if (cmp !== 0)
    return cmp;
  cmp = compareNum(a[3], b[3]);
  if (cmp !== 0)
    return cmp;
  if (a.length === 4)
    return 0;
  return compareNum(a[4], b[4]);
}
function compareNum(a, b) {
  return a - b;
}
function insert(array2, index2, value2) {
  if (index2 === -1)
    return;
  for (let i = array2.length; i > index2; i--) {
    array2[i] = array2[i - 1];
  }
  array2[index2] = value2;
}
var SOURCELESS_MAPPING = {
  source: null,
  column: null,
  line: null,
  name: null,
  content: null
};
var EMPTY_SOURCES = [];
function Source(map2, sources, source2, content) {
  return {
    map: map2,
    sources,
    source: source2,
    content
  };
}
function MapSource(map2, sources) {
  return Source(map2, sources, "", null);
}
function OriginalSource(source2, content) {
  return Source(null, EMPTY_SOURCES, source2, content);
}
function traceMappings(tree) {
  const gen = new GenMapping({ file: tree.map.file });
  const { sources: rootSources, map: map2 } = tree;
  const rootNames = map2.names;
  const rootMappings = decodedMappings(map2);
  for (let i = 0; i < rootMappings.length; i++) {
    const segments = rootMappings[i];
    let lastSource = null;
    let lastSourceLine = null;
    let lastSourceColumn = null;
    for (let j = 0; j < segments.length; j++) {
      const segment = segments[j];
      const genCol = segment[0];
      let traced = SOURCELESS_MAPPING;
      if (segment.length !== 1) {
        const source3 = rootSources[segment[1]];
        traced = originalPositionFor(source3, segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : "");
        if (traced == null)
          continue;
      }
      const { column: column2, line: line2, name, content, source: source2 } = traced;
      if (line2 === lastSourceLine && column2 === lastSourceColumn && source2 === lastSource) {
        continue;
      }
      lastSourceLine = line2;
      lastSourceColumn = column2;
      lastSource = source2;
      addSegment(gen, i, genCol, source2, line2, column2, name);
      if (content != null)
        setSourceContent(gen, source2, content);
    }
  }
  return gen;
}
function originalPositionFor(source2, line2, column2, name) {
  if (!source2.map) {
    return { column: column2, line: line2, name, source: source2.source, content: source2.content };
  }
  const segment = traceSegment(source2.map, line2, column2);
  if (segment == null)
    return null;
  if (segment.length === 1)
    return SOURCELESS_MAPPING;
  return originalPositionFor(source2.sources[segment[1]], segment[2], segment[3], segment.length === 5 ? source2.map.names[segment[4]] : name);
}
function asArray(value2) {
  if (Array.isArray(value2))
    return value2;
  return [value2];
}
function buildSourceMapTree(input, loader) {
  const maps = asArray(input).map((m) => new TraceMap(m, ""));
  const map2 = maps.pop();
  for (let i = 0; i < maps.length; i++) {
    if (maps[i].sources.length > 1) {
      throw new Error(`Transformation map ${i} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
    }
  }
  let tree = build$2(map2, loader, "", 0);
  for (let i = maps.length - 1; i >= 0; i--) {
    tree = MapSource(maps[i], [tree]);
  }
  return tree;
}
function build$2(map2, loader, importer, importerDepth) {
  const { resolvedSources, sourcesContent } = map2;
  const depth2 = importerDepth + 1;
  const children = resolvedSources.map((sourceFile, i) => {
    const ctx2 = {
      importer,
      depth: depth2,
      source: sourceFile || "",
      content: void 0
    };
    const sourceMap = loader(ctx2.source, ctx2);
    const { source: source2, content } = ctx2;
    if (sourceMap)
      return build$2(new TraceMap(sourceMap, source2), loader, source2, depth2);
    const sourceContent = content !== void 0 ? content : sourcesContent ? sourcesContent[i] : null;
    return OriginalSource(source2, sourceContent);
  });
  return MapSource(map2, children);
}
var SourceMap = class {
  constructor(map2, options3) {
    const out2 = options3.decodedMappings ? decodedMap(map2) : encodedMap(map2);
    this.version = out2.version;
    this.file = out2.file;
    this.mappings = out2.mappings;
    this.names = out2.names;
    this.sourceRoot = out2.sourceRoot;
    this.sources = out2.sources;
    if (!options3.excludeContent) {
      this.sourcesContent = out2.sourcesContent;
    }
  }
  toString() {
    return JSON.stringify(this);
  }
};
function remapping(input, loader, options3) {
  const opts = typeof options3 === "object" ? options3 : { excludeContent: !!options3, decodedMappings: false };
  const tree = buildSourceMapTree(input, loader);
  return new SourceMap(traceMappings(tree), opts);
}
var src$2 = { exports: {} };
var browser$2 = { exports: {} };
var ms$1;
var hasRequiredMs$1;
function requireMs$1() {
  if (hasRequiredMs$1)
    return ms$1;
  hasRequiredMs$1 = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms$1 = function(val, options3) {
    options3 = options3 || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse6(val);
    } else if (type === "number" && isFinite(val)) {
      return options3.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse6(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n2 = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n2 * y;
      case "weeks":
      case "week":
      case "w":
        return n2 * w;
      case "days":
      case "day":
      case "d":
        return n2 * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n2 * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n2 * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n2 * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n2;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n2, name) {
    var isPlural = msAbs >= n2 * 1.5;
    return Math.round(ms2 / n2) + " " + name + (isPlural ? "s" : "");
  }
  return ms$1;
}
var common$b;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon)
    return common$b;
  hasRequiredCommon = 1;
  function setup(env2) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs$1();
    createDebug.destroy = destroy;
    Object.keys(env2).forEach((key2) => {
      createDebug[key2] = env2[key2];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return "%";
          }
          index2++;
          const formatter2 = createDebug.formatters[format2];
          if (typeof formatter2 === "function") {
            const val = args[index2];
            match = formatter2.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace);
      debug2.extend = extend2;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend2(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common$b = setup;
  return common$b;
}
var hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1)
    return browser$2.exports;
  hasRequiredBrowser$1 = 1;
  (function(module2, exports) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load2;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned2 = false;
      return () => {
        if (!warned2) {
          warned2 = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c2);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load2() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error2) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module2.exports = requireCommon()(exports);
    const { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  })(browser$2, browser$2.exports);
  return browser$2.exports;
}
var node$1 = { exports: {} };
var hasRequiredNode$1;
function requireNode$1() {
  if (hasRequiredNode$1)
    return node$1.exports;
  hasRequiredNode$1 = 1;
  (function(module2, exports) {
    const tty2 = import_tty.default;
    const util2 = import_util.default;
    exports.init = init2;
    exports.log = log2;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load2;
    exports.useColors = useColors;
    exports.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require2("supports-color");
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error2) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key2) => {
      return /^debug_/i.test(key2);
    }).reduce((obj, key2) => {
      const prop = key2.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key2];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty2.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c2 = this.color;
        const colorCode = "\x1B[3" + (c2 < 8 ? c2 : "8;5;" + c2);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log2(...args) {
      return process.stderr.write(util2.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function init2(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug2.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module2.exports = requireCommon()(exports);
    const { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  })(node$1, node$1.exports);
  return node$1.exports;
}
(function(module2) {
  if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
    module2.exports = requireBrowser$1();
  } else {
    module2.exports = requireNode$1();
  }
})(src$2);
var _debug = getDefaultExportFromCjs(src$2.exports);
function isArray$1(arg) {
  return Array.isArray(arg);
}
function ensureArray(thing) {
  if (isArray$1(thing))
    return thing;
  if (thing == null)
    return [];
  return [thing];
}
var normalizePath$4 = function normalizePath2(filename) {
  return filename.split(import_path.win32.sep).join(import_path.posix.sep);
};
function getMatcherString(id, resolutionBase) {
  if (resolutionBase === false || (0, import_path.isAbsolute)(id) || id.startsWith("*")) {
    return normalizePath$4(id);
  }
  const basePath = normalizePath$4((0, import_path.resolve)(resolutionBase || "")).replace(/[-^$*+?.()|[\]{}]/g, "\\$&");
  return import_path.posix.join(basePath, normalizePath$4(id));
}
var createFilter$1 = function createFilter2(include, exclude, options3) {
  const resolutionBase = options3 && options3.resolve;
  const getMatcher = (id) => id instanceof RegExp ? id : {
    test: (what) => {
      const pattern2 = getMatcherString(id, resolutionBase);
      const fn = picomatch$3(pattern2, { dot: true });
      const result = fn(what);
      return result;
    }
  };
  const includeMatchers = ensureArray(include).map(getMatcher);
  const excludeMatchers = ensureArray(exclude).map(getMatcher);
  return function result(id) {
    if (typeof id !== "string")
      return false;
    if (/\0/.test(id))
      return false;
    const pathId = normalizePath$4(id);
    for (let i = 0; i < excludeMatchers.length; ++i) {
      const matcher2 = excludeMatchers[i];
      if (matcher2.test(pathId))
        return false;
    }
    for (let i = 0; i < includeMatchers.length; ++i) {
      const matcher2 = includeMatchers[i];
      if (matcher2.test(pathId))
        return true;
    }
    return !includeMatchers.length;
  };
};
var reservedWords$1 = "break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public";
var builtins$1 = "arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl";
var forbiddenIdentifiers = new Set(`${reservedWords$1} ${builtins$1}`.split(" "));
forbiddenIdentifiers.add("");
var makeLegalIdentifier2 = function makeLegalIdentifier3(str) {
  let identifier = str.replace(/-(\w)/g, (_, letter) => letter.toUpperCase()).replace(/[^$_a-zA-Z0-9]/g, "_");
  if (/\d/.test(identifier[0]) || forbiddenIdentifiers.has(identifier)) {
    identifier = `_${identifier}`;
  }
  return identifier || "_";
};
function stringify$9(obj) {
  return (JSON.stringify(obj) || "undefined").replace(/[\u2028\u2029]/g, (char) => `\\u${`000${char.charCodeAt(0).toString(16)}`.slice(-4)}`);
}
function serializeArray(arr, indent, baseIndent) {
  let output = "[";
  const separator = indent ? `
${baseIndent}${indent}` : "";
  for (let i = 0; i < arr.length; i++) {
    const key2 = arr[i];
    output += `${i > 0 ? "," : ""}${separator}${serialize(key2, indent, baseIndent + indent)}`;
  }
  return `${output}${indent ? `
${baseIndent}` : ""}]`;
}
function serializeObject(obj, indent, baseIndent) {
  let output = "{";
  const separator = indent ? `
${baseIndent}${indent}` : "";
  const entries = Object.entries(obj);
  for (let i = 0; i < entries.length; i++) {
    const [key2, value2] = entries[i];
    const stringKey = makeLegalIdentifier2(key2) === key2 ? key2 : stringify$9(key2);
    output += `${i > 0 ? "," : ""}${separator}${stringKey}:${indent ? " " : ""}${serialize(value2, indent, baseIndent + indent)}`;
  }
  return `${output}${indent ? `
${baseIndent}` : ""}}`;
}
function serialize(obj, indent, baseIndent) {
  if (typeof obj === "object" && obj !== null) {
    if (Array.isArray(obj))
      return serializeArray(obj, indent, baseIndent);
    if (obj instanceof Date)
      return `new Date(${obj.getTime()})`;
    if (obj instanceof RegExp)
      return obj.toString();
    return serializeObject(obj, indent, baseIndent);
  }
  if (typeof obj === "number") {
    if (obj === Infinity)
      return "Infinity";
    if (obj === -Infinity)
      return "-Infinity";
    if (obj === 0)
      return 1 / obj === Infinity ? "0" : "-0";
    if (obj !== obj)
      return "NaN";
  }
  if (typeof obj === "symbol") {
    const key2 = Symbol.keyFor(obj);
    if (key2 !== void 0)
      return `Symbol.for(${stringify$9(key2)})`;
  }
  if (typeof obj === "bigint")
    return `${obj}n`;
  return stringify$9(obj);
}
var dataToEsm = function dataToEsm2(data2, options3 = {}) {
  const t = options3.compact ? "" : "indent" in options3 ? options3.indent : "	";
  const _ = options3.compact ? "" : " ";
  const n2 = options3.compact ? "" : "\n";
  const declarationType = options3.preferConst ? "const" : "var";
  if (options3.namedExports === false || typeof data2 !== "object" || Array.isArray(data2) || data2 instanceof Date || data2 instanceof RegExp || data2 === null) {
    const code = serialize(data2, options3.compact ? null : t, "");
    const magic = _ || (/^[{[\-\/]/.test(code) ? "" : " ");
    return `export default${magic}${code};`;
  }
  let namedExportCode = "";
  const defaultExportRows = [];
  for (const [key2, value2] of Object.entries(data2)) {
    if (key2 === makeLegalIdentifier2(key2)) {
      if (options3.objectShorthand)
        defaultExportRows.push(key2);
      else
        defaultExportRows.push(`${key2}:${_}${key2}`);
      namedExportCode += `export ${declarationType} ${key2}${_}=${_}${serialize(value2, options3.compact ? null : t, "")};${n2}`;
    } else {
      defaultExportRows.push(`${stringify$9(key2)}:${_}${serialize(value2, options3.compact ? null : t, "")}`);
    }
  }
  return `${namedExportCode}export default${_}{${n2}${t}${defaultExportRows.join(`,${n2}${t}`)}${n2}};${n2}`;
};
var createFilter3 = createFilter$1;
function slash$1(p) {
  return p.replace(/\\/g, "/");
}
function wrapId(id) {
  return id.startsWith(VALID_ID_PREFIX) ? id : VALID_ID_PREFIX + id.replace("\0", NULL_BYTE_PLACEHOLDER);
}
function unwrapId(id) {
  return id.startsWith(VALID_ID_PREFIX) ? id.slice(VALID_ID_PREFIX.length).replace(NULL_BYTE_PLACEHOLDER, "\0") : id;
}
var flattenId = (id) => id.replace(/[\/:]/g, "_").replace(/[\.]/g, "__").replace(/(\s*>\s*)/g, "___");
var normalizeId = (id) => id.replace(/(\s*>\s*)/g, " > ");
var builtins = /* @__PURE__ */ new Set([
  ...import_node_module.builtinModules,
  "assert/strict",
  "diagnostics_channel",
  "dns/promises",
  "fs/promises",
  "path/posix",
  "path/win32",
  "readline/promises",
  "stream/consumers",
  "stream/promises",
  "stream/web",
  "timers/promises",
  "util/types",
  "wasi"
]);
function isBuiltin(id) {
  return builtins.has(id.replace(/^node:/, ""));
}
function moduleListContains(moduleList, id) {
  return moduleList == null ? void 0 : moduleList.some((m) => m === id || id.startsWith(m + "/"));
}
function isOptimizable(id, optimizeDeps2) {
  var _a;
  const { extensions: extensions2 } = optimizeDeps2;
  return OPTIMIZABLE_ENTRY_RE.test(id) || ((_a = extensions2 == null ? void 0 : extensions2.some((ext2) => id.endsWith(ext2))) != null ? _a : false);
}
var bareImportRE = /^[\w@](?!.*:\/\/)/;
var isRunningWithYarnPnp;
var _require$4 = (0, import_node_module.createRequire)(import.meta.url);
try {
  isRunningWithYarnPnp = Boolean(_require$4("pnpapi"));
} catch {
}
var ssrExtensions = [".js", ".cjs", ".json", ".node"];
function resolveFrom(id, basedir, preserveSymlinks = false, ssr = false) {
  return import_resolve.default.sync(id, {
    basedir,
    paths: [],
    extensions: ssr ? ssrExtensions : DEFAULT_EXTENSIONS,
    preserveSymlinks: preserveSymlinks || isRunningWithYarnPnp || false
  });
}
function nestedResolveFrom(id, basedir, preserveSymlinks = false) {
  const pkgs = id.split(">").map((pkg) => pkg.trim());
  try {
    for (const pkg of pkgs) {
      basedir = resolveFrom(pkg, basedir, preserveSymlinks);
    }
  } catch {
  }
  return basedir;
}
var filter = process.env.VITE_DEBUG_FILTER;
var DEBUG = process.env.DEBUG;
function createDebugger(namespace, options3 = {}) {
  const log2 = _debug(namespace);
  const { onlyWhenFocused } = options3;
  const focus = typeof onlyWhenFocused === "string" ? onlyWhenFocused : namespace;
  return (msg, ...args) => {
    if (filter && !msg.includes(filter)) {
      return;
    }
    if (onlyWhenFocused && !(DEBUG == null ? void 0 : DEBUG.includes(focus))) {
      return;
    }
    log2(msg, ...args);
  };
}
function testCaseInsensitiveFS() {
  if (!CLIENT_ENTRY.endsWith("client.mjs")) {
    throw new Error(`cannot test case insensitive FS, CLIENT_ENTRY const doesn't contain client.mjs`);
  }
  if (!import_node_fs.default.existsSync(CLIENT_ENTRY)) {
    throw new Error("cannot test case insensitive FS, CLIENT_ENTRY does not point to an existing file: " + CLIENT_ENTRY);
  }
  return import_node_fs.default.existsSync(CLIENT_ENTRY.replace("client.mjs", "cLiEnT.mjs"));
}
var isCaseInsensitiveFS = testCaseInsensitiveFS();
var isWindows$4 = import_node_os.default.platform() === "win32";
var VOLUME_RE = /^[A-Z]:/i;
function normalizePath$3(id) {
  return import_node_path2.default.posix.normalize(isWindows$4 ? slash$1(id) : id);
}
function fsPathFromId(id) {
  const fsPath = normalizePath$3(id.startsWith(FS_PREFIX) ? id.slice(FS_PREFIX.length) : id);
  return fsPath.startsWith("/") || fsPath.match(VOLUME_RE) ? fsPath : `/${fsPath}`;
}
function fsPathFromUrl(url2) {
  return fsPathFromId(cleanUrl(url2));
}
function isParentDirectory(dir, file) {
  if (!dir.endsWith("/")) {
    dir = `${dir}/`;
  }
  return file.startsWith(dir) || isCaseInsensitiveFS && file.toLowerCase().startsWith(dir.toLowerCase());
}
function ensureVolumeInPath(file) {
  return isWindows$4 ? import_node_path2.default.resolve(file) : file;
}
var queryRE = /\?.*$/s;
var hashRE = /#.*$/s;
var cleanUrl = (url2) => url2.replace(hashRE, "").replace(queryRE, "");
var externalRE = /^(https?:)?\/\//;
var isExternalUrl = (url2) => externalRE.test(url2);
var dataUrlRE = /^\s*data:/i;
var isDataUrl = (url2) => dataUrlRE.test(url2);
var virtualModuleRE = /^virtual-module:.*/;
var virtualModulePrefix = "virtual-module:";
var knownJsSrcRE = /\.((j|t)sx?|m[jt]s|vue|marko|svelte|astro|imba)($|\?)/;
var isJSRequest = (url2) => {
  url2 = cleanUrl(url2);
  if (knownJsSrcRE.test(url2)) {
    return true;
  }
  if (!import_node_path2.default.extname(url2) && !url2.endsWith("/")) {
    return true;
  }
  return false;
};
var knownTsRE = /\.(ts|mts|cts|tsx)$/;
var knownTsOutputRE = /\.(js|mjs|cjs|jsx)$/;
var isTsRequest = (url2) => knownTsRE.test(url2);
var isPossibleTsOutput = (url2) => knownTsOutputRE.test(cleanUrl(url2));
function getPotentialTsSrcPaths(filePath) {
  const [name, type, query = ""] = filePath.split(/(\.(?:[cm]?js|jsx))(\?.*)?$/);
  const paths = [name + type.replace("js", "ts") + query];
  if (!type.endsWith("x")) {
    paths.push(name + type.replace("js", "tsx") + query);
  }
  return paths;
}
var importQueryRE = /(\?|&)import=?(?:&|$)/;
var directRequestRE$1 = /(\?|&)direct=?(?:&|$)/;
var internalPrefixes = [
  FS_PREFIX,
  VALID_ID_PREFIX,
  CLIENT_PUBLIC_PATH,
  ENV_PUBLIC_PATH
];
var InternalPrefixRE = new RegExp(`^(?:${internalPrefixes.join("|")})`);
var trailingSeparatorRE = /[\?&]$/;
var isImportRequest = (url2) => importQueryRE.test(url2);
var isInternalRequest = (url2) => InternalPrefixRE.test(url2);
function removeImportQuery(url2) {
  return url2.replace(importQueryRE, "$1").replace(trailingSeparatorRE, "");
}
function removeDirectQuery(url2) {
  return url2.replace(directRequestRE$1, "$1").replace(trailingSeparatorRE, "");
}
function injectQuery(url2, queryToInject) {
  const resolvedUrl = new import_node_url2.URL(url2.replace(/%/g, "%25"), "relative:///");
  const { search, hash } = resolvedUrl;
  let pathname = cleanUrl(url2);
  pathname = isWindows$4 ? slash$1(pathname) : pathname;
  return `${pathname}?${queryToInject}${search ? `&` + search.slice(1) : ""}${hash != null ? hash : ""}`;
}
var timestampRE = /\bt=\d{13}&?\b/;
function removeTimestampQuery(url2) {
  return url2.replace(timestampRE, "").replace(trailingSeparatorRE, "");
}
async function asyncReplace(input, re, replacer) {
  let match;
  let remaining = input;
  let rewritten = "";
  while (match = re.exec(remaining)) {
    rewritten += remaining.slice(0, match.index);
    rewritten += await replacer(match);
    remaining = remaining.slice(match.index + match[0].length);
  }
  rewritten += remaining;
  return rewritten;
}
function timeFrom(start, subtract = 0) {
  const time = import_node_perf_hooks.performance.now() - start - subtract;
  const timeString = (time.toFixed(2) + `ms`).padEnd(5, " ");
  if (time < 10) {
    return picocolors.exports.green(timeString);
  } else if (time < 50) {
    return picocolors.exports.yellow(timeString);
  } else {
    return picocolors.exports.red(timeString);
  }
}
function prettifyUrl(url2, root2) {
  url2 = removeTimestampQuery(url2);
  const isAbsoluteFile = url2.startsWith(root2);
  if (isAbsoluteFile || url2.startsWith(FS_PREFIX)) {
    let file = import_node_path2.default.relative(root2, isAbsoluteFile ? url2 : fsPathFromId(url2));
    const seg = file.split("/");
    const npmIndex = seg.indexOf(`node_modules`);
    const isSourceMap = file.endsWith(".map");
    if (npmIndex > 0) {
      file = seg[npmIndex + 1];
      if (file.startsWith("@")) {
        file = `${file}/${seg[npmIndex + 2]}`;
      }
      file = `npm: ${picocolors.exports.dim(file)}${isSourceMap ? ` (source map)` : ``}`;
    }
    return picocolors.exports.dim(file);
  } else {
    return picocolors.exports.dim(url2);
  }
}
function isObject$1(value2) {
  return Object.prototype.toString.call(value2) === "[object Object]";
}
function isDefined(value2) {
  return value2 != null;
}
function lookupFile(dir, formats, options3) {
  for (const format2 of formats) {
    const fullPath = import_node_path2.default.join(dir, format2);
    if (import_node_fs.default.existsSync(fullPath) && import_node_fs.default.statSync(fullPath).isFile()) {
      const result = (options3 == null ? void 0 : options3.pathOnly) ? fullPath : import_node_fs.default.readFileSync(fullPath, "utf-8");
      if (!(options3 == null ? void 0 : options3.predicate) || options3.predicate(result)) {
        return result;
      }
    }
  }
  const parentDir = import_node_path2.default.dirname(dir);
  if (parentDir !== dir && (!(options3 == null ? void 0 : options3.rootDir) || parentDir.startsWith(options3 == null ? void 0 : options3.rootDir))) {
    return lookupFile(parentDir, formats, options3);
  }
}
var splitRE = /\r?\n/;
var range = 2;
function pad$1(source2, n2 = 2) {
  const lines = source2.split(splitRE);
  return lines.map((l) => ` `.repeat(n2) + l).join(`
`);
}
function posToNumber(source2, pos2) {
  if (typeof pos2 === "number")
    return pos2;
  const lines = source2.split(splitRE);
  const { line: line2, column: column2 } = pos2;
  let start = 0;
  for (let i = 0; i < line2 - 1 && i < lines.length; i++) {
    start += lines[i].length + 1;
  }
  return start + column2;
}
function numberToPos(source2, offset3) {
  if (typeof offset3 !== "number")
    return offset3;
  if (offset3 > source2.length) {
    throw new Error(`offset is longer than source length! offset ${offset3} > length ${source2.length}`);
  }
  const lines = source2.split(splitRE);
  let counted = 0;
  let line2 = 0;
  let column2 = 0;
  for (; line2 < lines.length; line2++) {
    const lineLength = lines[line2].length + 1;
    if (counted + lineLength >= offset3) {
      column2 = offset3 - counted + 1;
      break;
    }
    counted += lineLength;
  }
  return { line: line2 + 1, column: column2 };
}
function generateCodeFrame(source2, start = 0, end) {
  start = posToNumber(source2, start);
  end = end || start;
  const lines = source2.split(splitRE);
  let count = 0;
  const res = [];
  for (let i = 0; i < lines.length; i++) {
    count += lines[i].length + 1;
    if (count >= start) {
      for (let j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length)
          continue;
        const line2 = j + 1;
        res.push(`${line2}${" ".repeat(Math.max(3 - String(line2).length, 0))}|  ${lines[j]}`);
        const lineLength = lines[j].length;
        if (j === i) {
          const pad2 = Math.max(start - (count - lineLength) + 1, 0);
          const length = Math.max(1, end > count ? lineLength - pad2 : end - start);
          res.push(`   |  ` + " ".repeat(pad2) + "^".repeat(length));
        } else if (j > i) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length));
          }
          count += lineLength + 1;
        }
      }
      break;
    }
  }
  return res.join("\n");
}
function writeFile(filename, content) {
  const dir = import_node_path2.default.dirname(filename);
  if (!import_node_fs.default.existsSync(dir)) {
    import_node_fs.default.mkdirSync(dir, { recursive: true });
  }
  import_node_fs.default.writeFileSync(filename, content);
}
function isFileReadable(filename) {
  try {
    const stat2 = import_node_fs.default.statSync(filename, { throwIfNoEntry: false });
    return !!stat2;
  } catch {
    return false;
  }
}
var splitFirstDirRE = /(.+?)[\\/](.+)/;
function emptyDir(dir, skip) {
  const skipInDir = [];
  let nested = null;
  if (skip == null ? void 0 : skip.length) {
    for (const file of skip) {
      if (import_node_path2.default.dirname(file) !== ".") {
        const matched = file.match(splitFirstDirRE);
        if (matched) {
          nested != null ? nested : nested = /* @__PURE__ */ new Map();
          const [, nestedDir, skipPath] = matched;
          let nestedSkip = nested.get(nestedDir);
          if (!nestedSkip) {
            nestedSkip = [];
            nested.set(nestedDir, nestedSkip);
          }
          if (!nestedSkip.includes(skipPath)) {
            nestedSkip.push(skipPath);
          }
        }
      } else {
        skipInDir.push(file);
      }
    }
  }
  for (const file of import_node_fs.default.readdirSync(dir)) {
    if (skipInDir.includes(file)) {
      continue;
    }
    if (nested == null ? void 0 : nested.has(file)) {
      emptyDir(import_node_path2.default.resolve(dir, file), nested.get(file));
    } else {
      import_node_fs.default.rmSync(import_node_path2.default.resolve(dir, file), { recursive: true, force: true });
    }
  }
}
function copyDir(srcDir, destDir) {
  import_node_fs.default.mkdirSync(destDir, { recursive: true });
  for (const file of import_node_fs.default.readdirSync(srcDir)) {
    const srcFile = import_node_path2.default.resolve(srcDir, file);
    if (srcFile === destDir) {
      continue;
    }
    const destFile = import_node_path2.default.resolve(destDir, file);
    const stat2 = import_node_fs.default.statSync(srcFile);
    if (stat2.isDirectory()) {
      copyDir(srcFile, destFile);
    } else {
      import_node_fs.default.copyFileSync(srcFile, destFile);
    }
  }
}
var removeDir = isWindows$4 ? (0, import_node_util.promisify)(gracefulRemoveDir) : function removeDirSync(dir) {
  import_node_fs.default.rmSync(dir, { recursive: true, force: true });
};
var renameDir = isWindows$4 ? (0, import_node_util.promisify)(gracefulRename) : import_node_fs.default.renameSync;
function ensureWatchedFile(watcher, file, root2) {
  if (file && !file.startsWith(root2 + "/") && !file.includes("\0") && import_node_fs.default.existsSync(file)) {
    watcher.add(import_node_path2.default.resolve(file));
  }
}
var escapedSpaceCharacters = /( |\\t|\\n|\\f|\\r)+/g;
var imageSetUrlRE = /^(?:[\w\-]+\(.*?\)|'.*?'|".*?"|\S*)/;
function reduceSrcset(ret) {
  return ret.reduce((prev, { url: url2, descriptor }, index2) => {
    descriptor != null ? descriptor : descriptor = "";
    return prev += url2 + ` ${descriptor}${index2 === ret.length - 1 ? "" : ", "}`;
  }, "");
}
function splitSrcSetDescriptor(srcs) {
  return splitSrcSet(srcs).map((s) => {
    const src2 = s.replace(escapedSpaceCharacters, " ").trim();
    const [url2] = imageSetUrlRE.exec(src2) || [];
    return {
      url: url2,
      descriptor: src2 == null ? void 0 : src2.slice(url2.length).trim()
    };
  }).filter(({ url: url2 }) => !!url2);
}
function processSrcSet(srcs, replacer) {
  return Promise.all(splitSrcSetDescriptor(srcs).map(async ({ url: url2, descriptor }) => ({
    url: await replacer({ url: url2, descriptor }),
    descriptor
  }))).then((ret) => reduceSrcset(ret));
}
function processSrcSetSync(srcs, replacer) {
  return reduceSrcset(splitSrcSetDescriptor(srcs).map(({ url: url2, descriptor }) => ({
    url: replacer({ url: url2, descriptor }),
    descriptor
  })));
}
function splitSrcSet(srcs) {
  const parts = [];
  const cleanedSrcs = srcs.replace(new RegExp(`(?:url|image|gradient|cross-fade)\\([^\\)]*\\)|"([^"]|(?<=\\\\)")*"|'([^']|(?<=\\\\)')*'`, "g"), blankReplacer);
  let startIndex = 0;
  let splitIndex;
  do {
    splitIndex = cleanedSrcs.indexOf(",", startIndex);
    parts.push(srcs.slice(startIndex, splitIndex !== -1 ? splitIndex : void 0));
    startIndex = splitIndex + 1;
  } while (splitIndex !== -1);
  return parts;
}
function escapeToLinuxLikePath(path4) {
  if (/^[A-Z]:/.test(path4)) {
    return path4.replace(/^([A-Z]):\//, "/windows/$1/");
  }
  if (/^\/[^/]/.test(path4)) {
    return `/linux${path4}`;
  }
  return path4;
}
function unescapeToLinuxLikePath(path4) {
  if (path4.startsWith("/linux/")) {
    return path4.slice("/linux".length);
  }
  if (path4.startsWith("/windows/")) {
    return path4.replace(/^\/windows\/([A-Z])\//, "$1:/");
  }
  return path4;
}
var nullSourceMap = {
  names: [],
  sources: [],
  mappings: "",
  version: 3
};
function combineSourcemaps(filename, sourcemapList, excludeContent = true) {
  if (sourcemapList.length === 0 || sourcemapList.every((m) => m.sources.length === 0)) {
    return { ...nullSourceMap };
  }
  sourcemapList = sourcemapList.map((sourcemap) => {
    const newSourcemaps = { ...sourcemap };
    newSourcemaps.sources = sourcemap.sources.map((source2) => source2 ? escapeToLinuxLikePath(source2) : null);
    if (sourcemap.sourceRoot) {
      newSourcemaps.sourceRoot = escapeToLinuxLikePath(sourcemap.sourceRoot);
    }
    return newSourcemaps;
  });
  const escapedFilename = escapeToLinuxLikePath(filename);
  let map2;
  let mapIndex = 1;
  const useArrayInterface = sourcemapList.slice(0, -1).find((m) => m.sources.length !== 1) === void 0;
  if (useArrayInterface) {
    map2 = remapping(sourcemapList, () => null, excludeContent);
  } else {
    map2 = remapping(sourcemapList[0], function loader(sourcefile) {
      if (sourcefile === escapedFilename && sourcemapList[mapIndex]) {
        return sourcemapList[mapIndex++];
      } else {
        return null;
      }
    }, excludeContent);
  }
  if (!map2.file) {
    delete map2.file;
  }
  map2.sources = map2.sources.map((source2) => source2 ? unescapeToLinuxLikePath(source2) : source2);
  map2.file = filename;
  return map2;
}
function unique(arr) {
  return Array.from(new Set(arr));
}
async function getLocalhostAddressIfDiffersFromDNS() {
  const [nodeResult, dnsResult] = await Promise.all([
    import_node_dns.promises.lookup("localhost"),
    import_node_dns.promises.lookup("localhost", { verbatim: true })
  ]);
  const isSame = nodeResult.family === dnsResult.family && nodeResult.address === dnsResult.address;
  return isSame ? void 0 : nodeResult.address;
}
async function resolveHostname(optionsHost) {
  let host;
  if (optionsHost === void 0 || optionsHost === false) {
    host = "localhost";
  } else if (optionsHost === true) {
    host = void 0;
  } else {
    host = optionsHost;
  }
  let name = host === void 0 || wildcardHosts.has(host) ? "localhost" : host;
  if (host === "localhost") {
    const localhostAddr = await getLocalhostAddressIfDiffersFromDNS();
    if (localhostAddr) {
      name = localhostAddr;
    }
  }
  return { host, name };
}
async function resolveServerUrls(server2, options3, config2) {
  const address = server2.address();
  const isAddressInfo = (x) => x == null ? void 0 : x.address;
  if (!isAddressInfo(address)) {
    return { local: [], network: [] };
  }
  const local = [];
  const network = [];
  const hostname = await resolveHostname(options3.host);
  const protocol = options3.https ? "https" : "http";
  const port = address.port;
  const base2 = config2.base === "./" || config2.base === "" ? "/" : config2.base;
  if (hostname.host && loopbackHosts.has(hostname.host)) {
    let hostnameName = hostname.name;
    if (hostnameName === "::1" || hostnameName === "0000:0000:0000:0000:0000:0000:0000:0001") {
      hostnameName = `[${hostnameName}]`;
    }
    local.push(`${protocol}://${hostnameName}:${port}${base2}`);
  } else {
    Object.values(import_node_os.default.networkInterfaces()).flatMap((nInterface) => nInterface != null ? nInterface : []).filter((detail) => detail && detail.address && (typeof detail.family === "string" && detail.family === "IPv4" || typeof detail.family === "number" && detail.family === 4)).forEach((detail) => {
      const host = detail.address.replace("127.0.0.1", hostname.name);
      const url2 = `${protocol}://${host}:${port}${base2}`;
      if (detail.address.includes("127.0.0.1")) {
        local.push(url2);
      } else {
        network.push(url2);
      }
    });
  }
  return { local, network };
}
function arraify(target) {
  return Array.isArray(target) ? target : [target];
}
function toUpperCaseDriveLetter(pathName) {
  return pathName.replace(/^\w:/, (letter) => letter.toUpperCase());
}
var multilineCommentsRE$1 = /\/\*[^*]*\*+(?:[^/*][^*]*\*+)*\//gm;
var singlelineCommentsRE$1 = /\/\/.*/g;
var requestQuerySplitRE = /\?(?!.*[\/|\}])/;
var usingDynamicImport = typeof jest === "undefined";
var dynamicImport = usingDynamicImport ? new Function("file", "return import(file)") : _require$4;
function parseRequest(id) {
  const [_, search] = id.split(requestQuerySplitRE, 2);
  if (!search) {
    return null;
  }
  return Object.fromEntries(new import_node_url2.URLSearchParams(search));
}
var blankReplacer = (match) => " ".repeat(match.length);
function getHash(text) {
  return (0, import_node_crypto.createHash)("sha256").update(text).digest("hex").substring(0, 8);
}
var requireResolveFromRootWithFallback = (root2, id) => {
  var _a, _b;
  const paths = ((_b = (_a = _require$4.resolve).paths) == null ? void 0 : _b.call(_a, id)) || [];
  paths.unshift(root2);
  import_resolve.default.sync(id, { basedir: root2, paths });
  return _require$4.resolve(id, { paths });
};
var GRACEFUL_RENAME_TIMEOUT = 5e3;
function gracefulRename(from, to, cb) {
  const start = Date.now();
  let backoff = 0;
  import_node_fs.default.rename(from, to, function CB(er) {
    if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < GRACEFUL_RENAME_TIMEOUT) {
      setTimeout(function() {
        import_node_fs.default.stat(to, function(stater, st) {
          if (stater && stater.code === "ENOENT")
            import_node_fs.default.rename(from, to, CB);
          else
            CB(er);
        });
      }, backoff);
      if (backoff < 100)
        backoff += 10;
      return;
    }
    if (cb)
      cb(er);
  });
}
var GRACEFUL_REMOVE_DIR_TIMEOUT = 5e3;
function gracefulRemoveDir(dir, cb) {
  const start = Date.now();
  let backoff = 0;
  import_node_fs.default.rm(dir, { recursive: true }, function CB(er) {
    if (er) {
      if ((er.code === "ENOTEMPTY" || er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < GRACEFUL_REMOVE_DIR_TIMEOUT) {
        setTimeout(function() {
          import_node_fs.default.rm(dir, { recursive: true }, CB);
        }, backoff);
        if (backoff < 100)
          backoff += 10;
        return;
      }
      if (er.code === "ENOENT") {
        er = null;
      }
    }
    if (cb)
      cb(er);
  });
}
function emptyCssComments(raw) {
  return raw.replace(multilineCommentsRE$1, (s) => " ".repeat(s.length));
}
function removeComments(raw) {
  return raw.replace(multilineCommentsRE$1, "").replace(singlelineCommentsRE$1, "");
}
function mergeConfigRecursively(defaults, overrides, rootPath) {
  const merged = { ...defaults };
  for (const key2 in overrides) {
    const value2 = overrides[key2];
    if (value2 == null) {
      continue;
    }
    const existing = merged[key2];
    if (existing == null) {
      merged[key2] = value2;
      continue;
    }
    if (key2 === "alias" && (rootPath === "resolve" || rootPath === "")) {
      merged[key2] = mergeAlias(existing, value2);
      continue;
    } else if (key2 === "assetsInclude" && rootPath === "") {
      merged[key2] = [].concat(existing, value2);
      continue;
    } else if (key2 === "noExternal" && rootPath === "ssr" && (existing === true || value2 === true)) {
      merged[key2] = true;
      continue;
    }
    if (Array.isArray(existing) || Array.isArray(value2)) {
      merged[key2] = [...arraify(existing != null ? existing : []), ...arraify(value2 != null ? value2 : [])];
      continue;
    }
    if (isObject$1(existing) && isObject$1(value2)) {
      merged[key2] = mergeConfigRecursively(existing, value2, rootPath ? `${rootPath}.${key2}` : key2);
      continue;
    }
    merged[key2] = value2;
  }
  return merged;
}
function mergeConfig(defaults, overrides, isRoot = true) {
  return mergeConfigRecursively(defaults, overrides, isRoot ? "" : ".");
}
function mergeAlias(a, b) {
  if (!a)
    return b;
  if (!b)
    return a;
  if (isObject$1(a) && isObject$1(b)) {
    return { ...a, ...b };
  }
  return [...normalizeAlias(b), ...normalizeAlias(a)];
}
function normalizeAlias(o = []) {
  return Array.isArray(o) ? o.map(normalizeSingleAlias) : Object.keys(o).map((find2) => normalizeSingleAlias({
    find: find2,
    replacement: o[find2]
  }));
}
function normalizeSingleAlias({ find: find2, replacement, customResolver }) {
  if (typeof find2 === "string" && find2.endsWith("/") && replacement.endsWith("/")) {
    find2 = find2.slice(0, find2.length - 1);
    replacement = replacement.slice(0, replacement.length - 1);
  }
  const alias2 = {
    find: find2,
    replacement
  };
  if (customResolver) {
    alias2.customResolver = customResolver;
  }
  return alias2;
}
function transformStableResult(s, id, config2) {
  return {
    code: s.toString(),
    map: config2.command === "build" && config2.build.sourcemap ? s.generateMap({ hires: true, source: id }) : null
  };
}
async function asyncFlatten(arr) {
  do {
    arr = (await Promise.all(arr)).flat(Infinity);
  } while (arr.some((v) => v == null ? void 0 : v.then));
  return arr;
}
function stripBomTag(content) {
  if (content.charCodeAt(0) === 65279) {
    return content.slice(1);
  }
  return content;
}
var windowsDrivePathPrefixRE = /^[A-Za-z]:[/\\]/;
var isNonDriveRelativeAbsolutePath = (p) => {
  if (!isWindows$4)
    return p.startsWith("/");
  return windowsDrivePathPrefixRE.test(p);
};
function joinUrlSegments(a, b) {
  if (!a || !b) {
    return a || b || "";
  }
  if (a.endsWith("/")) {
    a = a.substring(0, a.length - 1);
  }
  if (!b.startsWith("/")) {
    b = "/" + b;
  }
  return a + b;
}
var LogLevels = {
  silent: 0,
  error: 1,
  warn: 2,
  info: 3
};
var lastType;
var lastMsg;
var sameCount = 0;
function clearScreen() {
  const repeatCount = process.stdout.rows - 2;
  const blank = repeatCount > 0 ? "\n".repeat(repeatCount) : "";
  console.log(blank);
  import_node_readline.default.cursorTo(process.stdout, 0, 0);
  import_node_readline.default.clearScreenDown(process.stdout);
}
function createLogger(level2 = "info", options3 = {}) {
  if (options3.customLogger) {
    return options3.customLogger;
  }
  const loggedErrors = /* @__PURE__ */ new WeakSet();
  const { prefix = "[vite]", allowClearScreen = true } = options3;
  const thresh = LogLevels[level2];
  const canClearScreen = allowClearScreen && process.stdout.isTTY && !process.env.CI;
  const clear = canClearScreen ? clearScreen : () => {
  };
  function output(type, msg, options4 = {}) {
    if (thresh >= LogLevels[type]) {
      const method = type === "info" ? "log" : type;
      const format2 = () => {
        if (options4.timestamp) {
          const tag = type === "info" ? picocolors.exports.cyan(picocolors.exports.bold(prefix)) : type === "warn" ? picocolors.exports.yellow(picocolors.exports.bold(prefix)) : picocolors.exports.red(picocolors.exports.bold(prefix));
          return `${picocolors.exports.dim(new Date().toLocaleTimeString())} ${tag} ${msg}`;
        } else {
          return msg;
        }
      };
      if (options4.error) {
        loggedErrors.add(options4.error);
      }
      if (canClearScreen) {
        if (type === lastType && msg === lastMsg) {
          sameCount++;
          clear();
          console[method](format2(), picocolors.exports.yellow(`(x${sameCount + 1})`));
        } else {
          sameCount = 0;
          lastMsg = msg;
          lastType = type;
          if (options4.clear) {
            clear();
          }
          console[method](format2());
        }
      } else {
        console[method](format2());
      }
    }
  }
  const warnedMessages = /* @__PURE__ */ new Set();
  const logger = {
    hasWarned: false,
    info(msg, opts) {
      output("info", msg, opts);
    },
    warn(msg, opts) {
      logger.hasWarned = true;
      output("warn", msg, opts);
    },
    warnOnce(msg, opts) {
      if (warnedMessages.has(msg))
        return;
      logger.hasWarned = true;
      output("warn", msg, opts);
      warnedMessages.add(msg);
    },
    error(msg, opts) {
      logger.hasWarned = true;
      output("error", msg, opts);
    },
    clearScreen(type) {
      if (thresh >= LogLevels[type]) {
        clear();
      }
    },
    hasErrorLogged(error2) {
      return loggedErrors.has(error2);
    }
  };
  return logger;
}
function printServerUrls(urls, optionsHost, info) {
  const colorUrl = (url2) => picocolors.exports.cyan(url2.replace(/:(\d+)\//, (_, port) => `:${picocolors.exports.bold(port)}/`));
  for (const url2 of urls.local) {
    info(`  ${picocolors.exports.green("\u279C")}  ${picocolors.exports.bold("Local")}:   ${colorUrl(url2)}`);
  }
  for (const url2 of urls.network) {
    info(`  ${picocolors.exports.green("\u279C")}  ${picocolors.exports.bold("Network")}: ${colorUrl(url2)}`);
  }
  if (urls.network.length === 0 && optionsHost === void 0) {
    const note = `use ${picocolors.exports.reset(picocolors.exports.bold("--host"))} to expose`;
    info(picocolors.exports.dim(`  ${picocolors.exports.green("\u279C")}  ${picocolors.exports.bold("Network")}: ${note}`));
  }
}
var writeColors = {
  [0]: picocolors.exports.cyan,
  [1]: picocolors.exports.magenta,
  [2]: picocolors.exports.green,
  [3]: picocolors.exports.blue,
  [4]: picocolors.exports.gray
};
function buildReporterPlugin(config2) {
  const compress = (0, import_node_util.promisify)(import_node_zlib.gzip);
  const chunkLimit = config2.build.chunkSizeWarningLimit;
  function isLarge(code) {
    return code.length / 1024 > chunkLimit;
  }
  async function getCompressedSize(code) {
    if (config2.build.ssr || !config2.build.reportCompressedSize) {
      return "";
    }
    return ` / gzip: ${((await compress(typeof code === "string" ? code : Buffer.from(code))).length / 1024).toFixed(2)} KiB`;
  }
  function printFileInfo(filePath, content, type, maxLength, outDir = config2.build.outDir, compressedSize = "") {
    outDir = normalizePath$3(import_node_path2.default.relative(config2.root, import_node_path2.default.resolve(config2.root, outDir))) + "/";
    const kibs = content.length / 1024;
    const sizeColor = kibs > chunkLimit ? picocolors.exports.yellow : picocolors.exports.dim;
    config2.logger.info(`${picocolors.exports.gray(picocolors.exports.white(picocolors.exports.dim(outDir)))}${writeColors[type](filePath.padEnd(maxLength + 2))} ${sizeColor(`${kibs.toFixed(2)} KiB${compressedSize}`)}`);
  }
  const tty2 = process.stdout.isTTY && !process.env.CI;
  const shouldLogInfo = LogLevels[config2.logLevel || "info"] >= LogLevels.info;
  let hasTransformed = false;
  let hasRenderedChunk = false;
  let transformedCount = 0;
  let chunkCount = 0;
  const logTransform = throttle((id) => {
    writeLine(`transforming (${transformedCount}) ${picocolors.exports.dim(import_node_path2.default.relative(config2.root, id))}`);
  });
  return {
    name: "vite:reporter",
    transform(_, id) {
      transformedCount++;
      if (shouldLogInfo) {
        if (!tty2) {
          if (!hasTransformed) {
            config2.logger.info(`transforming...`);
          }
        } else {
          if (id.includes(`?`))
            return;
          logTransform(id);
        }
        hasTransformed = true;
      }
      return null;
    },
    buildEnd() {
      if (shouldLogInfo) {
        if (tty2) {
          process.stdout.clearLine(0);
          process.stdout.cursorTo(0);
        }
        config2.logger.info(`${picocolors.exports.green(`\u2713`)} ${transformedCount} modules transformed.`);
      }
    },
    renderStart() {
      chunkCount = 0;
    },
    renderChunk() {
      chunkCount++;
      if (shouldLogInfo) {
        if (!tty2) {
          if (!hasRenderedChunk) {
            config2.logger.info("rendering chunks...");
          }
        } else {
          writeLine(`rendering chunks (${chunkCount})...`);
        }
        hasRenderedChunk = true;
      }
      return null;
    },
    generateBundle() {
      if (shouldLogInfo && tty2) {
        process.stdout.clearLine(0);
        process.stdout.cursorTo(0);
      }
    },
    async writeBundle({ dir: outDir }, output) {
      let hasLargeChunks = false;
      if (shouldLogInfo) {
        let longest = 0;
        for (const file in output) {
          const l = output[file].fileName.length;
          if (l > longest)
            longest = l;
        }
        const deferredLogs = [];
        await Promise.all(Object.keys(output).map(async (file) => {
          const chunk = output[file];
          if (chunk.type === "chunk") {
            const log2 = async () => {
              printFileInfo(chunk.fileName, chunk.code, 0, longest, outDir, await getCompressedSize(chunk.code));
              if (chunk.map) {
                printFileInfo(chunk.fileName + ".map", chunk.map.toString(), 4, longest, outDir);
              }
            };
            if (isLarge(chunk.code)) {
              hasLargeChunks = true;
              deferredLogs.push(log2);
            } else {
              await log2();
            }
          } else if (chunk.source) {
            const isCSS = chunk.fileName.endsWith(".css");
            const isMap2 = chunk.fileName.endsWith(".js.map");
            printFileInfo(chunk.fileName, chunk.source, isCSS ? 1 : isMap2 ? 4 : 2, longest, outDir, isCSS ? await getCompressedSize(chunk.source) : void 0);
          }
        }));
        await Promise.all(deferredLogs.map((l) => l()));
      } else {
        hasLargeChunks = Object.keys(output).some((file) => {
          const chunk = output[file];
          return chunk.type === "chunk" && chunk.code.length / 1024 > chunkLimit;
        });
      }
      if (hasLargeChunks && config2.build.minify && !config2.build.lib && !config2.build.ssr) {
        config2.logger.warn(picocolors.exports.yellow(`
(!) Some chunks are larger than ${chunkLimit} KiB after minification. Consider:
- Using dynamic import() to code-split the application
- Use build.rollupOptions.output.manualChunks to improve chunking: https://rollupjs.org/guide/en/#outputmanualchunks
- Adjust chunk size limit for this warning via build.chunkSizeWarningLimit.`));
      }
    }
  };
}
function writeLine(output) {
  process.stdout.clearLine(0);
  process.stdout.cursorTo(0);
  if (output.length < process.stdout.columns) {
    process.stdout.write(output);
  } else {
    process.stdout.write(output.substring(0, process.stdout.columns - 1));
  }
}
function throttle(fn) {
  let timerHandle = null;
  return (...args) => {
    if (timerHandle)
      return;
    fn(...args);
    timerHandle = setTimeout(() => {
      timerHandle = null;
    }, 100);
  };
}
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key2, value2) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key2] = value2;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
async function find(filename, options3) {
  let dir = import_path.default.dirname(import_path.default.resolve(filename));
  const root2 = (options3 == null ? void 0 : options3.root) ? import_path.default.resolve(options3.root) : null;
  while (dir) {
    const tsconfig = await tsconfigInDir(dir, options3);
    if (tsconfig) {
      return tsconfig;
    } else {
      if (root2 === dir) {
        break;
      }
      const parent = import_path.default.dirname(dir);
      if (parent === dir) {
        break;
      } else {
        dir = parent;
      }
    }
  }
  throw new Error(`no tsconfig file found for ${filename}`);
}
async function tsconfigInDir(dir, options3) {
  const tsconfig = import_path.default.join(dir, "tsconfig.json");
  if (options3 == null ? void 0 : options3.tsConfigPaths) {
    return options3.tsConfigPaths.has(tsconfig) ? tsconfig : void 0;
  }
  try {
    const stat2 = await import_fs.promises.stat(tsconfig);
    if (stat2.isFile() || stat2.isFIFO()) {
      return tsconfig;
    }
  } catch (e) {
    if (e.code !== "ENOENT") {
      throw e;
    }
  }
}
async function findAll(dir, options3) {
  const files = [];
  for await (const tsconfigFile of findTSConfig(import_path.default.resolve(dir), options3)) {
    files.push(tsconfigFile);
  }
  return files;
}
async function* findTSConfig(dir, options3, visited = /* @__PURE__ */ new Set()) {
  if (!visited.has(dir)) {
    visited.add(dir);
    try {
      const dirents = await import_fs.promises.readdir(dir, { withFileTypes: true });
      for (const dirent of dirents) {
        if (dirent.isDirectory() && (!(options3 == null ? void 0 : options3.skip) || !options3.skip(dirent.name))) {
          yield* findTSConfig(import_path.default.resolve(dir, dirent.name), options3, visited);
        } else if (dirent.isFile() && dirent.name === "tsconfig.json") {
          yield import_path.default.resolve(dir, dirent.name);
        }
      }
    } catch (e) {
      if (e.code === "EACCES" || e.code === "ENOENT") {
        return;
      }
      throw e;
    }
  }
}
function toJson(tsconfigJson) {
  const stripped = stripDanglingComma(stripJsonComments(stripBom(tsconfigJson)));
  if (stripped.trim() === "") {
    return "{}";
  } else {
    return stripped;
  }
}
function stripDanglingComma(pseudoJson) {
  let insideString = false;
  let offset3 = 0;
  let result = "";
  let danglingCommaPos = null;
  for (let i = 0; i < pseudoJson.length; i++) {
    const currentCharacter = pseudoJson[i];
    if (currentCharacter === '"') {
      const escaped2 = isEscaped(pseudoJson, i);
      if (!escaped2) {
        insideString = !insideString;
      }
    }
    if (insideString) {
      danglingCommaPos = null;
      continue;
    }
    if (currentCharacter === ",") {
      danglingCommaPos = i;
      continue;
    }
    if (danglingCommaPos) {
      if (currentCharacter === "}" || currentCharacter === "]") {
        result += pseudoJson.slice(offset3, danglingCommaPos) + " ";
        offset3 = danglingCommaPos + 1;
        danglingCommaPos = null;
      } else if (!currentCharacter.match(/\s/)) {
        danglingCommaPos = null;
      }
    }
  }
  return result + pseudoJson.substring(offset3);
}
function isEscaped(jsonString, quotePosition) {
  let index2 = quotePosition - 1;
  let backslashCount = 0;
  while (jsonString[index2] === "\\") {
    index2 -= 1;
    backslashCount += 1;
  }
  return Boolean(backslashCount % 2);
}
function strip(string2, start, end) {
  return string2.slice(start, end).replace(/\S/g, " ");
}
var singleComment = Symbol("singleComment");
var multiComment = Symbol("multiComment");
function stripJsonComments(jsonString) {
  let isInsideString = false;
  let isInsideComment = false;
  let offset3 = 0;
  let result = "";
  for (let index2 = 0; index2 < jsonString.length; index2++) {
    const currentCharacter = jsonString[index2];
    const nextCharacter = jsonString[index2 + 1];
    if (!isInsideComment && currentCharacter === '"') {
      const escaped2 = isEscaped(jsonString, index2);
      if (!escaped2) {
        isInsideString = !isInsideString;
      }
    }
    if (isInsideString) {
      continue;
    }
    if (!isInsideComment && currentCharacter + nextCharacter === "//") {
      result += jsonString.slice(offset3, index2);
      offset3 = index2;
      isInsideComment = singleComment;
      index2++;
    } else if (isInsideComment === singleComment && currentCharacter + nextCharacter === "\r\n") {
      index2++;
      isInsideComment = false;
      result += strip(jsonString, offset3, index2);
      offset3 = index2;
    } else if (isInsideComment === singleComment && currentCharacter === "\n") {
      isInsideComment = false;
      result += strip(jsonString, offset3, index2);
      offset3 = index2;
    } else if (!isInsideComment && currentCharacter + nextCharacter === "/*") {
      result += jsonString.slice(offset3, index2);
      offset3 = index2;
      isInsideComment = multiComment;
      index2++;
    } else if (isInsideComment === multiComment && currentCharacter + nextCharacter === "*/") {
      index2++;
      isInsideComment = false;
      result += strip(jsonString, offset3, index2 + 1);
      offset3 = index2 + 1;
    }
  }
  return result + (isInsideComment ? strip(jsonString.slice(offset3)) : jsonString.slice(offset3));
}
function stripBom(string2) {
  if (string2.charCodeAt(0) === 65279) {
    return string2.slice(1);
  }
  return string2;
}
var POSIX_SEP_RE = new RegExp("\\" + import_path.default.posix.sep, "g");
var NATIVE_SEP_RE = new RegExp("\\" + import_path.default.sep, "g");
var PATTERN_REGEX_CACHE = /* @__PURE__ */ new Map();
var GLOB_ALL_PATTERN = `**/*`;
var DEFAULT_EXTENSIONS2 = [".ts", ".tsx", ".mts", ".cts"];
var DEFAULT_EXTENSIONS_RE_GROUP = `\\.(?:${DEFAULT_EXTENSIONS2.map((ext2) => ext2.substring(1)).join("|")})`;
new Function("path", "return import(path).then(m => m.default)");
async function resolveTSConfig(filename) {
  if (import_path.default.extname(filename) !== ".json") {
    return;
  }
  const tsconfig = import_path.default.resolve(filename);
  try {
    const stat2 = await import_fs.promises.stat(tsconfig);
    if (stat2.isFile() || stat2.isFIFO()) {
      return tsconfig;
    }
  } catch (e) {
    if (e.code !== "ENOENT") {
      throw e;
    }
  }
  throw new Error(`no tsconfig file found for ${filename}`);
}
function posix2native(filename) {
  return import_path.default.posix.sep !== import_path.default.sep && filename.includes(import_path.default.posix.sep) ? filename.replace(POSIX_SEP_RE, import_path.default.sep) : filename;
}
function native2posix(filename) {
  return import_path.default.posix.sep !== import_path.default.sep && filename.includes(import_path.default.sep) ? filename.replace(NATIVE_SEP_RE, import_path.default.posix.sep) : filename;
}
function resolve2posix(dir, filename) {
  if (import_path.default.sep === import_path.default.posix.sep) {
    return dir ? import_path.default.resolve(dir, filename) : import_path.default.resolve(filename);
  }
  return native2posix(dir ? import_path.default.resolve(posix2native(dir), posix2native(filename)) : import_path.default.resolve(posix2native(filename)));
}
function resolveReferencedTSConfigFiles(result) {
  const dir = import_path.default.dirname(result.tsconfigFile);
  return result.tsconfig.references.map((ref2) => {
    const refPath = ref2.path.endsWith(".json") ? ref2.path : import_path.default.join(ref2.path, "tsconfig.json");
    return resolve2posix(dir, refPath);
  });
}
function resolveSolutionTSConfig(filename, result) {
  if (result.referenced && DEFAULT_EXTENSIONS2.some((ext2) => filename.endsWith(ext2)) && !isIncluded(filename, result)) {
    const solutionTSConfig = result.referenced.find((referenced) => isIncluded(filename, referenced));
    if (solutionTSConfig) {
      return __spreadProps(__spreadValues({}, solutionTSConfig), {
        solution: result
      });
    }
  }
  return result;
}
function isIncluded(filename, result) {
  const dir = native2posix(import_path.default.dirname(result.tsconfigFile));
  const files = (result.tsconfig.files || []).map((file) => resolve2posix(dir, file));
  const absoluteFilename = resolve2posix(null, filename);
  if (files.includes(filename)) {
    return true;
  }
  const isIncluded2 = isGlobMatch(absoluteFilename, dir, result.tsconfig.include || (result.tsconfig.files ? [] : [GLOB_ALL_PATTERN]));
  if (isIncluded2) {
    const isExcluded = isGlobMatch(absoluteFilename, dir, result.tsconfig.exclude || []);
    return !isExcluded;
  }
  return false;
}
function isGlobMatch(filename, dir, patterns2) {
  return patterns2.some((pattern2) => {
    let lastWildcardIndex = pattern2.length;
    let hasWildcard = false;
    for (let i = pattern2.length - 1; i > -1; i--) {
      if (pattern2[i] === "*" || pattern2[i] === "?") {
        lastWildcardIndex = i;
        hasWildcard = true;
        break;
      }
    }
    if (lastWildcardIndex < pattern2.length - 1 && !filename.endsWith(pattern2.slice(lastWildcardIndex + 1))) {
      return false;
    }
    if (pattern2.endsWith("*") && !DEFAULT_EXTENSIONS2.some((ext2) => filename.endsWith(ext2))) {
      return false;
    }
    if (pattern2 === GLOB_ALL_PATTERN) {
      return filename.startsWith(`${dir}/`);
    }
    const resolvedPattern = resolve2posix(dir, pattern2);
    let firstWildcardIndex = -1;
    for (let i = 0; i < resolvedPattern.length; i++) {
      if (resolvedPattern[i] === "*" || resolvedPattern[i] === "?") {
        firstWildcardIndex = i;
        hasWildcard = true;
        break;
      }
    }
    if (firstWildcardIndex > 1 && !filename.startsWith(resolvedPattern.slice(0, firstWildcardIndex - 1))) {
      return false;
    }
    if (!hasWildcard) {
      return filename === resolvedPattern;
    }
    if (PATTERN_REGEX_CACHE.has(resolvedPattern)) {
      return PATTERN_REGEX_CACHE.get(resolvedPattern).test(filename);
    }
    const regex = pattern2regex(resolvedPattern);
    PATTERN_REGEX_CACHE.set(resolvedPattern, regex);
    return regex.test(filename);
  });
}
function pattern2regex(resolvedPattern) {
  let regexStr = "^";
  for (let i = 0; i < resolvedPattern.length; i++) {
    const char = resolvedPattern[i];
    if (char === "?") {
      regexStr += "[^\\/]";
      continue;
    }
    if (char === "*") {
      if (resolvedPattern[i + 1] === "*" && resolvedPattern[i + 2] === "/") {
        i += 2;
        regexStr += "(?:[^\\/]*\\/)*";
        continue;
      }
      regexStr += "[^\\/]*";
      continue;
    }
    if ("/.+^${}()|[]\\".includes(char)) {
      regexStr += `\\`;
    }
    regexStr += char;
  }
  if (resolvedPattern.endsWith("*")) {
    regexStr += DEFAULT_EXTENSIONS_RE_GROUP;
  }
  regexStr += "$";
  return new RegExp(regexStr);
}
async function parse$g(filename, options3) {
  const cache = options3 == null ? void 0 : options3.cache;
  if (cache == null ? void 0 : cache.has(filename)) {
    return cache.get(filename);
  }
  let tsconfigFile;
  if (options3 == null ? void 0 : options3.resolveWithEmptyIfConfigNotFound) {
    try {
      tsconfigFile = await resolveTSConfig(filename) || await find(filename, options3);
    } catch (e) {
      const notFoundResult = {
        tsconfigFile: "no_tsconfig_file_found",
        tsconfig: {}
      };
      cache == null ? void 0 : cache.set(filename, notFoundResult);
      return notFoundResult;
    }
  } else {
    tsconfigFile = await resolveTSConfig(filename) || await find(filename, options3);
  }
  let result;
  if (cache == null ? void 0 : cache.has(tsconfigFile)) {
    result = cache.get(tsconfigFile);
  } else {
    result = await parseFile$1(tsconfigFile, cache);
    await Promise.all([parseExtends(result, cache), parseReferences(result, cache)]);
    cache == null ? void 0 : cache.set(tsconfigFile, result);
  }
  result = resolveSolutionTSConfig(filename, result);
  cache == null ? void 0 : cache.set(filename, result);
  return result;
}
async function parseFile$1(tsconfigFile, cache) {
  if (cache == null ? void 0 : cache.has(tsconfigFile)) {
    return cache.get(tsconfigFile);
  }
  try {
    const tsconfigJson = await import_fs.promises.readFile(tsconfigFile, "utf-8");
    const json = toJson(tsconfigJson);
    const result = {
      tsconfigFile,
      tsconfig: normalizeTSConfig(JSON.parse(json), import_path.default.dirname(tsconfigFile))
    };
    cache == null ? void 0 : cache.set(tsconfigFile, result);
    return result;
  } catch (e) {
    throw new TSConfckParseError(`parsing ${tsconfigFile} failed: ${e}`, "PARSE_FILE", tsconfigFile, e);
  }
}
function normalizeTSConfig(tsconfig, dir) {
  var _a;
  if (((_a = tsconfig.compilerOptions) == null ? void 0 : _a.baseUrl) && !import_path.default.isAbsolute(tsconfig.compilerOptions.baseUrl)) {
    tsconfig.compilerOptions.baseUrl = resolve2posix(dir, tsconfig.compilerOptions.baseUrl);
  }
  return tsconfig;
}
async function parseReferences(result, cache) {
  if (!result.tsconfig.references) {
    return;
  }
  const referencedFiles = resolveReferencedTSConfigFiles(result);
  const referenced = await Promise.all(referencedFiles.map((file) => parseFile$1(file, cache)));
  await Promise.all(referenced.map((ref2) => parseExtends(ref2, cache)));
  result.referenced = referenced;
}
async function parseExtends(result, cache) {
  if (!result.tsconfig.extends) {
    return;
  }
  const extended = [
    { tsconfigFile: result.tsconfigFile, tsconfig: JSON.parse(JSON.stringify(result.tsconfig)) }
  ];
  while (extended[extended.length - 1].tsconfig.extends) {
    const extending = extended[extended.length - 1];
    const extendedTSConfigFile = resolveExtends(extending.tsconfig.extends, extending.tsconfigFile);
    if (extended.some((x) => x.tsconfigFile === extendedTSConfigFile)) {
      const circle = extended.concat({ tsconfigFile: extendedTSConfigFile, tsconfig: null }).map((e) => e.tsconfigFile).join(" -> ");
      throw new TSConfckParseError(`Circular dependency in "extends": ${circle}`, "EXTENDS_CIRCULAR", result.tsconfigFile);
    }
    extended.push(await parseFile$1(extendedTSConfigFile, cache));
  }
  result.extended = extended;
  for (const ext2 of result.extended.slice(1)) {
    extendTSConfig(result, ext2);
  }
}
function resolveExtends(extended, from) {
  let error2;
  try {
    return (0, import_module.createRequire)(from).resolve(extended);
  } catch (e) {
    error2 = e;
  }
  if (!import_path.default.isAbsolute(extended) && !extended.startsWith("./") && !extended.startsWith("../")) {
    try {
      const fallbackExtended = import_path.default.join(extended, "tsconfig.json");
      return (0, import_module.createRequire)(from).resolve(fallbackExtended);
    } catch (e) {
      error2 = e;
    }
  }
  throw new TSConfckParseError(`failed to resolve "extends":"${extended}" in ${from}`, "EXTENDS_RESOLVE", from, error2);
}
var EXTENDABLE_KEYS = [
  "compilerOptions",
  "files",
  "include",
  "exclude",
  "watchOptions",
  "compileOnSave",
  "typeAcquisition",
  "buildOptions"
];
function extendTSConfig(extending, extended) {
  const extendingConfig = extending.tsconfig;
  const extendedConfig = extended.tsconfig;
  const relativePath = native2posix(import_path.default.relative(import_path.default.dirname(extending.tsconfigFile), import_path.default.dirname(extended.tsconfigFile)));
  for (const key2 of Object.keys(extendedConfig).filter((key22) => EXTENDABLE_KEYS.includes(key22))) {
    if (key2 === "compilerOptions") {
      if (!extendingConfig.compilerOptions) {
        extendingConfig.compilerOptions = {};
      }
      for (const option of Object.keys(extendedConfig.compilerOptions)) {
        if (Object.prototype.hasOwnProperty.call(extendingConfig.compilerOptions, option)) {
          continue;
        }
        extendingConfig.compilerOptions[option] = rebaseRelative(option, extendedConfig.compilerOptions[option], relativePath);
      }
    } else if (extendingConfig[key2] === void 0) {
      if (key2 === "watchOptions") {
        extendingConfig.watchOptions = {};
        for (const option of Object.keys(extendedConfig.watchOptions)) {
          extendingConfig.watchOptions[option] = rebaseRelative(option, extendedConfig.watchOptions[option], relativePath);
        }
      } else {
        extendingConfig[key2] = rebaseRelative(key2, extendedConfig[key2], relativePath);
      }
    }
  }
}
var REBASE_KEYS = [
  "files",
  "include",
  "exclude",
  "baseUrl",
  "rootDir",
  "rootDirs",
  "typeRoots",
  "outDir",
  "outFile",
  "declarationDir",
  "excludeDirectories",
  "excludeFiles"
];
function rebaseRelative(key2, value2, prependPath) {
  if (!REBASE_KEYS.includes(key2)) {
    return value2;
  }
  if (Array.isArray(value2)) {
    return value2.map((x) => rebasePath(x, prependPath));
  } else {
    return rebasePath(value2, prependPath);
  }
}
function rebasePath(value2, prependPath) {
  if (import_path.default.isAbsolute(value2)) {
    return value2;
  } else {
    return import_path.default.posix.normalize(import_path.default.posix.join(prependPath, value2));
  }
}
var TSConfckParseError = class extends Error {
  constructor(message, code, tsconfigFile, cause) {
    super(message);
    Object.setPrototypeOf(this, TSConfckParseError.prototype);
    this.name = TSConfckParseError.name;
    this.code = code;
    this.cause = cause;
    this.tsconfigFile = tsconfigFile;
  }
};
var debug$f = createDebugger("vite:esbuild");
var INJECT_HELPERS_IIFE_RE = /^(.*)((?:const|var) [^\s]+=function\([^)]*?\){"use strict";)/s;
var INJECT_HELPERS_UMD_RE = /^(.*)(\(function\([^)]*?\){.+amd.+function\([^)]*?\){"use strict";)/s;
var server;
async function transformWithEsbuild(code, filename, options3, inMap) {
  var _a;
  let loader = options3 == null ? void 0 : options3.loader;
  if (!loader) {
    const ext2 = import_node_path2.default.extname(/\.\w+$/.test(filename) ? filename : cleanUrl(filename)).slice(1);
    if (ext2 === "cjs" || ext2 === "mjs") {
      loader = "js";
    } else if (ext2 === "cts" || ext2 === "mts") {
      loader = "ts";
    } else {
      loader = ext2;
    }
  }
  let tsconfigRaw = options3 == null ? void 0 : options3.tsconfigRaw;
  if (typeof tsconfigRaw !== "string") {
    const meaningfulFields = [
      "target",
      "jsxFactory",
      "jsxFragmentFactory",
      "useDefineForClassFields",
      "importsNotUsedAsValues",
      "preserveValueImports"
    ];
    const compilerOptionsForFile = {};
    if (loader === "ts" || loader === "tsx") {
      const loadedTsconfig = await loadTsconfigJsonForFile(filename);
      const loadedCompilerOptions = (_a = loadedTsconfig.compilerOptions) != null ? _a : {};
      for (const field of meaningfulFields) {
        if (field in loadedCompilerOptions) {
          compilerOptionsForFile[field] = loadedCompilerOptions[field];
        }
      }
    }
    tsconfigRaw = {
      ...tsconfigRaw,
      compilerOptions: {
        ...compilerOptionsForFile,
        ...tsconfigRaw == null ? void 0 : tsconfigRaw.compilerOptions
      }
    };
  }
  const resolvedOptions = {
    sourcemap: true,
    sourcefile: filename,
    ...options3,
    loader,
    tsconfigRaw
  };
  delete resolvedOptions.include;
  delete resolvedOptions.exclude;
  delete resolvedOptions.jsxInject;
  try {
    const result = await (0, import_esbuild.transform)(code, resolvedOptions);
    let map2;
    if (inMap && resolvedOptions.sourcemap) {
      const nextMap = JSON.parse(result.map);
      nextMap.sourcesContent = [];
      map2 = combineSourcemaps(filename, [
        nextMap,
        inMap
      ]);
    } else {
      map2 = resolvedOptions.sourcemap && resolvedOptions.sourcemap !== "inline" ? JSON.parse(result.map) : { mappings: "" };
    }
    if (Array.isArray(map2.sources)) {
      map2.sources = map2.sources.map((it) => toUpperCaseDriveLetter(it));
    }
    return {
      ...result,
      map: map2
    };
  } catch (e) {
    debug$f(`esbuild error with options used: `, resolvedOptions);
    if (e.errors) {
      e.frame = "";
      e.errors.forEach((m) => {
        e.frame += `
` + prettifyMessage(m, code);
      });
      e.loc = e.errors[0].location;
    }
    throw e;
  }
}
function esbuildPlugin(options3 = {}) {
  const filter2 = createFilter3(options3.include || /\.(m?ts|[jt]sx)$/, options3.exclude || /\.js$/);
  const transformOptions = {
    target: "esnext",
    ...options3,
    minify: false,
    minifyIdentifiers: false,
    minifySyntax: false,
    minifyWhitespace: false,
    treeShaking: false,
    keepNames: false
  };
  return {
    name: "vite:esbuild",
    configureServer(_server) {
      server = _server;
      server.watcher.on("add", reloadOnTsconfigChange).on("change", reloadOnTsconfigChange).on("unlink", reloadOnTsconfigChange);
    },
    async configResolved(config2) {
      await initTSConfck(config2);
    },
    buildEnd() {
      server = null;
    },
    async transform(code, id) {
      if (filter2(id) || filter2(cleanUrl(id))) {
        const result = await transformWithEsbuild(code, id, transformOptions);
        if (result.warnings.length) {
          result.warnings.forEach((m) => {
            this.warn(prettifyMessage(m, code));
          });
        }
        if (options3.jsxInject && /\.(?:j|t)sx\b/.test(id)) {
          result.code = options3.jsxInject + ";" + result.code;
        }
        return {
          code: result.code,
          map: result.map
        };
      }
    }
  };
}
var rollupToEsbuildFormatMap = {
  es: "esm",
  cjs: "cjs",
  iife: void 0
};
var buildEsbuildPlugin = (config2) => {
  return {
    name: "vite:esbuild-transpile",
    async configResolved(config3) {
      await initTSConfck(config3);
    },
    async renderChunk(code, chunk, opts) {
      if (opts.__vite_skip_esbuild__) {
        return null;
      }
      const options3 = resolveEsbuildTranspileOptions(config2, opts.format);
      if (!options3) {
        return null;
      }
      const res = await transformWithEsbuild(code, chunk.fileName, options3);
      if (config2.build.lib) {
        const injectHelpers = opts.format === "umd" ? INJECT_HELPERS_UMD_RE : opts.format === "iife" ? INJECT_HELPERS_IIFE_RE : void 0;
        if (injectHelpers) {
          res.code = res.code.replace(injectHelpers, (_, helpers, header) => header + helpers);
        }
      }
      return res;
    }
  };
};
function resolveEsbuildTranspileOptions(config2, format2) {
  var _a, _b, _c, _d, _e;
  const target = config2.build.target;
  const minify = config2.build.minify === "esbuild";
  if ((!target || target === "esnext") && !minify) {
    return null;
  }
  const isEsLibBuild = config2.build.lib && format2 === "es";
  const esbuildOptions = config2.esbuild || {};
  const options3 = {
    ...esbuildOptions,
    target: target || void 0,
    format: rollupToEsbuildFormatMap[format2],
    supported: {
      "dynamic-import": true,
      "import-meta": true,
      ...esbuildOptions.supported
    }
  };
  if (!minify) {
    return {
      ...options3,
      minify: false,
      minifyIdentifiers: false,
      minifySyntax: false,
      minifyWhitespace: false,
      treeShaking: false
    };
  }
  if (options3.minifyIdentifiers != null || options3.minifySyntax != null || options3.minifyWhitespace != null) {
    if (isEsLibBuild) {
      return {
        ...options3,
        minify: false,
        minifyIdentifiers: (_a = options3.minifyIdentifiers) != null ? _a : true,
        minifySyntax: (_b = options3.minifySyntax) != null ? _b : true,
        minifyWhitespace: false,
        treeShaking: true
      };
    } else {
      return {
        ...options3,
        minify: false,
        minifyIdentifiers: (_c = options3.minifyIdentifiers) != null ? _c : true,
        minifySyntax: (_d = options3.minifySyntax) != null ? _d : true,
        minifyWhitespace: (_e = options3.minifyWhitespace) != null ? _e : true,
        treeShaking: true
      };
    }
  }
  if (isEsLibBuild) {
    return {
      ...options3,
      minify: false,
      minifyIdentifiers: true,
      minifySyntax: true,
      minifyWhitespace: false,
      treeShaking: true
    };
  } else {
    return {
      ...options3,
      minify: true,
      treeShaking: true
    };
  }
}
function prettifyMessage(m, code) {
  let res = picocolors.exports.yellow(m.text);
  if (m.location) {
    const lines = code.split(/\r?\n/g);
    const line2 = Number(m.location.line);
    const column2 = Number(m.location.column);
    const offset3 = lines.slice(0, line2 - 1).map((l) => l.length).reduce((total, l) => total + l + 1, 0) + column2;
    res += `
` + generateCodeFrame(code, offset3, offset3 + 1);
  }
  return res + `
`;
}
var tsconfckParseOptions = {
  cache: /* @__PURE__ */ new Map(),
  tsConfigPaths: void 0,
  root: void 0,
  resolveWithEmptyIfConfigNotFound: true
};
async function initTSConfck(config2) {
  const workspaceRoot = searchForWorkspaceRoot(config2.root);
  debug$f(`init tsconfck (root: ${picocolors.exports.cyan(workspaceRoot)})`);
  tsconfckParseOptions.cache.clear();
  tsconfckParseOptions.root = workspaceRoot;
  tsconfckParseOptions.tsConfigPaths = /* @__PURE__ */ new Set([
    ...await findAll(workspaceRoot, {
      skip: (dir) => dir === "node_modules" || dir === ".git"
    })
  ]);
  debug$f(`init tsconfck end`);
}
async function loadTsconfigJsonForFile(filename) {
  try {
    const result = await parse$g(filename, tsconfckParseOptions);
    if (server && result.tsconfigFile !== "no_tsconfig_file_found") {
      ensureWatchedFile(server.watcher, result.tsconfigFile, server.config.root);
    }
    return result.tsconfig;
  } catch (e) {
    if (e instanceof TSConfckParseError) {
      if (server && e.tsconfigFile) {
        ensureWatchedFile(server.watcher, e.tsconfigFile, server.config.root);
      }
    }
    throw e;
  }
}
function reloadOnTsconfigChange(changedFile) {
  var _a;
  if (import_node_path2.default.basename(changedFile) === "tsconfig.json" || changedFile.endsWith(".json") && ((_a = tsconfckParseOptions == null ? void 0 : tsconfckParseOptions.cache) == null ? void 0 : _a.has(changedFile))) {
    server.config.logger.info(`changed tsconfig file detected: ${changedFile} - Clearing cache and forcing full-reload to ensure TypeScript is compiled with updated config values.`, { clear: server.config.clearScreen, timestamp: true });
    server.moduleGraph.invalidateAll();
    initTSConfck(server.config).finally(() => {
      if (server) {
        server.ws.send({
          type: "full-reload",
          path: "*"
        });
      }
    });
  }
}
var dist$1 = {};
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(dist$1, "__esModule", { value: true });
var Worker_1 = dist$1.Worker = void 0;
var os_1 = __importDefault(import_os.default);
var worker_threads_1 = import_worker_threads.default;
var Worker = class {
  constructor(fn, options3 = {}) {
    this.code = genWorkerCode(fn);
    this.max = options3.max || Math.max(1, os_1.default.cpus().length - 1);
    this.pool = [];
    this.idlePool = [];
    this.queue = [];
  }
  async run(...args) {
    const worker = await this._getAvailableWorker();
    return new Promise((resolve3, reject) => {
      worker.currentResolve = resolve3;
      worker.currentReject = reject;
      worker.postMessage(args);
    });
  }
  stop() {
    this.pool.forEach((w) => w.unref());
    this.queue.forEach(([_, reject]) => reject(new Error("Main worker pool stopped before a worker was available.")));
    this.pool = [];
    this.idlePool = [];
    this.queue = [];
  }
  async _getAvailableWorker() {
    if (this.idlePool.length) {
      return this.idlePool.shift();
    }
    if (this.pool.length < this.max) {
      const worker = new worker_threads_1.Worker(this.code, { eval: true });
      worker.on("message", (res) => {
        worker.currentResolve && worker.currentResolve(res);
        worker.currentResolve = null;
        this._assignDoneWorker(worker);
      });
      worker.on("error", (err) => {
        worker.currentReject && worker.currentReject(err);
        worker.currentReject = null;
      });
      worker.on("exit", (code) => {
        const i = this.pool.indexOf(worker);
        if (i > -1)
          this.pool.splice(i, 1);
        if (code !== 0 && worker.currentReject) {
          worker.currentReject(new Error(`Wroker stopped with non-0 exit code ${code}`));
          worker.currentReject = null;
        }
      });
      this.pool.push(worker);
      return worker;
    }
    let resolve3;
    let reject;
    const onWorkerAvailablePromise = new Promise((r, rj) => {
      resolve3 = r;
      reject = rj;
    });
    this.queue.push([resolve3, reject]);
    return onWorkerAvailablePromise;
  }
  _assignDoneWorker(worker) {
    if (this.queue.length) {
      const [resolve3] = this.queue.shift();
      resolve3(worker);
      return;
    }
    this.idlePool.push(worker);
  }
};
Worker_1 = dist$1.Worker = Worker;
function genWorkerCode(fn) {
  return `
const doWork = ${fn.toString()}

const { parentPort } = require('worker_threads')

parentPort.on('message', async (args) => {
  const res = await doWork(...args)
  parentPort.postMessage(res)
})
  `;
}
var terserPath;
var loadTerserPath = (root2) => {
  if (terserPath)
    return terserPath;
  try {
    terserPath = requireResolveFromRootWithFallback(root2, "terser");
  } catch (e) {
    if (e.code === "MODULE_NOT_FOUND") {
      throw new Error("terser not found. Since Vite v3, terser has become an optional dependency. You need to install it.");
    } else {
      const message = new Error(`terser failed to load:
${e.message}`);
      message.stack = e.stack + "\n" + message.stack;
      throw message;
    }
  }
  return terserPath;
};
function terserPlugin(config2) {
  const makeWorker = () => new Worker_1(async (terserPath2, code, options3) => {
    const terser = require2(terserPath2);
    return terser.minify(code, options3);
  });
  let worker;
  return {
    name: "vite:terser",
    async renderChunk(code, _chunk, outputOptions) {
      if (config2.build.minify !== "terser" && !outputOptions.__vite_force_terser__) {
        return null;
      }
      if (config2.build.lib && outputOptions.format === "es") {
        return null;
      }
      worker || (worker = makeWorker());
      const terserPath2 = loadTerserPath(config2.root);
      const res = await worker.run(terserPath2, code, {
        safari10: true,
        ...config2.build.terserOptions,
        sourceMap: !!outputOptions.sourcemap,
        module: outputOptions.format.startsWith("es"),
        toplevel: outputOptions.format === "cjs"
      });
      return {
        code: res.code,
        map: res.map
      };
    },
    closeBundle() {
      worker == null ? void 0 : worker.stop();
    }
  };
}
var tasks = {};
var utils$g = {};
var array$1 = {};
Object.defineProperty(array$1, "__esModule", { value: true });
array$1.splitWhen = array$1.flatten = void 0;
function flatten$1(items) {
  return items.reduce((collection, item) => [].concat(collection, item), []);
}
array$1.flatten = flatten$1;
function splitWhen(items, predicate) {
  const result = [[]];
  let groupIndex = 0;
  for (const item of items) {
    if (predicate(item)) {
      groupIndex++;
      result[groupIndex] = [];
    } else {
      result[groupIndex].push(item);
    }
  }
  return result;
}
array$1.splitWhen = splitWhen;
var errno$1 = {};
Object.defineProperty(errno$1, "__esModule", { value: true });
errno$1.isEnoentCodeError = void 0;
function isEnoentCodeError(error2) {
  return error2.code === "ENOENT";
}
errno$1.isEnoentCodeError = isEnoentCodeError;
var fs$h = {};
Object.defineProperty(fs$h, "__esModule", { value: true });
fs$h.createDirentFromStats = void 0;
var DirentFromStats$1 = class {
  constructor(name, stats) {
    this.name = name;
    this.isBlockDevice = stats.isBlockDevice.bind(stats);
    this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
    this.isDirectory = stats.isDirectory.bind(stats);
    this.isFIFO = stats.isFIFO.bind(stats);
    this.isFile = stats.isFile.bind(stats);
    this.isSocket = stats.isSocket.bind(stats);
    this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
  }
};
function createDirentFromStats$1(name, stats) {
  return new DirentFromStats$1(name, stats);
}
fs$h.createDirentFromStats = createDirentFromStats$1;
var path$h = {};
Object.defineProperty(path$h, "__esModule", { value: true });
path$h.removeLeadingDotSegment = path$h.escape = path$h.makeAbsolute = path$h.unixify = void 0;
var path$g = import_path.default;
var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
var UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
function unixify(filepath) {
  return filepath.replace(/\\/g, "/");
}
path$h.unixify = unixify;
function makeAbsolute(cwd, filepath) {
  return path$g.resolve(cwd, filepath);
}
path$h.makeAbsolute = makeAbsolute;
function escape$3(pattern2) {
  return pattern2.replace(UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
}
path$h.escape = escape$3;
function removeLeadingDotSegment(entry2) {
  if (entry2.charAt(0) === ".") {
    const secondCharactery = entry2.charAt(1);
    if (secondCharactery === "/" || secondCharactery === "\\") {
      return entry2.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
    }
  }
  return entry2;
}
path$h.removeLeadingDotSegment = removeLeadingDotSegment;
var pattern$1 = {};
var isExtglob$1 = function isExtglob(str) {
  if (typeof str !== "string" || str === "") {
    return false;
  }
  var match;
  while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
    if (match[2])
      return true;
    str = str.slice(match.index + match[0].length);
  }
  return false;
};
var isExtglob2 = isExtglob$1;
var chars = { "{": "}", "(": ")", "[": "]" };
var strictCheck = function(str) {
  if (str[0] === "!") {
    return true;
  }
  var index2 = 0;
  var pipeIndex = -2;
  var closeSquareIndex = -2;
  var closeCurlyIndex = -2;
  var closeParenIndex = -2;
  var backSlashIndex = -2;
  while (index2 < str.length) {
    if (str[index2] === "*") {
      return true;
    }
    if (str[index2 + 1] === "?" && /[\].+)]/.test(str[index2])) {
      return true;
    }
    if (closeSquareIndex !== -1 && str[index2] === "[" && str[index2 + 1] !== "]") {
      if (closeSquareIndex < index2) {
        closeSquareIndex = str.indexOf("]", index2);
      }
      if (closeSquareIndex > index2) {
        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
          return true;
        }
        backSlashIndex = str.indexOf("\\", index2);
        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
          return true;
        }
      }
    }
    if (closeCurlyIndex !== -1 && str[index2] === "{" && str[index2 + 1] !== "}") {
      closeCurlyIndex = str.indexOf("}", index2);
      if (closeCurlyIndex > index2) {
        backSlashIndex = str.indexOf("\\", index2);
        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
          return true;
        }
      }
    }
    if (closeParenIndex !== -1 && str[index2] === "(" && str[index2 + 1] === "?" && /[:!=]/.test(str[index2 + 2]) && str[index2 + 3] !== ")") {
      closeParenIndex = str.indexOf(")", index2);
      if (closeParenIndex > index2) {
        backSlashIndex = str.indexOf("\\", index2);
        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
          return true;
        }
      }
    }
    if (pipeIndex !== -1 && str[index2] === "(" && str[index2 + 1] !== "|") {
      if (pipeIndex < index2) {
        pipeIndex = str.indexOf("|", index2);
      }
      if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
        closeParenIndex = str.indexOf(")", pipeIndex);
        if (closeParenIndex > pipeIndex) {
          backSlashIndex = str.indexOf("\\", pipeIndex);
          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
            return true;
          }
        }
      }
    }
    if (str[index2] === "\\") {
      var open2 = str[index2 + 1];
      index2 += 2;
      var close2 = chars[open2];
      if (close2) {
        var n2 = str.indexOf(close2, index2);
        if (n2 !== -1) {
          index2 = n2 + 1;
        }
      }
      if (str[index2] === "!") {
        return true;
      }
    } else {
      index2++;
    }
  }
  return false;
};
var relaxedCheck = function(str) {
  if (str[0] === "!") {
    return true;
  }
  var index2 = 0;
  while (index2 < str.length) {
    if (/[*?{}()[\]]/.test(str[index2])) {
      return true;
    }
    if (str[index2] === "\\") {
      var open2 = str[index2 + 1];
      index2 += 2;
      var close2 = chars[open2];
      if (close2) {
        var n2 = str.indexOf(close2, index2);
        if (n2 !== -1) {
          index2 = n2 + 1;
        }
      }
      if (str[index2] === "!") {
        return true;
      }
    } else {
      index2++;
    }
  }
  return false;
};
var isGlob$2 = function isGlob(str, options3) {
  if (typeof str !== "string" || str === "") {
    return false;
  }
  if (isExtglob2(str)) {
    return true;
  }
  var check = strictCheck;
  if (options3 && options3.strict === false) {
    check = relaxedCheck;
  }
  return check(str);
};
var isGlob$1 = isGlob$2;
var pathPosixDirname = import_path.default.posix.dirname;
var isWin32 = import_os.default.platform() === "win32";
var slash = "/";
var backslash = /\\/g;
var enclosure = /[\{\[].*[\}\]]$/;
var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
var globParent$2 = function globParent(str, opts) {
  var options3 = Object.assign({ flipBackslashes: true }, opts);
  if (options3.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
    str = str.replace(backslash, slash);
  }
  if (enclosure.test(str)) {
    str += slash;
  }
  str += "a";
  do {
    str = pathPosixDirname(str);
  } while (isGlob$1(str) || globby.test(str));
  return str.replace(escaped, "$1");
};
var utils$f = {};
(function(exports) {
  exports.isInteger = (num) => {
    if (typeof num === "number") {
      return Number.isInteger(num);
    }
    if (typeof num === "string" && num.trim() !== "") {
      return Number.isInteger(Number(num));
    }
    return false;
  };
  exports.find = (node2, type) => node2.nodes.find((node3) => node3.type === type);
  exports.exceedsLimit = (min2, max, step = 1, limit) => {
    if (limit === false)
      return false;
    if (!exports.isInteger(min2) || !exports.isInteger(max))
      return false;
    return (Number(max) - Number(min2)) / Number(step) >= limit;
  };
  exports.escapeNode = (block, n2 = 0, type) => {
    let node2 = block.nodes[n2];
    if (!node2)
      return;
    if (type && node2.type === type || node2.type === "open" || node2.type === "close") {
      if (node2.escaped !== true) {
        node2.value = "\\" + node2.value;
        node2.escaped = true;
      }
    }
  };
  exports.encloseBrace = (node2) => {
    if (node2.type !== "brace")
      return false;
    if (node2.commas >> 0 + node2.ranges >> 0 === 0) {
      node2.invalid = true;
      return true;
    }
    return false;
  };
  exports.isInvalidBrace = (block) => {
    if (block.type !== "brace")
      return false;
    if (block.invalid === true || block.dollar)
      return true;
    if (block.commas >> 0 + block.ranges >> 0 === 0) {
      block.invalid = true;
      return true;
    }
    if (block.open !== true || block.close !== true) {
      block.invalid = true;
      return true;
    }
    return false;
  };
  exports.isOpenOrClose = (node2) => {
    if (node2.type === "open" || node2.type === "close") {
      return true;
    }
    return node2.open === true || node2.close === true;
  };
  exports.reduce = (nodes) => nodes.reduce((acc, node2) => {
    if (node2.type === "text")
      acc.push(node2.value);
    if (node2.type === "range")
      node2.type = "text";
    return acc;
  }, []);
  exports.flatten = (...args) => {
    const result = [];
    const flat = (arr) => {
      for (let i = 0; i < arr.length; i++) {
        let ele = arr[i];
        Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);
      }
      return result;
    };
    flat(args);
    return result;
  };
})(utils$f);
var utils$e = utils$f;
var stringify$8 = (ast, options3 = {}) => {
  let stringify3 = (node2, parent = {}) => {
    let invalidBlock = options3.escapeInvalid && utils$e.isInvalidBrace(parent);
    let invalidNode = node2.invalid === true && options3.escapeInvalid === true;
    let output = "";
    if (node2.value) {
      if ((invalidBlock || invalidNode) && utils$e.isOpenOrClose(node2)) {
        return "\\" + node2.value;
      }
      return node2.value;
    }
    if (node2.value) {
      return node2.value;
    }
    if (node2.nodes) {
      for (let child of node2.nodes) {
        output += stringify3(child);
      }
    }
    return output;
  };
  return stringify3(ast);
};
var isNumber$2 = function(num) {
  if (typeof num === "number") {
    return num - num === 0;
  }
  if (typeof num === "string" && num.trim() !== "") {
    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
  }
  return false;
};
var isNumber$1 = isNumber$2;
var toRegexRange$1 = (min2, max, options3) => {
  if (isNumber$1(min2) === false) {
    throw new TypeError("toRegexRange: expected the first argument to be a number");
  }
  if (max === void 0 || min2 === max) {
    return String(min2);
  }
  if (isNumber$1(max) === false) {
    throw new TypeError("toRegexRange: expected the second argument to be a number.");
  }
  let opts = { relaxZeros: true, ...options3 };
  if (typeof opts.strictZeros === "boolean") {
    opts.relaxZeros = opts.strictZeros === false;
  }
  let relax = String(opts.relaxZeros);
  let shorthand = String(opts.shorthand);
  let capture = String(opts.capture);
  let wrap2 = String(opts.wrap);
  let cacheKey = min2 + ":" + max + "=" + relax + shorthand + capture + wrap2;
  if (toRegexRange$1.cache.hasOwnProperty(cacheKey)) {
    return toRegexRange$1.cache[cacheKey].result;
  }
  let a = Math.min(min2, max);
  let b = Math.max(min2, max);
  if (Math.abs(a - b) === 1) {
    let result = min2 + "|" + max;
    if (opts.capture) {
      return `(${result})`;
    }
    if (opts.wrap === false) {
      return result;
    }
    return `(?:${result})`;
  }
  let isPadded2 = hasPadding(min2) || hasPadding(max);
  let state = { min: min2, max, a, b };
  let positives = [];
  let negatives = [];
  if (isPadded2) {
    state.isPadded = isPadded2;
    state.maxLen = String(state.max).length;
  }
  if (a < 0) {
    let newMin = b < 0 ? Math.abs(b) : 1;
    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
    a = state.a = 0;
  }
  if (b >= 0) {
    positives = splitToPatterns(a, b, state, opts);
  }
  state.negatives = negatives;
  state.positives = positives;
  state.result = collatePatterns(negatives, positives);
  if (opts.capture === true) {
    state.result = `(${state.result})`;
  } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
    state.result = `(?:${state.result})`;
  }
  toRegexRange$1.cache[cacheKey] = state;
  return state.result;
};
function collatePatterns(neg, pos2, options3) {
  let onlyNegative = filterPatterns(neg, pos2, "-", false) || [];
  let onlyPositive = filterPatterns(pos2, neg, "", false) || [];
  let intersected = filterPatterns(neg, pos2, "-?", true) || [];
  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
  return subpatterns.join("|");
}
function splitToRanges(min2, max) {
  let nines = 1;
  let zeros2 = 1;
  let stop = countNines(min2, nines);
  let stops = /* @__PURE__ */ new Set([max]);
  while (min2 <= stop && stop <= max) {
    stops.add(stop);
    nines += 1;
    stop = countNines(min2, nines);
  }
  stop = countZeros(max + 1, zeros2) - 1;
  while (min2 < stop && stop <= max) {
    stops.add(stop);
    zeros2 += 1;
    stop = countZeros(max + 1, zeros2) - 1;
  }
  stops = [...stops];
  stops.sort(compare);
  return stops;
}
function rangeToPattern(start, stop, options3) {
  if (start === stop) {
    return { pattern: start, count: [], digits: 0 };
  }
  let zipped = zip(start, stop);
  let digits = zipped.length;
  let pattern2 = "";
  let count = 0;
  for (let i = 0; i < digits; i++) {
    let [startDigit, stopDigit] = zipped[i];
    if (startDigit === stopDigit) {
      pattern2 += startDigit;
    } else if (startDigit !== "0" || stopDigit !== "9") {
      pattern2 += toCharacterClass(startDigit, stopDigit);
    } else {
      count++;
    }
  }
  if (count) {
    pattern2 += options3.shorthand === true ? "\\d" : "[0-9]";
  }
  return { pattern: pattern2, count: [count], digits };
}
function splitToPatterns(min2, max, tok, options3) {
  let ranges = splitToRanges(min2, max);
  let tokens = [];
  let start = min2;
  let prev;
  for (let i = 0; i < ranges.length; i++) {
    let max2 = ranges[i];
    let obj = rangeToPattern(String(start), String(max2), options3);
    let zeros2 = "";
    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
      if (prev.count.length > 1) {
        prev.count.pop();
      }
      prev.count.push(obj.count[0]);
      prev.string = prev.pattern + toQuantifier(prev.count);
      start = max2 + 1;
      continue;
    }
    if (tok.isPadded) {
      zeros2 = padZeros(max2, tok, options3);
    }
    obj.string = zeros2 + obj.pattern + toQuantifier(obj.count);
    tokens.push(obj);
    start = max2 + 1;
    prev = obj;
  }
  return tokens;
}
function filterPatterns(arr, comparison, prefix, intersection, options3) {
  let result = [];
  for (let ele of arr) {
    let { string: string2 } = ele;
    if (!intersection && !contains(comparison, "string", string2)) {
      result.push(prefix + string2);
    }
    if (intersection && contains(comparison, "string", string2)) {
      result.push(prefix + string2);
    }
  }
  return result;
}
function zip(a, b) {
  let arr = [];
  for (let i = 0; i < a.length; i++)
    arr.push([a[i], b[i]]);
  return arr;
}
function compare(a, b) {
  return a > b ? 1 : b > a ? -1 : 0;
}
function contains(arr, key2, val) {
  return arr.some((ele) => ele[key2] === val);
}
function countNines(min2, len) {
  return Number(String(min2).slice(0, -len) + "9".repeat(len));
}
function countZeros(integer, zeros2) {
  return integer - integer % Math.pow(10, zeros2);
}
function toQuantifier(digits) {
  let [start = 0, stop = ""] = digits;
  if (stop || start > 1) {
    return `{${start + (stop ? "," + stop : "")}}`;
  }
  return "";
}
function toCharacterClass(a, b, options3) {
  return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
}
function hasPadding(str) {
  return /^-?(0+)\d/.test(str);
}
function padZeros(value2, tok, options3) {
  if (!tok.isPadded) {
    return value2;
  }
  let diff = Math.abs(tok.maxLen - String(value2).length);
  let relax = options3.relaxZeros !== false;
  switch (diff) {
    case 0:
      return "";
    case 1:
      return relax ? "0?" : "0";
    case 2:
      return relax ? "0{0,2}" : "00";
    default: {
      return relax ? `0{0,${diff}}` : `0{${diff}}`;
    }
  }
}
toRegexRange$1.cache = {};
toRegexRange$1.clearCache = () => toRegexRange$1.cache = {};
var toRegexRange_1 = toRegexRange$1;
var util$2 = import_util.default;
var toRegexRange = toRegexRange_1;
var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
var transform$1 = (toNumber) => {
  return (value2) => toNumber === true ? Number(value2) : String(value2);
};
var isValidValue = (value2) => {
  return typeof value2 === "number" || typeof value2 === "string" && value2 !== "";
};
var isNumber = (num) => Number.isInteger(+num);
var zeros = (input) => {
  let value2 = `${input}`;
  let index2 = -1;
  if (value2[0] === "-")
    value2 = value2.slice(1);
  if (value2 === "0")
    return false;
  while (value2[++index2] === "0")
    ;
  return index2 > 0;
};
var stringify$7 = (start, end, options3) => {
  if (typeof start === "string" || typeof end === "string") {
    return true;
  }
  return options3.stringify === true;
};
var pad = (input, maxLength, toNumber) => {
  if (maxLength > 0) {
    let dash = input[0] === "-" ? "-" : "";
    if (dash)
      input = input.slice(1);
    input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
  }
  if (toNumber === false) {
    return String(input);
  }
  return input;
};
var toMaxLen = (input, maxLength) => {
  let negative = input[0] === "-" ? "-" : "";
  if (negative) {
    input = input.slice(1);
    maxLength--;
  }
  while (input.length < maxLength)
    input = "0" + input;
  return negative ? "-" + input : input;
};
var toSequence = (parts, options3) => {
  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
  let prefix = options3.capture ? "" : "?:";
  let positives = "";
  let negatives = "";
  let result;
  if (parts.positives.length) {
    positives = parts.positives.join("|");
  }
  if (parts.negatives.length) {
    negatives = `-(${prefix}${parts.negatives.join("|")})`;
  }
  if (positives && negatives) {
    result = `${positives}|${negatives}`;
  } else {
    result = positives || negatives;
  }
  if (options3.wrap) {
    return `(${prefix}${result})`;
  }
  return result;
};
var toRange = (a, b, isNumbers, options3) => {
  if (isNumbers) {
    return toRegexRange(a, b, { wrap: false, ...options3 });
  }
  let start = String.fromCharCode(a);
  if (a === b)
    return start;
  let stop = String.fromCharCode(b);
  return `[${start}-${stop}]`;
};
var toRegex = (start, end, options3) => {
  if (Array.isArray(start)) {
    let wrap2 = options3.wrap === true;
    let prefix = options3.capture ? "" : "?:";
    return wrap2 ? `(${prefix}${start.join("|")})` : start.join("|");
  }
  return toRegexRange(start, end, options3);
};
var rangeError = (...args) => {
  return new RangeError("Invalid range arguments: " + util$2.inspect(...args));
};
var invalidRange = (start, end, options3) => {
  if (options3.strictRanges === true)
    throw rangeError([start, end]);
  return [];
};
var invalidStep = (step, options3) => {
  if (options3.strictRanges === true) {
    throw new TypeError(`Expected step "${step}" to be a number`);
  }
  return [];
};
var fillNumbers = (start, end, step = 1, options3 = {}) => {
  let a = Number(start);
  let b = Number(end);
  if (!Number.isInteger(a) || !Number.isInteger(b)) {
    if (options3.strictRanges === true)
      throw rangeError([start, end]);
    return [];
  }
  if (a === 0)
    a = 0;
  if (b === 0)
    b = 0;
  let descending = a > b;
  let startString = String(start);
  let endString = String(end);
  let stepString = String(step);
  step = Math.max(Math.abs(step), 1);
  let padded = zeros(startString) || zeros(endString) || zeros(stepString);
  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
  let toNumber = padded === false && stringify$7(start, end, options3) === false;
  let format2 = options3.transform || transform$1(toNumber);
  if (options3.toRegex && step === 1) {
    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options3);
  }
  let parts = { negatives: [], positives: [] };
  let push2 = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
  let range2 = [];
  let index2 = 0;
  while (descending ? a >= b : a <= b) {
    if (options3.toRegex === true && step > 1) {
      push2(a);
    } else {
      range2.push(pad(format2(a, index2), maxLen, toNumber));
    }
    a = descending ? a - step : a + step;
    index2++;
  }
  if (options3.toRegex === true) {
    return step > 1 ? toSequence(parts, options3) : toRegex(range2, null, { wrap: false, ...options3 });
  }
  return range2;
};
var fillLetters = (start, end, step = 1, options3 = {}) => {
  if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
    return invalidRange(start, end, options3);
  }
  let format2 = options3.transform || ((val) => String.fromCharCode(val));
  let a = `${start}`.charCodeAt(0);
  let b = `${end}`.charCodeAt(0);
  let descending = a > b;
  let min2 = Math.min(a, b);
  let max = Math.max(a, b);
  if (options3.toRegex && step === 1) {
    return toRange(min2, max, false, options3);
  }
  let range2 = [];
  let index2 = 0;
  while (descending ? a >= b : a <= b) {
    range2.push(format2(a, index2));
    a = descending ? a - step : a + step;
    index2++;
  }
  if (options3.toRegex === true) {
    return toRegex(range2, null, { wrap: false, options: options3 });
  }
  return range2;
};
var fill$2 = (start, end, step, options3 = {}) => {
  if (end == null && isValidValue(start)) {
    return [start];
  }
  if (!isValidValue(start) || !isValidValue(end)) {
    return invalidRange(start, end, options3);
  }
  if (typeof step === "function") {
    return fill$2(start, end, 1, { transform: step });
  }
  if (isObject(step)) {
    return fill$2(start, end, 0, step);
  }
  let opts = { ...options3 };
  if (opts.capture === true)
    opts.wrap = true;
  step = step || opts.step || 1;
  if (!isNumber(step)) {
    if (step != null && !isObject(step))
      return invalidStep(step, opts);
    return fill$2(start, end, 1, step);
  }
  if (isNumber(start) && isNumber(end)) {
    return fillNumbers(start, end, step, opts);
  }
  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
};
var fillRange = fill$2;
var fill$1 = fillRange;
var utils$d = utils$f;
var compile$1 = (ast, options3 = {}) => {
  let walk2 = (node2, parent = {}) => {
    let invalidBlock = utils$d.isInvalidBrace(parent);
    let invalidNode = node2.invalid === true && options3.escapeInvalid === true;
    let invalid = invalidBlock === true || invalidNode === true;
    let prefix = options3.escapeInvalid === true ? "\\" : "";
    let output = "";
    if (node2.isOpen === true) {
      return prefix + node2.value;
    }
    if (node2.isClose === true) {
      return prefix + node2.value;
    }
    if (node2.type === "open") {
      return invalid ? prefix + node2.value : "(";
    }
    if (node2.type === "close") {
      return invalid ? prefix + node2.value : ")";
    }
    if (node2.type === "comma") {
      return node2.prev.type === "comma" ? "" : invalid ? node2.value : "|";
    }
    if (node2.value) {
      return node2.value;
    }
    if (node2.nodes && node2.ranges > 0) {
      let args = utils$d.reduce(node2.nodes);
      let range2 = fill$1(...args, { ...options3, wrap: false, toRegex: true });
      if (range2.length !== 0) {
        return args.length > 1 && range2.length > 1 ? `(${range2})` : range2;
      }
    }
    if (node2.nodes) {
      for (let child of node2.nodes) {
        output += walk2(child, node2);
      }
    }
    return output;
  };
  return walk2(ast);
};
var compile_1 = compile$1;
var fill = fillRange;
var stringify$6 = stringify$8;
var utils$c = utils$f;
var append$1 = (queue2 = "", stash = "", enclose = false) => {
  let result = [];
  queue2 = [].concat(queue2);
  stash = [].concat(stash);
  if (!stash.length)
    return queue2;
  if (!queue2.length) {
    return enclose ? utils$c.flatten(stash).map((ele) => `{${ele}}`) : stash;
  }
  for (let item of queue2) {
    if (Array.isArray(item)) {
      for (let value2 of item) {
        result.push(append$1(value2, stash, enclose));
      }
    } else {
      for (let ele of stash) {
        if (enclose === true && typeof ele === "string")
          ele = `{${ele}}`;
        result.push(Array.isArray(ele) ? append$1(item, ele, enclose) : item + ele);
      }
    }
  }
  return utils$c.flatten(result);
};
var expand$1 = (ast, options3 = {}) => {
  let rangeLimit = options3.rangeLimit === void 0 ? 1e3 : options3.rangeLimit;
  let walk2 = (node2, parent = {}) => {
    node2.queue = [];
    let p = parent;
    let q = parent.queue;
    while (p.type !== "brace" && p.type !== "root" && p.parent) {
      p = p.parent;
      q = p.queue;
    }
    if (node2.invalid || node2.dollar) {
      q.push(append$1(q.pop(), stringify$6(node2, options3)));
      return;
    }
    if (node2.type === "brace" && node2.invalid !== true && node2.nodes.length === 2) {
      q.push(append$1(q.pop(), ["{}"]));
      return;
    }
    if (node2.nodes && node2.ranges > 0) {
      let args = utils$c.reduce(node2.nodes);
      if (utils$c.exceedsLimit(...args, options3.step, rangeLimit)) {
        throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
      }
      let range2 = fill(...args, options3);
      if (range2.length === 0) {
        range2 = stringify$6(node2, options3);
      }
      q.push(append$1(q.pop(), range2));
      node2.nodes = [];
      return;
    }
    let enclose = utils$c.encloseBrace(node2);
    let queue2 = node2.queue;
    let block = node2;
    while (block.type !== "brace" && block.type !== "root" && block.parent) {
      block = block.parent;
      queue2 = block.queue;
    }
    for (let i = 0; i < node2.nodes.length; i++) {
      let child = node2.nodes[i];
      if (child.type === "comma" && node2.type === "brace") {
        if (i === 1)
          queue2.push("");
        queue2.push("");
        continue;
      }
      if (child.type === "close") {
        q.push(append$1(q.pop(), queue2, enclose));
        continue;
      }
      if (child.value && child.type !== "open") {
        queue2.push(append$1(queue2.pop(), child.value));
        continue;
      }
      if (child.nodes) {
        walk2(child, node2);
      }
    }
    return queue2;
  };
  return utils$c.flatten(walk2(ast));
};
var expand_1 = expand$1;
var constants$3 = {
  MAX_LENGTH: 1024 * 64,
  CHAR_0: "0",
  CHAR_9: "9",
  CHAR_UPPERCASE_A: "A",
  CHAR_LOWERCASE_A: "a",
  CHAR_UPPERCASE_Z: "Z",
  CHAR_LOWERCASE_Z: "z",
  CHAR_LEFT_PARENTHESES: "(",
  CHAR_RIGHT_PARENTHESES: ")",
  CHAR_ASTERISK: "*",
  CHAR_AMPERSAND: "&",
  CHAR_AT: "@",
  CHAR_BACKSLASH: "\\",
  CHAR_BACKTICK: "`",
  CHAR_CARRIAGE_RETURN: "\r",
  CHAR_CIRCUMFLEX_ACCENT: "^",
  CHAR_COLON: ":",
  CHAR_COMMA: ",",
  CHAR_DOLLAR: "$",
  CHAR_DOT: ".",
  CHAR_DOUBLE_QUOTE: '"',
  CHAR_EQUAL: "=",
  CHAR_EXCLAMATION_MARK: "!",
  CHAR_FORM_FEED: "\f",
  CHAR_FORWARD_SLASH: "/",
  CHAR_HASH: "#",
  CHAR_HYPHEN_MINUS: "-",
  CHAR_LEFT_ANGLE_BRACKET: "<",
  CHAR_LEFT_CURLY_BRACE: "{",
  CHAR_LEFT_SQUARE_BRACKET: "[",
  CHAR_LINE_FEED: "\n",
  CHAR_NO_BREAK_SPACE: "\xA0",
  CHAR_PERCENT: "%",
  CHAR_PLUS: "+",
  CHAR_QUESTION_MARK: "?",
  CHAR_RIGHT_ANGLE_BRACKET: ">",
  CHAR_RIGHT_CURLY_BRACE: "}",
  CHAR_RIGHT_SQUARE_BRACKET: "]",
  CHAR_SEMICOLON: ";",
  CHAR_SINGLE_QUOTE: "'",
  CHAR_SPACE: " ",
  CHAR_TAB: "	",
  CHAR_UNDERSCORE: "_",
  CHAR_VERTICAL_LINE: "|",
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
};
var stringify$5 = stringify$8;
var {
  MAX_LENGTH,
  CHAR_BACKSLASH,
  CHAR_BACKTICK,
  CHAR_COMMA,
  CHAR_DOT,
  CHAR_LEFT_PARENTHESES,
  CHAR_RIGHT_PARENTHESES,
  CHAR_LEFT_CURLY_BRACE,
  CHAR_RIGHT_CURLY_BRACE,
  CHAR_LEFT_SQUARE_BRACKET,
  CHAR_RIGHT_SQUARE_BRACKET,
  CHAR_DOUBLE_QUOTE,
  CHAR_SINGLE_QUOTE,
  CHAR_NO_BREAK_SPACE,
  CHAR_ZERO_WIDTH_NOBREAK_SPACE
} = constants$3;
var parse$f = (input, options3 = {}) => {
  if (typeof input !== "string") {
    throw new TypeError("Expected a string");
  }
  let opts = options3 || {};
  let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  if (input.length > max) {
    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
  }
  let ast = { type: "root", input, nodes: [] };
  let stack2 = [ast];
  let block = ast;
  let prev = ast;
  let brackets = 0;
  let length = input.length;
  let index2 = 0;
  let depth2 = 0;
  let value2;
  const advance2 = () => input[index2++];
  const push2 = (node2) => {
    if (node2.type === "text" && prev.type === "dot") {
      prev.type = "text";
    }
    if (prev && prev.type === "text" && node2.type === "text") {
      prev.value += node2.value;
      return;
    }
    block.nodes.push(node2);
    node2.parent = block;
    node2.prev = prev;
    prev = node2;
    return node2;
  };
  push2({ type: "bos" });
  while (index2 < length) {
    block = stack2[stack2.length - 1];
    value2 = advance2();
    if (value2 === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value2 === CHAR_NO_BREAK_SPACE) {
      continue;
    }
    if (value2 === CHAR_BACKSLASH) {
      push2({ type: "text", value: (options3.keepEscaping ? value2 : "") + advance2() });
      continue;
    }
    if (value2 === CHAR_RIGHT_SQUARE_BRACKET) {
      push2({ type: "text", value: "\\" + value2 });
      continue;
    }
    if (value2 === CHAR_LEFT_SQUARE_BRACKET) {
      brackets++;
      let next;
      while (index2 < length && (next = advance2())) {
        value2 += next;
        if (next === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          continue;
        }
        if (next === CHAR_BACKSLASH) {
          value2 += advance2();
          continue;
        }
        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
          brackets--;
          if (brackets === 0) {
            break;
          }
        }
      }
      push2({ type: "text", value: value2 });
      continue;
    }
    if (value2 === CHAR_LEFT_PARENTHESES) {
      block = push2({ type: "paren", nodes: [] });
      stack2.push(block);
      push2({ type: "text", value: value2 });
      continue;
    }
    if (value2 === CHAR_RIGHT_PARENTHESES) {
      if (block.type !== "paren") {
        push2({ type: "text", value: value2 });
        continue;
      }
      block = stack2.pop();
      push2({ type: "text", value: value2 });
      block = stack2[stack2.length - 1];
      continue;
    }
    if (value2 === CHAR_DOUBLE_QUOTE || value2 === CHAR_SINGLE_QUOTE || value2 === CHAR_BACKTICK) {
      let open2 = value2;
      let next;
      if (options3.keepQuotes !== true) {
        value2 = "";
      }
      while (index2 < length && (next = advance2())) {
        if (next === CHAR_BACKSLASH) {
          value2 += next + advance2();
          continue;
        }
        if (next === open2) {
          if (options3.keepQuotes === true)
            value2 += next;
          break;
        }
        value2 += next;
      }
      push2({ type: "text", value: value2 });
      continue;
    }
    if (value2 === CHAR_LEFT_CURLY_BRACE) {
      depth2++;
      let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
      let brace = {
        type: "brace",
        open: true,
        close: false,
        dollar,
        depth: depth2,
        commas: 0,
        ranges: 0,
        nodes: []
      };
      block = push2(brace);
      stack2.push(block);
      push2({ type: "open", value: value2 });
      continue;
    }
    if (value2 === CHAR_RIGHT_CURLY_BRACE) {
      if (block.type !== "brace") {
        push2({ type: "text", value: value2 });
        continue;
      }
      let type = "close";
      block = stack2.pop();
      block.close = true;
      push2({ type, value: value2 });
      depth2--;
      block = stack2[stack2.length - 1];
      continue;
    }
    if (value2 === CHAR_COMMA && depth2 > 0) {
      if (block.ranges > 0) {
        block.ranges = 0;
        let open2 = block.nodes.shift();
        block.nodes = [open2, { type: "text", value: stringify$5(block) }];
      }
      push2({ type: "comma", value: value2 });
      block.commas++;
      continue;
    }
    if (value2 === CHAR_DOT && depth2 > 0 && block.commas === 0) {
      let siblings = block.nodes;
      if (depth2 === 0 || siblings.length === 0) {
        push2({ type: "text", value: value2 });
        continue;
      }
      if (prev.type === "dot") {
        block.range = [];
        prev.value += value2;
        prev.type = "range";
        if (block.nodes.length !== 3 && block.nodes.length !== 5) {
          block.invalid = true;
          block.ranges = 0;
          prev.type = "text";
          continue;
        }
        block.ranges++;
        block.args = [];
        continue;
      }
      if (prev.type === "range") {
        siblings.pop();
        let before = siblings[siblings.length - 1];
        before.value += prev.value + value2;
        prev = before;
        block.ranges--;
        continue;
      }
      push2({ type: "dot", value: value2 });
      continue;
    }
    push2({ type: "text", value: value2 });
  }
  do {
    block = stack2.pop();
    if (block.type !== "root") {
      block.nodes.forEach((node2) => {
        if (!node2.nodes) {
          if (node2.type === "open")
            node2.isOpen = true;
          if (node2.type === "close")
            node2.isClose = true;
          if (!node2.nodes)
            node2.type = "text";
          node2.invalid = true;
        }
      });
      let parent = stack2[stack2.length - 1];
      let index3 = parent.nodes.indexOf(block);
      parent.nodes.splice(index3, 1, ...block.nodes);
    }
  } while (stack2.length > 0);
  push2({ type: "eos" });
  return ast;
};
var parse_1$1 = parse$f;
var stringify$4 = stringify$8;
var compile = compile_1;
var expand = expand_1;
var parse$e = parse_1$1;
var braces$2 = (input, options3 = {}) => {
  let output = [];
  if (Array.isArray(input)) {
    for (let pattern2 of input) {
      let result = braces$2.create(pattern2, options3);
      if (Array.isArray(result)) {
        output.push(...result);
      } else {
        output.push(result);
      }
    }
  } else {
    output = [].concat(braces$2.create(input, options3));
  }
  if (options3 && options3.expand === true && options3.nodupes === true) {
    output = [...new Set(output)];
  }
  return output;
};
braces$2.parse = (input, options3 = {}) => parse$e(input, options3);
braces$2.stringify = (input, options3 = {}) => {
  if (typeof input === "string") {
    return stringify$4(braces$2.parse(input, options3), options3);
  }
  return stringify$4(input, options3);
};
braces$2.compile = (input, options3 = {}) => {
  if (typeof input === "string") {
    input = braces$2.parse(input, options3);
  }
  return compile(input, options3);
};
braces$2.expand = (input, options3 = {}) => {
  if (typeof input === "string") {
    input = braces$2.parse(input, options3);
  }
  let result = expand(input, options3);
  if (options3.noempty === true) {
    result = result.filter(Boolean);
  }
  if (options3.nodupes === true) {
    result = [...new Set(result)];
  }
  return result;
};
braces$2.create = (input, options3 = {}) => {
  if (input === "" || input.length < 3) {
    return [input];
  }
  return options3.expand !== true ? braces$2.compile(input, options3) : braces$2.expand(input, options3);
};
var braces_1 = braces$2;
var util$1 = import_util.default;
var braces$1 = braces_1;
var picomatch$2 = picomatch$5.exports;
var utils$b = utils$k;
var isEmptyString = (val) => val === "" || val === "./";
var micromatch$1 = (list, patterns2, options3) => {
  patterns2 = [].concat(patterns2);
  list = [].concat(list);
  let omit = /* @__PURE__ */ new Set();
  let keep = /* @__PURE__ */ new Set();
  let items = /* @__PURE__ */ new Set();
  let negatives = 0;
  let onResult = (state) => {
    items.add(state.output);
    if (options3 && options3.onResult) {
      options3.onResult(state);
    }
  };
  for (let i = 0; i < patterns2.length; i++) {
    let isMatch2 = picomatch$2(String(patterns2[i]), { ...options3, onResult }, true);
    let negated = isMatch2.state.negated || isMatch2.state.negatedExtglob;
    if (negated)
      negatives++;
    for (let item of list) {
      let matched = isMatch2(item, true);
      let match = negated ? !matched.isMatch : matched.isMatch;
      if (!match)
        continue;
      if (negated) {
        omit.add(matched.output);
      } else {
        omit.delete(matched.output);
        keep.add(matched.output);
      }
    }
  }
  let result = negatives === patterns2.length ? [...items] : [...keep];
  let matches2 = result.filter((item) => !omit.has(item));
  if (options3 && matches2.length === 0) {
    if (options3.failglob === true) {
      throw new Error(`No matches found for "${patterns2.join(", ")}"`);
    }
    if (options3.nonull === true || options3.nullglob === true) {
      return options3.unescape ? patterns2.map((p) => p.replace(/\\/g, "")) : patterns2;
    }
  }
  return matches2;
};
micromatch$1.match = micromatch$1;
micromatch$1.matcher = (pattern2, options3) => picomatch$2(pattern2, options3);
micromatch$1.isMatch = (str, patterns2, options3) => picomatch$2(patterns2, options3)(str);
micromatch$1.any = micromatch$1.isMatch;
micromatch$1.not = (list, patterns2, options3 = {}) => {
  patterns2 = [].concat(patterns2).map(String);
  let result = /* @__PURE__ */ new Set();
  let items = [];
  let onResult = (state) => {
    if (options3.onResult)
      options3.onResult(state);
    items.push(state.output);
  };
  let matches2 = new Set(micromatch$1(list, patterns2, { ...options3, onResult }));
  for (let item of items) {
    if (!matches2.has(item)) {
      result.add(item);
    }
  }
  return [...result];
};
micromatch$1.contains = (str, pattern2, options3) => {
  if (typeof str !== "string") {
    throw new TypeError(`Expected a string: "${util$1.inspect(str)}"`);
  }
  if (Array.isArray(pattern2)) {
    return pattern2.some((p) => micromatch$1.contains(str, p, options3));
  }
  if (typeof pattern2 === "string") {
    if (isEmptyString(str) || isEmptyString(pattern2)) {
      return false;
    }
    if (str.includes(pattern2) || str.startsWith("./") && str.slice(2).includes(pattern2)) {
      return true;
    }
  }
  return micromatch$1.isMatch(str, pattern2, { ...options3, contains: true });
};
micromatch$1.matchKeys = (obj, patterns2, options3) => {
  if (!utils$b.isObject(obj)) {
    throw new TypeError("Expected the first argument to be an object");
  }
  let keys = micromatch$1(Object.keys(obj), patterns2, options3);
  let res = {};
  for (let key2 of keys)
    res[key2] = obj[key2];
  return res;
};
micromatch$1.some = (list, patterns2, options3) => {
  let items = [].concat(list);
  for (let pattern2 of [].concat(patterns2)) {
    let isMatch2 = picomatch$2(String(pattern2), options3);
    if (items.some((item) => isMatch2(item))) {
      return true;
    }
  }
  return false;
};
micromatch$1.every = (list, patterns2, options3) => {
  let items = [].concat(list);
  for (let pattern2 of [].concat(patterns2)) {
    let isMatch2 = picomatch$2(String(pattern2), options3);
    if (!items.every((item) => isMatch2(item))) {
      return false;
    }
  }
  return true;
};
micromatch$1.all = (str, patterns2, options3) => {
  if (typeof str !== "string") {
    throw new TypeError(`Expected a string: "${util$1.inspect(str)}"`);
  }
  return [].concat(patterns2).every((p) => picomatch$2(p, options3)(str));
};
micromatch$1.capture = (glob, input, options3) => {
  let posix2 = utils$b.isWindows(options3);
  let regex = picomatch$2.makeRe(String(glob), { ...options3, capture: true });
  let match = regex.exec(posix2 ? utils$b.toPosixSlashes(input) : input);
  if (match) {
    return match.slice(1).map((v) => v === void 0 ? "" : v);
  }
};
micromatch$1.makeRe = (...args) => picomatch$2.makeRe(...args);
micromatch$1.scan = (...args) => picomatch$2.scan(...args);
micromatch$1.parse = (patterns2, options3) => {
  let res = [];
  for (let pattern2 of [].concat(patterns2 || [])) {
    for (let str of braces$1(String(pattern2), options3)) {
      res.push(picomatch$2.parse(str, options3));
    }
  }
  return res;
};
micromatch$1.braces = (pattern2, options3) => {
  if (typeof pattern2 !== "string")
    throw new TypeError("Expected a string");
  if (options3 && options3.nobrace === true || !/\{.*\}/.test(pattern2)) {
    return [pattern2];
  }
  return braces$1(pattern2, options3);
};
micromatch$1.braceExpand = (pattern2, options3) => {
  if (typeof pattern2 !== "string")
    throw new TypeError("Expected a string");
  return micromatch$1.braces(pattern2, { ...options3, expand: true });
};
var micromatch_1 = micromatch$1;
Object.defineProperty(pattern$1, "__esModule", { value: true });
pattern$1.matchAny = pattern$1.convertPatternsToRe = pattern$1.makeRe = pattern$1.getPatternParts = pattern$1.expandBraceExpansion = pattern$1.expandPatternsWithBraceExpansion = pattern$1.isAffectDepthOfReadingPattern = pattern$1.endsWithSlashGlobStar = pattern$1.hasGlobStar = pattern$1.getBaseDirectory = pattern$1.isPatternRelatedToParentDirectory = pattern$1.getPatternsOutsideCurrentDirectory = pattern$1.getPatternsInsideCurrentDirectory = pattern$1.getPositivePatterns = pattern$1.getNegativePatterns = pattern$1.isPositivePattern = pattern$1.isNegativePattern = pattern$1.convertToNegativePattern = pattern$1.convertToPositivePattern = pattern$1.isDynamicPattern = pattern$1.isStaticPattern = void 0;
var path$f = import_path.default;
var globParent$1 = globParent$2;
var micromatch = micromatch_1;
var GLOBSTAR$1 = "**";
var ESCAPE_SYMBOL = "\\";
var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
var BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
function isStaticPattern(pattern2, options3 = {}) {
  return !isDynamicPattern(pattern2, options3);
}
pattern$1.isStaticPattern = isStaticPattern;
function isDynamicPattern(pattern2, options3 = {}) {
  if (pattern2 === "") {
    return false;
  }
  if (options3.caseSensitiveMatch === false || pattern2.includes(ESCAPE_SYMBOL)) {
    return true;
  }
  if (COMMON_GLOB_SYMBOLS_RE.test(pattern2) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern2) || REGEX_GROUP_SYMBOLS_RE.test(pattern2)) {
    return true;
  }
  if (options3.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern2)) {
    return true;
  }
  if (options3.braceExpansion !== false && hasBraceExpansion(pattern2)) {
    return true;
  }
  return false;
}
pattern$1.isDynamicPattern = isDynamicPattern;
function hasBraceExpansion(pattern2) {
  const openingBraceIndex = pattern2.indexOf("{");
  if (openingBraceIndex === -1) {
    return false;
  }
  const closingBraceIndex = pattern2.indexOf("}", openingBraceIndex + 1);
  if (closingBraceIndex === -1) {
    return false;
  }
  const braceContent = pattern2.slice(openingBraceIndex, closingBraceIndex);
  return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
}
function convertToPositivePattern(pattern2) {
  return isNegativePattern(pattern2) ? pattern2.slice(1) : pattern2;
}
pattern$1.convertToPositivePattern = convertToPositivePattern;
function convertToNegativePattern(pattern2) {
  return "!" + pattern2;
}
pattern$1.convertToNegativePattern = convertToNegativePattern;
function isNegativePattern(pattern2) {
  return pattern2.startsWith("!") && pattern2[1] !== "(";
}
pattern$1.isNegativePattern = isNegativePattern;
function isPositivePattern(pattern2) {
  return !isNegativePattern(pattern2);
}
pattern$1.isPositivePattern = isPositivePattern;
function getNegativePatterns(patterns2) {
  return patterns2.filter(isNegativePattern);
}
pattern$1.getNegativePatterns = getNegativePatterns;
function getPositivePatterns$1(patterns2) {
  return patterns2.filter(isPositivePattern);
}
pattern$1.getPositivePatterns = getPositivePatterns$1;
function getPatternsInsideCurrentDirectory(patterns2) {
  return patterns2.filter((pattern2) => !isPatternRelatedToParentDirectory(pattern2));
}
pattern$1.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
function getPatternsOutsideCurrentDirectory(patterns2) {
  return patterns2.filter(isPatternRelatedToParentDirectory);
}
pattern$1.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
function isPatternRelatedToParentDirectory(pattern2) {
  return pattern2.startsWith("..") || pattern2.startsWith("./..");
}
pattern$1.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
function getBaseDirectory(pattern2) {
  return globParent$1(pattern2, { flipBackslashes: false });
}
pattern$1.getBaseDirectory = getBaseDirectory;
function hasGlobStar(pattern2) {
  return pattern2.includes(GLOBSTAR$1);
}
pattern$1.hasGlobStar = hasGlobStar;
function endsWithSlashGlobStar(pattern2) {
  return pattern2.endsWith("/" + GLOBSTAR$1);
}
pattern$1.endsWithSlashGlobStar = endsWithSlashGlobStar;
function isAffectDepthOfReadingPattern(pattern2) {
  const basename2 = path$f.basename(pattern2);
  return endsWithSlashGlobStar(pattern2) || isStaticPattern(basename2);
}
pattern$1.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
function expandPatternsWithBraceExpansion(patterns2) {
  return patterns2.reduce((collection, pattern2) => {
    return collection.concat(expandBraceExpansion(pattern2));
  }, []);
}
pattern$1.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
function expandBraceExpansion(pattern2) {
  return micromatch.braces(pattern2, {
    expand: true,
    nodupes: true
  });
}
pattern$1.expandBraceExpansion = expandBraceExpansion;
function getPatternParts(pattern2, options3) {
  let { parts } = micromatch.scan(pattern2, Object.assign(Object.assign({}, options3), { parts: true }));
  if (parts.length === 0) {
    parts = [pattern2];
  }
  if (parts[0].startsWith("/")) {
    parts[0] = parts[0].slice(1);
    parts.unshift("");
  }
  return parts;
}
pattern$1.getPatternParts = getPatternParts;
function makeRe(pattern2, options3) {
  return micromatch.makeRe(pattern2, options3);
}
pattern$1.makeRe = makeRe;
function convertPatternsToRe(patterns2, options3) {
  return patterns2.map((pattern2) => makeRe(pattern2, options3));
}
pattern$1.convertPatternsToRe = convertPatternsToRe;
function matchAny(entry2, patternsRe) {
  return patternsRe.some((patternRe) => patternRe.test(entry2));
}
pattern$1.matchAny = matchAny;
var stream$4 = {};
var Stream = import_stream.default;
var PassThrough = Stream.PassThrough;
var slice = Array.prototype.slice;
var merge2_1 = merge2$1;
function merge2$1() {
  const streamsQueue = [];
  const args = slice.call(arguments);
  let merging = false;
  let options3 = args[args.length - 1];
  if (options3 && !Array.isArray(options3) && options3.pipe == null) {
    args.pop();
  } else {
    options3 = {};
  }
  const doEnd = options3.end !== false;
  const doPipeError = options3.pipeError === true;
  if (options3.objectMode == null) {
    options3.objectMode = true;
  }
  if (options3.highWaterMark == null) {
    options3.highWaterMark = 64 * 1024;
  }
  const mergedStream = PassThrough(options3);
  function addStream() {
    for (let i = 0, len = arguments.length; i < len; i++) {
      streamsQueue.push(pauseStreams(arguments[i], options3));
    }
    mergeStream();
    return this;
  }
  function mergeStream() {
    if (merging) {
      return;
    }
    merging = true;
    let streams = streamsQueue.shift();
    if (!streams) {
      process.nextTick(endStream);
      return;
    }
    if (!Array.isArray(streams)) {
      streams = [streams];
    }
    let pipesCount = streams.length + 1;
    function next() {
      if (--pipesCount > 0) {
        return;
      }
      merging = false;
      mergeStream();
    }
    function pipe(stream4) {
      function onend() {
        stream4.removeListener("merge2UnpipeEnd", onend);
        stream4.removeListener("end", onend);
        if (doPipeError) {
          stream4.removeListener("error", onerror);
        }
        next();
      }
      function onerror(err) {
        mergedStream.emit("error", err);
      }
      if (stream4._readableState.endEmitted) {
        return next();
      }
      stream4.on("merge2UnpipeEnd", onend);
      stream4.on("end", onend);
      if (doPipeError) {
        stream4.on("error", onerror);
      }
      stream4.pipe(mergedStream, { end: false });
      stream4.resume();
    }
    for (let i = 0; i < streams.length; i++) {
      pipe(streams[i]);
    }
    next();
  }
  function endStream() {
    merging = false;
    mergedStream.emit("queueDrain");
    if (doEnd) {
      mergedStream.end();
    }
  }
  mergedStream.setMaxListeners(0);
  mergedStream.add = addStream;
  mergedStream.on("unpipe", function(stream4) {
    stream4.emit("merge2UnpipeEnd");
  });
  if (args.length) {
    addStream.apply(null, args);
  }
  return mergedStream;
}
function pauseStreams(streams, options3) {
  if (!Array.isArray(streams)) {
    if (!streams._readableState && streams.pipe) {
      streams = streams.pipe(PassThrough(options3));
    }
    if (!streams._readableState || !streams.pause || !streams.pipe) {
      throw new Error("Only readable stream can be merged.");
    }
    streams.pause();
  } else {
    for (let i = 0, len = streams.length; i < len; i++) {
      streams[i] = pauseStreams(streams[i], options3);
    }
  }
  return streams;
}
Object.defineProperty(stream$4, "__esModule", { value: true });
stream$4.merge = void 0;
var merge2 = merge2_1;
function merge$1(streams) {
  const mergedStream = merge2(streams);
  streams.forEach((stream4) => {
    stream4.once("error", (error2) => mergedStream.emit("error", error2));
  });
  mergedStream.once("close", () => propagateCloseEventToSources(streams));
  mergedStream.once("end", () => propagateCloseEventToSources(streams));
  return mergedStream;
}
stream$4.merge = merge$1;
function propagateCloseEventToSources(streams) {
  streams.forEach((stream4) => stream4.emit("close"));
}
var string$2 = {};
Object.defineProperty(string$2, "__esModule", { value: true });
string$2.isEmpty = string$2.isString = void 0;
function isString(input) {
  return typeof input === "string";
}
string$2.isString = isString;
function isEmpty$1(input) {
  return input === "";
}
string$2.isEmpty = isEmpty$1;
Object.defineProperty(utils$g, "__esModule", { value: true });
utils$g.string = utils$g.stream = utils$g.pattern = utils$g.path = utils$g.fs = utils$g.errno = utils$g.array = void 0;
var array = array$1;
utils$g.array = array;
var errno = errno$1;
utils$g.errno = errno;
var fs$g = fs$h;
utils$g.fs = fs$g;
var path$e = path$h;
utils$g.path = path$e;
var pattern = pattern$1;
utils$g.pattern = pattern;
var stream$3 = stream$4;
utils$g.stream = stream$3;
var string$1 = string$2;
utils$g.string = string$1;
Object.defineProperty(tasks, "__esModule", { value: true });
tasks.convertPatternGroupToTask = tasks.convertPatternGroupsToTasks = tasks.groupPatternsByBaseDirectory = tasks.getNegativePatternsAsPositive = tasks.getPositivePatterns = tasks.convertPatternsToTasks = tasks.generate = void 0;
var utils$a = utils$g;
function generate(patterns2, settings2) {
  const positivePatterns = getPositivePatterns(patterns2);
  const negativePatterns = getNegativePatternsAsPositive(patterns2, settings2.ignore);
  const staticPatterns = positivePatterns.filter((pattern2) => utils$a.pattern.isStaticPattern(pattern2, settings2));
  const dynamicPatterns = positivePatterns.filter((pattern2) => utils$a.pattern.isDynamicPattern(pattern2, settings2));
  const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, false);
  const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, true);
  return staticTasks.concat(dynamicTasks);
}
tasks.generate = generate;
function convertPatternsToTasks(positive, negative, dynamic) {
  const tasks2 = [];
  const patternsOutsideCurrentDirectory = utils$a.pattern.getPatternsOutsideCurrentDirectory(positive);
  const patternsInsideCurrentDirectory = utils$a.pattern.getPatternsInsideCurrentDirectory(positive);
  const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
  const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
  tasks2.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
  if ("." in insideCurrentDirectoryGroup) {
    tasks2.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic));
  } else {
    tasks2.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
  }
  return tasks2;
}
tasks.convertPatternsToTasks = convertPatternsToTasks;
function getPositivePatterns(patterns2) {
  return utils$a.pattern.getPositivePatterns(patterns2);
}
tasks.getPositivePatterns = getPositivePatterns;
function getNegativePatternsAsPositive(patterns2, ignore2) {
  const negative = utils$a.pattern.getNegativePatterns(patterns2).concat(ignore2);
  const positive = negative.map(utils$a.pattern.convertToPositivePattern);
  return positive;
}
tasks.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
function groupPatternsByBaseDirectory(patterns2) {
  const group = {};
  return patterns2.reduce((collection, pattern2) => {
    const base2 = utils$a.pattern.getBaseDirectory(pattern2);
    if (base2 in collection) {
      collection[base2].push(pattern2);
    } else {
      collection[base2] = [pattern2];
    }
    return collection;
  }, group);
}
tasks.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
function convertPatternGroupsToTasks(positive, negative, dynamic) {
  return Object.keys(positive).map((base2) => {
    return convertPatternGroupToTask(base2, positive[base2], negative, dynamic);
  });
}
tasks.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
function convertPatternGroupToTask(base2, positive, negative, dynamic) {
  return {
    dynamic,
    positive,
    negative,
    base: base2,
    patterns: [].concat(positive, negative.map(utils$a.pattern.convertToNegativePattern))
  };
}
tasks.convertPatternGroupToTask = convertPatternGroupToTask;
var patterns = {};
Object.defineProperty(patterns, "__esModule", { value: true });
patterns.removeDuplicateSlashes = patterns.transform = void 0;
var DOUBLE_SLASH_RE$1 = /(?!^)\/{2,}/g;
function transform(patterns2) {
  return patterns2.map((pattern2) => removeDuplicateSlashes(pattern2));
}
patterns.transform = transform;
function removeDuplicateSlashes(pattern2) {
  return pattern2.replace(DOUBLE_SLASH_RE$1, "/");
}
patterns.removeDuplicateSlashes = removeDuplicateSlashes;
var async$7 = {};
var async$6 = {};
var out$3 = {};
var async$5 = {};
var async$4 = {};
var out$2 = {};
var async$3 = {};
var out$1 = {};
var async$2 = {};
Object.defineProperty(async$2, "__esModule", { value: true });
async$2.read = void 0;
function read$4(path4, settings2, callback) {
  settings2.fs.lstat(path4, (lstatError, lstat2) => {
    if (lstatError !== null) {
      callFailureCallback$2(callback, lstatError);
      return;
    }
    if (!lstat2.isSymbolicLink() || !settings2.followSymbolicLink) {
      callSuccessCallback$2(callback, lstat2);
      return;
    }
    settings2.fs.stat(path4, (statError, stat2) => {
      if (statError !== null) {
        if (settings2.throwErrorOnBrokenSymbolicLink) {
          callFailureCallback$2(callback, statError);
          return;
        }
        callSuccessCallback$2(callback, lstat2);
        return;
      }
      if (settings2.markSymbolicLink) {
        stat2.isSymbolicLink = () => true;
      }
      callSuccessCallback$2(callback, stat2);
    });
  });
}
async$2.read = read$4;
function callFailureCallback$2(callback, error2) {
  callback(error2);
}
function callSuccessCallback$2(callback, result) {
  callback(null, result);
}
var sync$8 = {};
Object.defineProperty(sync$8, "__esModule", { value: true });
sync$8.read = void 0;
function read$3(path4, settings2) {
  const lstat2 = settings2.fs.lstatSync(path4);
  if (!lstat2.isSymbolicLink() || !settings2.followSymbolicLink) {
    return lstat2;
  }
  try {
    const stat2 = settings2.fs.statSync(path4);
    if (settings2.markSymbolicLink) {
      stat2.isSymbolicLink = () => true;
    }
    return stat2;
  } catch (error2) {
    if (!settings2.throwErrorOnBrokenSymbolicLink) {
      return lstat2;
    }
    throw error2;
  }
}
sync$8.read = read$3;
var settings$3 = {};
var fs$f = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
  const fs2 = import_fs.default;
  exports.FILE_SYSTEM_ADAPTER = {
    lstat: fs2.lstat,
    stat: fs2.stat,
    lstatSync: fs2.lstatSync,
    statSync: fs2.statSync
  };
  function createFileSystemAdapter(fsMethods) {
    if (fsMethods === void 0) {
      return exports.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
  }
  exports.createFileSystemAdapter = createFileSystemAdapter;
})(fs$f);
Object.defineProperty(settings$3, "__esModule", { value: true });
var fs$e = fs$f;
var Settings$2 = class {
  constructor(_options = {}) {
    this._options = _options;
    this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
    this.fs = fs$e.createFileSystemAdapter(this._options.fs);
    this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
    this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
  }
  _getValue(option, value2) {
    return option !== null && option !== void 0 ? option : value2;
  }
};
settings$3.default = Settings$2;
Object.defineProperty(out$1, "__esModule", { value: true });
out$1.statSync = out$1.stat = out$1.Settings = void 0;
var async$1 = async$2;
var sync$7 = sync$8;
var settings_1$3 = settings$3;
out$1.Settings = settings_1$3.default;
function stat$4(path4, optionsOrSettingsOrCallback, callback) {
  if (typeof optionsOrSettingsOrCallback === "function") {
    async$1.read(path4, getSettings$2(), optionsOrSettingsOrCallback);
    return;
  }
  async$1.read(path4, getSettings$2(optionsOrSettingsOrCallback), callback);
}
out$1.stat = stat$4;
function statSync2(path4, optionsOrSettings) {
  const settings2 = getSettings$2(optionsOrSettings);
  return sync$7.read(path4, settings2);
}
out$1.statSync = statSync2;
function getSettings$2(settingsOrOptions = {}) {
  if (settingsOrOptions instanceof settings_1$3.default) {
    return settingsOrOptions;
  }
  return new settings_1$3.default(settingsOrOptions);
}
var promise;
var queueMicrotask_1 = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : commonjsGlobal) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
  throw err;
}, 0));
var runParallel_1 = runParallel;
var queueMicrotask$1 = queueMicrotask_1;
function runParallel(tasks2, cb) {
  let results, pending, keys;
  let isSync = true;
  if (Array.isArray(tasks2)) {
    results = [];
    pending = tasks2.length;
  } else {
    keys = Object.keys(tasks2);
    results = {};
    pending = keys.length;
  }
  function done(err) {
    function end() {
      if (cb)
        cb(err, results);
      cb = null;
    }
    if (isSync)
      queueMicrotask$1(end);
    else
      end();
  }
  function each(i, err, result) {
    results[i] = result;
    if (--pending === 0 || err) {
      done(err);
    }
  }
  if (!pending) {
    done(null);
  } else if (keys) {
    keys.forEach(function(key2) {
      tasks2[key2](function(err, result) {
        each(key2, err, result);
      });
    });
  } else {
    tasks2.forEach(function(task, i) {
      task(function(err, result) {
        each(i, err, result);
      });
    });
  }
  isSync = false;
}
var constants$2 = {};
Object.defineProperty(constants$2, "__esModule", { value: true });
constants$2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0) {
  throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
}
var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
var MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
var SUPPORTED_MAJOR_VERSION = 10;
var SUPPORTED_MINOR_VERSION = 10;
var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
constants$2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
var utils$9 = {};
var fs$d = {};
Object.defineProperty(fs$d, "__esModule", { value: true });
fs$d.createDirentFromStats = void 0;
var DirentFromStats = class {
  constructor(name, stats) {
    this.name = name;
    this.isBlockDevice = stats.isBlockDevice.bind(stats);
    this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
    this.isDirectory = stats.isDirectory.bind(stats);
    this.isFIFO = stats.isFIFO.bind(stats);
    this.isFile = stats.isFile.bind(stats);
    this.isSocket = stats.isSocket.bind(stats);
    this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
  }
};
function createDirentFromStats(name, stats) {
  return new DirentFromStats(name, stats);
}
fs$d.createDirentFromStats = createDirentFromStats;
Object.defineProperty(utils$9, "__esModule", { value: true });
utils$9.fs = void 0;
var fs$c = fs$d;
utils$9.fs = fs$c;
var common$a = {};
Object.defineProperty(common$a, "__esModule", { value: true });
common$a.joinPathSegments = void 0;
function joinPathSegments$1(a, b, separator) {
  if (a.endsWith(separator)) {
    return a + b;
  }
  return a + separator + b;
}
common$a.joinPathSegments = joinPathSegments$1;
Object.defineProperty(async$3, "__esModule", { value: true });
async$3.readdir = async$3.readdirWithFileTypes = async$3.read = void 0;
var fsStat$5 = out$1;
var rpl = runParallel_1;
var constants_1$1 = constants$2;
var utils$8 = utils$9;
var common$9 = common$a;
function read$2(directory, settings2, callback) {
  if (!settings2.stats && constants_1$1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
    readdirWithFileTypes$1(directory, settings2, callback);
    return;
  }
  readdir$3(directory, settings2, callback);
}
async$3.read = read$2;
function readdirWithFileTypes$1(directory, settings2, callback) {
  settings2.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
    if (readdirError !== null) {
      callFailureCallback$1(callback, readdirError);
      return;
    }
    const entries = dirents.map((dirent) => ({
      dirent,
      name: dirent.name,
      path: common$9.joinPathSegments(directory, dirent.name, settings2.pathSegmentSeparator)
    }));
    if (!settings2.followSymbolicLinks) {
      callSuccessCallback$1(callback, entries);
      return;
    }
    const tasks2 = entries.map((entry2) => makeRplTaskEntry(entry2, settings2));
    rpl(tasks2, (rplError, rplEntries) => {
      if (rplError !== null) {
        callFailureCallback$1(callback, rplError);
        return;
      }
      callSuccessCallback$1(callback, rplEntries);
    });
  });
}
async$3.readdirWithFileTypes = readdirWithFileTypes$1;
function makeRplTaskEntry(entry2, settings2) {
  return (done) => {
    if (!entry2.dirent.isSymbolicLink()) {
      done(null, entry2);
      return;
    }
    settings2.fs.stat(entry2.path, (statError, stats) => {
      if (statError !== null) {
        if (settings2.throwErrorOnBrokenSymbolicLink) {
          done(statError);
          return;
        }
        done(null, entry2);
        return;
      }
      entry2.dirent = utils$8.fs.createDirentFromStats(entry2.name, stats);
      done(null, entry2);
    });
  };
}
function readdir$3(directory, settings2, callback) {
  settings2.fs.readdir(directory, (readdirError, names) => {
    if (readdirError !== null) {
      callFailureCallback$1(callback, readdirError);
      return;
    }
    const tasks2 = names.map((name) => {
      const path4 = common$9.joinPathSegments(directory, name, settings2.pathSegmentSeparator);
      return (done) => {
        fsStat$5.stat(path4, settings2.fsStatSettings, (error2, stats) => {
          if (error2 !== null) {
            done(error2);
            return;
          }
          const entry2 = {
            name,
            path: path4,
            dirent: utils$8.fs.createDirentFromStats(name, stats)
          };
          if (settings2.stats) {
            entry2.stats = stats;
          }
          done(null, entry2);
        });
      };
    });
    rpl(tasks2, (rplError, entries) => {
      if (rplError !== null) {
        callFailureCallback$1(callback, rplError);
        return;
      }
      callSuccessCallback$1(callback, entries);
    });
  });
}
async$3.readdir = readdir$3;
function callFailureCallback$1(callback, error2) {
  callback(error2);
}
function callSuccessCallback$1(callback, result) {
  callback(null, result);
}
var sync$6 = {};
Object.defineProperty(sync$6, "__esModule", { value: true });
sync$6.readdir = sync$6.readdirWithFileTypes = sync$6.read = void 0;
var fsStat$4 = out$1;
var constants_1 = constants$2;
var utils$7 = utils$9;
var common$8 = common$a;
function read$1(directory, settings2) {
  if (!settings2.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
    return readdirWithFileTypes(directory, settings2);
  }
  return readdir$2(directory, settings2);
}
sync$6.read = read$1;
function readdirWithFileTypes(directory, settings2) {
  const dirents = settings2.fs.readdirSync(directory, { withFileTypes: true });
  return dirents.map((dirent) => {
    const entry2 = {
      dirent,
      name: dirent.name,
      path: common$8.joinPathSegments(directory, dirent.name, settings2.pathSegmentSeparator)
    };
    if (entry2.dirent.isSymbolicLink() && settings2.followSymbolicLinks) {
      try {
        const stats = settings2.fs.statSync(entry2.path);
        entry2.dirent = utils$7.fs.createDirentFromStats(entry2.name, stats);
      } catch (error2) {
        if (settings2.throwErrorOnBrokenSymbolicLink) {
          throw error2;
        }
      }
    }
    return entry2;
  });
}
sync$6.readdirWithFileTypes = readdirWithFileTypes;
function readdir$2(directory, settings2) {
  const names = settings2.fs.readdirSync(directory);
  return names.map((name) => {
    const entryPath = common$8.joinPathSegments(directory, name, settings2.pathSegmentSeparator);
    const stats = fsStat$4.statSync(entryPath, settings2.fsStatSettings);
    const entry2 = {
      name,
      path: entryPath,
      dirent: utils$7.fs.createDirentFromStats(name, stats)
    };
    if (settings2.stats) {
      entry2.stats = stats;
    }
    return entry2;
  });
}
sync$6.readdir = readdir$2;
var settings$2 = {};
var fs$b = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
  const fs2 = import_fs.default;
  exports.FILE_SYSTEM_ADAPTER = {
    lstat: fs2.lstat,
    stat: fs2.stat,
    lstatSync: fs2.lstatSync,
    statSync: fs2.statSync,
    readdir: fs2.readdir,
    readdirSync: fs2.readdirSync
  };
  function createFileSystemAdapter(fsMethods) {
    if (fsMethods === void 0) {
      return exports.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
  }
  exports.createFileSystemAdapter = createFileSystemAdapter;
})(fs$b);
Object.defineProperty(settings$2, "__esModule", { value: true });
var path$d = import_path.default;
var fsStat$3 = out$1;
var fs$a = fs$b;
var Settings$1 = class {
  constructor(_options = {}) {
    this._options = _options;
    this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
    this.fs = fs$a.createFileSystemAdapter(this._options.fs);
    this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path$d.sep);
    this.stats = this._getValue(this._options.stats, false);
    this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
    this.fsStatSettings = new fsStat$3.Settings({
      followSymbolicLink: this.followSymbolicLinks,
      fs: this.fs,
      throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
    });
  }
  _getValue(option, value2) {
    return option !== null && option !== void 0 ? option : value2;
  }
};
settings$2.default = Settings$1;
Object.defineProperty(out$2, "__esModule", { value: true });
out$2.Settings = out$2.scandirSync = out$2.scandir = void 0;
var async = async$3;
var sync$5 = sync$6;
var settings_1$2 = settings$2;
out$2.Settings = settings_1$2.default;
function scandir(path4, optionsOrSettingsOrCallback, callback) {
  if (typeof optionsOrSettingsOrCallback === "function") {
    async.read(path4, getSettings$1(), optionsOrSettingsOrCallback);
    return;
  }
  async.read(path4, getSettings$1(optionsOrSettingsOrCallback), callback);
}
out$2.scandir = scandir;
function scandirSync(path4, optionsOrSettings) {
  const settings2 = getSettings$1(optionsOrSettings);
  return sync$5.read(path4, settings2);
}
out$2.scandirSync = scandirSync;
function getSettings$1(settingsOrOptions = {}) {
  if (settingsOrOptions instanceof settings_1$2.default) {
    return settingsOrOptions;
  }
  return new settings_1$2.default(settingsOrOptions);
}
var queue = { exports: {} };
function reusify$1(Constructor) {
  var head = new Constructor();
  var tail = head;
  function get2() {
    var current2 = head;
    if (current2.next) {
      head = current2.next;
    } else {
      head = new Constructor();
      tail = head;
    }
    current2.next = null;
    return current2;
  }
  function release(obj) {
    tail.next = obj;
    tail = obj;
  }
  return {
    get: get2,
    release
  };
}
var reusify_1 = reusify$1;
var reusify = reusify_1;
function fastqueue(context, worker, concurrency) {
  if (typeof context === "function") {
    concurrency = worker;
    worker = context;
    context = null;
  }
  if (concurrency < 1) {
    throw new Error("fastqueue concurrency must be greater than 1");
  }
  var cache = reusify(Task);
  var queueHead = null;
  var queueTail = null;
  var _running = 0;
  var errorHandler = null;
  var self2 = {
    push: push2,
    drain: noop$3,
    saturated: noop$3,
    pause,
    paused: false,
    concurrency,
    running,
    resume: resume2,
    idle,
    length,
    getQueue,
    unshift,
    empty: noop$3,
    kill,
    killAndDrain,
    error: error2
  };
  return self2;
  function running() {
    return _running;
  }
  function pause() {
    self2.paused = true;
  }
  function length() {
    var current2 = queueHead;
    var counter = 0;
    while (current2) {
      current2 = current2.next;
      counter++;
    }
    return counter;
  }
  function getQueue() {
    var current2 = queueHead;
    var tasks2 = [];
    while (current2) {
      tasks2.push(current2.value);
      current2 = current2.next;
    }
    return tasks2;
  }
  function resume2() {
    if (!self2.paused)
      return;
    self2.paused = false;
    for (var i = 0; i < self2.concurrency; i++) {
      _running++;
      release();
    }
  }
  function idle() {
    return _running === 0 && self2.length() === 0;
  }
  function push2(value2, done) {
    var current2 = cache.get();
    current2.context = context;
    current2.release = release;
    current2.value = value2;
    current2.callback = done || noop$3;
    current2.errorHandler = errorHandler;
    if (_running === self2.concurrency || self2.paused) {
      if (queueTail) {
        queueTail.next = current2;
        queueTail = current2;
      } else {
        queueHead = current2;
        queueTail = current2;
        self2.saturated();
      }
    } else {
      _running++;
      worker.call(context, current2.value, current2.worked);
    }
  }
  function unshift(value2, done) {
    var current2 = cache.get();
    current2.context = context;
    current2.release = release;
    current2.value = value2;
    current2.callback = done || noop$3;
    if (_running === self2.concurrency || self2.paused) {
      if (queueHead) {
        current2.next = queueHead;
        queueHead = current2;
      } else {
        queueHead = current2;
        queueTail = current2;
        self2.saturated();
      }
    } else {
      _running++;
      worker.call(context, current2.value, current2.worked);
    }
  }
  function release(holder) {
    if (holder) {
      cache.release(holder);
    }
    var next = queueHead;
    if (next) {
      if (!self2.paused) {
        if (queueTail === queueHead) {
          queueTail = null;
        }
        queueHead = next.next;
        next.next = null;
        worker.call(context, next.value, next.worked);
        if (queueTail === null) {
          self2.empty();
        }
      } else {
        _running--;
      }
    } else if (--_running === 0) {
      self2.drain();
    }
  }
  function kill() {
    queueHead = null;
    queueTail = null;
    self2.drain = noop$3;
  }
  function killAndDrain() {
    queueHead = null;
    queueTail = null;
    self2.drain();
    self2.drain = noop$3;
  }
  function error2(handler) {
    errorHandler = handler;
  }
}
function noop$3() {
}
function Task() {
  this.value = null;
  this.callback = noop$3;
  this.next = null;
  this.release = noop$3;
  this.context = null;
  this.errorHandler = null;
  var self2 = this;
  this.worked = function worked(err, result) {
    var callback = self2.callback;
    var errorHandler = self2.errorHandler;
    var val = self2.value;
    self2.value = null;
    self2.callback = noop$3;
    if (self2.errorHandler) {
      errorHandler(err, val);
    }
    callback.call(self2.context, err, result);
    self2.release(self2);
  };
}
function queueAsPromised(context, worker, concurrency) {
  if (typeof context === "function") {
    concurrency = worker;
    worker = context;
    context = null;
  }
  function asyncWrapper(arg, cb) {
    worker.call(this, arg).then(function(res) {
      cb(null, res);
    }, cb);
  }
  var queue2 = fastqueue(context, asyncWrapper, concurrency);
  var pushCb = queue2.push;
  var unshiftCb = queue2.unshift;
  queue2.push = push2;
  queue2.unshift = unshift;
  queue2.drained = drained;
  return queue2;
  function push2(value2) {
    var p = new Promise(function(resolve3, reject) {
      pushCb(value2, function(err, result) {
        if (err) {
          reject(err);
          return;
        }
        resolve3(result);
      });
    });
    p.catch(noop$3);
    return p;
  }
  function unshift(value2) {
    var p = new Promise(function(resolve3, reject) {
      unshiftCb(value2, function(err, result) {
        if (err) {
          reject(err);
          return;
        }
        resolve3(result);
      });
    });
    p.catch(noop$3);
    return p;
  }
  function drained() {
    var previousDrain = queue2.drain;
    var p = new Promise(function(resolve3) {
      queue2.drain = function() {
        previousDrain();
        resolve3();
      };
    });
    return p;
  }
}
queue.exports = fastqueue;
queue.exports.promise = queueAsPromised;
var common$7 = {};
Object.defineProperty(common$7, "__esModule", { value: true });
common$7.joinPathSegments = common$7.replacePathSegmentSeparator = common$7.isAppliedFilter = common$7.isFatalError = void 0;
function isFatalError(settings2, error2) {
  if (settings2.errorFilter === null) {
    return true;
  }
  return !settings2.errorFilter(error2);
}
common$7.isFatalError = isFatalError;
function isAppliedFilter(filter2, value2) {
  return filter2 === null || filter2(value2);
}
common$7.isAppliedFilter = isAppliedFilter;
function replacePathSegmentSeparator(filepath, separator) {
  return filepath.split(/[/\\]/).join(separator);
}
common$7.replacePathSegmentSeparator = replacePathSegmentSeparator;
function joinPathSegments(a, b, separator) {
  if (a === "") {
    return b;
  }
  if (a.endsWith(separator)) {
    return a + b;
  }
  return a + separator + b;
}
common$7.joinPathSegments = joinPathSegments;
var reader$1 = {};
Object.defineProperty(reader$1, "__esModule", { value: true });
var common$6 = common$7;
var Reader$1 = class {
  constructor(_root, _settings) {
    this._root = _root;
    this._settings = _settings;
    this._root = common$6.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
  }
};
reader$1.default = Reader$1;
Object.defineProperty(async$4, "__esModule", { value: true });
var events_1 = import_events.default;
var fsScandir$2 = out$2;
var fastq = queue.exports;
var common$5 = common$7;
var reader_1$4 = reader$1;
var AsyncReader = class extends reader_1$4.default {
  constructor(_root, _settings) {
    super(_root, _settings);
    this._settings = _settings;
    this._scandir = fsScandir$2.scandir;
    this._emitter = new events_1.EventEmitter();
    this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
    this._isFatalError = false;
    this._isDestroyed = false;
    this._queue.drain = () => {
      if (!this._isFatalError) {
        this._emitter.emit("end");
      }
    };
  }
  read() {
    this._isFatalError = false;
    this._isDestroyed = false;
    setImmediate(() => {
      this._pushToQueue(this._root, this._settings.basePath);
    });
    return this._emitter;
  }
  get isDestroyed() {
    return this._isDestroyed;
  }
  destroy() {
    if (this._isDestroyed) {
      throw new Error("The reader is already destroyed");
    }
    this._isDestroyed = true;
    this._queue.killAndDrain();
  }
  onEntry(callback) {
    this._emitter.on("entry", callback);
  }
  onError(callback) {
    this._emitter.once("error", callback);
  }
  onEnd(callback) {
    this._emitter.once("end", callback);
  }
  _pushToQueue(directory, base2) {
    const queueItem = { directory, base: base2 };
    this._queue.push(queueItem, (error2) => {
      if (error2 !== null) {
        this._handleError(error2);
      }
    });
  }
  _worker(item, done) {
    this._scandir(item.directory, this._settings.fsScandirSettings, (error2, entries) => {
      if (error2 !== null) {
        done(error2, void 0);
        return;
      }
      for (const entry2 of entries) {
        this._handleEntry(entry2, item.base);
      }
      done(null, void 0);
    });
  }
  _handleError(error2) {
    if (this._isDestroyed || !common$5.isFatalError(this._settings, error2)) {
      return;
    }
    this._isFatalError = true;
    this._isDestroyed = true;
    this._emitter.emit("error", error2);
  }
  _handleEntry(entry2, base2) {
    if (this._isDestroyed || this._isFatalError) {
      return;
    }
    const fullpath = entry2.path;
    if (base2 !== void 0) {
      entry2.path = common$5.joinPathSegments(base2, entry2.name, this._settings.pathSegmentSeparator);
    }
    if (common$5.isAppliedFilter(this._settings.entryFilter, entry2)) {
      this._emitEntry(entry2);
    }
    if (entry2.dirent.isDirectory() && common$5.isAppliedFilter(this._settings.deepFilter, entry2)) {
      this._pushToQueue(fullpath, base2 === void 0 ? void 0 : entry2.path);
    }
  }
  _emitEntry(entry2) {
    this._emitter.emit("entry", entry2);
  }
};
async$4.default = AsyncReader;
Object.defineProperty(async$5, "__esModule", { value: true });
var async_1$4 = async$4;
var AsyncProvider = class {
  constructor(_root, _settings) {
    this._root = _root;
    this._settings = _settings;
    this._reader = new async_1$4.default(this._root, this._settings);
    this._storage = [];
  }
  read(callback) {
    this._reader.onError((error2) => {
      callFailureCallback(callback, error2);
    });
    this._reader.onEntry((entry2) => {
      this._storage.push(entry2);
    });
    this._reader.onEnd(() => {
      callSuccessCallback(callback, this._storage);
    });
    this._reader.read();
  }
};
async$5.default = AsyncProvider;
function callFailureCallback(callback, error2) {
  callback(error2);
}
function callSuccessCallback(callback, entries) {
  callback(null, entries);
}
var stream$2 = {};
Object.defineProperty(stream$2, "__esModule", { value: true });
var stream_1$5 = import_stream.default;
var async_1$3 = async$4;
var StreamProvider = class {
  constructor(_root, _settings) {
    this._root = _root;
    this._settings = _settings;
    this._reader = new async_1$3.default(this._root, this._settings);
    this._stream = new stream_1$5.Readable({
      objectMode: true,
      read: () => {
      },
      destroy: () => {
        if (!this._reader.isDestroyed) {
          this._reader.destroy();
        }
      }
    });
  }
  read() {
    this._reader.onError((error2) => {
      this._stream.emit("error", error2);
    });
    this._reader.onEntry((entry2) => {
      this._stream.push(entry2);
    });
    this._reader.onEnd(() => {
      this._stream.push(null);
    });
    this._reader.read();
    return this._stream;
  }
};
stream$2.default = StreamProvider;
var sync$4 = {};
var sync$3 = {};
Object.defineProperty(sync$3, "__esModule", { value: true });
var fsScandir$1 = out$2;
var common$4 = common$7;
var reader_1$3 = reader$1;
var SyncReader = class extends reader_1$3.default {
  constructor() {
    super(...arguments);
    this._scandir = fsScandir$1.scandirSync;
    this._storage = [];
    this._queue = /* @__PURE__ */ new Set();
  }
  read() {
    this._pushToQueue(this._root, this._settings.basePath);
    this._handleQueue();
    return this._storage;
  }
  _pushToQueue(directory, base2) {
    this._queue.add({ directory, base: base2 });
  }
  _handleQueue() {
    for (const item of this._queue.values()) {
      this._handleDirectory(item.directory, item.base);
    }
  }
  _handleDirectory(directory, base2) {
    try {
      const entries = this._scandir(directory, this._settings.fsScandirSettings);
      for (const entry2 of entries) {
        this._handleEntry(entry2, base2);
      }
    } catch (error2) {
      this._handleError(error2);
    }
  }
  _handleError(error2) {
    if (!common$4.isFatalError(this._settings, error2)) {
      return;
    }
    throw error2;
  }
  _handleEntry(entry2, base2) {
    const fullpath = entry2.path;
    if (base2 !== void 0) {
      entry2.path = common$4.joinPathSegments(base2, entry2.name, this._settings.pathSegmentSeparator);
    }
    if (common$4.isAppliedFilter(this._settings.entryFilter, entry2)) {
      this._pushToStorage(entry2);
    }
    if (entry2.dirent.isDirectory() && common$4.isAppliedFilter(this._settings.deepFilter, entry2)) {
      this._pushToQueue(fullpath, base2 === void 0 ? void 0 : entry2.path);
    }
  }
  _pushToStorage(entry2) {
    this._storage.push(entry2);
  }
};
sync$3.default = SyncReader;
Object.defineProperty(sync$4, "__esModule", { value: true });
var sync_1$3 = sync$3;
var SyncProvider = class {
  constructor(_root, _settings) {
    this._root = _root;
    this._settings = _settings;
    this._reader = new sync_1$3.default(this._root, this._settings);
  }
  read() {
    return this._reader.read();
  }
};
sync$4.default = SyncProvider;
var settings$1 = {};
Object.defineProperty(settings$1, "__esModule", { value: true });
var path$c = import_path.default;
var fsScandir = out$2;
var Settings = class {
  constructor(_options = {}) {
    this._options = _options;
    this.basePath = this._getValue(this._options.basePath, void 0);
    this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
    this.deepFilter = this._getValue(this._options.deepFilter, null);
    this.entryFilter = this._getValue(this._options.entryFilter, null);
    this.errorFilter = this._getValue(this._options.errorFilter, null);
    this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path$c.sep);
    this.fsScandirSettings = new fsScandir.Settings({
      followSymbolicLinks: this._options.followSymbolicLinks,
      fs: this._options.fs,
      pathSegmentSeparator: this._options.pathSegmentSeparator,
      stats: this._options.stats,
      throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
    });
  }
  _getValue(option, value2) {
    return option !== null && option !== void 0 ? option : value2;
  }
};
settings$1.default = Settings;
Object.defineProperty(out$3, "__esModule", { value: true });
out$3.Settings = out$3.walkStream = out$3.walkSync = out$3.walk = void 0;
var async_1$2 = async$5;
var stream_1$4 = stream$2;
var sync_1$2 = sync$4;
var settings_1$1 = settings$1;
out$3.Settings = settings_1$1.default;
function walk$2(directory, optionsOrSettingsOrCallback, callback) {
  if (typeof optionsOrSettingsOrCallback === "function") {
    new async_1$2.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
    return;
  }
  new async_1$2.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
}
out$3.walk = walk$2;
function walkSync(directory, optionsOrSettings) {
  const settings2 = getSettings(optionsOrSettings);
  const provider2 = new sync_1$2.default(directory, settings2);
  return provider2.read();
}
out$3.walkSync = walkSync;
function walkStream(directory, optionsOrSettings) {
  const settings2 = getSettings(optionsOrSettings);
  const provider2 = new stream_1$4.default(directory, settings2);
  return provider2.read();
}
out$3.walkStream = walkStream;
function getSettings(settingsOrOptions = {}) {
  if (settingsOrOptions instanceof settings_1$1.default) {
    return settingsOrOptions;
  }
  return new settings_1$1.default(settingsOrOptions);
}
var reader = {};
Object.defineProperty(reader, "__esModule", { value: true });
var path$b = import_path.default;
var fsStat$2 = out$1;
var utils$6 = utils$g;
var Reader = class {
  constructor(_settings) {
    this._settings = _settings;
    this._fsStatSettings = new fsStat$2.Settings({
      followSymbolicLink: this._settings.followSymbolicLinks,
      fs: this._settings.fs,
      throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
    });
  }
  _getFullEntryPath(filepath) {
    return path$b.resolve(this._settings.cwd, filepath);
  }
  _makeEntry(stats, pattern2) {
    const entry2 = {
      name: pattern2,
      path: pattern2,
      dirent: utils$6.fs.createDirentFromStats(pattern2, stats)
    };
    if (this._settings.stats) {
      entry2.stats = stats;
    }
    return entry2;
  }
  _isFatalError(error2) {
    return !utils$6.errno.isEnoentCodeError(error2) && !this._settings.suppressErrors;
  }
};
reader.default = Reader;
var stream$1 = {};
Object.defineProperty(stream$1, "__esModule", { value: true });
var stream_1$3 = import_stream.default;
var fsStat$1 = out$1;
var fsWalk$2 = out$3;
var reader_1$2 = reader;
var ReaderStream = class extends reader_1$2.default {
  constructor() {
    super(...arguments);
    this._walkStream = fsWalk$2.walkStream;
    this._stat = fsStat$1.stat;
  }
  dynamic(root2, options3) {
    return this._walkStream(root2, options3);
  }
  static(patterns2, options3) {
    const filepaths = patterns2.map(this._getFullEntryPath, this);
    const stream4 = new stream_1$3.PassThrough({ objectMode: true });
    stream4._write = (index2, _enc, done) => {
      return this._getEntry(filepaths[index2], patterns2[index2], options3).then((entry2) => {
        if (entry2 !== null && options3.entryFilter(entry2)) {
          stream4.push(entry2);
        }
        if (index2 === filepaths.length - 1) {
          stream4.end();
        }
        done();
      }).catch(done);
    };
    for (let i = 0; i < filepaths.length; i++) {
      stream4.write(i);
    }
    return stream4;
  }
  _getEntry(filepath, pattern2, options3) {
    return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern2)).catch((error2) => {
      if (options3.errorFilter(error2)) {
        return null;
      }
      throw error2;
    });
  }
  _getStat(filepath) {
    return new Promise((resolve3, reject) => {
      this._stat(filepath, this._fsStatSettings, (error2, stats) => {
        return error2 === null ? resolve3(stats) : reject(error2);
      });
    });
  }
};
stream$1.default = ReaderStream;
Object.defineProperty(async$6, "__esModule", { value: true });
var fsWalk$1 = out$3;
var reader_1$1 = reader;
var stream_1$2 = stream$1;
var ReaderAsync = class extends reader_1$1.default {
  constructor() {
    super(...arguments);
    this._walkAsync = fsWalk$1.walk;
    this._readerStream = new stream_1$2.default(this._settings);
  }
  dynamic(root2, options3) {
    return new Promise((resolve3, reject) => {
      this._walkAsync(root2, options3, (error2, entries) => {
        if (error2 === null) {
          resolve3(entries);
        } else {
          reject(error2);
        }
      });
    });
  }
  async static(patterns2, options3) {
    const entries = [];
    const stream4 = this._readerStream.static(patterns2, options3);
    return new Promise((resolve3, reject) => {
      stream4.once("error", reject);
      stream4.on("data", (entry2) => entries.push(entry2));
      stream4.once("end", () => resolve3(entries));
    });
  }
};
async$6.default = ReaderAsync;
var provider = {};
var deep = {};
var partial = {};
var matcher = {};
Object.defineProperty(matcher, "__esModule", { value: true });
var utils$5 = utils$g;
var Matcher = class {
  constructor(_patterns, _settings, _micromatchOptions) {
    this._patterns = _patterns;
    this._settings = _settings;
    this._micromatchOptions = _micromatchOptions;
    this._storage = [];
    this._fillStorage();
  }
  _fillStorage() {
    const patterns2 = utils$5.pattern.expandPatternsWithBraceExpansion(this._patterns);
    for (const pattern2 of patterns2) {
      const segments = this._getPatternSegments(pattern2);
      const sections = this._splitSegmentsIntoSections(segments);
      this._storage.push({
        complete: sections.length <= 1,
        pattern: pattern2,
        segments,
        sections
      });
    }
  }
  _getPatternSegments(pattern2) {
    const parts = utils$5.pattern.getPatternParts(pattern2, this._micromatchOptions);
    return parts.map((part) => {
      const dynamic = utils$5.pattern.isDynamicPattern(part, this._settings);
      if (!dynamic) {
        return {
          dynamic: false,
          pattern: part
        };
      }
      return {
        dynamic: true,
        pattern: part,
        patternRe: utils$5.pattern.makeRe(part, this._micromatchOptions)
      };
    });
  }
  _splitSegmentsIntoSections(segments) {
    return utils$5.array.splitWhen(segments, (segment) => segment.dynamic && utils$5.pattern.hasGlobStar(segment.pattern));
  }
};
matcher.default = Matcher;
Object.defineProperty(partial, "__esModule", { value: true });
var matcher_1 = matcher;
var PartialMatcher = class extends matcher_1.default {
  match(filepath) {
    const parts = filepath.split("/");
    const levels = parts.length;
    const patterns2 = this._storage.filter((info) => !info.complete || info.segments.length > levels);
    for (const pattern2 of patterns2) {
      const section = pattern2.sections[0];
      if (!pattern2.complete && levels > section.length) {
        return true;
      }
      const match = parts.every((part, index2) => {
        const segment = pattern2.segments[index2];
        if (segment.dynamic && segment.patternRe.test(part)) {
          return true;
        }
        if (!segment.dynamic && segment.pattern === part) {
          return true;
        }
        return false;
      });
      if (match) {
        return true;
      }
    }
    return false;
  }
};
partial.default = PartialMatcher;
Object.defineProperty(deep, "__esModule", { value: true });
var utils$4 = utils$g;
var partial_1 = partial;
var DeepFilter = class {
  constructor(_settings, _micromatchOptions) {
    this._settings = _settings;
    this._micromatchOptions = _micromatchOptions;
  }
  getFilter(basePath, positive, negative) {
    const matcher2 = this._getMatcher(positive);
    const negativeRe = this._getNegativePatternsRe(negative);
    return (entry2) => this._filter(basePath, entry2, matcher2, negativeRe);
  }
  _getMatcher(patterns2) {
    return new partial_1.default(patterns2, this._settings, this._micromatchOptions);
  }
  _getNegativePatternsRe(patterns2) {
    const affectDepthOfReadingPatterns = patterns2.filter(utils$4.pattern.isAffectDepthOfReadingPattern);
    return utils$4.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
  }
  _filter(basePath, entry2, matcher2, negativeRe) {
    if (this._isSkippedByDeep(basePath, entry2.path)) {
      return false;
    }
    if (this._isSkippedSymbolicLink(entry2)) {
      return false;
    }
    const filepath = utils$4.path.removeLeadingDotSegment(entry2.path);
    if (this._isSkippedByPositivePatterns(filepath, matcher2)) {
      return false;
    }
    return this._isSkippedByNegativePatterns(filepath, negativeRe);
  }
  _isSkippedByDeep(basePath, entryPath) {
    if (this._settings.deep === Infinity) {
      return false;
    }
    return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
  }
  _getEntryLevel(basePath, entryPath) {
    const entryPathDepth = entryPath.split("/").length;
    if (basePath === "") {
      return entryPathDepth;
    }
    const basePathDepth = basePath.split("/").length;
    return entryPathDepth - basePathDepth;
  }
  _isSkippedSymbolicLink(entry2) {
    return !this._settings.followSymbolicLinks && entry2.dirent.isSymbolicLink();
  }
  _isSkippedByPositivePatterns(entryPath, matcher2) {
    return !this._settings.baseNameMatch && !matcher2.match(entryPath);
  }
  _isSkippedByNegativePatterns(entryPath, patternsRe) {
    return !utils$4.pattern.matchAny(entryPath, patternsRe);
  }
};
deep.default = DeepFilter;
var entry$1 = {};
Object.defineProperty(entry$1, "__esModule", { value: true });
var utils$3 = utils$g;
var EntryFilter = class {
  constructor(_settings, _micromatchOptions) {
    this._settings = _settings;
    this._micromatchOptions = _micromatchOptions;
    this.index = /* @__PURE__ */ new Map();
  }
  getFilter(positive, negative) {
    const positiveRe = utils$3.pattern.convertPatternsToRe(positive, this._micromatchOptions);
    const negativeRe = utils$3.pattern.convertPatternsToRe(negative, this._micromatchOptions);
    return (entry2) => this._filter(entry2, positiveRe, negativeRe);
  }
  _filter(entry2, positiveRe, negativeRe) {
    if (this._settings.unique && this._isDuplicateEntry(entry2)) {
      return false;
    }
    if (this._onlyFileFilter(entry2) || this._onlyDirectoryFilter(entry2)) {
      return false;
    }
    if (this._isSkippedByAbsoluteNegativePatterns(entry2.path, negativeRe)) {
      return false;
    }
    const filepath = this._settings.baseNameMatch ? entry2.name : entry2.path;
    const isDirectory2 = entry2.dirent.isDirectory();
    const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory2) && !this._isMatchToPatterns(entry2.path, negativeRe, isDirectory2);
    if (this._settings.unique && isMatched) {
      this._createIndexRecord(entry2);
    }
    return isMatched;
  }
  _isDuplicateEntry(entry2) {
    return this.index.has(entry2.path);
  }
  _createIndexRecord(entry2) {
    this.index.set(entry2.path, void 0);
  }
  _onlyFileFilter(entry2) {
    return this._settings.onlyFiles && !entry2.dirent.isFile();
  }
  _onlyDirectoryFilter(entry2) {
    return this._settings.onlyDirectories && !entry2.dirent.isDirectory();
  }
  _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
    if (!this._settings.absolute) {
      return false;
    }
    const fullpath = utils$3.path.makeAbsolute(this._settings.cwd, entryPath);
    return utils$3.pattern.matchAny(fullpath, patternsRe);
  }
  _isMatchToPatterns(entryPath, patternsRe, isDirectory2) {
    const filepath = utils$3.path.removeLeadingDotSegment(entryPath);
    const isMatched = utils$3.pattern.matchAny(filepath, patternsRe);
    if (!isMatched && isDirectory2) {
      return utils$3.pattern.matchAny(filepath + "/", patternsRe);
    }
    return isMatched;
  }
};
entry$1.default = EntryFilter;
var error$2 = {};
Object.defineProperty(error$2, "__esModule", { value: true });
var utils$2 = utils$g;
var ErrorFilter = class {
  constructor(_settings) {
    this._settings = _settings;
  }
  getFilter() {
    return (error2) => this._isNonFatalError(error2);
  }
  _isNonFatalError(error2) {
    return utils$2.errno.isEnoentCodeError(error2) || this._settings.suppressErrors;
  }
};
error$2.default = ErrorFilter;
var entry = {};
Object.defineProperty(entry, "__esModule", { value: true });
var utils$1 = utils$g;
var EntryTransformer = class {
  constructor(_settings) {
    this._settings = _settings;
  }
  getTransformer() {
    return (entry2) => this._transform(entry2);
  }
  _transform(entry2) {
    let filepath = entry2.path;
    if (this._settings.absolute) {
      filepath = utils$1.path.makeAbsolute(this._settings.cwd, filepath);
      filepath = utils$1.path.unixify(filepath);
    }
    if (this._settings.markDirectories && entry2.dirent.isDirectory()) {
      filepath += "/";
    }
    if (!this._settings.objectMode) {
      return filepath;
    }
    return Object.assign(Object.assign({}, entry2), { path: filepath });
  }
};
entry.default = EntryTransformer;
Object.defineProperty(provider, "__esModule", { value: true });
var path$a = import_path.default;
var deep_1 = deep;
var entry_1 = entry$1;
var error_1 = error$2;
var entry_2 = entry;
var Provider = class {
  constructor(_settings) {
    this._settings = _settings;
    this.errorFilter = new error_1.default(this._settings);
    this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
    this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
    this.entryTransformer = new entry_2.default(this._settings);
  }
  _getRootDirectory(task) {
    return path$a.resolve(this._settings.cwd, task.base);
  }
  _getReaderOptions(task) {
    const basePath = task.base === "." ? "" : task.base;
    return {
      basePath,
      pathSegmentSeparator: "/",
      concurrency: this._settings.concurrency,
      deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
      entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
      errorFilter: this.errorFilter.getFilter(),
      followSymbolicLinks: this._settings.followSymbolicLinks,
      fs: this._settings.fs,
      stats: this._settings.stats,
      throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
      transform: this.entryTransformer.getTransformer()
    };
  }
  _getMicromatchOptions() {
    return {
      dot: this._settings.dot,
      matchBase: this._settings.baseNameMatch,
      nobrace: !this._settings.braceExpansion,
      nocase: !this._settings.caseSensitiveMatch,
      noext: !this._settings.extglob,
      noglobstar: !this._settings.globstar,
      posix: true,
      strictSlashes: false
    };
  }
};
provider.default = Provider;
Object.defineProperty(async$7, "__esModule", { value: true });
var async_1$1 = async$6;
var provider_1$2 = provider;
var ProviderAsync = class extends provider_1$2.default {
  constructor() {
    super(...arguments);
    this._reader = new async_1$1.default(this._settings);
  }
  async read(task) {
    const root2 = this._getRootDirectory(task);
    const options3 = this._getReaderOptions(task);
    const entries = await this.api(root2, task, options3);
    return entries.map((entry2) => options3.transform(entry2));
  }
  api(root2, task, options3) {
    if (task.dynamic) {
      return this._reader.dynamic(root2, options3);
    }
    return this._reader.static(task.patterns, options3);
  }
};
async$7.default = ProviderAsync;
var stream = {};
Object.defineProperty(stream, "__esModule", { value: true });
var stream_1$1 = import_stream.default;
var stream_2 = stream$1;
var provider_1$1 = provider;
var ProviderStream = class extends provider_1$1.default {
  constructor() {
    super(...arguments);
    this._reader = new stream_2.default(this._settings);
  }
  read(task) {
    const root2 = this._getRootDirectory(task);
    const options3 = this._getReaderOptions(task);
    const source2 = this.api(root2, task, options3);
    const destination = new stream_1$1.Readable({ objectMode: true, read: () => {
    } });
    source2.once("error", (error2) => destination.emit("error", error2)).on("data", (entry2) => destination.emit("data", options3.transform(entry2))).once("end", () => destination.emit("end"));
    destination.once("close", () => source2.destroy());
    return destination;
  }
  api(root2, task, options3) {
    if (task.dynamic) {
      return this._reader.dynamic(root2, options3);
    }
    return this._reader.static(task.patterns, options3);
  }
};
stream.default = ProviderStream;
var sync$2 = {};
var sync$1 = {};
Object.defineProperty(sync$1, "__esModule", { value: true });
var fsStat = out$1;
var fsWalk = out$3;
var reader_1 = reader;
var ReaderSync = class extends reader_1.default {
  constructor() {
    super(...arguments);
    this._walkSync = fsWalk.walkSync;
    this._statSync = fsStat.statSync;
  }
  dynamic(root2, options3) {
    return this._walkSync(root2, options3);
  }
  static(patterns2, options3) {
    const entries = [];
    for (const pattern2 of patterns2) {
      const filepath = this._getFullEntryPath(pattern2);
      const entry2 = this._getEntry(filepath, pattern2, options3);
      if (entry2 === null || !options3.entryFilter(entry2)) {
        continue;
      }
      entries.push(entry2);
    }
    return entries;
  }
  _getEntry(filepath, pattern2, options3) {
    try {
      const stats = this._getStat(filepath);
      return this._makeEntry(stats, pattern2);
    } catch (error2) {
      if (options3.errorFilter(error2)) {
        return null;
      }
      throw error2;
    }
  }
  _getStat(filepath) {
    return this._statSync(filepath, this._fsStatSettings);
  }
};
sync$1.default = ReaderSync;
Object.defineProperty(sync$2, "__esModule", { value: true });
var sync_1$1 = sync$1;
var provider_1 = provider;
var ProviderSync = class extends provider_1.default {
  constructor() {
    super(...arguments);
    this._reader = new sync_1$1.default(this._settings);
  }
  read(task) {
    const root2 = this._getRootDirectory(task);
    const options3 = this._getReaderOptions(task);
    const entries = this.api(root2, task, options3);
    return entries.map(options3.transform);
  }
  api(root2, task, options3) {
    if (task.dynamic) {
      return this._reader.dynamic(root2, options3);
    }
    return this._reader.static(task.patterns, options3);
  }
};
sync$2.default = ProviderSync;
var settings = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
  const fs2 = import_fs.default;
  const os2 = import_os.default;
  const CPU_COUNT = Math.max(os2.cpus().length, 1);
  exports.DEFAULT_FILE_SYSTEM_ADAPTER = {
    lstat: fs2.lstat,
    lstatSync: fs2.lstatSync,
    stat: fs2.stat,
    statSync: fs2.statSync,
    readdir: fs2.readdir,
    readdirSync: fs2.readdirSync
  };
  class Settings2 {
    constructor(_options = {}) {
      this._options = _options;
      this.absolute = this._getValue(this._options.absolute, false);
      this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
      this.braceExpansion = this._getValue(this._options.braceExpansion, true);
      this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
      this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
      this.cwd = this._getValue(this._options.cwd, process.cwd());
      this.deep = this._getValue(this._options.deep, Infinity);
      this.dot = this._getValue(this._options.dot, false);
      this.extglob = this._getValue(this._options.extglob, true);
      this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
      this.fs = this._getFileSystemMethods(this._options.fs);
      this.globstar = this._getValue(this._options.globstar, true);
      this.ignore = this._getValue(this._options.ignore, []);
      this.markDirectories = this._getValue(this._options.markDirectories, false);
      this.objectMode = this._getValue(this._options.objectMode, false);
      this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
      this.onlyFiles = this._getValue(this._options.onlyFiles, true);
      this.stats = this._getValue(this._options.stats, false);
      this.suppressErrors = this._getValue(this._options.suppressErrors, false);
      this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
      this.unique = this._getValue(this._options.unique, true);
      if (this.onlyDirectories) {
        this.onlyFiles = false;
      }
      if (this.stats) {
        this.objectMode = true;
      }
    }
    _getValue(option, value2) {
      return option === void 0 ? value2 : option;
    }
    _getFileSystemMethods(methods = {}) {
      return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
    }
  }
  exports.default = Settings2;
})(settings);
var taskManager = tasks;
var patternManager = patterns;
var async_1 = async$7;
var stream_1 = stream;
var sync_1 = sync$2;
var settings_1 = settings;
var utils = utils$g;
async function FastGlob(source2, options3) {
  assertPatternsInput(source2);
  const works = getWorks(source2, async_1.default, options3);
  const result = await Promise.all(works);
  return utils.array.flatten(result);
}
(function(FastGlob2) {
  function sync2(source2, options3) {
    assertPatternsInput(source2);
    const works = getWorks(source2, sync_1.default, options3);
    return utils.array.flatten(works);
  }
  FastGlob2.sync = sync2;
  function stream4(source2, options3) {
    assertPatternsInput(source2);
    const works = getWorks(source2, stream_1.default, options3);
    return utils.stream.merge(works);
  }
  FastGlob2.stream = stream4;
  function generateTasks(source2, options3) {
    assertPatternsInput(source2);
    const patterns2 = patternManager.transform([].concat(source2));
    const settings2 = new settings_1.default(options3);
    return taskManager.generate(patterns2, settings2);
  }
  FastGlob2.generateTasks = generateTasks;
  function isDynamicPattern2(source2, options3) {
    assertPatternsInput(source2);
    const settings2 = new settings_1.default(options3);
    return utils.pattern.isDynamicPattern(source2, settings2);
  }
  FastGlob2.isDynamicPattern = isDynamicPattern2;
  function escapePath(source2) {
    assertPatternsInput(source2);
    return utils.path.escape(source2);
  }
  FastGlob2.escapePath = escapePath;
})(FastGlob || (FastGlob = {}));
function getWorks(source2, _Provider, options3) {
  const patterns2 = patternManager.transform([].concat(source2));
  const settings2 = new settings_1.default(options3);
  const tasks2 = taskManager.generate(patterns2, settings2);
  const provider2 = new _Provider(settings2);
  return tasks2.map(provider2.read, provider2);
}
function assertPatternsInput(input) {
  const source2 = [].concat(input);
  const isValidSource = source2.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
  if (!isValidSource) {
    throw new TypeError("Patterns must be a string (non empty) or an array of strings");
  }
}
var out = FastGlob;
var dist = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.lilconfigSync = exports.lilconfig = exports.defaultLoaders = void 0;
  const path4 = import_path.default;
  const fs2 = import_fs.default;
  const os2 = import_os.default;
  const fsReadFileAsync = fs2.promises.readFile;
  function getDefaultSearchPlaces(name) {
    return [
      "package.json",
      `.${name}rc.json`,
      `.${name}rc.js`,
      `${name}.config.js`,
      `.${name}rc.cjs`,
      `${name}.config.cjs`
    ];
  }
  function getSearchPaths(startDir, stopDir) {
    return startDir.split(path4.sep).reduceRight((acc, _, ind, arr) => {
      const currentPath = arr.slice(0, ind + 1).join(path4.sep);
      if (!acc.passedStopDir)
        acc.searchPlaces.push(currentPath || path4.sep);
      if (currentPath === stopDir)
        acc.passedStopDir = true;
      return acc;
    }, { searchPlaces: [], passedStopDir: false }).searchPlaces;
  }
  exports.defaultLoaders = Object.freeze({
    ".js": __require2,
    ".json": __require2,
    ".cjs": __require2,
    noExt(_, content) {
      return JSON.parse(content);
    }
  });
  function getExtDesc(ext2) {
    return ext2 === "noExt" ? "files without extensions" : `extension "${ext2}"`;
  }
  function getOptions2(name, options3 = {}) {
    const conf = {
      stopDir: os2.homedir(),
      searchPlaces: getDefaultSearchPlaces(name),
      ignoreEmptySearchPlaces: true,
      transform: (x) => x,
      packageProp: [name],
      ...options3,
      loaders: { ...exports.defaultLoaders, ...options3.loaders }
    };
    conf.searchPlaces.forEach((place) => {
      const key2 = path4.extname(place) || "noExt";
      const loader = conf.loaders[key2];
      if (!loader) {
        throw new Error(`No loader specified for ${getExtDesc(key2)}, so searchPlaces item "${place}" is invalid`);
      }
      if (typeof loader !== "function") {
        throw new Error(`loader for ${getExtDesc(key2)} is not a function (type provided: "${typeof loader}"), so searchPlaces item "${place}" is invalid`);
      }
    });
    return conf;
  }
  function getPackageProp(props, obj) {
    if (typeof props === "string" && props in obj)
      return obj[props];
    return (Array.isArray(props) ? props : props.split(".")).reduce((acc, prop) => acc === void 0 ? acc : acc[prop], obj) || null;
  }
  function getSearchItems(searchPlaces, searchPaths) {
    return searchPaths.reduce((acc, searchPath) => {
      searchPlaces.forEach((fileName) => acc.push({
        fileName,
        filepath: path4.join(searchPath, fileName),
        loaderKey: path4.extname(fileName) || "noExt"
      }));
      return acc;
    }, []);
  }
  function validateFilePath(filepath) {
    if (!filepath)
      throw new Error("load must pass a non-empty string");
  }
  function validateLoader(loader, ext2) {
    if (!loader)
      throw new Error(`No loader specified for extension "${ext2}"`);
    if (typeof loader !== "function")
      throw new Error("loader is not a function");
  }
  function lilconfig(name, options3) {
    const { ignoreEmptySearchPlaces, loaders, packageProp, searchPlaces, stopDir, transform: transform2 } = getOptions2(name, options3);
    return {
      async search(searchFrom = process.cwd()) {
        const searchPaths = getSearchPaths(searchFrom, stopDir);
        const result = {
          config: null,
          filepath: ""
        };
        const searchItems = getSearchItems(searchPlaces, searchPaths);
        for (const { fileName, filepath, loaderKey } of searchItems) {
          try {
            await fs2.promises.access(filepath);
          } catch (_a) {
            continue;
          }
          const content = String(await fsReadFileAsync(filepath));
          const loader = loaders[loaderKey];
          if (fileName === "package.json") {
            const pkg = await loader(filepath, content);
            const maybeConfig = getPackageProp(packageProp, pkg);
            if (maybeConfig != null) {
              result.config = maybeConfig;
              result.filepath = filepath;
              break;
            }
            continue;
          }
          const isEmpty2 = content.trim() === "";
          if (isEmpty2 && ignoreEmptySearchPlaces)
            continue;
          if (isEmpty2) {
            result.isEmpty = true;
            result.config = void 0;
          } else {
            validateLoader(loader, loaderKey);
            result.config = await loader(filepath, content);
          }
          result.filepath = filepath;
          break;
        }
        if (result.filepath === "" && result.config === null)
          return transform2(null);
        return transform2(result);
      },
      async load(filepath) {
        validateFilePath(filepath);
        const absPath = path4.resolve(process.cwd(), filepath);
        const { base: base2, ext: ext2 } = path4.parse(absPath);
        const loaderKey = ext2 || "noExt";
        const loader = loaders[loaderKey];
        validateLoader(loader, loaderKey);
        const content = String(await fsReadFileAsync(absPath));
        if (base2 === "package.json") {
          const pkg = await loader(absPath, content);
          return transform2({
            config: getPackageProp(packageProp, pkg),
            filepath: absPath
          });
        }
        const result = {
          config: null,
          filepath: absPath
        };
        const isEmpty2 = content.trim() === "";
        if (isEmpty2 && ignoreEmptySearchPlaces)
          return transform2({
            config: void 0,
            filepath: absPath,
            isEmpty: true
          });
        result.config = isEmpty2 ? void 0 : await loader(absPath, content);
        return transform2(isEmpty2 ? { ...result, isEmpty: isEmpty2, config: void 0 } : result);
      }
    };
  }
  exports.lilconfig = lilconfig;
  function lilconfigSync(name, options3) {
    const { ignoreEmptySearchPlaces, loaders, packageProp, searchPlaces, stopDir, transform: transform2 } = getOptions2(name, options3);
    return {
      search(searchFrom = process.cwd()) {
        const searchPaths = getSearchPaths(searchFrom, stopDir);
        const result = {
          config: null,
          filepath: ""
        };
        const searchItems = getSearchItems(searchPlaces, searchPaths);
        for (const { fileName, filepath, loaderKey } of searchItems) {
          try {
            fs2.accessSync(filepath);
          } catch (_a) {
            continue;
          }
          const loader = loaders[loaderKey];
          const content = String(fs2.readFileSync(filepath));
          if (fileName === "package.json") {
            const pkg = loader(filepath, content);
            const maybeConfig = getPackageProp(packageProp, pkg);
            if (maybeConfig != null) {
              result.config = maybeConfig;
              result.filepath = filepath;
              break;
            }
            continue;
          }
          const isEmpty2 = content.trim() === "";
          if (isEmpty2 && ignoreEmptySearchPlaces)
            continue;
          if (isEmpty2) {
            result.isEmpty = true;
            result.config = void 0;
          } else {
            validateLoader(loader, loaderKey);
            result.config = loader(filepath, content);
          }
          result.filepath = filepath;
          break;
        }
        if (result.filepath === "" && result.config === null)
          return transform2(null);
        return transform2(result);
      },
      load(filepath) {
        validateFilePath(filepath);
        const absPath = path4.resolve(process.cwd(), filepath);
        const { base: base2, ext: ext2 } = path4.parse(absPath);
        const loaderKey = ext2 || "noExt";
        const loader = loaders[loaderKey];
        validateLoader(loader, loaderKey);
        const content = String(fs2.readFileSync(absPath));
        if (base2 === "package.json") {
          const pkg = loader(absPath, content);
          return transform2({
            config: getPackageProp(packageProp, pkg),
            filepath: absPath
          });
        }
        const result = {
          config: null,
          filepath: absPath
        };
        const isEmpty2 = content.trim() === "";
        if (isEmpty2 && ignoreEmptySearchPlaces)
          return transform2({
            filepath: absPath,
            config: void 0,
            isEmpty: true
          });
        result.config = isEmpty2 ? void 0 : loader(absPath, content);
        return transform2(isEmpty2 ? { ...result, isEmpty: isEmpty2, config: void 0 } : result);
      }
    };
  }
  exports.lilconfigSync = lilconfigSync;
})(dist);
var ALIAS = Symbol.for("yaml.alias");
var DOC = Symbol.for("yaml.document");
var MAP = Symbol.for("yaml.map");
var PAIR = Symbol.for("yaml.pair");
var SCALAR$1 = Symbol.for("yaml.scalar");
var SEQ = Symbol.for("yaml.seq");
var NODE_TYPE = Symbol.for("yaml.node.type");
var isAlias = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === ALIAS;
var isDocument = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === DOC;
var isMap = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === MAP;
var isPair = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === PAIR;
var isScalar$1 = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === SCALAR$1;
var isSeq = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === SEQ;
function isCollection$1(node2) {
  if (node2 && typeof node2 === "object")
    switch (node2[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
function isNode(node2) {
  if (node2 && typeof node2 === "object")
    switch (node2[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR$1:
      case SEQ:
        return true;
    }
  return false;
}
var hasAnchor = (node2) => (isScalar$1(node2) || isCollection$1(node2)) && !!node2.anchor;
var NodeBase = class {
  constructor(type) {
    Object.defineProperty(this, NODE_TYPE, { value: type });
  }
  clone() {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
};
var BREAK$1 = Symbol("break visit");
var SKIP$1 = Symbol("skip children");
var REMOVE$1 = Symbol("remove node");
function visit$1(node2, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node2)) {
    const cd = visit_(null, node2.contents, visitor_, Object.freeze([node2]));
    if (cd === REMOVE$1)
      node2.contents = null;
  } else
    visit_(null, node2, visitor_, Object.freeze([]));
}
visit$1.BREAK = BREAK$1;
visit$1.SKIP = SKIP$1;
visit$1.REMOVE = REMOVE$1;
function visit_(key2, node2, visitor, path4) {
  const ctrl = callVisitor(key2, node2, visitor, path4);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key2, path4, ctrl);
    return visit_(key2, ctrl, visitor, path4);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection$1(node2)) {
      path4 = Object.freeze(path4.concat(node2));
      for (let i = 0; i < node2.items.length; ++i) {
        const ci = visit_(i, node2.items[i], visitor, path4);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK$1)
          return BREAK$1;
        else if (ci === REMOVE$1) {
          node2.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node2)) {
      path4 = Object.freeze(path4.concat(node2));
      const ck = visit_("key", node2.key, visitor, path4);
      if (ck === BREAK$1)
        return BREAK$1;
      else if (ck === REMOVE$1)
        node2.key = null;
      const cv = visit_("value", node2.value, visitor, path4);
      if (cv === BREAK$1)
        return BREAK$1;
      else if (cv === REMOVE$1)
        node2.value = null;
    }
  }
  return ctrl;
}
async function visitAsync(node2, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node2)) {
    const cd = await visitAsync_(null, node2.contents, visitor_, Object.freeze([node2]));
    if (cd === REMOVE$1)
      node2.contents = null;
  } else
    await visitAsync_(null, node2, visitor_, Object.freeze([]));
}
visitAsync.BREAK = BREAK$1;
visitAsync.SKIP = SKIP$1;
visitAsync.REMOVE = REMOVE$1;
async function visitAsync_(key2, node2, visitor, path4) {
  const ctrl = await callVisitor(key2, node2, visitor, path4);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key2, path4, ctrl);
    return visitAsync_(key2, ctrl, visitor, path4);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection$1(node2)) {
      path4 = Object.freeze(path4.concat(node2));
      for (let i = 0; i < node2.items.length; ++i) {
        const ci = await visitAsync_(i, node2.items[i], visitor, path4);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK$1)
          return BREAK$1;
        else if (ci === REMOVE$1) {
          node2.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node2)) {
      path4 = Object.freeze(path4.concat(node2));
      const ck = await visitAsync_("key", node2.key, visitor, path4);
      if (ck === BREAK$1)
        return BREAK$1;
      else if (ck === REMOVE$1)
        node2.key = null;
      const cv = await visitAsync_("value", node2.value, visitor, path4);
      if (cv === BREAK$1)
        return BREAK$1;
      else if (cv === REMOVE$1)
        node2.value = null;
    }
  }
  return ctrl;
}
function initVisitor(visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
function callVisitor(key2, node2, visitor, path4) {
  var _a, _b, _c, _d, _e;
  if (typeof visitor === "function")
    return visitor(key2, node2, path4);
  if (isMap(node2))
    return (_a = visitor.Map) == null ? void 0 : _a.call(visitor, key2, node2, path4);
  if (isSeq(node2))
    return (_b = visitor.Seq) == null ? void 0 : _b.call(visitor, key2, node2, path4);
  if (isPair(node2))
    return (_c = visitor.Pair) == null ? void 0 : _c.call(visitor, key2, node2, path4);
  if (isScalar$1(node2))
    return (_d = visitor.Scalar) == null ? void 0 : _d.call(visitor, key2, node2, path4);
  if (isAlias(node2))
    return (_e = visitor.Alias) == null ? void 0 : _e.call(visitor, key2, node2, path4);
  return void 0;
}
function replaceNode(key2, path4, node2) {
  const parent = path4[path4.length - 1];
  if (isCollection$1(parent)) {
    parent.items[key2] = node2;
  } else if (isPair(parent)) {
    if (key2 === "key")
      parent.key = node2;
    else
      parent.value = node2;
  } else if (isDocument(parent)) {
    parent.contents = node2;
  } else {
    const pt = isAlias(parent) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${pt} parent`);
  }
}
var escapeChars = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
};
var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
var Directives = class {
  constructor(yaml2, tags) {
    this.docStart = null;
    this.docEnd = false;
    this.yaml = Object.assign({}, Directives.defaultYaml, yaml2);
    this.tags = Object.assign({}, Directives.defaultTags, tags);
  }
  clone() {
    const copy = new Directives(this.yaml, this.tags);
    copy.docStart = this.docStart;
    return copy;
  }
  atDocument() {
    const res = new Directives(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = true;
        break;
      case "1.2":
        this.atNextDocument = false;
        this.yaml = {
          explicit: Directives.defaultYaml.explicit,
          version: "1.2"
        };
        this.tags = Object.assign({}, Directives.defaultTags);
        break;
    }
    return res;
  }
  add(line2, onError) {
    if (this.atNextDocument) {
      this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
      this.tags = Object.assign({}, Directives.defaultTags);
      this.atNextDocument = false;
    }
    const parts = line2.trim().split(/[ \t]+/);
    const name = parts.shift();
    switch (name) {
      case "%TAG": {
        if (parts.length !== 2) {
          onError(0, "%TAG directive should contain exactly two parts");
          if (parts.length < 2)
            return false;
        }
        const [handle2, prefix] = parts;
        this.tags[handle2] = prefix;
        return true;
      }
      case "%YAML": {
        this.yaml.explicit = true;
        if (parts.length !== 1) {
          onError(0, "%YAML directive should contain exactly one part");
          return false;
        }
        const [version3] = parts;
        if (version3 === "1.1" || version3 === "1.2") {
          this.yaml.version = version3;
          return true;
        } else {
          const isValid = /^\d+\.\d+$/.test(version3);
          onError(6, `Unsupported YAML version ${version3}`, isValid);
          return false;
        }
      }
      default:
        onError(0, `Unknown directive ${name}`, true);
        return false;
    }
  }
  tagName(source2, onError) {
    if (source2 === "!")
      return "!";
    if (source2[0] !== "!") {
      onError(`Not a valid tag: ${source2}`);
      return null;
    }
    if (source2[1] === "<") {
      const verbatim = source2.slice(2, -1);
      if (verbatim === "!" || verbatim === "!!") {
        onError(`Verbatim tags aren't resolved, so ${source2} is invalid.`);
        return null;
      }
      if (source2[source2.length - 1] !== ">")
        onError("Verbatim tags must end with a >");
      return verbatim;
    }
    const [, handle2, suffix] = source2.match(/^(.*!)([^!]*)$/);
    if (!suffix)
      onError(`The ${source2} tag has no suffix`);
    const prefix = this.tags[handle2];
    if (prefix)
      return prefix + decodeURIComponent(suffix);
    if (handle2 === "!")
      return source2;
    onError(`Could not resolve tag: ${source2}`);
    return null;
  }
  tagString(tag) {
    for (const [handle2, prefix] of Object.entries(this.tags)) {
      if (tag.startsWith(prefix))
        return handle2 + escapeTagName(tag.substring(prefix.length));
    }
    return tag[0] === "!" ? tag : `!<${tag}>`;
  }
  toString(doc) {
    const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
    const tagEntries = Object.entries(this.tags);
    let tagNames;
    if (doc && tagEntries.length > 0 && isNode(doc.contents)) {
      const tags = {};
      visit$1(doc.contents, (_key, node2) => {
        if (isNode(node2) && node2.tag)
          tags[node2.tag] = true;
      });
      tagNames = Object.keys(tags);
    } else
      tagNames = [];
    for (const [handle2, prefix] of tagEntries) {
      if (handle2 === "!!" && prefix === "tag:yaml.org,2002:")
        continue;
      if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
        lines.push(`%TAG ${handle2} ${prefix}`);
    }
    return lines.join("\n");
  }
};
Directives.defaultYaml = { explicit: false, version: "1.2" };
Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root2) {
  const anchors = /* @__PURE__ */ new Set();
  visit$1(root2, {
    Value(_key, node2) {
      if (node2.anchor)
        anchors.add(node2.anchor);
    }
  });
  return anchors;
}
function findNewAnchor(prefix, exclude) {
  for (let i = 1; true; ++i) {
    const name = `${prefix}${i}`;
    if (!exclude.has(name))
      return name;
  }
}
function createNodeAnchors(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor: (source2) => {
      aliasObjects.push(source2);
      if (!prevAnchors)
        prevAnchors = anchorNames(doc);
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    setAnchors: () => {
      for (const source2 of aliasObjects) {
        const ref2 = sourceObjects.get(source2);
        if (typeof ref2 === "object" && ref2.anchor && (isScalar$1(ref2.node) || isCollection$1(ref2.node))) {
          ref2.node.anchor = ref2.anchor;
        } else {
          const error2 = new Error("Failed to resolve repeated object (this should not happen)");
          error2.source = source2;
          throw error2;
        }
      }
    },
    sourceObjects
  };
}
var Alias = class extends NodeBase {
  constructor(source2) {
    super(ALIAS);
    this.source = source2;
    Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  resolve(doc) {
    let found2 = void 0;
    visit$1(doc, {
      Node: (_key, node2) => {
        if (node2 === this)
          return visit$1.BREAK;
        if (node2.anchor === this.source)
          found2 = node2;
      }
    });
    return found2;
  }
  toJSON(_arg, ctx2) {
    if (!ctx2)
      return { source: this.source };
    const { anchors, doc, maxAliasCount } = ctx2;
    const source2 = this.resolve(doc);
    if (!source2) {
      const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(msg);
    }
    const data2 = anchors.get(source2);
    if (!data2 || data2.res === void 0) {
      const msg = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(msg);
    }
    if (maxAliasCount >= 0) {
      data2.count += 1;
      if (data2.aliasCount === 0)
        data2.aliasCount = getAliasCount(doc, source2, anchors);
      if (data2.count * data2.aliasCount > maxAliasCount) {
        const msg = "Excessive alias count indicates a resource exhaustion attack";
        throw new ReferenceError(msg);
      }
    }
    return data2.res;
  }
  toString(ctx2, _onComment, _onChompKeep) {
    const src2 = `*${this.source}`;
    if (ctx2) {
      anchorIsValid(this.source);
      if (ctx2.options.verifyAliasOrder && !ctx2.anchors.has(this.source)) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(msg);
      }
      if (ctx2.implicitKey)
        return `${src2} `;
    }
    return src2;
  }
};
function getAliasCount(doc, node2, anchors) {
  if (isAlias(node2)) {
    const source2 = node2.resolve(doc);
    const anchor = anchors && source2 && anchors.get(source2);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection$1(node2)) {
    let count = 0;
    for (const item of node2.items) {
      const c2 = getAliasCount(doc, item, anchors);
      if (c2 > count)
        count = c2;
    }
    return count;
  } else if (isPair(node2)) {
    const kc = getAliasCount(doc, node2.key, anchors);
    const vc = getAliasCount(doc, node2.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}
function toJS(value2, arg, ctx2) {
  if (Array.isArray(value2))
    return value2.map((v, i) => toJS(v, String(i), ctx2));
  if (value2 && typeof value2.toJSON === "function") {
    if (!ctx2 || !hasAnchor(value2))
      return value2.toJSON(arg, ctx2);
    const data2 = { aliasCount: 0, count: 1, res: void 0 };
    ctx2.anchors.set(value2, data2);
    ctx2.onCreate = (res2) => {
      data2.res = res2;
      delete ctx2.onCreate;
    };
    const res = value2.toJSON(arg, ctx2);
    if (ctx2.onCreate)
      ctx2.onCreate(res);
    return res;
  }
  if (typeof value2 === "bigint" && !(ctx2 == null ? void 0 : ctx2.keep))
    return Number(value2);
  return value2;
}
var isScalarValue = (value2) => !value2 || typeof value2 !== "function" && typeof value2 !== "object";
var Scalar = class extends NodeBase {
  constructor(value2) {
    super(SCALAR$1);
    this.value = value2;
  }
  toJSON(arg, ctx2) {
    return (ctx2 == null ? void 0 : ctx2.keep) ? this.value : toJS(this.value, arg, ctx2);
  }
  toString() {
    return String(this.value);
  }
};
Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
Scalar.PLAIN = "PLAIN";
Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
var defaultTagPrefix = "tag:yaml.org,2002:";
function findTagObject(value2, tagName, tags) {
  var _a;
  if (tagName) {
    const match = tags.filter((t) => t.tag === tagName);
    const tagObj = (_a = match.find((t) => !t.format)) != null ? _a : match[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find((t) => {
    var _a2;
    return ((_a2 = t.identify) == null ? void 0 : _a2.call(t, value2)) && !t.format;
  });
}
function createNode(value2, tagName, ctx2) {
  var _a, _b;
  if (isDocument(value2))
    value2 = value2.contents;
  if (isNode(value2))
    return value2;
  if (isPair(value2)) {
    const map2 = (_b = (_a = ctx2.schema[MAP]).createNode) == null ? void 0 : _b.call(_a, ctx2.schema, null, ctx2);
    map2.items.push(value2);
    return map2;
  }
  if (value2 instanceof String || value2 instanceof Number || value2 instanceof Boolean || typeof BigInt === "function" && value2 instanceof BigInt) {
    value2 = value2.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema2, sourceObjects } = ctx2;
  let ref2 = void 0;
  if (aliasDuplicateObjects && value2 && typeof value2 === "object") {
    ref2 = sourceObjects.get(value2);
    if (ref2) {
      if (!ref2.anchor)
        ref2.anchor = onAnchor(value2);
      return new Alias(ref2.anchor);
    } else {
      ref2 = { anchor: null, node: null };
      sourceObjects.set(value2, ref2);
    }
  }
  if (tagName == null ? void 0 : tagName.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value2, tagName, schema2.tags);
  if (!tagObj) {
    if (value2 && typeof value2.toJSON === "function") {
      value2 = value2.toJSON();
    }
    if (!value2 || typeof value2 !== "object") {
      const node3 = new Scalar(value2);
      if (ref2)
        ref2.node = node3;
      return node3;
    }
    tagObj = value2 instanceof Map ? schema2[MAP] : Symbol.iterator in Object(value2) ? schema2[SEQ] : schema2[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx2.onTagObj;
  }
  const node2 = (tagObj == null ? void 0 : tagObj.createNode) ? tagObj.createNode(ctx2.schema, value2, ctx2) : new Scalar(value2);
  if (tagName)
    node2.tag = tagName;
  if (ref2)
    ref2.node = node2;
  return node2;
}
function collectionFromPath(schema2, path4, value2) {
  let v = value2;
  for (let i = path4.length - 1; i >= 0; --i) {
    const k = path4[i];
    if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
      const a = [];
      a[k] = v;
      v = a;
    } else {
      v = /* @__PURE__ */ new Map([[k, v]]);
    }
  }
  return createNode(v, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema2,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
var isEmptyPath = (path4) => path4 == null || typeof path4 === "object" && !!path4[Symbol.iterator]().next().done;
var Collection = class extends NodeBase {
  constructor(type, schema2) {
    super(type);
    Object.defineProperty(this, "schema", {
      value: schema2,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  clone(schema2) {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (schema2)
      copy.schema = schema2;
    copy.items = copy.items.map((it) => isNode(it) || isPair(it) ? it.clone(schema2) : it);
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  addIn(path4, value2) {
    if (isEmptyPath(path4))
      this.add(value2);
    else {
      const [key2, ...rest] = path4;
      const node2 = this.get(key2, true);
      if (isCollection$1(node2))
        node2.addIn(rest, value2);
      else if (node2 === void 0 && this.schema)
        this.set(key2, collectionFromPath(this.schema, rest, value2));
      else
        throw new Error(`Expected YAML collection at ${key2}. Remaining path: ${rest}`);
    }
  }
  deleteIn(path4) {
    const [key2, ...rest] = path4;
    if (rest.length === 0)
      return this.delete(key2);
    const node2 = this.get(key2, true);
    if (isCollection$1(node2))
      return node2.deleteIn(rest);
    else
      throw new Error(`Expected YAML collection at ${key2}. Remaining path: ${rest}`);
  }
  getIn(path4, keepScalar) {
    const [key2, ...rest] = path4;
    const node2 = this.get(key2, true);
    if (rest.length === 0)
      return !keepScalar && isScalar$1(node2) ? node2.value : node2;
    else
      return isCollection$1(node2) ? node2.getIn(rest, keepScalar) : void 0;
  }
  hasAllNullValues(allowScalar) {
    return this.items.every((node2) => {
      if (!isPair(node2))
        return false;
      const n2 = node2.value;
      return n2 == null || allowScalar && isScalar$1(n2) && n2.value == null && !n2.commentBefore && !n2.comment && !n2.tag;
    });
  }
  hasIn(path4) {
    const [key2, ...rest] = path4;
    if (rest.length === 0)
      return this.has(key2);
    const node2 = this.get(key2, true);
    return isCollection$1(node2) ? node2.hasIn(rest) : false;
  }
  setIn(path4, value2) {
    const [key2, ...rest] = path4;
    if (rest.length === 0) {
      this.set(key2, value2);
    } else {
      const node2 = this.get(key2, true);
      if (isCollection$1(node2))
        node2.setIn(rest, value2);
      else if (node2 === void 0 && this.schema)
        this.set(key2, collectionFromPath(this.schema, rest, value2));
      else
        throw new Error(`Expected YAML collection at ${key2}. Remaining path: ${rest}`);
    }
  }
};
Collection.maxFlowStringSingleLineLength = 60;
var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
function indentComment(comment, indent) {
  if (/^\n+$/.test(comment))
    return comment.substring(1);
  return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
var lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
var FOLD_FLOW = "flow";
var FOLD_BLOCK = "block";
var FOLD_QUOTED = "quoted";
function foldFlowLines(text, indent, mode2 = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep)
    return text;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev = void 0;
  let overflow = false;
  let i = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode2 === FOLD_BLOCK) {
    i = consumeMoreIndentedLines(text, i);
    if (i !== -1)
      end = i + endStep;
  }
  for (let ch; ch = text[i += 1]; ) {
    if (mode2 === FOLD_QUOTED && ch === "\\") {
      escStart = i;
      switch (text[i + 1]) {
        case "x":
          i += 3;
          break;
        case "u":
          i += 5;
          break;
        case "U":
          i += 9;
          break;
        default:
          i += 1;
      }
      escEnd = i;
    }
    if (ch === "\n") {
      if (mode2 === FOLD_BLOCK)
        i = consumeMoreIndentedLines(text, i);
      end = i + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        const next = text[i + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split = i;
      }
      if (i >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = void 0;
        } else if (mode2 === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text[i += 1];
            overflow = true;
          }
          const j = i > escEnd + 1 ? i - 2 : escStart - 1;
          if (escapedFolds[j])
            return text;
          folds.push(j);
          escapedFolds[j] = true;
          end = j + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text;
  if (onFold)
    onFold();
  let res = text.slice(0, folds[0]);
  for (let i2 = 0; i2 < folds.length; ++i2) {
    const fold = folds[i2];
    const end2 = folds[i2 + 1] || text.length;
    if (fold === 0)
      res = `
${indent}${text.slice(0, end2)}`;
    else {
      if (mode2 === FOLD_QUOTED && escapedFolds[fold])
        res += `${text[fold]}\\`;
      res += `
${indent}${text.slice(fold + 1, end2)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines(text, i) {
  let ch = text[i + 1];
  while (ch === " " || ch === "	") {
    do {
      ch = text[i += 1];
    } while (ch && ch !== "\n");
    ch = text[i + 1];
  }
  return i;
}
var getFoldOptions = (ctx2) => ({
  indentAtStart: ctx2.indentAtStart,
  lineWidth: ctx2.options.lineWidth,
  minContentWidth: ctx2.options.minContentWidth
});
var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit)
    return false;
  for (let i = 0, start = 0; i < strLen; ++i) {
    if (str[i] === "\n") {
      if (i - start > limit)
        return true;
      start = i + 1;
      if (strLen - start <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value2, ctx2) {
  const json = JSON.stringify(value2);
  if (ctx2.options.doubleQuotedAsJSON)
    return json;
  const { implicitKey } = ctx2;
  const minMultiLineLength = ctx2.options.doubleQuotedMinMultiLineLength;
  const indent = ctx2.indent || (containsDocumentMarker(value2) ? "  " : "");
  let str = "";
  let start = 0;
  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
    if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
      str += json.slice(start, i) + "\\ ";
      i += 1;
      start = i;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json[i + 1]) {
        case "u":
          {
            str += json.slice(start, i);
            const code = json.substr(i + 2, 4);
            switch (code) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str += "\\x" + code.substr(2);
                else
                  str += json.substr(i, 6);
            }
            i += 5;
            start = i + 1;
          }
          break;
        case "n":
          if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
            i += 1;
          } else {
            str += json.slice(start, i) + "\n\n";
            while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
              str += "\n";
              i += 2;
            }
            str += indent;
            if (json[i + 2] === " ")
              str += "\\";
            i += 1;
            start = i + 1;
          }
          break;
        default:
          i += 1;
      }
  }
  str = start ? str + json.slice(start) : json;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx2));
}
function singleQuotedString(value2, ctx2) {
  if (ctx2.options.singleQuote === false || ctx2.implicitKey && value2.includes("\n") || /[ \t]\n|\n[ \t]/.test(value2))
    return doubleQuotedString(value2, ctx2);
  const indent = ctx2.indent || (containsDocumentMarker(value2) ? "  " : "");
  const res = "'" + value2.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx2.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx2));
}
function quotedString(value2, ctx2) {
  const { singleQuote } = ctx2.options;
  let qs2;
  if (singleQuote === false)
    qs2 = doubleQuotedString;
  else {
    const hasDouble = value2.includes('"');
    const hasSingle = value2.includes("'");
    if (hasDouble && !hasSingle)
      qs2 = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs2 = doubleQuotedString;
    else
      qs2 = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs2(value2, ctx2);
}
function blockString({ comment, type, value: value2 }, ctx2, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx2.options;
  if (!blockQuote || /\n[\t ]+$/.test(value2) || /^\s*$/.test(value2)) {
    return quotedString(value2, ctx2);
  }
  const indent = ctx2.indent || (ctx2.forceBlockIndent || containsDocumentMarker(value2) ? "  " : "");
  const literal2 = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value2, lineWidth, indent.length);
  if (!value2)
    return literal2 ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value2.length; endStart > 0; --endStart) {
    const ch = value2[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end = value2.substring(endStart);
  const endNlPos = end.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value2 === end || endNlPos !== end.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end) {
    value2 = value2.slice(0, -end.length);
    if (end[end.length - 1] === "\n")
      end = end.slice(0, -1);
    end = end.replace(/\n+(?!\n|$)/g, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value2.length; ++startEnd) {
    const ch = value2[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start = value2.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start) {
    value2 = value2.substring(start.length);
    start = start.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (literal2 ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
  if (comment) {
    header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (literal2) {
    value2 = value2.replace(/\n+/g, `$&${indent}`);
    return `${header}
${indent}${start}${value2}${end}`;
  }
  value2 = value2.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
  const body = foldFlowLines(`${start}${value2}${end}`, indent, FOLD_BLOCK, getFoldOptions(ctx2));
  return `${header}
${indent}${body}`;
}
function plainString(item, ctx2, onComment, onChompKeep) {
  const { type, value: value2 } = item;
  const { actualString, implicitKey, indent, inFlow } = ctx2;
  if (implicitKey && /[\n[\]{},]/.test(value2) || inFlow && /[[\]{},]/.test(value2)) {
    return quotedString(value2, ctx2);
  }
  if (!value2 || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value2)) {
    return implicitKey || inFlow || !value2.includes("\n") ? quotedString(value2, ctx2) : blockString(item, ctx2, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value2.includes("\n")) {
    return blockString(item, ctx2, onComment, onChompKeep);
  }
  if (indent === "" && containsDocumentMarker(value2)) {
    ctx2.forceBlockIndent = true;
    return blockString(item, ctx2, onComment, onChompKeep);
  }
  const str = value2.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test = (tag) => {
      var _a;
      return tag.default && tag.tag !== "tag:yaml.org,2002:str" && ((_a = tag.test) == null ? void 0 : _a.test(str));
    };
    const { compat, tags } = ctx2.doc.schema;
    if (tags.some(test) || (compat == null ? void 0 : compat.some(test)))
      return quotedString(value2, ctx2);
  }
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx2));
}
function stringifyString(item, ctx2, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx2;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx2) : blockString(ss, ctx2, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx2);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx2);
      case Scalar.PLAIN:
        return plainString(ss, ctx2, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx2.options;
    const t = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t);
    if (res === null)
      throw new Error(`Unsupported default string type ${t}`);
  }
  return res;
}
function createStringifyContext(doc, options3) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options3);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject(tags, item) {
  var _a, _b, _c, _d;
  if (item.tag) {
    const match = tags.filter((t) => t.tag === item.tag);
    if (match.length > 0)
      return (_a = match.find((t) => t.format === item.format)) != null ? _a : match[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar$1(item)) {
    obj = item.value;
    const match = tags.filter((t) => {
      var _a2;
      return (_a2 = t.identify) == null ? void 0 : _a2.call(t, obj);
    });
    tagObj = (_b = match.find((t) => t.format === item.format)) != null ? _b : match.find((t) => !t.format);
  } else {
    obj = item;
    tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
  }
  if (!tagObj) {
    const name = (_d = (_c = obj == null ? void 0 : obj.constructor) == null ? void 0 : _c.name) != null ? _d : typeof obj;
    throw new Error(`Tag not resolved for ${name} value`);
  }
  return tagObj;
}
function stringifyProps(node2, tagObj, { anchors, doc }) {
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar$1(node2) || isCollection$1(node2)) && node2.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag = node2.tag ? node2.tag : tagObj.default ? null : tagObj.tag;
  if (tag)
    props.push(doc.directives.tagString(tag));
  return props.join(" ");
}
function stringify$3(item, ctx2, onComment, onChompKeep) {
  var _a, _b;
  if (isPair(item))
    return item.toString(ctx2, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx2.doc.directives)
      return item.toString(ctx2);
    if ((_a = ctx2.resolvedAliases) == null ? void 0 : _a.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx2.resolvedAliases)
        ctx2.resolvedAliases.add(item);
      else
        ctx2.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx2.doc);
    }
  }
  let tagObj = void 0;
  const node2 = isNode(item) ? item : ctx2.doc.createNode(item, { onTagObj: (o) => tagObj = o });
  if (!tagObj)
    tagObj = getTagObject(ctx2.doc.schema.tags, node2);
  const props = stringifyProps(node2, tagObj, ctx2);
  if (props.length > 0)
    ctx2.indentAtStart = ((_b = ctx2.indentAtStart) != null ? _b : 0) + props.length + 1;
  const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node2, ctx2, onComment, onChompKeep) : isScalar$1(node2) ? stringifyString(node2, ctx2, onComment, onChompKeep) : node2.toString(ctx2, onComment, onChompKeep);
  if (!props)
    return str;
  return isScalar$1(node2) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx2.indent}${str}`;
}
function stringifyPair({ key: key2, value: value2 }, ctx2, onComment, onChompKeep) {
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx2;
  let keyComment = isNode(key2) && key2.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection$1(key2)) {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key2 || keyComment && value2 == null && !ctx2.inFlow || isCollection$1(key2) || (isScalar$1(key2) ? key2.type === Scalar.BLOCK_FOLDED || key2.type === Scalar.BLOCK_LITERAL : typeof key2 === "object"));
  ctx2 = Object.assign({}, ctx2, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str = stringify$3(key2, ctx2, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx2.inFlow && str.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx2.inFlow) {
    if (allNullValues || value2 == null) {
      if (keyCommentDone && onComment)
        onComment();
      return str === "" ? "?" : explicitKey ? `? ${str}` : str;
    }
  } else if (allNullValues && !simpleKeys || value2 == null && explicitKey) {
    str = `? ${str}`;
    if (keyComment && !keyCommentDone) {
      str += lineComment(str, ctx2.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str += lineComment(str, ctx2.indent, commentString(keyComment));
    str = `? ${str}
${indent}:`;
  } else {
    str = `${str}:`;
    if (keyComment)
      str += lineComment(str, ctx2.indent, commentString(keyComment));
  }
  let vcb = "";
  let valueComment = null;
  if (isNode(value2)) {
    if (value2.spaceBefore)
      vcb = "\n";
    if (value2.commentBefore) {
      const cs = commentString(value2.commentBefore);
      vcb += `
${indentComment(cs, ctx2.indent)}`;
    }
    valueComment = value2.comment;
  } else if (value2 && typeof value2 === "object") {
    value2 = doc.createNode(value2);
  }
  ctx2.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar$1(value2))
    ctx2.indentAtStart = str.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx2.inFlow && !explicitKey && isSeq(value2) && !value2.flow && !value2.tag && !value2.anchor) {
    ctx2.indent = ctx2.indent.substr(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify$3(value2, ctx2, () => valueCommentDone = true, () => chompKeep = true);
  let ws = " ";
  if (vcb || keyComment) {
    if (valueStr === "" && !ctx2.inFlow)
      ws = vcb === "\n" ? "\n\n" : vcb;
    else
      ws = `${vcb}
${ctx2.indent}`;
  } else if (!explicitKey && isCollection$1(value2)) {
    const flow = valueStr[0] === "[" || valueStr[0] === "{";
    if (!flow || valueStr.includes("\n"))
      ws = `
${ctx2.indent}`;
  } else if (valueStr === "" || valueStr[0] === "\n")
    ws = "";
  str += ws + valueStr;
  if (ctx2.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str += lineComment(str, ctx2.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str;
}
function warn(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    if (typeof process !== "undefined" && process.emitWarning)
      process.emitWarning(warning);
    else
      console.warn(warning);
  }
}
var MERGE_KEY = "<<";
function addPairToJSMap(ctx2, map2, { key: key2, value: value2 }) {
  if ((ctx2 == null ? void 0 : ctx2.doc.schema.merge) && isMergeKey(key2)) {
    value2 = isAlias(value2) ? value2.resolve(ctx2.doc) : value2;
    if (isSeq(value2))
      for (const it of value2.items)
        mergeToJSMap(ctx2, map2, it);
    else if (Array.isArray(value2))
      for (const it of value2)
        mergeToJSMap(ctx2, map2, it);
    else
      mergeToJSMap(ctx2, map2, value2);
  } else {
    const jsKey = toJS(key2, "", ctx2);
    if (map2 instanceof Map) {
      map2.set(jsKey, toJS(value2, jsKey, ctx2));
    } else if (map2 instanceof Set) {
      map2.add(jsKey);
    } else {
      const stringKey = stringifyKey(key2, jsKey, ctx2);
      const jsValue = toJS(value2, stringKey, ctx2);
      if (stringKey in map2)
        Object.defineProperty(map2, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map2[stringKey] = jsValue;
    }
  }
  return map2;
}
var isMergeKey = (key2) => key2 === MERGE_KEY || isScalar$1(key2) && key2.value === MERGE_KEY && (!key2.type || key2.type === Scalar.PLAIN);
function mergeToJSMap(ctx2, map2, value2) {
  const source2 = ctx2 && isAlias(value2) ? value2.resolve(ctx2.doc) : value2;
  if (!isMap(source2))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source2.toJSON(null, ctx2, Map);
  for (const [key2, value3] of srcMap) {
    if (map2 instanceof Map) {
      if (!map2.has(key2))
        map2.set(key2, value3);
    } else if (map2 instanceof Set) {
      map2.add(key2);
    } else if (!Object.prototype.hasOwnProperty.call(map2, key2)) {
      Object.defineProperty(map2, key2, {
        value: value3,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map2;
}
function stringifyKey(key2, jsKey, ctx2) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode(key2) && ctx2 && ctx2.doc) {
    const strCtx = createStringifyContext(ctx2.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node2 of ctx2.anchors.keys())
      strCtx.anchors.add(node2.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key2.toString(strCtx);
    if (!ctx2.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn(ctx2.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx2.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}
function createPair(key2, value2, ctx2) {
  const k = createNode(key2, void 0, ctx2);
  const v = createNode(value2, void 0, ctx2);
  return new Pair(k, v);
}
var Pair = class {
  constructor(key2, value2 = null) {
    Object.defineProperty(this, NODE_TYPE, { value: PAIR });
    this.key = key2;
    this.value = value2;
  }
  clone(schema2) {
    let { key: key2, value: value2 } = this;
    if (isNode(key2))
      key2 = key2.clone(schema2);
    if (isNode(value2))
      value2 = value2.clone(schema2);
    return new Pair(key2, value2);
  }
  toJSON(_, ctx2) {
    const pair = (ctx2 == null ? void 0 : ctx2.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    return addPairToJSMap(ctx2, pair, this);
  }
  toString(ctx2, onComment, onChompKeep) {
    return (ctx2 == null ? void 0 : ctx2.doc) ? stringifyPair(this, ctx2, onComment, onChompKeep) : JSON.stringify(this);
  }
};
function stringifyCollection(collection, ctx2, options3) {
  var _a;
  const flow = (_a = ctx2.inFlow) != null ? _a : collection.flow;
  const stringify3 = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify3(collection, ctx2, options3);
}
function stringifyBlockCollection({ comment, items }, ctx2, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx2;
  const itemCtx = Object.assign({}, ctx2, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment2 = null;
    if (isNode(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx2, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx2, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str2 = stringify$3(item, itemCtx, () => comment2 = null, () => chompKeep = true);
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (chompKeep && comment2)
      chompKeep = false;
    lines.push(blockItemPrefix + str2);
  }
  let str;
  if (lines.length === 0) {
    str = flowChars.start + flowChars.end;
  } else {
    str = lines[0];
    for (let i = 1; i < lines.length; ++i) {
      const line2 = lines[i];
      str += line2 ? `
${indent}${line2}` : "\n";
    }
  }
  if (comment) {
    str += "\n" + indentComment(commentString(comment), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str;
}
function stringifyFlowCollection({ comment, items }, ctx2, { flowChars, itemIndent, onComment }) {
  const { indent, indentStep, options: { commentString } } = ctx2;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx2, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment2 = null;
    if (isNode(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx2, lines, item.commentBefore, false);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx2, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment2 = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && ik && ik.comment) {
        comment2 = ik.comment;
      }
    }
    if (comment2)
      reqNewline = true;
    let str2 = stringify$3(item, itemCtx, () => comment2 = null);
    if (i < items.length - 1)
      str2 += ",";
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (!reqNewline && (lines.length > linesAtValue || str2.includes("\n")))
      reqNewline = true;
    lines.push(str2);
    linesAtValue = lines.length;
  }
  let str;
  const { start, end } = flowChars;
  if (lines.length === 0) {
    str = start + end;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line2) => sum + line2.length + 2, 2);
      reqNewline = len > Collection.maxFlowStringSingleLineLength;
    }
    if (reqNewline) {
      str = start;
      for (const line2 of lines)
        str += line2 ? `
${indentStep}${indent}${line2}` : "\n";
      str += `
${indent}${end}`;
    } else {
      str = `${start} ${lines.join(" ")} ${end}`;
    }
  }
  if (comment) {
    str += lineComment(str, commentString(comment), indent);
    if (onComment)
      onComment();
  }
  return str;
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
  if (comment && chompKeep)
    comment = comment.replace(/^\n+/, "");
  if (comment) {
    const ic = indentComment(commentString(comment), indent);
    lines.push(ic.trimStart());
  }
}
function findPair(items, key2) {
  const k = isScalar$1(key2) ? key2.value : key2;
  for (const it of items) {
    if (isPair(it)) {
      if (it.key === key2 || it.key === k)
        return it;
      if (isScalar$1(it.key) && it.key.value === k)
        return it;
    }
  }
  return void 0;
}
var YAMLMap = class extends Collection {
  constructor(schema2) {
    super(MAP, schema2);
    this.items = [];
  }
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  add(pair, overwrite) {
    var _a;
    let _pair;
    if (isPair(pair))
      _pair = pair;
    else if (!pair || typeof pair !== "object" || !("key" in pair)) {
      _pair = new Pair(pair, pair == null ? void 0 : pair.value);
    } else
      _pair = new Pair(pair.key, pair.value);
    const prev = findPair(this.items, _pair.key);
    const sortEntries = (_a = this.schema) == null ? void 0 : _a.sortMapEntries;
    if (prev) {
      if (!overwrite)
        throw new Error(`Key ${_pair.key} already set`);
      if (isScalar$1(prev.value) && isScalarValue(_pair.value))
        prev.value.value = _pair.value;
      else
        prev.value = _pair.value;
    } else if (sortEntries) {
      const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
      if (i === -1)
        this.items.push(_pair);
      else
        this.items.splice(i, 0, _pair);
    } else {
      this.items.push(_pair);
    }
  }
  delete(key2) {
    const it = findPair(this.items, key2);
    if (!it)
      return false;
    const del = this.items.splice(this.items.indexOf(it), 1);
    return del.length > 0;
  }
  get(key2, keepScalar) {
    var _a;
    const it = findPair(this.items, key2);
    const node2 = it == null ? void 0 : it.value;
    return (_a = !keepScalar && isScalar$1(node2) ? node2.value : node2) != null ? _a : void 0;
  }
  has(key2) {
    return !!findPair(this.items, key2);
  }
  set(key2, value2) {
    this.add(new Pair(key2, value2), true);
  }
  toJSON(_, ctx2, Type) {
    const map2 = Type ? new Type() : (ctx2 == null ? void 0 : ctx2.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    if (ctx2 == null ? void 0 : ctx2.onCreate)
      ctx2.onCreate(map2);
    for (const item of this.items)
      addPairToJSMap(ctx2, map2, item);
    return map2;
  }
  toString(ctx2, onComment, onChompKeep) {
    if (!ctx2)
      return JSON.stringify(this);
    for (const item of this.items) {
      if (!isPair(item))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
    }
    if (!ctx2.allNullValues && this.hasAllNullValues(false))
      ctx2 = Object.assign({}, ctx2, { allNullValues: true });
    return stringifyCollection(this, ctx2, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: ctx2.indent || "",
      onChompKeep,
      onComment
    });
  }
};
function createMap(schema2, obj, ctx2) {
  const { keepUndefined, replacer } = ctx2;
  const map2 = new YAMLMap(schema2);
  const add = (key2, value2) => {
    if (typeof replacer === "function")
      value2 = replacer.call(obj, key2, value2);
    else if (Array.isArray(replacer) && !replacer.includes(key2))
      return;
    if (value2 !== void 0 || keepUndefined)
      map2.items.push(createPair(key2, value2, ctx2));
  };
  if (obj instanceof Map) {
    for (const [key2, value2] of obj)
      add(key2, value2);
  } else if (obj && typeof obj === "object") {
    for (const key2 of Object.keys(obj))
      add(key2, obj[key2]);
  }
  if (typeof schema2.sortMapEntries === "function") {
    map2.items.sort(schema2.sortMapEntries);
  }
  return map2;
}
var map = {
  collection: "map",
  createNode: createMap,
  default: true,
  nodeClass: YAMLMap,
  tag: "tag:yaml.org,2002:map",
  resolve(map2, onError) {
    if (!isMap(map2))
      onError("Expected a mapping for this tag");
    return map2;
  }
};
var YAMLSeq = class extends Collection {
  constructor(schema2) {
    super(SEQ, schema2);
    this.items = [];
  }
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  add(value2) {
    this.items.push(value2);
  }
  delete(key2) {
    const idx = asItemIndex(key2);
    if (typeof idx !== "number")
      return false;
    const del = this.items.splice(idx, 1);
    return del.length > 0;
  }
  get(key2, keepScalar) {
    const idx = asItemIndex(key2);
    if (typeof idx !== "number")
      return void 0;
    const it = this.items[idx];
    return !keepScalar && isScalar$1(it) ? it.value : it;
  }
  has(key2) {
    const idx = asItemIndex(key2);
    return typeof idx === "number" && idx < this.items.length;
  }
  set(key2, value2) {
    const idx = asItemIndex(key2);
    if (typeof idx !== "number")
      throw new Error(`Expected a valid index, not ${key2}.`);
    const prev = this.items[idx];
    if (isScalar$1(prev) && isScalarValue(value2))
      prev.value = value2;
    else
      this.items[idx] = value2;
  }
  toJSON(_, ctx2) {
    const seq2 = [];
    if (ctx2 == null ? void 0 : ctx2.onCreate)
      ctx2.onCreate(seq2);
    let i = 0;
    for (const item of this.items)
      seq2.push(toJS(item, String(i++), ctx2));
    return seq2;
  }
  toString(ctx2, onComment, onChompKeep) {
    if (!ctx2)
      return JSON.stringify(this);
    return stringifyCollection(this, ctx2, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (ctx2.indent || "") + "  ",
      onChompKeep,
      onComment
    });
  }
};
function asItemIndex(key2) {
  let idx = isScalar$1(key2) ? key2.value : key2;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}
function createSeq(schema2, obj, ctx2) {
  const { replacer } = ctx2;
  const seq2 = new YAMLSeq(schema2);
  if (obj && Symbol.iterator in Object(obj)) {
    let i = 0;
    for (let it of obj) {
      if (typeof replacer === "function") {
        const key2 = obj instanceof Set ? it : String(i++);
        it = replacer.call(obj, key2, it);
      }
      seq2.items.push(createNode(it, void 0, ctx2));
    }
  }
  return seq2;
}
var seq = {
  collection: "seq",
  createNode: createSeq,
  default: true,
  nodeClass: YAMLSeq,
  tag: "tag:yaml.org,2002:seq",
  resolve(seq2, onError) {
    if (!isSeq(seq2))
      onError("Expected a sequence for this tag");
    return seq2;
  }
};
var string = {
  identify: (value2) => typeof value2 === "string",
  default: true,
  tag: "tag:yaml.org,2002:str",
  resolve: (str) => str,
  stringify(item, ctx2, onComment, onChompKeep) {
    ctx2 = Object.assign({ actualString: true }, ctx2);
    return stringifyString(item, ctx2, onComment, onChompKeep);
  }
};
var nullTag = {
  identify: (value2) => value2 == null,
  createNode: () => new Scalar(null),
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new Scalar(null),
  stringify: ({ source: source2 }, ctx2) => typeof source2 === "string" && nullTag.test.test(source2) ? source2 : ctx2.options.nullStr
};
var boolTag = {
  identify: (value2) => typeof value2 === "boolean",
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (str) => new Scalar(str[0] === "t" || str[0] === "T"),
  stringify({ source: source2, value: value2 }, ctx2) {
    if (source2 && boolTag.test.test(source2)) {
      const sv = source2[0] === "t" || source2[0] === "T";
      if (value2 === sv)
        return source2;
    }
    return value2 ? ctx2.options.trueStr : ctx2.options.falseStr;
  }
};
function stringifyNumber({ format: format2, minFractionDigits, tag, value: value2 }) {
  if (typeof value2 === "bigint")
    return String(value2);
  const num = typeof value2 === "number" ? value2 : Number(value2);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n2 = JSON.stringify(value2);
  if (!format2 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n2)) {
    let i = n2.indexOf(".");
    if (i < 0) {
      i = n2.length;
      n2 += ".";
    }
    let d = minFractionDigits - (n2.length - i - 1);
    while (d-- > 0)
      n2 += "0";
  }
  return n2;
}
var floatNaN$1 = {
  identify: (value2) => typeof value2 === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp$1 = {
  identify: (value2) => typeof value2 === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str),
  stringify(node2) {
    const num = Number(node2.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node2);
  }
};
var float$1 = {
  identify: (value2) => typeof value2 === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(str) {
    const node2 = new Scalar(parseFloat(str));
    const dot = str.indexOf(".");
    if (dot !== -1 && str[str.length - 1] === "0")
      node2.minFractionDigits = str.length - dot - 1;
    return node2;
  },
  stringify: stringifyNumber
};
var intIdentify$2 = (value2) => typeof value2 === "bigint" || Number.isInteger(value2);
var intResolve$1 = (str, offset3, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset3), radix);
function intStringify$1(node2, radix, prefix) {
  const { value: value2 } = node2;
  if (intIdentify$2(value2) && value2 >= 0)
    return prefix + value2.toString(radix);
  return stringifyNumber(node2);
}
var intOct$1 = {
  identify: (value2) => intIdentify$2(value2) && value2 >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (str, _onError, opt) => intResolve$1(str, 2, 8, opt),
  stringify: (node2) => intStringify$1(node2, 8, "0o")
};
var int$1 = {
  identify: intIdentify$2,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (str, _onError, opt) => intResolve$1(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex$1 = {
  identify: (value2) => intIdentify$2(value2) && value2 >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (str, _onError, opt) => intResolve$1(str, 2, 16, opt),
  stringify: (node2) => intStringify$1(node2, 16, "0x")
};
var schema$2 = [
  map,
  seq,
  string,
  nullTag,
  boolTag,
  intOct$1,
  int$1,
  intHex$1,
  floatNaN$1,
  floatExp$1,
  float$1
];
function intIdentify$1(value2) {
  return typeof value2 === "bigint" || Number.isInteger(value2);
}
var stringifyJSON = ({ value: value2 }) => JSON.stringify(value2);
var jsonScalars = [
  {
    identify: (value2) => typeof value2 === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify: stringifyJSON
  },
  {
    identify: (value2) => value2 == null,
    createNode: () => new Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: stringifyJSON
  },
  {
    identify: (value2) => typeof value2 === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^true|false$/,
    resolve: (str) => str === "true",
    stringify: stringifyJSON
  },
  {
    identify: intIdentify$1,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
    stringify: ({ value: value2 }) => intIdentify$1(value2) ? value2.toString() : JSON.stringify(value2)
  },
  {
    identify: (value2) => typeof value2 === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (str) => parseFloat(str),
    stringify: stringifyJSON
  }
];
var jsonError = {
  default: true,
  tag: "",
  test: /^/,
  resolve(str, onError) {
    onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
    return str;
  }
};
var schema$1 = [map, seq].concat(jsonScalars, jsonError);
var binary = {
  identify: (value2) => value2 instanceof Uint8Array,
  default: false,
  tag: "tag:yaml.org,2002:binary",
  resolve(src2, onError) {
    if (typeof Buffer === "function") {
      return Buffer.from(src2, "base64");
    } else if (typeof atob === "function") {
      const str = atob(src2.replace(/[\n\r]/g, ""));
      const buffer2 = new Uint8Array(str.length);
      for (let i = 0; i < str.length; ++i)
        buffer2[i] = str.charCodeAt(i);
      return buffer2;
    } else {
      onError("This environment does not support reading binary tags; either Buffer or atob is required");
      return src2;
    }
  },
  stringify({ comment, type, value: value2 }, ctx2, onComment, onChompKeep) {
    const buf = value2;
    let str;
    if (typeof Buffer === "function") {
      str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
    } else if (typeof btoa === "function") {
      let s = "";
      for (let i = 0; i < buf.length; ++i)
        s += String.fromCharCode(buf[i]);
      str = btoa(s);
    } else {
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    }
    if (!type)
      type = Scalar.BLOCK_LITERAL;
    if (type !== Scalar.QUOTE_DOUBLE) {
      const lineWidth = Math.max(ctx2.options.lineWidth - ctx2.indent.length, ctx2.options.minContentWidth);
      const n2 = Math.ceil(str.length / lineWidth);
      const lines = new Array(n2);
      for (let i = 0, o = 0; i < n2; ++i, o += lineWidth) {
        lines[i] = str.substr(o, lineWidth);
      }
      str = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
    }
    return stringifyString({ comment, type, value: str }, ctx2, onComment, onChompKeep);
  }
};
function resolvePairs(seq2, onError) {
  var _a;
  if (isSeq(seq2)) {
    for (let i = 0; i < seq2.items.length; ++i) {
      let item = seq2.items[i];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn = (_a = pair.value) != null ? _a : pair.key;
          cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq2;
}
function createPairs(schema2, iterable, ctx2) {
  const { replacer } = ctx2;
  const pairs2 = new YAMLSeq(schema2);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it of iterable) {
      if (typeof replacer === "function")
        it = replacer.call(iterable, String(i++), it);
      let key2, value2;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key2 = it[0];
          value2 = it[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it}`);
      } else if (it && it instanceof Object) {
        const keys = Object.keys(it);
        if (keys.length === 1) {
          key2 = keys[0];
          value2 = it[key2];
        } else
          throw new TypeError(`Expected { key: value } tuple: ${it}`);
      } else {
        key2 = it;
      }
      pairs2.items.push(createPair(key2, value2, ctx2));
    }
  return pairs2;
}
var pairs = {
  collection: "seq",
  default: false,
  tag: "tag:yaml.org,2002:pairs",
  resolve: resolvePairs,
  createNode: createPairs
};
var YAMLOMap = class extends YAMLSeq {
  constructor() {
    super();
    this.add = YAMLMap.prototype.add.bind(this);
    this.delete = YAMLMap.prototype.delete.bind(this);
    this.get = YAMLMap.prototype.get.bind(this);
    this.has = YAMLMap.prototype.has.bind(this);
    this.set = YAMLMap.prototype.set.bind(this);
    this.tag = YAMLOMap.tag;
  }
  toJSON(_, ctx2) {
    if (!ctx2)
      return super.toJSON(_);
    const map2 = /* @__PURE__ */ new Map();
    if (ctx2 == null ? void 0 : ctx2.onCreate)
      ctx2.onCreate(map2);
    for (const pair of this.items) {
      let key2, value2;
      if (isPair(pair)) {
        key2 = toJS(pair.key, "", ctx2);
        value2 = toJS(pair.value, key2, ctx2);
      } else {
        key2 = toJS(pair, "", ctx2);
      }
      if (map2.has(key2))
        throw new Error("Ordered maps must not include duplicate keys");
      map2.set(key2, value2);
    }
    return map2;
  }
};
YAMLOMap.tag = "tag:yaml.org,2002:omap";
var omap = {
  collection: "seq",
  identify: (value2) => value2 instanceof Map,
  nodeClass: YAMLOMap,
  default: false,
  tag: "tag:yaml.org,2002:omap",
  resolve(seq2, onError) {
    const pairs2 = resolvePairs(seq2, onError);
    const seenKeys = [];
    for (const { key: key2 } of pairs2.items) {
      if (isScalar$1(key2)) {
        if (seenKeys.includes(key2.value)) {
          onError(`Ordered maps must not include duplicate keys: ${key2.value}`);
        } else {
          seenKeys.push(key2.value);
        }
      }
    }
    return Object.assign(new YAMLOMap(), pairs2);
  },
  createNode(schema2, iterable, ctx2) {
    const pairs2 = createPairs(schema2, iterable, ctx2);
    const omap2 = new YAMLOMap();
    omap2.items = pairs2.items;
    return omap2;
  }
};
function boolStringify({ value: value2, source: source2 }, ctx2) {
  const boolObj = value2 ? trueTag : falseTag;
  if (source2 && boolObj.test.test(source2))
    return source2;
  return value2 ? ctx2.options.trueStr : ctx2.options.falseStr;
}
var trueTag = {
  identify: (value2) => value2 === true,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new Scalar(true),
  stringify: boolStringify
};
var falseTag = {
  identify: (value2) => value2 === false,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
  resolve: () => new Scalar(false),
  stringify: boolStringify
};
var floatNaN = {
  identify: (value2) => typeof value2 === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp = {
  identify: (value2) => typeof value2 === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str.replace(/_/g, "")),
  stringify(node2) {
    const num = Number(node2.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node2);
  }
};
var float = {
  identify: (value2) => typeof value2 === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(str) {
    const node2 = new Scalar(parseFloat(str.replace(/_/g, "")));
    const dot = str.indexOf(".");
    if (dot !== -1) {
      const f = str.substring(dot + 1).replace(/_/g, "");
      if (f[f.length - 1] === "0")
        node2.minFractionDigits = f.length;
    }
    return node2;
  },
  stringify: stringifyNumber
};
var intIdentify = (value2) => typeof value2 === "bigint" || Number.isInteger(value2);
function intResolve(str, offset3, radix, { intAsBigInt }) {
  const sign2 = str[0];
  if (sign2 === "-" || sign2 === "+")
    offset3 += 1;
  str = str.substring(offset3).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;
      case 8:
        str = `0o${str}`;
        break;
      case 16:
        str = `0x${str}`;
        break;
    }
    const n3 = BigInt(str);
    return sign2 === "-" ? BigInt(-1) * n3 : n3;
  }
  const n2 = parseInt(str, radix);
  return sign2 === "-" ? -1 * n2 : n2;
}
function intStringify(node2, radix, prefix) {
  const { value: value2 } = node2;
  if (intIdentify(value2)) {
    const str = value2.toString(radix);
    return value2 < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node2);
}
var intBin = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
  stringify: (node2) => intStringify(node2, 2, "0b")
};
var intOct = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
  stringify: (node2) => intStringify(node2, 8, "0")
};
var int = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
  stringify: (node2) => intStringify(node2, 16, "0x")
};
var YAMLSet = class extends YAMLMap {
  constructor(schema2) {
    super(schema2);
    this.tag = YAMLSet.tag;
  }
  add(key2) {
    let pair;
    if (isPair(key2))
      pair = key2;
    else if (typeof key2 === "object" && "key" in key2 && "value" in key2 && key2.value === null)
      pair = new Pair(key2.key, null);
    else
      pair = new Pair(key2, null);
    const prev = findPair(this.items, pair.key);
    if (!prev)
      this.items.push(pair);
  }
  get(key2, keepPair) {
    const pair = findPair(this.items, key2);
    return !keepPair && isPair(pair) ? isScalar$1(pair.key) ? pair.key.value : pair.key : pair;
  }
  set(key2, value2) {
    if (typeof value2 !== "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value2}`);
    const prev = findPair(this.items, key2);
    if (prev && !value2) {
      this.items.splice(this.items.indexOf(prev), 1);
    } else if (!prev && value2) {
      this.items.push(new Pair(key2));
    }
  }
  toJSON(_, ctx2) {
    return super.toJSON(_, ctx2, Set);
  }
  toString(ctx2, onComment, onChompKeep) {
    if (!ctx2)
      return JSON.stringify(this);
    if (this.hasAllNullValues(true))
      return super.toString(Object.assign({}, ctx2, { allNullValues: true }), onComment, onChompKeep);
    else
      throw new Error("Set items must all have null values");
  }
};
YAMLSet.tag = "tag:yaml.org,2002:set";
var set = {
  collection: "map",
  identify: (value2) => value2 instanceof Set,
  nodeClass: YAMLSet,
  default: false,
  tag: "tag:yaml.org,2002:set",
  resolve(map2, onError) {
    if (isMap(map2)) {
      if (map2.hasAllNullValues(true))
        return Object.assign(new YAMLSet(), map2);
      else
        onError("Set items must all have null values");
    } else
      onError("Expected a mapping for this tag");
    return map2;
  },
  createNode(schema2, iterable, ctx2) {
    const { replacer } = ctx2;
    const set2 = new YAMLSet(schema2);
    if (iterable && Symbol.iterator in Object(iterable))
      for (let value2 of iterable) {
        if (typeof replacer === "function")
          value2 = replacer.call(iterable, value2, value2);
        set2.items.push(createPair(value2, null, ctx2));
      }
    return set2;
  }
};
function parseSexagesimal(str, asBigInt) {
  const sign2 = str[0];
  const parts = sign2 === "-" || sign2 === "+" ? str.substring(1) : str;
  const num = (n2) => asBigInt ? BigInt(n2) : Number(n2);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
  return sign2 === "-" ? num(-1) * res : res;
}
function stringifySexagesimal(node2) {
  let { value: value2 } = node2;
  let num = (n2) => n2;
  if (typeof value2 === "bigint")
    num = (n2) => BigInt(n2);
  else if (isNaN(value2) || !isFinite(value2))
    return stringifyNumber(node2);
  let sign2 = "";
  if (value2 < 0) {
    sign2 = "-";
    value2 *= num(-1);
  }
  const _60 = num(60);
  const parts = [value2 % _60];
  if (value2 < 60) {
    parts.unshift(0);
  } else {
    value2 = (value2 - parts[0]) / _60;
    parts.unshift(value2 % _60);
    if (value2 >= 60) {
      value2 = (value2 - parts[0]) / _60;
      parts.unshift(value2);
    }
  }
  return sign2 + parts.map((n2) => n2 < 10 ? "0" + String(n2) : String(n2)).join(":").replace(/000000\d*$/, "");
}
var intTime = {
  identify: (value2) => typeof value2 === "bigint" || Number.isInteger(value2),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
  stringify: stringifySexagesimal
};
var floatTime = {
  identify: (value2) => typeof value2 === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (str) => parseSexagesimal(str, false),
  stringify: stringifySexagesimal
};
var timestamp = {
  identify: (value2) => value2 instanceof Date,
  default: true,
  tag: "tag:yaml.org,2002:timestamp",
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(str) {
    const match = str.match(timestamp.test);
    if (!match)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, year, month, day, hour, minute, second] = match.map(Number);
    const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
    const tz = match[8];
    if (tz && tz !== "Z") {
      let d = parseSexagesimal(tz, false);
      if (Math.abs(d) < 30)
        d *= 60;
      date -= 6e4 * d;
    }
    return new Date(date);
  },
  stringify: ({ value: value2 }) => value2.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
};
var schema = [
  map,
  seq,
  string,
  nullTag,
  trueTag,
  falseTag,
  intBin,
  intOct,
  int,
  intHex,
  floatNaN,
  floatExp,
  float,
  binary,
  omap,
  pairs,
  set,
  intTime,
  floatTime,
  timestamp
];
var schemas = /* @__PURE__ */ new Map([
  ["core", schema$2],
  ["failsafe", [map, seq, string]],
  ["json", schema$1],
  ["yaml11", schema],
  ["yaml-1.1", schema]
]);
var tagsByName = {
  binary,
  bool: boolTag,
  float: float$1,
  floatExp: floatExp$1,
  floatNaN: floatNaN$1,
  floatTime,
  int: int$1,
  intHex: intHex$1,
  intOct: intOct$1,
  intTime,
  map,
  null: nullTag,
  omap,
  pairs,
  seq,
  set,
  timestamp
};
var coreKnownTags = {
  "tag:yaml.org,2002:binary": binary,
  "tag:yaml.org,2002:omap": omap,
  "tag:yaml.org,2002:pairs": pairs,
  "tag:yaml.org,2002:set": set,
  "tag:yaml.org,2002:timestamp": timestamp
};
function getTags(customTags, schemaName) {
  let tags = schemas.get(schemaName);
  if (!tags) {
    if (Array.isArray(customTags))
      tags = [];
    else {
      const keys = Array.from(schemas.keys()).filter((key2) => key2 !== "yaml11").map((key2) => JSON.stringify(key2)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag of customTags)
      tags = tags.concat(tag);
  } else if (typeof customTags === "function") {
    tags = customTags(tags.slice());
  }
  return tags.map((tag) => {
    if (typeof tag !== "string")
      return tag;
    const tagObj = tagsByName[tag];
    if (tagObj)
      return tagObj;
    const keys = Object.keys(tagsByName).map((key2) => JSON.stringify(key2)).join(", ");
    throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
  });
}
var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
var Schema = class {
  constructor({ compat, customTags, merge: merge3, resolveKnownTags, schema: schema2, sortMapEntries, toStringDefaults }) {
    this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
    this.merge = !!merge3;
    this.name = typeof schema2 === "string" && schema2 || "core";
    this.knownTags = resolveKnownTags ? coreKnownTags : {};
    this.tags = getTags(customTags, this.name);
    this.toStringOptions = toStringDefaults != null ? toStringDefaults : null;
    Object.defineProperty(this, MAP, { value: map });
    Object.defineProperty(this, SCALAR$1, { value: string });
    Object.defineProperty(this, SEQ, { value: seq });
    this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
  }
  clone() {
    const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
    copy.tags = this.tags.slice();
    return copy;
  }
};
function stringifyDocument(doc, options3) {
  var _a;
  const lines = [];
  let hasDirectives = options3.directives === true;
  if (options3.directives !== false && doc.directives) {
    const dir = doc.directives.toString(doc);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc.directives.docStart)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx2 = createStringifyContext(doc, options3);
  const { commentString } = ctx2.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc.commentBefore);
    lines.unshift(indentComment(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs = commentString(doc.contents.commentBefore);
        lines.push(indentComment(cs, ""));
      }
      ctx2.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify$3(doc.contents, ctx2, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify$3(doc.contents, ctx2));
  }
  if ((_a = doc.directives) == null ? void 0 : _a.docEnd) {
    if (doc.comment) {
      const cs = commentString(doc.comment);
      if (cs.includes("\n")) {
        lines.push("...");
        lines.push(indentComment(cs, ""));
      } else {
        lines.push(`... ${cs}`);
      }
    } else {
      lines.push("...");
    }
  } else {
    let dc = doc.comment;
    if (dc && chompKeep)
      dc = dc.replace(/^\n+/, "");
    if (dc) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
        lines.push("");
      lines.push(indentComment(commentString(dc), ""));
    }
  }
  return lines.join("\n") + "\n";
}
function applyReviver(reviver, obj, key2, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i = 0, len = val.length; i < len; ++i) {
        const v0 = val[i];
        const v1 = applyReviver(reviver, val, String(i), v0);
        if (v1 === void 0)
          delete val[i];
        else if (v1 !== v0)
          val[i] = v1;
      }
    } else if (val instanceof Map) {
      for (const k of Array.from(val.keys())) {
        const v0 = val.get(k);
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          val.delete(k);
        else if (v1 !== v0)
          val.set(k, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          delete val[k];
        else if (v1 !== v0)
          val[k] = v1;
      }
    }
  }
  return reviver.call(obj, key2, val);
}
var Document = class {
  constructor(value2, replacer, options3) {
    this.commentBefore = null;
    this.comment = null;
    this.errors = [];
    this.warnings = [];
    Object.defineProperty(this, NODE_TYPE, { value: DOC });
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options3 === void 0 && replacer) {
      options3 = replacer;
      replacer = void 0;
    }
    const opt = Object.assign({
      intAsBigInt: false,
      keepSourceTokens: false,
      logLevel: "warn",
      prettyErrors: true,
      strict: true,
      uniqueKeys: true,
      version: "1.2"
    }, options3);
    this.options = opt;
    let { version: version3 } = opt;
    if (options3 == null ? void 0 : options3._directives) {
      this.directives = options3._directives.atDocument();
      if (this.directives.yaml.explicit)
        version3 = this.directives.yaml.version;
    } else
      this.directives = new Directives({ version: version3 });
    this.setSchema(version3, options3);
    if (value2 === void 0)
      this.contents = null;
    else {
      this.contents = this.createNode(value2, _replacer, options3);
    }
  }
  clone() {
    const copy = Object.create(Document.prototype, {
      [NODE_TYPE]: { value: DOC }
    });
    copy.commentBefore = this.commentBefore;
    copy.comment = this.comment;
    copy.errors = this.errors.slice();
    copy.warnings = this.warnings.slice();
    copy.options = Object.assign({}, this.options);
    if (this.directives)
      copy.directives = this.directives.clone();
    copy.schema = this.schema.clone();
    copy.contents = isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  add(value2) {
    if (assertCollection(this.contents))
      this.contents.add(value2);
  }
  addIn(path4, value2) {
    if (assertCollection(this.contents))
      this.contents.addIn(path4, value2);
  }
  createAlias(node2, name) {
    if (!node2.anchor) {
      const prev = anchorNames(this);
      node2.anchor = !name || prev.has(name) ? findNewAnchor(name || "a", prev) : name;
    }
    return new Alias(node2.anchor);
  }
  createNode(value2, replacer, options3) {
    let _replacer = void 0;
    if (typeof replacer === "function") {
      value2 = replacer.call({ "": value2 }, "", value2);
      _replacer = replacer;
    } else if (Array.isArray(replacer)) {
      const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
      const asStr = replacer.filter(keyToStr).map(String);
      if (asStr.length > 0)
        replacer = replacer.concat(asStr);
      _replacer = replacer;
    } else if (options3 === void 0 && replacer) {
      options3 = replacer;
      replacer = void 0;
    }
    const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options3 != null ? options3 : {};
    const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(
      this,
      anchorPrefix || "a"
    );
    const ctx2 = {
      aliasDuplicateObjects: aliasDuplicateObjects != null ? aliasDuplicateObjects : true,
      keepUndefined: keepUndefined != null ? keepUndefined : false,
      onAnchor,
      onTagObj,
      replacer: _replacer,
      schema: this.schema,
      sourceObjects
    };
    const node2 = createNode(value2, tag, ctx2);
    if (flow && isCollection$1(node2))
      node2.flow = true;
    setAnchors();
    return node2;
  }
  createPair(key2, value2, options3 = {}) {
    const k = this.createNode(key2, null, options3);
    const v = this.createNode(value2, null, options3);
    return new Pair(k, v);
  }
  delete(key2) {
    return assertCollection(this.contents) ? this.contents.delete(key2) : false;
  }
  deleteIn(path4) {
    if (isEmptyPath(path4)) {
      if (this.contents == null)
        return false;
      this.contents = null;
      return true;
    }
    return assertCollection(this.contents) ? this.contents.deleteIn(path4) : false;
  }
  get(key2, keepScalar) {
    return isCollection$1(this.contents) ? this.contents.get(key2, keepScalar) : void 0;
  }
  getIn(path4, keepScalar) {
    if (isEmptyPath(path4))
      return !keepScalar && isScalar$1(this.contents) ? this.contents.value : this.contents;
    return isCollection$1(this.contents) ? this.contents.getIn(path4, keepScalar) : void 0;
  }
  has(key2) {
    return isCollection$1(this.contents) ? this.contents.has(key2) : false;
  }
  hasIn(path4) {
    if (isEmptyPath(path4))
      return this.contents !== void 0;
    return isCollection$1(this.contents) ? this.contents.hasIn(path4) : false;
  }
  set(key2, value2) {
    if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, [key2], value2);
    } else if (assertCollection(this.contents)) {
      this.contents.set(key2, value2);
    }
  }
  setIn(path4, value2) {
    if (isEmptyPath(path4))
      this.contents = value2;
    else if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, Array.from(path4), value2);
    } else if (assertCollection(this.contents)) {
      this.contents.setIn(path4, value2);
    }
  }
  setSchema(version3, options3 = {}) {
    if (typeof version3 === "number")
      version3 = String(version3);
    let opt;
    switch (version3) {
      case "1.1":
        if (this.directives)
          this.directives.yaml.version = "1.1";
        else
          this.directives = new Directives({ version: "1.1" });
        opt = { merge: true, resolveKnownTags: false, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        if (this.directives)
          this.directives.yaml.version = version3;
        else
          this.directives = new Directives({ version: version3 });
        opt = { merge: false, resolveKnownTags: true, schema: "core" };
        break;
      case null:
        if (this.directives)
          delete this.directives;
        opt = null;
        break;
      default: {
        const sv = JSON.stringify(version3);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
      }
    }
    if (options3.schema instanceof Object)
      this.schema = options3.schema;
    else if (opt)
      this.schema = new Schema(Object.assign(opt, options3));
    else
      throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
  }
  toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    const ctx2 = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !json,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100,
      stringify: stringify$3
    };
    const res = toJS(this.contents, jsonArg != null ? jsonArg : "", ctx2);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx2.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
  toJSON(jsonArg, onAnchor) {
    return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
  }
  toString(options3 = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in options3 && (!Number.isInteger(options3.indent) || Number(options3.indent) <= 0)) {
      const s = JSON.stringify(options3.indent);
      throw new Error(`"indent" option must be a positive integer, not ${s}`);
    }
    return stringifyDocument(this, options3);
  }
};
function assertCollection(contents) {
  if (isCollection$1(contents))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}
var YAMLError = class extends Error {
  constructor(name, pos2, code, message) {
    super();
    this.name = name;
    this.code = code;
    this.message = message;
    this.pos = pos2;
  }
};
var YAMLParseError = class extends YAMLError {
  constructor(pos2, code, message) {
    super("YAMLParseError", pos2, code, message);
  }
};
var YAMLWarning = class extends YAMLError {
  constructor(pos2, code, message) {
    super("YAMLWarning", pos2, code, message);
  }
};
var prettifyError = (src2, lc) => (error2) => {
  if (error2.pos[0] === -1)
    return;
  error2.linePos = error2.pos.map((pos2) => lc.linePos(pos2));
  const { line: line2, col } = error2.linePos[0];
  error2.message += ` at line ${line2}, column ${col}`;
  let ci = col - 1;
  let lineStr = src2.substring(lc.lineStarts[line2 - 1], lc.lineStarts[line2]).replace(/[\n\r]+$/, "");
  if (ci >= 60 && lineStr.length > 80) {
    const trimStart = Math.min(ci - 39, lineStr.length - 79);
    lineStr = "\u2026" + lineStr.substring(trimStart);
    ci -= trimStart - 1;
  }
  if (lineStr.length > 80)
    lineStr = lineStr.substring(0, 79) + "\u2026";
  if (line2 > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
    let prev = src2.substring(lc.lineStarts[line2 - 2], lc.lineStarts[line2 - 1]);
    if (prev.length > 80)
      prev = prev.substring(0, 79) + "\u2026\n";
    lineStr = prev + lineStr;
  }
  if (/[^ ]/.test(lineStr)) {
    let count = 1;
    const end = error2.linePos[1];
    if (end && end.line === line2 && end.col > col) {
      count = Math.min(end.col - col, 80 - ci);
    }
    const pointer = " ".repeat(ci) + "^".repeat(count);
    error2.message += `:

${lineStr}
${pointer}
`;
  }
};
function resolveProps(tokens, { flow, indicator, next, offset: offset3, onError, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment = "";
  let commentSep = "";
  let hasNewline = false;
  let hasNewlineAfterProp = false;
  let reqSpace = false;
  let anchor = null;
  let tag = null;
  let comma2 = null;
  let found2 = null;
  let start = null;
  for (const token2 of tokens) {
    if (reqSpace) {
      if (token2.type !== "space" && token2.type !== "newline" && token2.type !== "comma")
        onError(token2.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    switch (token2.type) {
      case "space":
        if (!flow && atNewline && indicator !== "doc-start" && token2.source[0] === "	")
          onError(token2, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError(token2, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token2.source.substring(1) || " ";
        if (!comment)
          comment = cb;
        else
          comment += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment)
            comment += token2.source;
          else
            spaceBefore = true;
        } else
          commentSep += token2.source;
        atNewline = true;
        hasNewline = true;
        if (anchor || tag)
          hasNewlineAfterProp = true;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError(token2, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        if (token2.source.endsWith(":"))
          onError(token2.offset + token2.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
        anchor = token2;
        if (start === null)
          start = token2.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag)
          onError(token2, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag = token2;
        if (start === null)
          start = token2.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag)
          onError(token2, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token2.source} indicator`);
        if (found2)
          onError(token2, "UNEXPECTED_TOKEN", `Unexpected ${token2.source} in ${flow != null ? flow : "collection"}`);
        found2 = token2;
        atNewline = false;
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma2)
            onError(token2, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma2 = token2;
          atNewline = false;
          hasSpace = false;
          break;
        }
      default:
        onError(token2, "UNEXPECTED_TOKEN", `Unexpected ${token2.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last = tokens[tokens.length - 1];
  const end = last ? last.offset + last.source.length : offset3;
  if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== ""))
    onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  return {
    comma: comma2,
    found: found2,
    spaceBefore,
    comment,
    hasNewline,
    hasNewlineAfterProp,
    anchor,
    tag,
    end,
    start: start != null ? start : end
  };
}
function containsNewline(key2) {
  if (!key2)
    return null;
  switch (key2.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key2.source.includes("\n"))
        return true;
      if (key2.end) {
        for (const st of key2.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it of key2.items) {
        for (const st of it.start)
          if (st.type === "newline")
            return true;
        if (it.sep) {
          for (const st of it.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline(it.key) || containsNewline(it.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}
function flowIndentCheck(indent, fc, onError) {
  if ((fc == null ? void 0 : fc.type) === "flow-collection") {
    const end = fc.end[0];
    if (end.indent === indent && (end.source === "]" || end.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError(end, "BAD_INDENT", msg, true);
    }
  }
}
function mapIncludes(ctx2, items, search) {
  const { uniqueKeys } = ctx2.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || isScalar$1(a) && isScalar$1(b) && a.value === b.value && !(a.value === "<<" && ctx2.schema.merge);
  return items.some((pair) => isEqual(pair.key, search));
}
var startColMsg = "All mapping items must start at the same column";
function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx2, bm, onError) {
  var _a;
  const map2 = new YAMLMap(ctx2.schema);
  if (ctx2.atRoot)
    ctx2.atRoot = false;
  let offset3 = bm.offset;
  for (const collItem of bm.items) {
    const { start, key: key2, sep: sep2, value: value2 } = collItem;
    const keyProps = resolveProps(start, {
      indicator: "explicit-key-ind",
      next: key2 != null ? key2 : sep2 == null ? void 0 : sep2[0],
      offset: offset3,
      onError,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key2) {
        if (key2.type === "block-seq")
          onError(offset3, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key2 && key2.indent !== bm.indent)
          onError(offset3, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep2) {
        if (keyProps.comment) {
          if (map2.comment)
            map2.comment += "\n" + keyProps.comment;
          else
            map2.comment = keyProps.comment;
        }
        continue;
      }
      if (keyProps.hasNewlineAfterProp || containsNewline(key2)) {
        onError(key2 != null ? key2 : start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
      }
    } else if (((_a = keyProps.found) == null ? void 0 : _a.indent) !== bm.indent) {
      onError(offset3, "BAD_INDENT", startColMsg);
    }
    const keyStart = keyProps.end;
    const keyNode = key2 ? composeNode2(ctx2, key2, keyProps, onError) : composeEmptyNode2(ctx2, keyStart, start, null, keyProps, onError);
    if (ctx2.schema.compat)
      flowIndentCheck(bm.indent, key2, onError);
    if (mapIncludes(ctx2, map2.items, keyNode))
      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep2 != null ? sep2 : [], {
      indicator: "map-value-ind",
      next: value2,
      offset: keyNode.range[2],
      onError,
      startOnNewline: !key2 || key2.type === "block-scalar"
    });
    offset3 = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if ((value2 == null ? void 0 : value2.type) === "block-map" && !valueProps.hasNewline)
          onError(offset3, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx2.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value2 ? composeNode2(ctx2, value2, valueProps, onError) : composeEmptyNode2(ctx2, offset3, sep2, null, valueProps, onError);
      if (ctx2.schema.compat)
        flowIndentCheck(bm.indent, value2, onError);
      offset3 = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx2.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    } else {
      if (implicitKey)
        onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx2.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    }
  }
  map2.range = [bm.offset, offset3, offset3];
  return map2;
}
function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx2, bs, onError) {
  const seq2 = new YAMLSeq(ctx2.schema);
  if (ctx2.atRoot)
    ctx2.atRoot = false;
  let offset3 = bs.offset;
  for (const { start, value: value2 } of bs.items) {
    const props = resolveProps(start, {
      indicator: "seq-item-ind",
      next: value2,
      offset: offset3,
      onError,
      startOnNewline: true
    });
    offset3 = props.end;
    if (!props.found) {
      if (props.anchor || props.tag || value2) {
        if (value2 && value2.type === "block-seq")
          onError(offset3, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError(offset3, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        if (props.comment)
          seq2.comment = props.comment;
        continue;
      }
    }
    const node2 = value2 ? composeNode2(ctx2, value2, props, onError) : composeEmptyNode2(ctx2, offset3, start, null, props, onError);
    if (ctx2.schema.compat)
      flowIndentCheck(bs.indent, value2, onError);
    offset3 = node2.range[2];
    seq2.items.push(node2);
  }
  seq2.range = [bs.offset, offset3, offset3];
  return seq2;
}
function resolveEnd(end, offset3, reqSpace, onError) {
  let comment = "";
  if (end) {
    let hasSpace = false;
    let sep2 = "";
    for (const token2 of end) {
      const { source: source2, type } = token2;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError(token2, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source2.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += sep2 + cb;
          sep2 = "";
          break;
        }
        case "newline":
          if (comment)
            sep2 += source2;
          hasSpace = true;
          break;
        default:
          onError(token2, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset3 += source2.length;
    }
  }
  return { comment, offset: offset3 };
}
var blockMsg = "Block collections are not allowed within flow collections";
var isBlock = (token2) => token2 && (token2.type === "block-map" || token2.type === "block-seq");
function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx2, fc, onError) {
  var _a;
  const isMap2 = fc.start.source === "{";
  const fcName = isMap2 ? "flow map" : "flow sequence";
  const coll = isMap2 ? new YAMLMap(ctx2.schema) : new YAMLSeq(ctx2.schema);
  coll.flow = true;
  const atRoot = ctx2.atRoot;
  if (atRoot)
    ctx2.atRoot = false;
  let offset3 = fc.offset + fc.start.source.length;
  for (let i = 0; i < fc.items.length; ++i) {
    const collItem = fc.items[i];
    const { start, key: key2, sep: sep2, value: value2 } = collItem;
    const props = resolveProps(start, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key2 != null ? key2 : sep2 == null ? void 0 : sep2[0],
      offset: offset3,
      onError,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep2 && !value2) {
        if (i === 0 && props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i < fc.items.length - 1)
          onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset3 = props.end;
        continue;
      }
      if (!isMap2 && ctx2.options.strict && containsNewline(key2))
        onError(
          key2,
          "MULTILINE_IMPLICIT_KEY",
          "Implicit keys of flow sequence pairs need to be on a single line"
        );
    }
    if (i === 0) {
      if (props.comma)
        onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop:
          for (const st of start) {
            switch (st.type) {
              case "comma":
              case "space":
                break;
              case "comment":
                prevItemComment = st.source.substring(1);
                break loop;
              default:
                break loop;
            }
          }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (isPair(prev))
            prev = (_a = prev.value) != null ? _a : prev.key;
          if (prev.comment)
            prev.comment += "\n" + prevItemComment;
          else
            prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap2 && !sep2 && !props.found) {
      const valueNode = value2 ? composeNode2(ctx2, value2, props, onError) : composeEmptyNode2(ctx2, props.end, sep2, null, props, onError);
      coll.items.push(valueNode);
      offset3 = valueNode.range[2];
      if (isBlock(value2))
        onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      const keyStart = props.end;
      const keyNode = key2 ? composeNode2(ctx2, key2, props, onError) : composeEmptyNode2(ctx2, keyStart, start, null, props, onError);
      if (isBlock(key2))
        onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      const valueProps = resolveProps(sep2 != null ? sep2 : [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value2,
        offset: keyNode.range[2],
        onError,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap2 && !props.found && ctx2.options.strict) {
          if (sep2)
            for (const st of sep2) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value2) {
        if ("source" in value2 && value2.source && value2.source[0] === ":")
          onError(value2, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value2 ? composeNode2(ctx2, value2, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx2, valueProps.end, sep2, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock(value2))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx2.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap2) {
        const map2 = coll;
        if (mapIncludes(ctx2, map2.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map2.items.push(pair);
      } else {
        const map2 = new YAMLMap(ctx2.schema);
        map2.flow = true;
        map2.items.push(pair);
        coll.items.push(map2);
      }
      offset3 = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap2 ? "}" : "]";
  const [ce, ...ee] = fc.end;
  let cePos = offset3;
  if (ce && ce.source === expectedEnd)
    cePos = ce.offset + ce.source.length;
  else {
    const name = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset3, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce && ce.source.length !== 1)
      ee.unshift(ce);
  }
  if (ee.length > 0) {
    const end = resolveEnd(ee, cePos, ctx2.options.strict, onError);
    if (end.comment) {
      if (coll.comment)
        coll.comment += "\n" + end.comment;
      else
        coll.comment = end.comment;
    }
    coll.range = [fc.offset, cePos, end.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}
function composeCollection(CN2, ctx2, token2, tagToken, onError) {
  let coll;
  switch (token2.type) {
    case "block-map": {
      coll = resolveBlockMap(CN2, ctx2, token2, onError);
      break;
    }
    case "block-seq": {
      coll = resolveBlockSeq(CN2, ctx2, token2, onError);
      break;
    }
    case "flow-collection": {
      coll = resolveFlowCollection(CN2, ctx2, token2, onError);
      break;
    }
  }
  if (!tagToken)
    return coll;
  const tagName = ctx2.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
  if (!tagName)
    return coll;
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  const expType = isMap(coll) ? "map" : "seq";
  let tag = ctx2.schema.tags.find((t) => t.collection === expType && t.tag === tagName);
  if (!tag) {
    const kt = ctx2.schema.knownTags[tagName];
    if (kt && kt.collection === expType) {
      ctx2.schema.tags.push(Object.assign({}, kt, { default: false }));
      tag = kt;
    } else {
      onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      coll.tag = tagName;
      return coll;
    }
  }
  const res = tag.resolve(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx2.options);
  const node2 = isNode(res) ? res : new Scalar(res);
  node2.range = coll.range;
  node2.tag = tagName;
  if (tag == null ? void 0 : tag.format)
    node2.format = tag.format;
  return node2;
}
function resolveBlockScalar(scalar, strict, onError) {
  const start = scalar.offset;
  const header = parseBlockScalarHeader(scalar, strict, onError);
  if (!header)
    return { value: "", type: null, comment: "", range: [start, start, start] };
  const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  let chompStart = lines.length;
  for (let i = lines.length - 1; i >= 0; --i) {
    const content = lines[i][1];
    if (content === "" || content === "\r")
      chompStart = i;
    else
      break;
  }
  if (chompStart === 0) {
    const value3 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
    let end2 = start + header.length;
    if (scalar.source)
      end2 += scalar.source.length;
    return { value: value3, type, comment: header.comment, range: [start, end2, end2] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset3 = scalar.offset + header.length;
  let contentStart = 0;
  for (let i = 0; i < chompStart; ++i) {
    const [indent, content] = lines[i];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError(offset3 + indent.length, "MISSING_CHAR", message);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i;
      break;
    }
    offset3 += indent.length + content.length + 1;
  }
  for (let i = lines.length - 1; i >= chompStart; --i) {
    if (lines[i][0].length > trimIndent)
      chompStart = i + 1;
  }
  let value2 = "";
  let sep2 = "";
  let prevMoreIndented = false;
  for (let i = 0; i < contentStart; ++i)
    value2 += lines[i][0].slice(trimIndent) + "\n";
  for (let i = contentStart; i < chompStart; ++i) {
    let [indent, content] = lines[i];
    offset3 += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src2 = header.indent ? "explicit indentation indicator" : "first line";
      const message = `Block scalar lines must not be less indented than their ${src2}`;
      onError(offset3 - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
      indent = "";
    }
    if (type === Scalar.BLOCK_LITERAL) {
      value2 += sep2 + indent.slice(trimIndent) + content;
      sep2 = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep2 === " ")
        sep2 = "\n";
      else if (!prevMoreIndented && sep2 === "\n")
        sep2 = "\n\n";
      value2 += sep2 + indent.slice(trimIndent) + content;
      sep2 = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep2 === "\n")
        value2 += "\n";
      else
        sep2 = "\n";
    } else {
      value2 += sep2 + content;
      sep2 = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i = chompStart; i < lines.length; ++i)
        value2 += "\n" + lines[i][0].slice(trimIndent);
      if (value2[value2.length - 1] !== "\n")
        value2 += "\n";
      break;
    default:
      value2 += "\n";
  }
  const end = start + header.length + scalar.source.length;
  return { value: value2, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset: offset3, props }, strict, onError) {
  if (props[0].type !== "block-scalar-header") {
    onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source: source2 } = props[0];
  const mode2 = source2[0];
  let indent = 0;
  let chomp = "";
  let error2 = -1;
  for (let i = 1; i < source2.length; ++i) {
    const ch = source2[i];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n2 = Number(ch);
      if (!indent && n2)
        indent = n2;
      else if (error2 === -1)
        error2 = offset3 + i;
    }
  }
  if (error2 !== -1)
    onError(error2, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source2}`);
  let hasSpace = false;
  let comment = "";
  let length = source2.length;
  for (let i = 1; i < props.length; ++i) {
    const token2 = props[i];
    switch (token2.type) {
      case "space":
        hasSpace = true;
      case "newline":
        length += token2.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message = "Comments must be separated from other tokens by white space characters";
          onError(token2, "MISSING_CHAR", message);
        }
        length += token2.source.length;
        comment = token2.source.substring(1);
        break;
      case "error":
        onError(token2, "UNEXPECTED_TOKEN", token2.message);
        length += token2.source.length;
        break;
      default: {
        const message = `Unexpected token in block scalar header: ${token2.type}`;
        onError(token2, "UNEXPECTED_TOKEN", message);
        const ts = token2.source;
        if (ts && typeof ts === "string")
          length += ts.length;
      }
    }
  }
  return { mode: mode2, indent, chomp, comment, length };
}
function splitLines(source2) {
  const split = source2.split(/\n( *)/);
  const first2 = split[0];
  const m = first2.match(/^( *)/);
  const line0 = (m == null ? void 0 : m[1]) ? [m[1], first2.slice(m[1].length)] : ["", first2];
  const lines = [line0];
  for (let i = 1; i < split.length; i += 2)
    lines.push([split[i], split[i + 1]]);
  return lines;
}
function resolveFlowScalar(scalar, strict, onError) {
  const { offset: offset3, type, source: source2, end } = scalar;
  let _type;
  let value2;
  const _onError = (rel, code, msg) => onError(offset3 + rel, code, msg);
  switch (type) {
    case "scalar":
      _type = Scalar.PLAIN;
      value2 = plainValue(source2, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value2 = singleQuotedValue(source2, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value2 = doubleQuotedValue(source2, _onError);
      break;
    default:
      onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset3, offset3 + source2.length, offset3 + source2.length]
      };
  }
  const valueEnd = offset3 + source2.length;
  const re = resolveEnd(end, valueEnd, strict, onError);
  return {
    value: value2,
    type: _type,
    comment: re.comment,
    range: [offset3, valueEnd, re.offset]
  };
}
function plainValue(source2, onError) {
  let badChar = "";
  switch (source2[0]) {
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source2[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source2[0]}`;
      break;
    }
  }
  if (badChar)
    onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source2);
}
function singleQuotedValue(source2, onError) {
  if (source2[source2.length - 1] !== "'" || source2.length === 1)
    onError(source2.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source2.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source2) {
  var _a;
  let first2, line2;
  try {
    first2 = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line2 = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch (_) {
    first2 = /(.*?)[ \t]*\r?\n/sy;
    line2 = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match = first2.exec(source2);
  if (!match)
    return source2;
  let res = match[1];
  let sep2 = " ";
  let pos2 = first2.lastIndex;
  line2.lastIndex = pos2;
  while (match = line2.exec(source2)) {
    if (match[1] === "") {
      if (sep2 === "\n")
        res += sep2;
      else
        sep2 = "\n";
    } else {
      res += sep2 + match[1];
      sep2 = " ";
    }
    pos2 = line2.lastIndex;
  }
  const last = /[ \t]*(.*)/sy;
  last.lastIndex = pos2;
  match = last.exec(source2);
  return res + sep2 + ((_a = match == null ? void 0 : match[1]) != null ? _a : "");
}
function doubleQuotedValue(source2, onError) {
  let res = "";
  for (let i = 1; i < source2.length - 1; ++i) {
    const ch = source2[i];
    if (ch === "\r" && source2[i + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset: offset3 } = foldNewline(source2, i);
      res += fold;
      i = offset3;
    } else if (ch === "\\") {
      let next = source2[++i];
      const cc = escapeCodes[next];
      if (cc)
        res += cc;
      else if (next === "\n") {
        next = source2[i + 1];
        while (next === " " || next === "	")
          next = source2[++i + 1];
      } else if (next === "\r" && source2[i + 1] === "\n") {
        next = source2[++i + 1];
        while (next === " " || next === "	")
          next = source2[++i + 1];
      } else if (next === "x" || next === "u" || next === "U") {
        const length = { x: 2, u: 4, U: 8 }[next];
        res += parseCharCode(source2, i + 1, length, onError);
        i += length;
      } else {
        const raw = source2.substr(i - 1, 2);
        onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i;
      let next = source2[i + 1];
      while (next === " " || next === "	")
        next = source2[++i + 1];
      if (next !== "\n" && !(next === "\r" && source2[i + 2] === "\n"))
        res += i > wsStart ? source2.slice(wsStart, i + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source2[source2.length - 1] !== '"' || source2.length === 1)
    onError(source2.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
function foldNewline(source2, offset3) {
  let fold = "";
  let ch = source2[offset3 + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source2[offset3 + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset3 += 1;
    ch = source2[offset3 + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset: offset3 };
}
var escapeCodes = {
  "0": "\0",
  a: "\x07",
  b: "\b",
  e: "\x1B",
  f: "\f",
  n: "\n",
  r: "\r",
  t: "	",
  v: "\v",
  N: "\x85",
  _: "\xA0",
  L: "\u2028",
  P: "\u2029",
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function parseCharCode(source2, offset3, length, onError) {
  const cc = source2.substr(offset3, length);
  const ok2 = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code = ok2 ? parseInt(cc, 16) : NaN;
  if (isNaN(code)) {
    const raw = source2.substr(offset3 - 2, length + 2);
    onError(offset3 - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code);
}
function composeScalar(ctx2, token2, tagToken, onError) {
  const { value: value2, type, comment, range: range2 } = token2.type === "block-scalar" ? resolveBlockScalar(token2, ctx2.options.strict, onError) : resolveFlowScalar(token2, ctx2.options.strict, onError);
  const tagName = tagToken ? ctx2.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  const tag = tagToken && tagName ? findScalarTagByName(ctx2.schema, value2, tagName, tagToken, onError) : token2.type === "scalar" ? findScalarTagByTest(ctx2, value2, token2, onError) : ctx2.schema[SCALAR$1];
  let scalar;
  try {
    const res = tag.resolve(value2, (msg) => onError(tagToken != null ? tagToken : token2, "TAG_RESOLVE_FAILED", msg), ctx2.options);
    scalar = isScalar$1(res) ? res : new Scalar(res);
  } catch (error2) {
    const msg = error2 instanceof Error ? error2.message : String(error2);
    onError(tagToken != null ? tagToken : token2, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value2);
  }
  scalar.range = range2;
  scalar.source = value2;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag.format)
    scalar.format = tag.format;
  if (comment)
    scalar.comment = comment;
  return scalar;
}
function findScalarTagByName(schema2, value2, tagName, tagToken, onError) {
  var _a;
  if (tagName === "!")
    return schema2[SCALAR$1];
  const matchWithTest = [];
  for (const tag of schema2.tags) {
    if (!tag.collection && tag.tag === tagName) {
      if (tag.default && tag.test)
        matchWithTest.push(tag);
      else
        return tag;
    }
  }
  for (const tag of matchWithTest)
    if ((_a = tag.test) == null ? void 0 : _a.test(value2))
      return tag;
  const kt = schema2.knownTags[tagName];
  if (kt && !kt.collection) {
    schema2.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
    return kt;
  }
  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema2[SCALAR$1];
}
function findScalarTagByTest({ directives, schema: schema2 }, value2, token2, onError) {
  var _a;
  const tag = schema2.tags.find((tag2) => {
    var _a2;
    return tag2.default && ((_a2 = tag2.test) == null ? void 0 : _a2.test(value2));
  }) || schema2[SCALAR$1];
  if (schema2.compat) {
    const compat = (_a = schema2.compat.find((tag2) => {
      var _a2;
      return tag2.default && ((_a2 = tag2.test) == null ? void 0 : _a2.test(value2));
    })) != null ? _a : schema2[SCALAR$1];
    if (tag.tag !== compat.tag) {
      const ts = directives.tagString(tag.tag);
      const cs = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError(token2, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag;
}
function emptyScalarPosition(offset3, before, pos2) {
  if (before) {
    if (pos2 === null)
      pos2 = before.length;
    for (let i = pos2 - 1; i >= 0; --i) {
      let st = before[i];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset3 -= st.source.length;
          continue;
      }
      st = before[++i];
      while ((st == null ? void 0 : st.type) === "space") {
        offset3 += st.source.length;
        st = before[++i];
      }
      break;
    }
  }
  return offset3;
}
var CN = { composeNode, composeEmptyNode };
function composeNode(ctx2, token2, props, onError) {
  const { spaceBefore, comment, anchor, tag } = props;
  let node2;
  let isSrcToken = true;
  switch (token2.type) {
    case "alias":
      node2 = composeAlias(ctx2, token2, onError);
      if (anchor || tag)
        onError(token2, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node2 = composeScalar(ctx2, token2, tag, onError);
      if (anchor)
        node2.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node2 = composeCollection(CN, ctx2, token2, tag, onError);
      if (anchor)
        node2.anchor = anchor.source.substring(1);
      break;
    default: {
      const message = token2.type === "error" ? token2.message : `Unsupported token (type: ${token2.type})`;
      onError(token2, "UNEXPECTED_TOKEN", message);
      node2 = composeEmptyNode(ctx2, token2.offset, void 0, null, props, onError);
      isSrcToken = false;
    }
  }
  if (anchor && node2.anchor === "")
    onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (spaceBefore)
    node2.spaceBefore = true;
  if (comment) {
    if (token2.type === "scalar" && token2.source === "")
      node2.comment = comment;
    else
      node2.commentBefore = comment;
  }
  if (ctx2.options.keepSourceTokens && isSrcToken)
    node2.srcToken = token2;
  return node2;
}
function composeEmptyNode(ctx2, offset3, before, pos2, { spaceBefore, comment, anchor, tag }, onError) {
  const token2 = {
    type: "scalar",
    offset: emptyScalarPosition(offset3, before, pos2),
    indent: -1,
    source: ""
  };
  const node2 = composeScalar(ctx2, token2, tag, onError);
  if (anchor) {
    node2.anchor = anchor.source.substring(1);
    if (node2.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node2.spaceBefore = true;
  if (comment)
    node2.comment = comment;
  return node2;
}
function composeAlias({ options: options3 }, { offset: offset3, source: source2, end }, onError) {
  const alias2 = new Alias(source2.substring(1));
  if (alias2.source === "")
    onError(offset3, "BAD_ALIAS", "Alias cannot be an empty string");
  if (alias2.source.endsWith(":"))
    onError(offset3 + source2.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const valueEnd = offset3 + source2.length;
  const re = resolveEnd(end, valueEnd, options3.strict, onError);
  alias2.range = [offset3, valueEnd, re.offset];
  if (re.comment)
    alias2.comment = re.comment;
  return alias2;
}
function composeDoc(options3, directives, { offset: offset3, start, value: value2, end }, onError) {
  const opts = Object.assign({ _directives: directives }, options3);
  const doc = new Document(void 0, opts);
  const ctx2 = {
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps(start, {
    indicator: "doc-start",
    next: value2 != null ? value2 : end == null ? void 0 : end[0],
    offset: offset3,
    onError,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.docStart = true;
    if (value2 && (value2.type === "block-map" || value2.type === "block-seq") && !props.hasNewline)
      onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc.contents = value2 ? composeNode(ctx2, value2, props, onError) : composeEmptyNode(ctx2, props.end, start, null, props, onError);
  const contentEnd = doc.contents.range[2];
  const re = resolveEnd(end, contentEnd, false, onError);
  if (re.comment)
    doc.comment = re.comment;
  doc.range = [offset3, contentEnd, re.offset];
  return doc;
}
function getErrorPos(src2) {
  if (typeof src2 === "number")
    return [src2, src2 + 1];
  if (Array.isArray(src2))
    return src2.length === 2 ? src2 : [src2[0], src2[1]];
  const { offset: offset3, source: source2 } = src2;
  return [offset3, offset3 + (typeof source2 === "string" ? source2.length : 1)];
}
function parsePrelude(prelude) {
  var _a;
  let comment = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i = 0; i < prelude.length; ++i) {
    const source2 = prelude[i];
    switch (source2[0]) {
      case "#":
        comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source2.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (((_a = prelude[i + 1]) == null ? void 0 : _a[0]) !== "#")
          i += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment, afterEmptyLine };
}
var Composer = class {
  constructor(options3 = {}) {
    this.doc = null;
    this.atDirectives = false;
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
    this.onError = (source2, code, message, warning) => {
      const pos2 = getErrorPos(source2);
      if (warning)
        this.warnings.push(new YAMLWarning(pos2, code, message));
      else
        this.errors.push(new YAMLParseError(pos2, code, message));
    };
    this.directives = new Directives({ version: options3.version || "1.2" });
    this.options = options3;
  }
  decorate(doc, afterDoc) {
    const { comment, afterEmptyLine } = parsePrelude(this.prelude);
    if (comment) {
      const dc = doc.contents;
      if (afterDoc) {
        doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
      } else if (afterEmptyLine || doc.directives.docStart || !dc) {
        doc.commentBefore = comment;
      } else if (isCollection$1(dc) && !dc.flow && dc.items.length > 0) {
        let it = dc.items[0];
        if (isPair(it))
          it = it.key;
        const cb = it.commentBefore;
        it.commentBefore = cb ? `${comment}
${cb}` : comment;
      } else {
        const cb = dc.commentBefore;
        dc.commentBefore = cb ? `${comment}
${cb}` : comment;
      }
    }
    if (afterDoc) {
      Array.prototype.push.apply(doc.errors, this.errors);
      Array.prototype.push.apply(doc.warnings, this.warnings);
    } else {
      doc.errors = this.errors;
      doc.warnings = this.warnings;
    }
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
  }
  streamInfo() {
    return {
      comment: parsePrelude(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  *compose(tokens, forceDoc = false, endOffset = -1) {
    for (const token2 of tokens)
      yield* this.next(token2);
    yield* this.end(forceDoc, endOffset);
  }
  *next(token2) {
    switch (token2.type) {
      case "directive":
        this.directives.add(token2.source, (offset3, message, warning) => {
          const pos2 = getErrorPos(token2);
          pos2[0] += offset3;
          this.onError(pos2, "BAD_DIRECTIVE", message, warning);
        });
        this.prelude.push(token2.source);
        this.atDirectives = true;
        break;
      case "document": {
        const doc = composeDoc(this.options, this.directives, token2, this.onError);
        if (this.atDirectives && !doc.directives.docStart)
          this.onError(token2, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
        this.decorate(doc, false);
        if (this.doc)
          yield this.doc;
        this.doc = doc;
        this.atDirectives = false;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(token2.source);
        break;
      case "error": {
        const msg = token2.source ? `${token2.message}: ${JSON.stringify(token2.source)}` : token2.message;
        const error2 = new YAMLParseError(getErrorPos(token2), "UNEXPECTED_TOKEN", msg);
        if (this.atDirectives || !this.doc)
          this.errors.push(error2);
        else
          this.doc.errors.push(error2);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const msg = "Unexpected doc-end without preceding document";
          this.errors.push(new YAMLParseError(getErrorPos(token2), "UNEXPECTED_TOKEN", msg));
          break;
        }
        this.doc.directives.docEnd = true;
        const end = resolveEnd(token2.end, token2.offset + token2.source.length, this.doc.options.strict, this.onError);
        this.decorate(this.doc, true);
        if (end.comment) {
          const dc = this.doc.comment;
          this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
        }
        this.doc.range[2] = end.offset;
        break;
      }
      default:
        this.errors.push(new YAMLParseError(getErrorPos(token2), "UNEXPECTED_TOKEN", `Unsupported token ${token2.type}`));
    }
  }
  *end(forceDoc = false, endOffset = -1) {
    if (this.doc) {
      this.decorate(this.doc, true);
      yield this.doc;
      this.doc = null;
    } else if (forceDoc) {
      const opts = Object.assign({ _directives: this.directives }, this.options);
      const doc = new Document(void 0, opts);
      if (this.atDirectives)
        this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
      doc.range = [0, endOffset, endOffset];
      this.decorate(doc, false);
      yield doc;
    }
  }
};
function resolveAsScalar(token2, strict = true, onError) {
  if (token2) {
    const _onError = (pos2, code, message) => {
      const offset3 = typeof pos2 === "number" ? pos2 : Array.isArray(pos2) ? pos2[0] : pos2.offset;
      if (onError)
        onError(offset3, code, message);
      else
        throw new YAMLParseError([offset3, offset3 + 1], code, message);
    };
    switch (token2.type) {
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return resolveFlowScalar(token2, strict, _onError);
      case "block-scalar":
        return resolveBlockScalar(token2, strict, _onError);
    }
  }
  return null;
}
function createScalarToken(value2, context) {
  var _a;
  const { implicitKey = false, indent, inFlow = false, offset: offset3 = -1, type = "PLAIN" } = context;
  const source2 = stringifyString({ type, value: value2 }, {
    implicitKey,
    indent: indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  const end = (_a = context.end) != null ? _a : [
    { type: "newline", offset: -1, indent, source: "\n" }
  ];
  switch (source2[0]) {
    case "|":
    case ">": {
      const he = source2.indexOf("\n");
      const head = source2.substring(0, he);
      const body = source2.substring(he + 1) + "\n";
      const props = [
        { type: "block-scalar-header", offset: offset3, indent, source: head }
      ];
      if (!addEndtoBlockProps(props, end))
        props.push({ type: "newline", offset: -1, indent, source: "\n" });
      return { type: "block-scalar", offset: offset3, indent, props, source: body };
    }
    case '"':
      return { type: "double-quoted-scalar", offset: offset3, indent, source: source2, end };
    case "'":
      return { type: "single-quoted-scalar", offset: offset3, indent, source: source2, end };
    default:
      return { type: "scalar", offset: offset3, indent, source: source2, end };
  }
}
function setScalarValue(token2, value2, context = {}) {
  let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
  let indent = "indent" in token2 ? token2.indent : null;
  if (afterKey && typeof indent === "number")
    indent += 2;
  if (!type)
    switch (token2.type) {
      case "single-quoted-scalar":
        type = "QUOTE_SINGLE";
        break;
      case "double-quoted-scalar":
        type = "QUOTE_DOUBLE";
        break;
      case "block-scalar": {
        const header = token2.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
        break;
      }
      default:
        type = "PLAIN";
    }
  const source2 = stringifyString({ type, value: value2 }, {
    implicitKey: implicitKey || indent === null,
    indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  switch (source2[0]) {
    case "|":
    case ">":
      setBlockScalarValue(token2, source2);
      break;
    case '"':
      setFlowScalarValue(token2, source2, "double-quoted-scalar");
      break;
    case "'":
      setFlowScalarValue(token2, source2, "single-quoted-scalar");
      break;
    default:
      setFlowScalarValue(token2, source2, "scalar");
  }
}
function setBlockScalarValue(token2, source2) {
  const he = source2.indexOf("\n");
  const head = source2.substring(0, he);
  const body = source2.substring(he + 1) + "\n";
  if (token2.type === "block-scalar") {
    const header = token2.props[0];
    if (header.type !== "block-scalar-header")
      throw new Error("Invalid block scalar header");
    header.source = head;
    token2.source = body;
  } else {
    const { offset: offset3 } = token2;
    const indent = "indent" in token2 ? token2.indent : -1;
    const props = [
      { type: "block-scalar-header", offset: offset3, indent, source: head }
    ];
    if (!addEndtoBlockProps(props, "end" in token2 ? token2.end : void 0))
      props.push({ type: "newline", offset: -1, indent, source: "\n" });
    for (const key2 of Object.keys(token2))
      if (key2 !== "type" && key2 !== "offset")
        delete token2[key2];
    Object.assign(token2, { type: "block-scalar", indent, props, source: body });
  }
}
function addEndtoBlockProps(props, end) {
  if (end)
    for (const st of end)
      switch (st.type) {
        case "space":
        case "comment":
          props.push(st);
          break;
        case "newline":
          props.push(st);
          return true;
      }
  return false;
}
function setFlowScalarValue(token2, source2, type) {
  switch (token2.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      token2.type = type;
      token2.source = source2;
      break;
    case "block-scalar": {
      const end = token2.props.slice(1);
      let oa = source2.length;
      if (token2.props[0].type === "block-scalar-header")
        oa -= token2.props[0].source.length;
      for (const tok of end)
        tok.offset += oa;
      delete token2.props;
      Object.assign(token2, { type, source: source2, end });
      break;
    }
    case "block-map":
    case "block-seq": {
      const offset3 = token2.offset + source2.length;
      const nl = { type: "newline", offset: offset3, indent: token2.indent, source: "\n" };
      delete token2.items;
      Object.assign(token2, { type, source: source2, end: [nl] });
      break;
    }
    default: {
      const indent = "indent" in token2 ? token2.indent : -1;
      const end = "end" in token2 && Array.isArray(token2.end) ? token2.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
      for (const key2 of Object.keys(token2))
        if (key2 !== "type" && key2 !== "offset")
          delete token2[key2];
      Object.assign(token2, { type, indent, source: source2, end });
    }
  }
}
var stringify$2 = (cst2) => "type" in cst2 ? stringifyToken(cst2) : stringifyItem(cst2);
function stringifyToken(token2) {
  switch (token2.type) {
    case "block-scalar": {
      let res = "";
      for (const tok of token2.props)
        res += stringifyToken(tok);
      return res + token2.source;
    }
    case "block-map":
    case "block-seq": {
      let res = "";
      for (const item of token2.items)
        res += stringifyItem(item);
      return res;
    }
    case "flow-collection": {
      let res = token2.start.source;
      for (const item of token2.items)
        res += stringifyItem(item);
      for (const st of token2.end)
        res += st.source;
      return res;
    }
    case "document": {
      let res = stringifyItem(token2);
      if (token2.end)
        for (const st of token2.end)
          res += st.source;
      return res;
    }
    default: {
      let res = token2.source;
      if ("end" in token2 && token2.end)
        for (const st of token2.end)
          res += st.source;
      return res;
    }
  }
}
function stringifyItem({ start, key: key2, sep: sep2, value: value2 }) {
  let res = "";
  for (const st of start)
    res += st.source;
  if (key2)
    res += stringifyToken(key2);
  if (sep2)
    for (const st of sep2)
      res += st.source;
  if (value2)
    res += stringifyToken(value2);
  return res;
}
var BREAK = Symbol("break visit");
var SKIP = Symbol("skip children");
var REMOVE = Symbol("remove item");
function visit(cst2, visitor) {
  if ("type" in cst2 && cst2.type === "document")
    cst2 = { start: cst2.start, value: cst2.value };
  _visit(Object.freeze([]), cst2, visitor);
}
visit.BREAK = BREAK;
visit.SKIP = SKIP;
visit.REMOVE = REMOVE;
visit.itemAtPath = (cst2, path4) => {
  let item = cst2;
  for (const [field, index2] of path4) {
    const tok = item == null ? void 0 : item[field];
    if (tok && "items" in tok) {
      item = tok.items[index2];
    } else
      return void 0;
  }
  return item;
};
visit.parentCollection = (cst2, path4) => {
  const parent = visit.itemAtPath(cst2, path4.slice(0, -1));
  const field = path4[path4.length - 1][0];
  const coll = parent == null ? void 0 : parent[field];
  if (coll && "items" in coll)
    return coll;
  throw new Error("Parent collection not found");
};
function _visit(path4, item, visitor) {
  let ctrl = visitor(item, path4);
  if (typeof ctrl === "symbol")
    return ctrl;
  for (const field of ["key", "value"]) {
    const token2 = item[field];
    if (token2 && "items" in token2) {
      for (let i = 0; i < token2.items.length; ++i) {
        const ci = _visit(Object.freeze(path4.concat([[field, i]])), token2.items[i], visitor);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          token2.items.splice(i, 1);
          i -= 1;
        }
      }
      if (typeof ctrl === "function" && field === "key")
        ctrl = ctrl(item, path4);
    }
  }
  return typeof ctrl === "function" ? ctrl(item, path4) : ctrl;
}
var BOM = "\uFEFF";
var DOCUMENT = "";
var FLOW_END = "";
var SCALAR = "";
var isCollection = (token2) => !!token2 && "items" in token2;
var isScalar = (token2) => !!token2 && (token2.type === "scalar" || token2.type === "single-quoted-scalar" || token2.type === "double-quoted-scalar" || token2.type === "block-scalar");
function prettyToken(token2) {
  switch (token2) {
    case BOM:
      return "<BOM>";
    case DOCUMENT:
      return "<DOC>";
    case FLOW_END:
      return "<FLOW_END>";
    case SCALAR:
      return "<SCALAR>";
    default:
      return JSON.stringify(token2);
  }
}
function tokenType(source2) {
  switch (source2) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source2[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}
var cst = {
  __proto__: null,
  BOM,
  DOCUMENT,
  FLOW_END,
  SCALAR,
  isCollection,
  isScalar,
  prettyToken,
  tokenType,
  createScalarToken,
  resolveAsScalar,
  setScalarValue,
  stringify: stringify$2,
  visit
};
function isEmpty(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
var hexDigits = "0123456789ABCDEFabcdef".split("");
var tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split("");
var invalidFlowScalarChars = ",[]{}".split("");
var invalidAnchorChars = " ,[]{}\n\r	".split("");
var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
var Lexer = class {
  constructor() {
    this.atEnd = false;
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    this.buffer = "";
    this.flowKey = false;
    this.flowLevel = 0;
    this.indentNext = 0;
    this.indentValue = 0;
    this.lineEndPos = null;
    this.next = null;
    this.pos = 0;
  }
  *lex(source2, incomplete = false) {
    var _a;
    if (source2) {
      this.buffer = this.buffer ? this.buffer + source2 : source2;
      this.lineEndPos = null;
    }
    this.atEnd = !incomplete;
    let next = (_a = this.next) != null ? _a : "stream";
    while (next && (incomplete || this.hasChars(1)))
      next = yield* this.parseNext(next);
  }
  atLineEnd() {
    let i = this.pos;
    let ch = this.buffer[i];
    while (ch === " " || ch === "	")
      ch = this.buffer[++i];
    if (!ch || ch === "#" || ch === "\n")
      return true;
    if (ch === "\r")
      return this.buffer[i + 1] === "\n";
    return false;
  }
  charAt(n2) {
    return this.buffer[this.pos + n2];
  }
  continueScalar(offset3) {
    let ch = this.buffer[offset3];
    if (this.indentNext > 0) {
      let indent = 0;
      while (ch === " ")
        ch = this.buffer[++indent + offset3];
      if (ch === "\r") {
        const next = this.buffer[indent + offset3 + 1];
        if (next === "\n" || !next && !this.atEnd)
          return offset3 + indent + 1;
      }
      return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset3 + indent : -1;
    }
    if (ch === "-" || ch === ".") {
      const dt = this.buffer.substr(offset3, 3);
      if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset3 + 3]))
        return -1;
    }
    return offset3;
  }
  getLine() {
    let end = this.lineEndPos;
    if (typeof end !== "number" || end !== -1 && end < this.pos) {
      end = this.buffer.indexOf("\n", this.pos);
      this.lineEndPos = end;
    }
    if (end === -1)
      return this.atEnd ? this.buffer.substring(this.pos) : null;
    if (this.buffer[end - 1] === "\r")
      end -= 1;
    return this.buffer.substring(this.pos, end);
  }
  hasChars(n2) {
    return this.pos + n2 <= this.buffer.length;
  }
  setNext(state) {
    this.buffer = this.buffer.substring(this.pos);
    this.pos = 0;
    this.lineEndPos = null;
    this.next = state;
    return null;
  }
  peek(n2) {
    return this.buffer.substr(this.pos, n2);
  }
  *parseNext(next) {
    switch (next) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let line2 = this.getLine();
    if (line2 === null)
      return this.setNext("stream");
    if (line2[0] === BOM) {
      yield* this.pushCount(1);
      line2 = line2.substring(1);
    }
    if (line2[0] === "%") {
      let dirEnd = line2.length;
      const cs = line2.indexOf("#");
      if (cs !== -1) {
        const ch = line2[cs - 1];
        if (ch === " " || ch === "	")
          dirEnd = cs - 1;
      }
      while (true) {
        const ch = line2[dirEnd - 1];
        if (ch === " " || ch === "	")
          dirEnd -= 1;
        else
          break;
      }
      const n2 = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
      yield* this.pushCount(line2.length - n2);
      this.pushNewline();
      return "stream";
    }
    if (this.atLineEnd()) {
      const sp = yield* this.pushSpaces(true);
      yield* this.pushCount(line2.length - sp);
      yield* this.pushNewline();
      return "stream";
    }
    yield DOCUMENT;
    return yield* this.parseLineStart();
  }
  *parseLineStart() {
    const ch = this.charAt(0);
    if (!ch && !this.atEnd)
      return this.setNext("line-start");
    if (ch === "-" || ch === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const s = this.peek(3);
      if (s === "---" && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        this.indentValue = 0;
        this.indentNext = 0;
        return "doc";
      } else if (s === "..." && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        return "stream";
      }
    }
    this.indentValue = yield* this.pushSpaces(false);
    if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
      this.indentNext = this.indentValue;
    return yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [ch0, ch1] = this.peek(2);
    if (!ch1 && !this.atEnd)
      return this.setNext("block-start");
    if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
      const n2 = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
      this.indentNext = this.indentValue + 1;
      this.indentValue += n2;
      return yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(true);
    const line2 = this.getLine();
    if (line2 === null)
      return this.setNext("doc");
    let n2 = yield* this.pushIndicators();
    switch (line2[n2]) {
      case "#":
        yield* this.pushCount(line2.length - n2);
      case void 0:
        yield* this.pushNewline();
        return yield* this.parseLineStart();
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel = 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        return "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        n2 += yield* this.parseBlockScalarHeader();
        n2 += yield* this.pushSpaces(true);
        yield* this.pushCount(line2.length - n2);
        yield* this.pushNewline();
        return yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let nl, sp;
    let indent = -1;
    do {
      nl = yield* this.pushNewline();
      if (nl > 0) {
        sp = yield* this.pushSpaces(false);
        this.indentValue = indent = sp;
      } else {
        sp = 0;
      }
      sp += yield* this.pushSpaces(true);
    } while (nl + sp > 0);
    const line2 = this.getLine();
    if (line2 === null)
      return this.setNext("flow");
    if (indent !== -1 && indent < this.indentNext && line2[0] !== "#" || indent === 0 && (line2.startsWith("---") || line2.startsWith("...")) && isEmpty(line2[3])) {
      const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line2[0] === "]" || line2[0] === "}");
      if (!atFlowEndMarker) {
        this.flowLevel = 0;
        yield FLOW_END;
        return yield* this.parseLineStart();
      }
    }
    let n2 = 0;
    while (line2[n2] === ",") {
      n2 += yield* this.pushCount(1);
      n2 += yield* this.pushSpaces(true);
      this.flowKey = false;
    }
    n2 += yield* this.pushIndicators();
    switch (line2[n2]) {
      case void 0:
        return "flow";
      case "#":
        yield* this.pushCount(line2.length - n2);
        return "flow";
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel += 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        this.flowKey = true;
        this.flowLevel -= 1;
        return this.flowLevel ? "flow" : "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "flow";
      case '"':
      case "'":
        this.flowKey = true;
        return yield* this.parseQuotedScalar();
      case ":": {
        const next = this.charAt(1);
        if (this.flowKey || isEmpty(next) || next === ",") {
          this.flowKey = false;
          yield* this.pushCount(1);
          yield* this.pushSpaces(true);
          return "flow";
        }
      }
      default:
        this.flowKey = false;
        return yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const quote = this.charAt(0);
    let end = this.buffer.indexOf(quote, this.pos + 1);
    if (quote === "'") {
      while (end !== -1 && this.buffer[end + 1] === "'")
        end = this.buffer.indexOf("'", end + 2);
    } else {
      while (end !== -1) {
        let n2 = 0;
        while (this.buffer[end - 1 - n2] === "\\")
          n2 += 1;
        if (n2 % 2 === 0)
          break;
        end = this.buffer.indexOf('"', end + 1);
      }
    }
    const qb = this.buffer.substring(0, end);
    let nl = qb.indexOf("\n", this.pos);
    if (nl !== -1) {
      while (nl !== -1) {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = qb.indexOf("\n", cs);
      }
      if (nl !== -1) {
        end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
      }
    }
    if (end === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      end = this.buffer.length;
    }
    yield* this.pushToIndex(end + 1, false);
    return this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    let i = this.pos;
    while (true) {
      const ch = this.buffer[++i];
      if (ch === "+")
        this.blockScalarKeep = true;
      else if (ch > "0" && ch <= "9")
        this.blockScalarIndent = Number(ch) - 1;
      else if (ch !== "-")
        break;
    }
    return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
  }
  *parseBlockScalar() {
    let nl = this.pos - 1;
    let indent = 0;
    let ch;
    loop:
      for (let i = this.pos; ch = this.buffer[i]; ++i) {
        switch (ch) {
          case " ":
            indent += 1;
            break;
          case "\n":
            nl = i;
            indent = 0;
            break;
          case "\r": {
            const next = this.buffer[i + 1];
            if (!next && !this.atEnd)
              return this.setNext("block-scalar");
            if (next === "\n")
              break;
          }
          default:
            break loop;
        }
      }
    if (!ch && !this.atEnd)
      return this.setNext("block-scalar");
    if (indent >= this.indentNext) {
      if (this.blockScalarIndent === -1)
        this.indentNext = indent;
      else
        this.indentNext += this.blockScalarIndent;
      do {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = this.buffer.indexOf("\n", cs);
      } while (nl !== -1);
      if (nl === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        nl = this.buffer.length;
      }
    }
    if (!this.blockScalarKeep) {
      do {
        let i = nl - 1;
        let ch2 = this.buffer[i];
        if (ch2 === "\r")
          ch2 = this.buffer[--i];
        const lastChar = i;
        while (ch2 === " " || ch2 === "	")
          ch2 = this.buffer[--i];
        if (ch2 === "\n" && i >= this.pos && i + 1 + indent > lastChar)
          nl = i;
        else
          break;
      } while (true);
    }
    yield SCALAR;
    yield* this.pushToIndex(nl + 1, true);
    return yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const inFlow = this.flowLevel > 0;
    let end = this.pos - 1;
    let i = this.pos - 1;
    let ch;
    while (ch = this.buffer[++i]) {
      if (ch === ":") {
        const next = this.buffer[i + 1];
        if (isEmpty(next) || inFlow && next === ",")
          break;
        end = i;
      } else if (isEmpty(ch)) {
        let next = this.buffer[i + 1];
        if (ch === "\r") {
          if (next === "\n") {
            i += 1;
            ch = "\n";
            next = this.buffer[i + 1];
          } else
            end = i;
        }
        if (next === "#" || inFlow && invalidFlowScalarChars.includes(next))
          break;
        if (ch === "\n") {
          const cs = this.continueScalar(i + 1);
          if (cs === -1)
            break;
          i = Math.max(i, cs - 2);
        }
      } else {
        if (inFlow && invalidFlowScalarChars.includes(ch))
          break;
        end = i;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("plain-scalar");
    yield SCALAR;
    yield* this.pushToIndex(end + 1, true);
    return inFlow ? "flow" : "doc";
  }
  *pushCount(n2) {
    if (n2 > 0) {
      yield this.buffer.substr(this.pos, n2);
      this.pos += n2;
      return n2;
    }
    return 0;
  }
  *pushToIndex(i, allowEmpty) {
    const s = this.buffer.slice(this.pos, i);
    if (s) {
      yield s;
      this.pos += s.length;
      return s.length;
    } else if (allowEmpty)
      yield "";
    return 0;
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "-":
      case "?":
      case ":": {
        const inFlow = this.flowLevel > 0;
        const ch1 = this.charAt(1);
        if (isEmpty(ch1) || inFlow && invalidFlowScalarChars.includes(ch1)) {
          if (!inFlow)
            this.indentNext = this.indentValue + 1;
          else if (this.flowKey)
            this.flowKey = false;
          return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        }
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let i = this.pos + 2;
      let ch = this.buffer[i];
      while (!isEmpty(ch) && ch !== ">")
        ch = this.buffer[++i];
      return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
    } else {
      let i = this.pos + 1;
      let ch = this.buffer[i];
      while (ch) {
        if (tagChars.includes(ch))
          ch = this.buffer[++i];
        else if (ch === "%" && hexDigits.includes(this.buffer[i + 1]) && hexDigits.includes(this.buffer[i + 2])) {
          ch = this.buffer[i += 3];
        } else
          break;
      }
      return yield* this.pushToIndex(i, false);
    }
  }
  *pushNewline() {
    const ch = this.buffer[this.pos];
    if (ch === "\n")
      return yield* this.pushCount(1);
    else if (ch === "\r" && this.charAt(1) === "\n")
      return yield* this.pushCount(2);
    else
      return 0;
  }
  *pushSpaces(allowTabs) {
    let i = this.pos - 1;
    let ch;
    do {
      ch = this.buffer[++i];
    } while (ch === " " || allowTabs && ch === "	");
    const n2 = i - this.pos;
    if (n2 > 0) {
      yield this.buffer.substr(this.pos, n2);
      this.pos = i;
    }
    return n2;
  }
  *pushUntil(test) {
    let i = this.pos;
    let ch = this.buffer[i];
    while (!test(ch))
      ch = this.buffer[++i];
    return yield* this.pushToIndex(i, false);
  }
};
var LineCounter = class {
  constructor() {
    this.lineStarts = [];
    this.addNewLine = (offset3) => this.lineStarts.push(offset3);
    this.linePos = (offset3) => {
      let low = 0;
      let high = this.lineStarts.length;
      while (low < high) {
        const mid = low + high >> 1;
        if (this.lineStarts[mid] < offset3)
          low = mid + 1;
        else
          high = mid;
      }
      if (this.lineStarts[low] === offset3)
        return { line: low + 1, col: 1 };
      if (low === 0)
        return { line: 0, col: offset3 };
      const start = this.lineStarts[low - 1];
      return { line: low, col: offset3 - start + 1 };
    };
  }
};
function includesToken(list, type) {
  for (let i = 0; i < list.length; ++i)
    if (list[i].type === type)
      return true;
  return false;
}
function findNonEmptyIndex(list) {
  for (let i = 0; i < list.length; ++i) {
    switch (list[i].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return i;
    }
  }
  return -1;
}
function isFlowToken(token2) {
  switch (token2 == null ? void 0 : token2.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function getPrevProps(parent) {
  var _a;
  switch (parent.type) {
    case "document":
      return parent.start;
    case "block-map": {
      const it = parent.items[parent.items.length - 1];
      return (_a = it.sep) != null ? _a : it.start;
    }
    case "block-seq":
      return parent.items[parent.items.length - 1].start;
    default:
      return [];
  }
}
function getFirstKeyStartProps(prev) {
  var _a;
  if (prev.length === 0)
    return [];
  let i = prev.length;
  loop:
    while (--i >= 0) {
      switch (prev[i].type) {
        case "doc-start":
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
        case "newline":
          break loop;
      }
    }
  while (((_a = prev[++i]) == null ? void 0 : _a.type) === "space") {
  }
  return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it of fc.items) {
      if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
        if (it.key)
          it.value = it.key;
        delete it.key;
        if (isFlowToken(it.value)) {
          if (it.value.end)
            Array.prototype.push.apply(it.value.end, it.sep);
          else
            it.value.end = it.sep;
        } else
          Array.prototype.push.apply(it.start, it.sep);
        delete it.sep;
      }
    }
  }
}
var Parser$1 = class {
  constructor(onNewLine) {
    this.atNewLine = true;
    this.atScalar = false;
    this.indent = 0;
    this.offset = 0;
    this.onKeyLine = false;
    this.stack = [];
    this.source = "";
    this.type = "";
    this.lexer = new Lexer();
    this.onNewLine = onNewLine;
  }
  *parse(source2, incomplete = false) {
    if (this.onNewLine && this.offset === 0)
      this.onNewLine(0);
    for (const lexeme of this.lexer.lex(source2, incomplete))
      yield* this.next(lexeme);
    if (!incomplete)
      yield* this.end();
  }
  *next(source2) {
    this.source = source2;
    if (this.atScalar) {
      this.atScalar = false;
      yield* this.step();
      this.offset += source2.length;
      return;
    }
    const type = tokenType(source2);
    if (!type) {
      const message = `Not a YAML token: ${source2}`;
      yield* this.pop({ type: "error", offset: this.offset, message, source: source2 });
      this.offset += source2.length;
    } else if (type === "scalar") {
      this.atNewLine = false;
      this.atScalar = true;
      this.type = "scalar";
    } else {
      this.type = type;
      yield* this.step();
      switch (type) {
        case "newline":
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine)
            this.onNewLine(this.offset + source2.length);
          break;
        case "space":
          if (this.atNewLine && source2[0] === " ")
            this.indent += source2.length;
          break;
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
          if (this.atNewLine)
            this.indent += source2.length;
          break;
        case "doc-mode":
        case "flow-error-end":
          return;
        default:
          this.atNewLine = false;
      }
      this.offset += source2.length;
    }
  }
  *end() {
    while (this.stack.length > 0)
      yield* this.pop();
  }
  get sourceToken() {
    const st = {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
    return st;
  }
  *step() {
    const top = this.peek(1);
    if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
      while (this.stack.length > 0)
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!top)
      return yield* this.stream();
    switch (top.type) {
      case "document":
        return yield* this.document(top);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(top);
      case "block-scalar":
        return yield* this.blockScalar(top);
      case "block-map":
        return yield* this.blockMap(top);
      case "block-seq":
        return yield* this.blockSequence(top);
      case "flow-collection":
        return yield* this.flowCollection(top);
      case "doc-end":
        return yield* this.documentEnd(top);
    }
    yield* this.pop();
  }
  peek(n2) {
    return this.stack[this.stack.length - n2];
  }
  *pop(error2) {
    const token2 = error2 != null ? error2 : this.stack.pop();
    if (!token2) {
      const message = "Tried to pop an empty stack";
      yield { type: "error", offset: this.offset, source: "", message };
    } else if (this.stack.length === 0) {
      yield token2;
    } else {
      const top = this.peek(1);
      if (token2.type === "block-scalar") {
        token2.indent = "indent" in top ? top.indent : 0;
      } else if (token2.type === "flow-collection" && top.type === "document") {
        token2.indent = 0;
      }
      if (token2.type === "flow-collection")
        fixFlowSeqItems(token2);
      switch (top.type) {
        case "document":
          top.value = token2;
          break;
        case "block-scalar":
          top.props.push(token2);
          break;
        case "block-map": {
          const it = top.items[top.items.length - 1];
          if (it.value) {
            top.items.push({ start: [], key: token2, sep: [] });
            this.onKeyLine = true;
            return;
          } else if (it.sep) {
            it.value = token2;
          } else {
            Object.assign(it, { key: token2, sep: [] });
            this.onKeyLine = !includesToken(it.start, "explicit-key-ind");
            return;
          }
          break;
        }
        case "block-seq": {
          const it = top.items[top.items.length - 1];
          if (it.value)
            top.items.push({ start: [], value: token2 });
          else
            it.value = token2;
          break;
        }
        case "flow-collection": {
          const it = top.items[top.items.length - 1];
          if (!it || it.value)
            top.items.push({ start: [], key: token2, sep: [] });
          else if (it.sep)
            it.value = token2;
          else
            Object.assign(it, { key: token2, sep: [] });
          return;
        }
        default:
          yield* this.pop();
          yield* this.pop(token2);
      }
      if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token2.type === "block-map" || token2.type === "block-seq")) {
        const last = token2.items[token2.items.length - 1];
        if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token2.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token2.indent))) {
          if (top.type === "document")
            top.end = last.start;
          else
            top.items.push({ start: last.start });
          token2.items.splice(-1, 1);
        }
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const doc = {
          type: "document",
          offset: this.offset,
          start: []
        };
        if (this.type === "doc-start")
          doc.start.push(this.sourceToken);
        this.stack.push(doc);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(doc) {
    if (doc.value)
      return yield* this.lineEnd(doc);
    switch (this.type) {
      case "doc-start": {
        if (findNonEmptyIndex(doc.start) !== -1) {
          yield* this.pop();
          yield* this.step();
        } else
          doc.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        doc.start.push(this.sourceToken);
        return;
    }
    const bv = this.startBlockValue(doc);
    if (bv)
      this.stack.push(bv);
    else {
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML document`,
        source: this.source
      };
    }
  }
  *scalar(scalar) {
    if (this.type === "map-value-ind") {
      const prev = getPrevProps(this.peek(2));
      const start = getFirstKeyStartProps(prev);
      let sep2;
      if (scalar.end) {
        sep2 = scalar.end;
        sep2.push(this.sourceToken);
        delete scalar.end;
      } else
        sep2 = [this.sourceToken];
      const map2 = {
        type: "block-map",
        offset: scalar.offset,
        indent: scalar.indent,
        items: [{ start, key: scalar, sep: sep2 }]
      };
      this.onKeyLine = true;
      this.stack[this.stack.length - 1] = map2;
    } else
      yield* this.lineEnd(scalar);
  }
  *blockScalar(scalar) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        scalar.props.push(this.sourceToken);
        return;
      case "scalar":
        scalar.source = this.source;
        this.atNewLine = true;
        this.indent = 0;
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        yield* this.pop();
        break;
      default:
        yield* this.pop();
        yield* this.step();
    }
  }
  *blockMap(map2) {
    var _a;
    const it = map2.items[map2.items.length - 1];
    switch (this.type) {
      case "newline":
        this.onKeyLine = false;
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if ((last == null ? void 0 : last.type) === "comment")
            end == null ? void 0 : end.push(this.sourceToken);
          else
            map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          it.start.push(this.sourceToken);
        }
        return;
      case "space":
      case "comment":
        if (it.value) {
          map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          if (this.atIndentedComment(it.start, map2.indent)) {
            const prev = map2.items[map2.items.length - 2];
            const end = (_a = prev == null ? void 0 : prev.value) == null ? void 0 : _a.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              map2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= map2.indent) {
      const atNextItem = !this.onKeyLine && this.indent === map2.indent && it.sep;
      let start = [];
      if (atNextItem && it.sep && !it.value) {
        const nl = [];
        for (let i = 0; i < it.sep.length; ++i) {
          const st = it.sep[i];
          switch (st.type) {
            case "newline":
              nl.push(i);
              break;
            case "space":
              break;
            case "comment":
              if (st.indent > map2.indent)
                nl.length = 0;
              break;
            default:
              nl.length = 0;
          }
        }
        if (nl.length >= 2)
          start = it.sep.splice(nl[1]);
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map2.items.push({ start });
            this.onKeyLine = true;
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            it.start.push(this.sourceToken);
          }
          return;
        case "explicit-key-ind":
          if (!it.sep && !includesToken(it.start, "explicit-key-ind")) {
            it.start.push(this.sourceToken);
          } else if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map2.items.push({ start });
          } else {
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            });
          }
          this.onKeyLine = true;
          return;
        case "map-value-ind":
          if (includesToken(it.start, "explicit-key-ind")) {
            if (!it.sep) {
              if (includesToken(it.start, "newline")) {
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              } else {
                const start2 = getFirstKeyStartProps(it.start);
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                });
              }
            } else if (it.value) {
              map2.items.push({ start: [], key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start, key: null, sep: [this.sourceToken] }]
              });
            } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
              const start2 = getFirstKeyStartProps(it.start);
              const key2 = it.key;
              const sep2 = it.sep;
              sep2.push(this.sourceToken);
              delete it.key, delete it.sep;
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: start2, key: key2, sep: sep2 }]
              });
            } else if (start.length > 0) {
              it.sep = it.sep.concat(start, this.sourceToken);
            } else {
              it.sep.push(this.sourceToken);
            }
          } else {
            if (!it.sep) {
              Object.assign(it, { key: null, sep: [this.sourceToken] });
            } else if (it.value || atNextItem) {
              map2.items.push({ start, key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [], key: null, sep: [this.sourceToken] }]
              });
            } else {
              it.sep.push(this.sourceToken);
            }
          }
          this.onKeyLine = true;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs2 = this.flowScalar(this.type);
          if (atNextItem || it.value) {
            map2.items.push({ start, key: fs2, sep: [] });
            this.onKeyLine = true;
          } else if (it.sep) {
            this.stack.push(fs2);
          } else {
            Object.assign(it, { key: fs2, sep: [] });
            this.onKeyLine = true;
          }
          return;
        }
        default: {
          const bv = this.startBlockValue(map2);
          if (bv) {
            if (atNextItem && bv.type !== "block-seq" && includesToken(it.start, "explicit-key-ind")) {
              map2.items.push({ start });
            }
            this.stack.push(bv);
            return;
          }
        }
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *blockSequence(seq2) {
    var _a;
    const it = seq2.items[seq2.items.length - 1];
    switch (this.type) {
      case "newline":
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if ((last == null ? void 0 : last.type) === "comment")
            end == null ? void 0 : end.push(this.sourceToken);
          else
            seq2.items.push({ start: [this.sourceToken] });
        } else
          it.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (it.value)
          seq2.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(it.start, seq2.indent)) {
            const prev = seq2.items[seq2.items.length - 2];
            const end = (_a = prev == null ? void 0 : prev.value) == null ? void 0 : _a.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              seq2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (it.value || this.indent <= seq2.indent)
          break;
        it.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== seq2.indent)
          break;
        if (it.value || includesToken(it.start, "seq-item-ind"))
          seq2.items.push({ start: [this.sourceToken] });
        else
          it.start.push(this.sourceToken);
        return;
    }
    if (this.indent > seq2.indent) {
      const bv = this.startBlockValue(seq2);
      if (bv) {
        this.stack.push(bv);
        return;
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *flowCollection(fc) {
    const it = fc.items[fc.items.length - 1];
    if (this.type === "flow-error-end") {
      let top;
      do {
        yield* this.pop();
        top = this.peek(1);
      } while (top && top.type === "flow-collection");
    } else if (fc.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          if (!it || it.sep)
            fc.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          if (!it || it.value)
            fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            Object.assign(it, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          if (!it || it.value)
            fc.items.push({ start: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            it.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs2 = this.flowScalar(this.type);
          if (!it || it.value)
            fc.items.push({ start: [], key: fs2, sep: [] });
          else if (it.sep)
            this.stack.push(fs2);
          else
            Object.assign(it, { key: fs2, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          fc.end.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(fc);
      if (bv)
        this.stack.push(bv);
      else {
        yield* this.pop();
        yield* this.step();
      }
    } else {
      const parent = this.peek(2);
      if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
        yield* this.pop();
        yield* this.step();
      } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        fixFlowSeqItems(fc);
        const sep2 = fc.end.splice(1, fc.end.length);
        sep2.push(this.sourceToken);
        const map2 = {
          type: "block-map",
          offset: fc.offset,
          indent: fc.indent,
          items: [{ start, key: fc, sep: sep2 }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map2;
      } else {
        yield* this.lineEnd(fc);
      }
    }
  }
  flowScalar(type) {
    if (this.onNewLine) {
      let nl = this.source.indexOf("\n") + 1;
      while (nl !== 0) {
        this.onNewLine(this.offset + nl);
        nl = this.source.indexOf("\n", nl) + 1;
      }
    }
    return {
      type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(parent) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        start.push(this.sourceToken);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(start, indent) {
    if (this.type !== "comment")
      return false;
    if (this.indent <= indent)
      return false;
    return start.every((st) => st.type === "newline" || st.type === "space");
  }
  *documentEnd(docEnd) {
    if (this.type !== "doc-mode") {
      if (docEnd.end)
        docEnd.end.push(this.sourceToken);
      else
        docEnd.end = [this.sourceToken];
      if (this.type === "newline")
        yield* this.pop();
    }
  }
  *lineEnd(token2) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop();
        yield* this.step();
        break;
      case "newline":
        this.onKeyLine = false;
      case "space":
      case "comment":
      default:
        if (token2.end)
          token2.end.push(this.sourceToken);
        else
          token2.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
    }
  }
};
function parseOptions(options3) {
  const prettyErrors = options3.prettyErrors !== false;
  const lineCounter = options3.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
function parseAllDocuments(source2, options3 = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options3);
  const parser2 = new Parser$1(lineCounter == null ? void 0 : lineCounter.addNewLine);
  const composer = new Composer(options3);
  const docs = Array.from(composer.compose(parser2.parse(source2)));
  if (prettyErrors && lineCounter)
    for (const doc of docs) {
      doc.errors.forEach(prettifyError(source2, lineCounter));
      doc.warnings.forEach(prettifyError(source2, lineCounter));
    }
  if (docs.length > 0)
    return docs;
  return Object.assign([], { empty: true }, composer.streamInfo());
}
function parseDocument(source2, options3 = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options3);
  const parser2 = new Parser$1(lineCounter == null ? void 0 : lineCounter.addNewLine);
  const composer = new Composer(options3);
  let doc = null;
  for (const _doc of composer.compose(parser2.parse(source2), true, source2.length)) {
    if (!doc)
      doc = _doc;
    else if (doc.options.logLevel !== "silent") {
      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(prettifyError(source2, lineCounter));
    doc.warnings.forEach(prettifyError(source2, lineCounter));
  }
  return doc;
}
function parse$d(src2, reviver, options3) {
  let _reviver = void 0;
  if (typeof reviver === "function") {
    _reviver = reviver;
  } else if (options3 === void 0 && reviver && typeof reviver === "object") {
    options3 = reviver;
  }
  const doc = parseDocument(src2, options3);
  if (!doc)
    return null;
  doc.warnings.forEach((warning) => warn(doc.options.logLevel, warning));
  if (doc.errors.length > 0) {
    if (doc.options.logLevel !== "silent")
      throw doc.errors[0];
    else
      doc.errors = [];
  }
  return doc.toJS(Object.assign({ reviver: _reviver }, options3));
}
function stringify$1(value2, replacer, options3) {
  var _a;
  let _replacer = null;
  if (typeof replacer === "function" || Array.isArray(replacer)) {
    _replacer = replacer;
  } else if (options3 === void 0 && replacer) {
    options3 = replacer;
  }
  if (typeof options3 === "string")
    options3 = options3.length;
  if (typeof options3 === "number") {
    const indent = Math.round(options3);
    options3 = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
  }
  if (value2 === void 0) {
    const { keepUndefined } = (_a = options3 != null ? options3 : replacer) != null ? _a : {};
    if (!keepUndefined)
      return void 0;
  }
  return new Document(value2, _replacer, options3).toString(options3);
}
var YAML = {
  __proto__: null,
  CST: cst,
  Composer,
  Document,
  Schema,
  YAMLError,
  YAMLParseError,
  YAMLWarning,
  Alias,
  isAlias,
  isCollection: isCollection$1,
  isDocument,
  isMap,
  isNode,
  isPair,
  isScalar: isScalar$1,
  isSeq,
  Pair,
  Scalar,
  YAMLMap,
  YAMLSeq,
  Lexer,
  LineCounter,
  Parser: Parser$1,
  parse: parse$d,
  parseAllDocuments,
  parseDocument,
  stringify: stringify$1,
  visit: visit$1,
  visitAsync
};
var browser$1 = {
  __proto__: null,
  "default": YAML,
  Composer,
  Document,
  Schema,
  YAMLError,
  YAMLParseError,
  YAMLWarning,
  Alias,
  isAlias,
  isCollection: isCollection$1,
  isDocument,
  isMap,
  isNode,
  isPair,
  isScalar: isScalar$1,
  isSeq,
  Pair,
  Scalar,
  YAMLMap,
  YAMLSeq,
  Lexer,
  LineCounter,
  Parser: Parser$1,
  parse: parse$d,
  parseAllDocuments,
  parseDocument,
  stringify: stringify$1,
  visit: visit$1,
  visitAsync,
  CST: cst
};
var require$$3 = getAugmentedNamespace(browser$1);
var { createRequire, createRequireFromPath } = import_module.default;
function req$2(name, rootFile) {
  const create = createRequire || createRequireFromPath;
  const require3 = create(rootFile);
  return require3(name);
}
var req_1 = req$2;
var req$1 = req_1;
var options2 = (config2, file) => {
  if (config2.parser && typeof config2.parser === "string") {
    try {
      config2.parser = req$1(config2.parser, file);
    } catch (err) {
      throw new Error(`Loading PostCSS Parser failed: ${err.message}

(@${file})`);
    }
  }
  if (config2.syntax && typeof config2.syntax === "string") {
    try {
      config2.syntax = req$1(config2.syntax, file);
    } catch (err) {
      throw new Error(`Loading PostCSS Syntax failed: ${err.message}

(@${file})`);
    }
  }
  if (config2.stringifier && typeof config2.stringifier === "string") {
    try {
      config2.stringifier = req$1(config2.stringifier, file);
    } catch (err) {
      throw new Error(`Loading PostCSS Stringifier failed: ${err.message}

(@${file})`);
    }
  }
  if (config2.plugins) {
    delete config2.plugins;
  }
  return config2;
};
var options_1 = options2;
var req = req_1;
var load = (plugin, options3, file) => {
  try {
    if (options3 === null || options3 === void 0 || Object.keys(options3).length === 0) {
      return req(plugin, file);
    } else {
      return req(plugin, file)(options3);
    }
  } catch (err) {
    throw new Error(`Loading PostCSS Plugin failed: ${err.message}

(@${file})`);
  }
};
var plugins = (config2, file) => {
  let plugins2 = [];
  if (Array.isArray(config2.plugins)) {
    plugins2 = config2.plugins.filter(Boolean);
  } else {
    plugins2 = Object.keys(config2.plugins).filter((plugin) => {
      return config2.plugins[plugin] !== false ? plugin : "";
    }).map((plugin) => {
      return load(plugin, config2.plugins[plugin], file);
    });
  }
  if (plugins2.length && plugins2.length > 0) {
    plugins2.forEach((plugin, i) => {
      if (plugin.default) {
        plugin = plugin.default;
      }
      if (plugin.postcss === true) {
        plugin = plugin();
      } else if (plugin.postcss) {
        plugin = plugin.postcss;
      }
      if (!(typeof plugin === "object" && Array.isArray(plugin.plugins) || typeof plugin === "object" && plugin.postcssPlugin || typeof plugin === "function")) {
        throw new TypeError(`Invalid PostCSS Plugin found at: plugins[${i}]

(@${file})`);
      }
    });
  }
  return plugins2;
};
var plugins_1 = plugins;
var resolve$1 = import_path.default.resolve;
var url$4 = import_url.default;
var config$1 = dist;
var yaml = require$$3;
var loadOptions = options_1;
var loadPlugins = plugins_1;
var interopRequireDefault = (obj) => obj && obj.__esModule ? obj : { default: obj };
var processResult = (ctx2, result) => {
  const file = result.filepath || "";
  let config2 = interopRequireDefault(result.config).default || {};
  if (typeof config2 === "function") {
    config2 = config2(ctx2);
  } else {
    config2 = Object.assign({}, config2, ctx2);
  }
  if (!config2.plugins) {
    config2.plugins = [];
  }
  return {
    plugins: loadPlugins(config2, file),
    options: loadOptions(config2, file),
    file
  };
};
var createContext = (ctx2) => {
  ctx2 = Object.assign({
    cwd: process.cwd(),
    env: "development"
  }, ctx2);
  if (!ctx2.env) {
    "development" = "development";
  }
  return ctx2;
};
var importDefault = async (filepath) => {
  const module2 = await import(url$4.pathToFileURL(filepath).href);
  return module2.default;
};
var addTypeScriptLoader = (options3 = {}, loader) => {
  const moduleName = "postcss";
  return {
    ...options3,
    searchPlaces: [
      ...options3.searchPlaces || [],
      "package.json",
      `.${moduleName}rc`,
      `.${moduleName}rc.json`,
      `.${moduleName}rc.yaml`,
      `.${moduleName}rc.yml`,
      `.${moduleName}rc.ts`,
      `.${moduleName}rc.js`,
      `.${moduleName}rc.cjs`,
      `.${moduleName}rc.mjs`,
      `${moduleName}.config.ts`,
      `${moduleName}.config.js`,
      `${moduleName}.config.cjs`,
      `${moduleName}.config.mjs`
    ],
    loaders: {
      ...options3.loaders,
      ".yaml": (filepath, content) => yaml.parse(content),
      ".yml": (filepath, content) => yaml.parse(content),
      ".js": importDefault,
      ".cjs": importDefault,
      ".mjs": importDefault,
      ".ts": loader
    }
  };
};
var withTypeScriptLoader = (rcFunc) => {
  return (ctx, path, options) => {
    return rcFunc(ctx, path, addTypeScriptLoader(options, (configFile) => {
      let registerer = { enabled() {
      } };
      try {
        registerer = eval("require")("ts-node").register();
        return eval("require")(configFile);
      } catch (err) {
        if (err.code === "MODULE_NOT_FOUND") {
          throw new Error(
            `'ts-node' is required for the TypeScript configuration files. Make sure it is installed
Error: ${err.message}`
          );
        }
        throw err;
      } finally {
        registerer.enabled(false);
      }
    }));
  };
};
var rc = withTypeScriptLoader((ctx2, path4, options3) => {
  ctx2 = createContext(ctx2);
  path4 = path4 ? resolve$1(path4) : process.cwd();
  return config$1.lilconfig("postcss", options3).search(path4).then((result) => {
    if (!result) {
      throw new Error(`No PostCSS Config found in: ${path4}`);
    }
    return processResult(ctx2, result);
  });
});
var src$1 = rc;
var isDebug$6 = !!process.env.DEBUG;
var debug$e = createDebugger("vite:sourcemap", {
  onlyWhenFocused: true
});
var virtualSourceRE = /^(\0|dep:|browser-external:)/;
async function injectSourcesContent(map2, file, logger) {
  let sourceRoot;
  try {
    sourceRoot = await import_node_fs.promises.realpath(import_node_path2.default.resolve(import_node_path2.default.dirname(file), map2.sourceRoot || ""));
  } catch {
  }
  const missingSources = [];
  map2.sourcesContent = await Promise.all(map2.sources.map((sourcePath) => {
    if (sourcePath && !virtualSourceRE.test(sourcePath)) {
      sourcePath = decodeURI(sourcePath);
      if (sourceRoot) {
        sourcePath = import_node_path2.default.resolve(sourceRoot, sourcePath);
      }
      return import_node_fs.promises.readFile(sourcePath, "utf-8").catch(() => {
        missingSources.push(sourcePath);
        return null;
      });
    }
    return null;
  }));
  if (missingSources.length) {
    logger.warnOnce(`Sourcemap for "${file}" points to missing source files`);
    isDebug$6 && debug$e(`Missing sources:
  ` + missingSources.join(`
  `));
  }
}
function genSourceMapUrl(map2) {
  if (typeof map2 !== "string") {
    map2 = JSON.stringify(map2);
  }
  return `data:application/json;base64,${Buffer.from(map2).toString("base64")}`;
}
function getCodeWithSourcemap(type, code, map2) {
  if (isDebug$6) {
    code += `
/*${JSON.stringify(map2, null, 2).replace(/\*\//g, "*\\/")}*/
`;
  }
  if (type === "js") {
    code += `
//# sourceMappingURL=${genSourceMapUrl(map2 != null ? map2 : void 0)}`;
  } else if (type === "css") {
    code += `
/*# sourceMappingURL=${genSourceMapUrl(map2 != null ? map2 : void 0)} */`;
  }
  return code;
}
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(code, set2) {
  var pos2 = 65536;
  for (var i = 0; i < set2.length; i += 2) {
    pos2 += set2[i];
    if (pos2 > code) {
      return false;
    }
    pos2 += set2[i + 1];
    if (pos2 >= code) {
      return true;
    }
  }
}
function isIdentifierStart(code, astral) {
  if (code < 65) {
    return code === 36;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code, astral) {
  if (code < 48) {
    return code === 36;
  }
  if (code < 58) {
    return true;
  }
  if (code < 65) {
    return false;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
var TokenType = function TokenType2(label, conf) {
  if (conf === void 0)
    conf = {};
  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};
function binop(name, prec) {
  return new TokenType(name, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true };
var startsExpr = { startsExpr: true };
var keywords = {};
function kw(name, options3) {
  if (options3 === void 0)
    options3 = {};
  options3.keyword = name;
  return keywords[name] = new TokenType(name, options3);
}
var types$1 = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  privateId: new TokenType("privateId", startsExpr),
  eof: new TokenType("eof"),
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true }),
  coalesce: binop("??", 1),
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", { isLoop: true, beforeExpr: true }),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", { isLoop: true }),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", { isLoop: true }),
  _with: kw("with"),
  _new: kw("new", { beforeExpr: true, startsExpr: true }),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", { beforeExpr: true, binop: 7 }),
  _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
  _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
  _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
  _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code) {
  return code === 10 || code === 13 || code === 8232 || code === 8233;
}
function nextLineBreak(code, from, end) {
  if (end === void 0)
    end = code.length;
  for (var i = from; i < end; i++) {
    var next = code.charCodeAt(i);
    if (isNewLine(next)) {
      return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
    }
  }
  return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty$1 = ref.hasOwnProperty;
var toString$1 = ref.toString;
var hasOwn = Object.hasOwn || function(obj, propName) {
  return hasOwnProperty$1.call(obj, propName);
};
var isArray = Array.isArray || function(obj) {
  return toString$1.call(obj) === "[object Array]";
};
function wordsRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
}
function codePointToString(code) {
  if (code <= 65535) {
    return String.fromCharCode(code);
  }
  code -= 65536;
  return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var Position = function Position2(line2, col) {
  this.line = line2;
  this.column = col;
};
Position.prototype.offset = function offset(n2) {
  return new Position(this.line, this.column + n2);
};
var SourceLocation = function SourceLocation2(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) {
    this.source = p.sourceFile;
  }
};
function getLineInfo(input, offset3) {
  for (var line2 = 1, cur = 0; ; ) {
    var nextBreak = nextLineBreak(input, cur, offset3);
    if (nextBreak < 0) {
      return new Position(line2, offset3 - cur);
    }
    ++line2;
    cur = nextBreak;
  }
}
var defaultOptions = {
  ecmaVersion: null,
  sourceType: "script",
  onInsertedSemicolon: null,
  onTrailingComma: null,
  allowReserved: null,
  allowReturnOutsideFunction: false,
  allowImportExportEverywhere: false,
  allowAwaitOutsideFunction: null,
  allowSuperOutsideMethod: null,
  allowHashBang: false,
  locations: false,
  onToken: null,
  onComment: null,
  ranges: false,
  program: null,
  sourceFile: null,
  directSourceFile: null,
  preserveParens: false
};
var warnedAboutEcmaVersion = false;
function getOptions(opts) {
  var options3 = {};
  for (var opt in defaultOptions) {
    options3[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
  }
  if (options3.ecmaVersion === "latest") {
    options3.ecmaVersion = 1e8;
  } else if (options3.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options3.ecmaVersion = 11;
  } else if (options3.ecmaVersion >= 2015) {
    options3.ecmaVersion -= 2009;
  }
  if (options3.allowReserved == null) {
    options3.allowReserved = options3.ecmaVersion < 5;
  }
  if (opts.allowHashBang == null) {
    options3.allowHashBang = options3.ecmaVersion >= 14;
  }
  if (isArray(options3.onToken)) {
    var tokens = options3.onToken;
    options3.onToken = function(token2) {
      return tokens.push(token2);
    };
  }
  if (isArray(options3.onComment)) {
    options3.onComment = pushComment(options3, options3.onComment);
  }
  return options3;
}
function pushComment(options3, array2) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start,
      end
    };
    if (options3.locations) {
      comment.loc = new SourceLocation(this, startLoc, endLoc);
    }
    if (options3.ranges) {
      comment.range = [start, end];
    }
    array2.push(comment);
  };
}
var SCOPE_TOP = 1;
var SCOPE_FUNCTION = 2;
var SCOPE_ASYNC = 4;
var SCOPE_GENERATOR = 8;
var SCOPE_ARROW = 16;
var SCOPE_SIMPLE_CATCH = 32;
var SCOPE_SUPER = 64;
var SCOPE_DIRECT_SUPER = 128;
var SCOPE_CLASS_STATIC_BLOCK = 256;
var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags(async2, generator) {
  return SCOPE_FUNCTION | (async2 ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
var BIND_NONE = 0;
var BIND_VAR = 1;
var BIND_LEXICAL = 2;
var BIND_FUNCTION = 3;
var BIND_SIMPLE_CATCH = 4;
var BIND_OUTSIDE = 5;
var Parser = function Parser2(options3, input, startPos) {
  this.options = options3 = getOptions(options3);
  this.sourceFile = options3.sourceFile;
  this.keywords = wordsRegexp(keywords$1[options3.ecmaVersion >= 6 ? 6 : options3.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options3.allowReserved !== true) {
    reserved = reservedWords[options3.ecmaVersion >= 6 ? 6 : options3.ecmaVersion === 5 ? 5 : 3];
    if (options3.sourceType === "module") {
      reserved += " await";
    }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);
  this.containsEsc = false;
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }
  this.type = types$1.eof;
  this.value = null;
  this.start = this.end = this.pos;
  this.startLoc = this.endLoc = this.curPosition();
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;
  this.context = this.initialContext();
  this.exprAllowed = true;
  this.inModule = options3.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);
  this.potentialArrowAt = -1;
  this.potentialArrowInForAwait = false;
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  this.labels = [];
  this.undefinedExports = /* @__PURE__ */ Object.create(null);
  if (this.pos === 0 && options3.allowHashBang && this.input.slice(0, 2) === "#!") {
    this.skipLineComment(2);
  }
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);
  this.regexpState = null;
  this.privateNameStack = [];
};
var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
Parser.prototype.parse = function parse2() {
  var node2 = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node2);
};
prototypeAccessors.inFunction.get = function() {
  return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
  return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.inAsync.get = function() {
  return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.canAwait.get = function() {
  for (var i = this.scopeStack.length - 1; i >= 0; i--) {
    var scope = this.scopeStack[i];
    if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {
      return false;
    }
    if (scope.flags & SCOPE_FUNCTION) {
      return (scope.flags & SCOPE_ASYNC) > 0;
    }
  }
  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
prototypeAccessors.allowSuper.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  var inClassFieldInit = ref2.inClassFieldInit;
  return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
};
prototypeAccessors.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
prototypeAccessors.allowNewDotTarget.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  var inClassFieldInit = ref2.inClassFieldInit;
  return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
};
prototypeAccessors.inClassStaticBlock.get = function() {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
};
Parser.extend = function extend() {
  var plugins2 = [], len = arguments.length;
  while (len--)
    plugins2[len] = arguments[len];
  var cls = this;
  for (var i = 0; i < plugins2.length; i++) {
    cls = plugins2[i](cls);
  }
  return cls;
};
Parser.parse = function parse3(input, options3) {
  return new this(options3, input).parse();
};
Parser.parseExpressionAt = function parseExpressionAt(input, pos2, options3) {
  var parser2 = new this(options3, input, pos2);
  parser2.nextToken();
  return parser2.parseExpression();
};
Parser.tokenizer = function tokenizer(input, options3) {
  return new this(options3, input);
};
Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp$9 = Parser.prototype;
var literal$1 = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
pp$9.strictDirective = function(start) {
  if (this.options.ecmaVersion < 5) {
    return false;
  }
  for (; ; ) {
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal$1.exec(this.input.slice(start));
    if (!match) {
      return false;
    }
    if ((match[1] || match[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start + match[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
      var next = this.input.charAt(end);
      return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
    }
    start += match[0].length;
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start] === ";") {
      start++;
    }
  }
};
pp$9.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true;
  } else {
    return false;
  }
};
pp$9.isContextual = function(name) {
  return this.type === types$1.name && this.value === name && !this.containsEsc;
};
pp$9.eatContextual = function(name) {
  if (!this.isContextual(name)) {
    return false;
  }
  this.next();
  return true;
};
pp$9.expectContextual = function(name) {
  if (!this.eatContextual(name)) {
    this.unexpected();
  }
};
pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) {
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    }
    return true;
  }
};
pp$9.semicolon = function() {
  if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
    this.unexpected();
  }
};
pp$9.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma) {
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    }
    if (!notNext) {
      this.next();
    }
    return true;
  }
};
pp$9.expect = function(type) {
  this.eat(type) || this.unexpected();
};
pp$9.unexpected = function(pos2) {
  this.raise(pos2 != null ? pos2 : this.start, "Unexpected token");
};
var DestructuringErrors = function DestructuringErrors2() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) {
    return;
  }
  if (refDestructuringErrors.trailingComma > -1) {
    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
  }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) {
    this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
  }
};
pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) {
    return false;
  }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) {
    return shorthandAssign >= 0 || doubleProto >= 0;
  }
  if (shorthandAssign >= 0) {
    this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
  }
  if (doubleProto >= 0) {
    this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
  }
};
pp$9.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
    this.raise(this.yieldPos, "Yield expression cannot be a default value");
  }
  if (this.awaitPos) {
    this.raise(this.awaitPos, "Await expression cannot be a default value");
  }
};
pp$9.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression") {
    return this.isSimpleAssignTarget(expr.expression);
  }
  return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$8 = Parser.prototype;
pp$8.parseTopLevel = function(node2) {
  var exports = /* @__PURE__ */ Object.create(null);
  if (!node2.body) {
    node2.body = [];
  }
  while (this.type !== types$1.eof) {
    var stmt = this.parseStatement(null, true, exports);
    node2.body.push(stmt);
  }
  if (this.inModule) {
    for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1) {
      var name = list[i];
      this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
    }
  }
  this.adaptDirectivePrologue(node2.body);
  this.next();
  node2.sourceType = this.options.sourceType;
  return this.finishNode(node2, "Program");
};
var loopLabel = { kind: "loop" };
var switchLabel = { kind: "switch" };
pp$8.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  if (nextCh === 91 || nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
    return true;
  }
  if (context) {
    return false;
  }
  if (nextCh === 123) {
    return true;
  }
  if (isIdentifierStart(nextCh, true)) {
    var pos2 = next + 1;
    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos2), true)) {
      ++pos2;
    }
    if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
      return true;
    }
    var ident = this.input.slice(next, pos2);
    if (!keywordRelationalOperator.test(ident)) {
      return true;
    }
  }
  return false;
};
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, after;
  return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
};
pp$8.parseStatement = function(context, topLevel, exports) {
  var starttype = this.type, node2 = this.startNode(), kind;
  if (this.isLet(context)) {
    starttype = types$1._var;
    kind = "let";
  }
  switch (starttype) {
    case types$1._break:
    case types$1._continue:
      return this.parseBreakContinueStatement(node2, starttype.keyword);
    case types$1._debugger:
      return this.parseDebuggerStatement(node2);
    case types$1._do:
      return this.parseDoStatement(node2);
    case types$1._for:
      return this.parseForStatement(node2);
    case types$1._function:
      if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
        this.unexpected();
      }
      return this.parseFunctionStatement(node2, false, !context);
    case types$1._class:
      if (context) {
        this.unexpected();
      }
      return this.parseClass(node2, true);
    case types$1._if:
      return this.parseIfStatement(node2);
    case types$1._return:
      return this.parseReturnStatement(node2);
    case types$1._switch:
      return this.parseSwitchStatement(node2);
    case types$1._throw:
      return this.parseThrowStatement(node2);
    case types$1._try:
      return this.parseTryStatement(node2);
    case types$1._const:
    case types$1._var:
      kind = kind || this.value;
      if (context && kind !== "var") {
        this.unexpected();
      }
      return this.parseVarStatement(node2, kind);
    case types$1._while:
      return this.parseWhileStatement(node2);
    case types$1._with:
      return this.parseWithStatement(node2);
    case types$1.braceL:
      return this.parseBlock(true, node2);
    case types$1.semi:
      return this.parseEmptyStatement(node2);
    case types$1._export:
    case types$1._import:
      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 40 || nextCh === 46) {
          return this.parseExpressionStatement(node2, this.parseExpression());
        }
      }
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.start, "'import' and 'export' may only appear at the top level");
        }
        if (!this.inModule) {
          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }
      return starttype === types$1._import ? this.parseImport(node2) : this.parseExport(node2, exports);
    default:
      if (this.isAsyncFunction()) {
        if (context) {
          this.unexpected();
        }
        this.next();
        return this.parseFunctionStatement(node2, true, !context);
      }
      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
        return this.parseLabeledStatement(node2, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node2, expr);
      }
  }
};
pp$8.parseBreakContinueStatement = function(node2, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node2.label = null;
  } else if (this.type !== types$1.name) {
    this.unexpected();
  } else {
    node2.label = this.parseIdent();
    this.semicolon();
  }
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node2.label == null || lab.name === node2.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) {
        break;
      }
      if (node2.label && isBreak) {
        break;
      }
    }
  }
  if (i === this.labels.length) {
    this.raise(node2.start, "Unsyntactic " + keyword);
  }
  return this.finishNode(node2, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$8.parseDebuggerStatement = function(node2) {
  this.next();
  this.semicolon();
  return this.finishNode(node2, "DebuggerStatement");
};
pp$8.parseDoStatement = function(node2) {
  this.next();
  this.labels.push(loopLabel);
  node2.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types$1._while);
  node2.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) {
    this.eat(types$1.semi);
  } else {
    this.semicolon();
  }
  return this.finishNode(node2, "DoWhileStatement");
};
pp$8.parseForStatement = function(node2) {
  this.next();
  var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types$1.parenL);
  if (this.type === types$1.semi) {
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node2, null);
  }
  var isLet = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types$1._in) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
        } else {
          node2.await = awaitAt > -1;
        }
      }
      return this.parseForIn(node2, init$1);
    }
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node2, init$1);
  }
  var startsWithLet = this.isContextual("let"), isForOf = false;
  var refDestructuringErrors = new DestructuringErrors();
  var init2 = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types$1._in) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
      } else {
        node2.await = awaitAt > -1;
      }
    }
    if (startsWithLet && isForOf) {
      this.raise(init2.start, "The left-hand side of a for-of loop may not start with 'let'.");
    }
    this.toAssignable(init2, false, refDestructuringErrors);
    this.checkLValPattern(init2);
    return this.parseForIn(node2, init2);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node2, init2);
};
pp$8.parseFunctionStatement = function(node2, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node2, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
};
pp$8.parseIfStatement = function(node2) {
  this.next();
  node2.test = this.parseParenExpression();
  node2.consequent = this.parseStatement("if");
  node2.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
  return this.finishNode(node2, "IfStatement");
};
pp$8.parseReturnStatement = function(node2) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.start, "'return' outside of function");
  }
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node2.argument = null;
  } else {
    node2.argument = this.parseExpression();
    this.semicolon();
  }
  return this.finishNode(node2, "ReturnStatement");
};
pp$8.parseSwitchStatement = function(node2) {
  this.next();
  node2.discriminant = this.parseParenExpression();
  node2.cases = [];
  this.expect(types$1.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);
  var cur;
  for (var sawDefault = false; this.type !== types$1.braceR; ) {
    if (this.type === types$1._case || this.type === types$1._default) {
      var isCase = this.type === types$1._case;
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      node2.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) {
          this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
        }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types$1.colon);
    } else {
      if (!cur) {
        this.unexpected();
      }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) {
    this.finishNode(cur, "SwitchCase");
  }
  this.next();
  this.labels.pop();
  return this.finishNode(node2, "SwitchStatement");
};
pp$8.parseThrowStatement = function(node2) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
    this.raise(this.lastTokEnd, "Illegal newline after throw");
  }
  node2.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node2, "ThrowStatement");
};
var empty$1 = [];
pp$8.parseTryStatement = function(node2) {
  this.next();
  node2.block = this.parseBlock();
  node2.handler = null;
  if (this.type === types$1._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types$1.parenL)) {
      clause.param = this.parseBindingAtom();
      var simple = clause.param.type === "Identifier";
      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
      this.expect(types$1.parenR);
    } else {
      if (this.options.ecmaVersion < 10) {
        this.unexpected();
      }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node2.handler = this.finishNode(clause, "CatchClause");
  }
  node2.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
  if (!node2.handler && !node2.finalizer) {
    this.raise(node2.start, "Missing catch or finally clause");
  }
  return this.finishNode(node2, "TryStatement");
};
pp$8.parseVarStatement = function(node2, kind) {
  this.next();
  this.parseVar(node2, false, kind);
  this.semicolon();
  return this.finishNode(node2, "VariableDeclaration");
};
pp$8.parseWhileStatement = function(node2) {
  this.next();
  node2.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node2.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node2, "WhileStatement");
};
pp$8.parseWithStatement = function(node2) {
  if (this.strict) {
    this.raise(this.start, "'with' in strict mode");
  }
  this.next();
  node2.object = this.parseParenExpression();
  node2.body = this.parseStatement("with");
  return this.finishNode(node2, "WithStatement");
};
pp$8.parseEmptyStatement = function(node2) {
  this.next();
  return this.finishNode(node2, "EmptyStatement");
};
pp$8.parseLabeledStatement = function(node2, maybeName, expr, context) {
  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1) {
    var label = list[i$1];
    if (label.name === maybeName) {
      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }
  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node2.start) {
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else {
      break;
    }
  }
  this.labels.push({ name: maybeName, kind, statementStart: this.start });
  node2.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node2.label = expr;
  return this.finishNode(node2, "LabeledStatement");
};
pp$8.parseExpressionStatement = function(node2, expr) {
  node2.expression = expr;
  this.semicolon();
  return this.finishNode(node2, "ExpressionStatement");
};
pp$8.parseBlock = function(createNewLexicalScope, node2, exitStrict) {
  if (createNewLexicalScope === void 0)
    createNewLexicalScope = true;
  if (node2 === void 0)
    node2 = this.startNode();
  node2.body = [];
  this.expect(types$1.braceL);
  if (createNewLexicalScope) {
    this.enterScope(0);
  }
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node2.body.push(stmt);
  }
  if (exitStrict) {
    this.strict = false;
  }
  this.next();
  if (createNewLexicalScope) {
    this.exitScope();
  }
  return this.finishNode(node2, "BlockStatement");
};
pp$8.parseFor = function(node2, init2) {
  node2.init = init2;
  this.expect(types$1.semi);
  node2.test = this.type === types$1.semi ? null : this.parseExpression();
  this.expect(types$1.semi);
  node2.update = this.type === types$1.parenR ? null : this.parseExpression();
  this.expect(types$1.parenR);
  node2.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node2, "ForStatement");
};
pp$8.parseForIn = function(node2, init2) {
  var isForIn = this.type === types$1._in;
  this.next();
  if (init2.type === "VariableDeclaration" && init2.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init2.kind !== "var" || init2.declarations[0].id.type !== "Identifier")) {
    this.raise(
      init2.start,
      (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
    );
  }
  node2.left = init2;
  node2.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types$1.parenR);
  node2.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node2, isForIn ? "ForInStatement" : "ForOfStatement");
};
pp$8.parseVar = function(node2, isFor, kind) {
  node2.declarations = [];
  node2.kind = kind;
  for (; ; ) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types$1.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node2.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types$1.comma)) {
      break;
    }
  }
  return node2;
};
pp$8.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};
var FUNC_STATEMENT = 1;
var FUNC_HANGING_STATEMENT = 2;
var FUNC_NULLABLE_ID = 4;
pp$8.parseFunction = function(node2, statement, allowExpressionBody, isAsync, forInit) {
  this.initFunction(node2);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
      this.unexpected();
    }
    node2.generator = this.eat(types$1.star);
  }
  if (this.options.ecmaVersion >= 8) {
    node2.async = !!isAsync;
  }
  if (statement & FUNC_STATEMENT) {
    node2.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
    if (node2.id && !(statement & FUNC_HANGING_STATEMENT)) {
      this.checkLValSimple(node2.id, this.strict || node2.generator || node2.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
    }
  }
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node2.async, node2.generator));
  if (!(statement & FUNC_STATEMENT)) {
    node2.id = this.type === types$1.name ? this.parseIdent() : null;
  }
  this.parseFunctionParams(node2);
  this.parseFunctionBody(node2, allowExpressionBody, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node2, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};
pp$8.parseFunctionParams = function(node2) {
  this.expect(types$1.parenL);
  node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};
pp$8.parseClass = function(node2, isStatement) {
  this.next();
  var oldStrict = this.strict;
  this.strict = true;
  this.parseClassId(node2, isStatement);
  this.parseClassSuper(node2);
  var privateNameMap = this.enterClassBody();
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types$1.braceL);
  while (this.type !== types$1.braceR) {
    var element = this.parseClassElement(node2.superClass !== null);
    if (element) {
      classBody.body.push(element);
      if (element.type === "MethodDefinition" && element.kind === "constructor") {
        if (hadConstructor) {
          this.raise(element.start, "Duplicate constructor in the same class");
        }
        hadConstructor = true;
      } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
        this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node2.body = this.finishNode(classBody, "ClassBody");
  this.exitClassBody();
  return this.finishNode(node2, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$8.parseClassElement = function(constructorAllowsSuper) {
  if (this.eat(types$1.semi)) {
    return null;
  }
  var ecmaVersion = this.options.ecmaVersion;
  var node2 = this.startNode();
  var keyName = "";
  var isGenerator = false;
  var isAsync = false;
  var kind = "method";
  var isStatic = false;
  if (this.eatContextual("static")) {
    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
      this.parseClassStaticBlock(node2);
      return node2;
    }
    if (this.isClassElementNameStart() || this.type === types$1.star) {
      isStatic = true;
    } else {
      keyName = "static";
    }
  }
  node2.static = isStatic;
  if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
      isAsync = true;
    } else {
      keyName = "async";
    }
  }
  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
    isGenerator = true;
  }
  if (!keyName && !isAsync && !isGenerator) {
    var lastValue = this.value;
    if (this.eatContextual("get") || this.eatContextual("set")) {
      if (this.isClassElementNameStart()) {
        kind = lastValue;
      } else {
        keyName = lastValue;
      }
    }
  }
  if (keyName) {
    node2.computed = false;
    node2.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
    node2.key.name = keyName;
    this.finishNode(node2.key, "Identifier");
  } else {
    this.parseClassElementName(node2);
  }
  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
    var isConstructor = !node2.static && checkKeyName(node2, "constructor");
    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
    if (isConstructor && kind !== "method") {
      this.raise(node2.key.start, "Constructor can't have get/set modifier");
    }
    node2.kind = isConstructor ? "constructor" : kind;
    this.parseClassMethod(node2, isGenerator, isAsync, allowsDirectSuper);
  } else {
    this.parseClassField(node2);
  }
  return node2;
};
pp$8.isClassElementNameStart = function() {
  return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
};
pp$8.parseClassElementName = function(element) {
  if (this.type === types$1.privateId) {
    if (this.value === "constructor") {
      this.raise(this.start, "Classes can't have an element named '#constructor'");
    }
    element.computed = false;
    element.key = this.parsePrivateIdent();
  } else {
    this.parsePropertyName(element);
  }
};
pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  var key2 = method.key;
  if (method.kind === "constructor") {
    if (isGenerator) {
      this.raise(key2.start, "Constructor can't be a generator");
    }
    if (isAsync) {
      this.raise(key2.start, "Constructor can't be an async method");
    }
  } else if (method.static && checkKeyName(method, "prototype")) {
    this.raise(key2.start, "Classes may not have a static property named prototype");
  }
  var value2 = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === "get" && value2.params.length !== 0) {
    this.raiseRecoverable(value2.start, "getter should have no params");
  }
  if (method.kind === "set" && value2.params.length !== 1) {
    this.raiseRecoverable(value2.start, "setter should have exactly one param");
  }
  if (method.kind === "set" && value2.params[0].type === "RestElement") {
    this.raiseRecoverable(value2.params[0].start, "Setter cannot use rest params");
  }
  return this.finishNode(method, "MethodDefinition");
};
pp$8.parseClassField = function(field) {
  if (checkKeyName(field, "constructor")) {
    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
  } else if (field.static && checkKeyName(field, "prototype")) {
    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
  }
  if (this.eat(types$1.eq)) {
    var scope = this.currentThisScope();
    var inClassFieldInit = scope.inClassFieldInit;
    scope.inClassFieldInit = true;
    field.value = this.parseMaybeAssign();
    scope.inClassFieldInit = inClassFieldInit;
  } else {
    field.value = null;
  }
  this.semicolon();
  return this.finishNode(field, "PropertyDefinition");
};
pp$8.parseClassStaticBlock = function(node2) {
  node2.body = [];
  var oldLabels = this.labels;
  this.labels = [];
  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node2.body.push(stmt);
  }
  this.next();
  this.exitScope();
  this.labels = oldLabels;
  return this.finishNode(node2, "StaticBlock");
};
pp$8.parseClassId = function(node2, isStatement) {
  if (this.type === types$1.name) {
    node2.id = this.parseIdent();
    if (isStatement) {
      this.checkLValSimple(node2.id, BIND_LEXICAL, false);
    }
  } else {
    if (isStatement === true) {
      this.unexpected();
    }
    node2.id = null;
  }
};
pp$8.parseClassSuper = function(node2) {
  node2.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(false) : null;
};
pp$8.enterClassBody = function() {
  var element = { declared: /* @__PURE__ */ Object.create(null), used: [] };
  this.privateNameStack.push(element);
  return element.declared;
};
pp$8.exitClassBody = function() {
  var ref2 = this.privateNameStack.pop();
  var declared = ref2.declared;
  var used = ref2.used;
  var len = this.privateNameStack.length;
  var parent = len === 0 ? null : this.privateNameStack[len - 1];
  for (var i = 0; i < used.length; ++i) {
    var id = used[i];
    if (!hasOwn(declared, id.name)) {
      if (parent) {
        parent.used.push(id);
      } else {
        this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
      }
    }
  }
};
function isPrivateNameConflicted(privateNameMap, element) {
  var name = element.key.name;
  var curr = privateNameMap[name];
  var next = "true";
  if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
    next = (element.static ? "s" : "i") + element.kind;
  }
  if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
    privateNameMap[name] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name] = next;
    return false;
  } else {
    return true;
  }
}
function checkKeyName(node2, name) {
  var computed = node2.computed;
  var key2 = node2.key;
  return !computed && (key2.type === "Identifier" && key2.name === name || key2.type === "Literal" && key2.value === name);
}
pp$8.parseExport = function(node2, exports) {
  this.next();
  if (this.eat(types$1.star)) {
    if (this.options.ecmaVersion >= 11) {
      if (this.eatContextual("as")) {
        node2.exported = this.parseModuleExportName();
        this.checkExport(exports, node2.exported, this.lastTokStart);
      } else {
        node2.exported = null;
      }
    }
    this.expectContextual("from");
    if (this.type !== types$1.string) {
      this.unexpected();
    }
    node2.source = this.parseExprAtom();
    this.semicolon();
    return this.finishNode(node2, "ExportAllDeclaration");
  }
  if (this.eat(types$1._default)) {
    this.checkExport(exports, "default", this.lastTokStart);
    var isAsync;
    if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();
      if (isAsync) {
        this.next();
      }
      node2.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
    } else if (this.type === types$1._class) {
      var cNode = this.startNode();
      node2.declaration = this.parseClass(cNode, "nullableID");
    } else {
      node2.declaration = this.parseMaybeAssign();
      this.semicolon();
    }
    return this.finishNode(node2, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
    node2.declaration = this.parseStatement(null);
    if (node2.declaration.type === "VariableDeclaration") {
      this.checkVariableExport(exports, node2.declaration.declarations);
    } else {
      this.checkExport(exports, node2.declaration.id, node2.declaration.id.start);
    }
    node2.specifiers = [];
    node2.source = null;
  } else {
    node2.declaration = null;
    node2.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types$1.string) {
        this.unexpected();
      }
      node2.source = this.parseExprAtom();
    } else {
      for (var i = 0, list = node2.specifiers; i < list.length; i += 1) {
        var spec = list[i];
        this.checkUnreserved(spec.local);
        this.checkLocalExport(spec.local);
        if (spec.local.type === "Literal") {
          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
      }
      node2.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node2, "ExportNamedDeclaration");
};
pp$8.checkExport = function(exports, name, pos2) {
  if (!exports) {
    return;
  }
  if (typeof name !== "string") {
    name = name.type === "Identifier" ? name.name : name.value;
  }
  if (hasOwn(exports, name)) {
    this.raiseRecoverable(pos2, "Duplicate export '" + name + "'");
  }
  exports[name] = true;
};
pp$8.checkPatternExport = function(exports, pat) {
  var type = pat.type;
  if (type === "Identifier") {
    this.checkExport(exports, pat, pat.start);
  } else if (type === "ObjectPattern") {
    for (var i = 0, list = pat.properties; i < list.length; i += 1) {
      var prop = list[i];
      this.checkPatternExport(exports, prop);
    }
  } else if (type === "ArrayPattern") {
    for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];
      if (elt) {
        this.checkPatternExport(exports, elt);
      }
    }
  } else if (type === "Property") {
    this.checkPatternExport(exports, pat.value);
  } else if (type === "AssignmentPattern") {
    this.checkPatternExport(exports, pat.left);
  } else if (type === "RestElement") {
    this.checkPatternExport(exports, pat.argument);
  } else if (type === "ParenthesizedExpression") {
    this.checkPatternExport(exports, pat.expression);
  }
};
pp$8.checkVariableExport = function(exports, decls) {
  if (!exports) {
    return;
  }
  for (var i = 0, list = decls; i < list.length; i += 1) {
    var decl = list[i];
    this.checkPatternExport(exports, decl.id);
  }
};
pp$8.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$8.parseExportSpecifiers = function(exports) {
  var nodes = [], first2 = true;
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first2) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first2 = false;
    }
    var node2 = this.startNode();
    node2.local = this.parseModuleExportName();
    node2.exported = this.eatContextual("as") ? this.parseModuleExportName() : node2.local;
    this.checkExport(
      exports,
      node2.exported,
      node2.exported.start
    );
    nodes.push(this.finishNode(node2, "ExportSpecifier"));
  }
  return nodes;
};
pp$8.parseImport = function(node2) {
  this.next();
  if (this.type === types$1.string) {
    node2.specifiers = empty$1;
    node2.source = this.parseExprAtom();
  } else {
    node2.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node2.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node2, "ImportDeclaration");
};
pp$8.parseImportSpecifiers = function() {
  var nodes = [], first2 = true;
  if (this.type === types$1.name) {
    var node2 = this.startNode();
    node2.local = this.parseIdent();
    this.checkLValSimple(node2.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node2, "ImportDefaultSpecifier"));
    if (!this.eat(types$1.comma)) {
      return nodes;
    }
  }
  if (this.type === types$1.star) {
    var node$12 = this.startNode();
    this.next();
    this.expectContextual("as");
    node$12.local = this.parseIdent();
    this.checkLValSimple(node$12.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$12, "ImportNamespaceSpecifier"));
    return nodes;
  }
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first2) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first2 = false;
    }
    var node$2 = this.startNode();
    node$2.imported = this.parseModuleExportName();
    if (this.eatContextual("as")) {
      node$2.local = this.parseIdent();
    } else {
      this.checkUnreserved(node$2.imported);
      node$2.local = node$2.imported;
    }
    this.checkLValSimple(node$2.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$2, "ImportSpecifier"));
  }
  return nodes;
};
pp$8.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
    var stringLiteral = this.parseLiteral(this.value);
    if (loneSurrogate.test(stringLiteral.value)) {
      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
    }
    return stringLiteral;
  }
  return this.parseIdent(true);
};
pp$8.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$8.isDirectiveCandidate = function(statement) {
  return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === '"' || this.input[statement.start] === "'");
};
var pp$7 = Parser.prototype;
pp$7.toAssignable = function(node2, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node2) {
    switch (node2.type) {
      case "Identifier":
        if (this.inAsync && node2.name === "await") {
          this.raise(node2.start, "Cannot use 'await' as identifier inside an async function");
        }
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        node2.type = "ObjectPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        for (var i = 0, list = node2.properties; i < list.length; i += 1) {
          var prop = list[i];
          this.toAssignable(prop, isBinding);
          if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
            this.raise(prop.argument.start, "Unexpected token");
          }
        }
        break;
      case "Property":
        if (node2.kind !== "init") {
          this.raise(node2.key.start, "Object pattern can't contain getter or setter");
        }
        this.toAssignable(node2.value, isBinding);
        break;
      case "ArrayExpression":
        node2.type = "ArrayPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        this.toAssignableList(node2.elements, isBinding);
        break;
      case "SpreadElement":
        node2.type = "RestElement";
        this.toAssignable(node2.argument, isBinding);
        if (node2.argument.type === "AssignmentPattern") {
          this.raise(node2.argument.start, "Rest elements cannot have a default value");
        }
        break;
      case "AssignmentExpression":
        if (node2.operator !== "=") {
          this.raise(node2.left.end, "Only '=' operator can be used for specifying default value.");
        }
        node2.type = "AssignmentPattern";
        delete node2.operator;
        this.toAssignable(node2.left, isBinding);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(node2.expression, isBinding, refDestructuringErrors);
        break;
      case "ChainExpression":
        this.raiseRecoverable(node2.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!isBinding) {
          break;
        }
      default:
        this.raise(node2.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) {
    this.checkPatternErrors(refDestructuringErrors, true);
  }
  return node2;
};
pp$7.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) {
      this.toAssignable(elt, isBinding);
    }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
      this.unexpected(last.argument.start);
    }
  }
  return exprList;
};
pp$7.parseSpread = function(refDestructuringErrors) {
  var node2 = this.startNode();
  this.next();
  node2.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node2, "SpreadElement");
};
pp$7.parseRestBinding = function() {
  var node2 = this.startNode();
  this.next();
  if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
    this.unexpected();
  }
  node2.argument = this.parseBindingAtom();
  return this.finishNode(node2, "RestElement");
};
pp$7.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
      case types$1.bracketL:
        var node2 = this.startNode();
        this.next();
        node2.elements = this.parseBindingList(types$1.bracketR, true, true);
        return this.finishNode(node2, "ArrayPattern");
      case types$1.braceL:
        return this.parseObj(true);
    }
  }
  return this.parseIdent();
};
pp$7.parseBindingList = function(close2, allowEmpty, allowTrailingComma) {
  var elts = [], first2 = true;
  while (!this.eat(close2)) {
    if (first2) {
      first2 = false;
    } else {
      this.expect(types$1.comma);
    }
    if (allowEmpty && this.type === types$1.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close2)) {
      break;
    } else if (this.type === types$1.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types$1.comma) {
        this.raise(this.start, "Comma is not permitted after the rest element");
      }
      this.expect(close2);
      break;
    } else {
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts;
};
pp$7.parseBindingListItem = function(param) {
  return param;
};
pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
    return left;
  }
  var node2 = this.startNodeAt(startPos, startLoc);
  node2.left = left;
  node2.right = this.parseMaybeAssign();
  return this.finishNode(node2, "AssignmentPattern");
};
pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  var isBind = bindingType !== BIND_NONE;
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
        this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      }
      if (isBind) {
        if (bindingType === BIND_LEXICAL && expr.name === "let") {
          this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
        }
        if (checkClashes) {
          if (hasOwn(checkClashes, expr.name)) {
            this.raiseRecoverable(expr.start, "Argument name clash");
          }
          checkClashes[expr.name] = true;
        }
        if (bindingType !== BIND_OUTSIDE) {
          this.declareName(expr.name, bindingType, expr.start);
        }
      }
      break;
    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding member expression");
      }
      break;
    case "ParenthesizedExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding parenthesized expression");
      }
      return this.checkLValSimple(expr.expression, bindingType, checkClashes);
    default:
      this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
  }
};
pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  switch (expr.type) {
    case "ObjectPattern":
      for (var i = 0, list = expr.properties; i < list.length; i += 1) {
        var prop = list[i];
        this.checkLValInnerPattern(prop, bindingType, checkClashes);
      }
      break;
    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];
        if (elem) {
          this.checkLValInnerPattern(elem, bindingType, checkClashes);
        }
      }
      break;
    default:
      this.checkLValSimple(expr, bindingType, checkClashes);
  }
};
pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  switch (expr.type) {
    case "Property":
      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(expr.left, bindingType, checkClashes);
      break;
    case "RestElement":
      this.checkLValPattern(expr.argument, bindingType, checkClashes);
      break;
    default:
      this.checkLValPattern(expr, bindingType, checkClashes);
  }
};
var TokContext = function TokContext2(token2, isExpr, preserveSpace, override, generator) {
  this.token = token2;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};
var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function(p) {
    return p.tryReadTemplateToken();
  }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};
var pp$6 = Parser.prototype;
pp$6.initialContext = function() {
  return [types.b_stat];
};
pp$6.curContext = function() {
  return this.context[this.context.length - 1];
};
pp$6.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types.f_expr || parent === types.f_stat) {
    return true;
  }
  if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
    return !parent.isExpr;
  }
  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }
  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
    return true;
  }
  if (prevType === types$1.braceL) {
    return parent === types.b_stat;
  }
  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
    return false;
  }
  return !this.exprAllowed;
};
pp$6.inGeneratorContext = function() {
  for (var i = this.context.length - 1; i >= 1; i--) {
    var context = this.context[i];
    if (context.token === "function") {
      return context.generator;
    }
  }
  return false;
};
pp$6.updateContext = function(prevType) {
  var update, type = this.type;
  if (type.keyword && prevType === types$1.dot) {
    this.exprAllowed = false;
  } else if (update = type.updateContext) {
    update.call(this, prevType);
  } else {
    this.exprAllowed = type.beforeExpr;
  }
};
pp$6.overrideContext = function(tokenCtx) {
  if (this.curContext() !== tokenCtx) {
    this.context[this.context.length - 1] = tokenCtx;
  }
};
types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return;
  }
  var out2 = this.context.pop();
  if (out2 === types.b_stat && this.curContext().token === "function") {
    out2 = this.context.pop();
  }
  this.exprAllowed = !out2.isExpr;
};
types$1.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};
types$1.dollarBraceL.updateContext = function() {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};
types$1.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};
types$1.incDec.updateContext = function() {
};
types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
    this.context.push(types.f_expr);
  } else {
    this.context.push(types.f_stat);
  }
  this.exprAllowed = false;
};
types$1.backQuote.updateContext = function() {
  if (this.curContext() === types.q_tmpl) {
    this.context.pop();
  } else {
    this.context.push(types.q_tmpl);
  }
  this.exprAllowed = false;
};
types$1.star.updateContext = function(prevType) {
  if (prevType === types$1._function) {
    var index2 = this.context.length - 1;
    if (this.context[index2] === types.f_expr) {
      this.context[index2] = types.f_expr_gen;
    } else {
      this.context[index2] = types.f_gen;
    }
  }
  this.exprAllowed = true;
};
types$1.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
    if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
      allowed = true;
    }
  }
  this.exprAllowed = allowed;
};
var pp$5 = Parser.prototype;
pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
    return;
  }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
    return;
  }
  var key2 = prop.key;
  var name;
  switch (key2.type) {
    case "Identifier":
      name = key2.name;
      break;
    case "Literal":
      name = String(key2.value);
      break;
    default:
      return;
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key2.start;
          }
        } else {
          this.raiseRecoverable(key2.start, "Redefinition of __proto__ property");
        }
      }
      propHash.proto = true;
    }
    return;
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition) {
      this.raiseRecoverable(key2.start, "Redefinition of property");
    }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};
pp$5.parseExpression = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
  if (this.type === types$1.comma) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.expressions = [expr];
    while (this.eat(types$1.comma)) {
      node2.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
    }
    return this.finishNode(node2, "SequenceExpression");
  }
  return expr;
};
pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) {
      return this.parseYield(forInit);
    } else {
      this.exprAllowed = false;
    }
  }
  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldDoubleProto = refDestructuringErrors.doubleProto;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors();
    ownDestructuringErrors = true;
  }
  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types$1.parenL || this.type === types$1.name) {
    this.potentialArrowAt = this.start;
    this.potentialArrowInForAwait = forInit === "await";
  }
  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
  if (afterLeftParse) {
    left = afterLeftParse.call(this, left, startPos, startLoc);
  }
  if (this.type.isAssign) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.operator = this.value;
    if (this.type === types$1.eq) {
      left = this.toAssignable(left, false, refDestructuringErrors);
    }
    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }
    if (refDestructuringErrors.shorthandAssign >= left.start) {
      refDestructuringErrors.shorthandAssign = -1;
    }
    if (this.type === types$1.eq) {
      this.checkLValPattern(left);
    } else {
      this.checkLValSimple(left);
    }
    node2.left = left;
    this.next();
    node2.right = this.parseMaybeAssign(forInit);
    if (oldDoubleProto > -1) {
      refDestructuringErrors.doubleProto = oldDoubleProto;
    }
    return this.finishNode(node2, "AssignmentExpression");
  } else {
    if (ownDestructuringErrors) {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
  }
  if (oldParenAssign > -1) {
    refDestructuringErrors.parenthesizedAssign = oldParenAssign;
  }
  if (oldTrailingComma > -1) {
    refDestructuringErrors.trailingComma = oldTrailingComma;
  }
  return left;
};
pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(forInit, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  if (this.eat(types$1.question)) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.test = expr;
    node2.consequent = this.parseMaybeAssign();
    this.expect(types$1.colon);
    node2.alternate = this.parseMaybeAssign(forInit);
    return this.finishNode(node2, "ConditionalExpression");
  }
  return expr;
};
pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
};
pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
  var prec = this.type.binop;
  if (prec != null && (!forInit || this.type !== types$1._in)) {
    if (prec > minPrec) {
      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
      var coalesce = this.type === types$1.coalesce;
      if (coalesce) {
        prec = types$1.logicalAND.binop;
      }
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
      var node2 = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
      if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }
      return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec, forInit);
    }
  }
  return left;
};
pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  if (right.type === "PrivateIdentifier") {
    this.raise(right.start, "Private identifier can only be left side of binary expression");
  }
  var node2 = this.startNodeAt(startPos, startLoc);
  node2.left = left;
  node2.operator = op;
  node2.right = right;
  return this.finishNode(node2, logical ? "LogicalExpression" : "BinaryExpression");
};
pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && this.canAwait) {
    expr = this.parseAwait(forInit);
    sawUnary = true;
  } else if (this.type.prefix) {
    var node2 = this.startNode(), update = this.type === types$1.incDec;
    node2.operator = this.value;
    node2.prefix = true;
    this.next();
    node2.argument = this.parseMaybeUnary(null, true, update, forInit);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) {
      this.checkLValSimple(node2.argument);
    } else if (this.strict && node2.operator === "delete" && node2.argument.type === "Identifier") {
      this.raiseRecoverable(node2.start, "Deleting local variable in strict mode");
    } else if (node2.operator === "delete" && isPrivateFieldAccess(node2.argument)) {
      this.raiseRecoverable(node2.start, "Private fields can not be deleted");
    } else {
      sawUnary = true;
    }
    expr = this.finishNode(node2, update ? "UpdateExpression" : "UnaryExpression");
  } else if (!sawUnary && this.type === types$1.privateId) {
    if (forInit || this.privateNameStack.length === 0) {
      this.unexpected();
    }
    expr = this.parsePrivateIdent();
    if (this.type !== types$1._in) {
      this.unexpected();
    }
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$12 = this.startNodeAt(startPos, startLoc);
      node$12.operator = this.value;
      node$12.prefix = false;
      node$12.argument = expr;
      this.checkLValSimple(expr);
      this.next();
      expr = this.finishNode(node$12, "UpdateExpression");
    }
  }
  if (!incDec && this.eat(types$1.starstar)) {
    if (sawUnary) {
      this.unexpected(this.lastTokStart);
    } else {
      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
    }
  } else {
    return expr;
  }
};
function isPrivateFieldAccess(node2) {
  return node2.type === "MemberExpression" && node2.property.type === "PrivateIdentifier" || node2.type === "ChainExpression" && isPrivateFieldAccess(node2.expression);
}
pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
    return expr;
  }
  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) {
      refDestructuringErrors.parenthesizedAssign = -1;
    }
    if (refDestructuringErrors.parenthesizedBind >= result.start) {
      refDestructuringErrors.parenthesizedBind = -1;
    }
    if (refDestructuringErrors.trailingComma >= result.start) {
      refDestructuringErrors.trailingComma = -1;
    }
  }
  return result;
};
pp$5.parseSubscripts = function(base2, startPos, startLoc, noCalls, forInit) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base2.type === "Identifier" && base2.name === "async" && this.lastTokEnd === base2.end && !this.canInsertSemicolon() && base2.end - base2.start === 5 && this.potentialArrowAt === base2.start;
  var optionalChained = false;
  while (true) {
    var element = this.parseSubscript(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
    if (element.optional) {
      optionalChained = true;
    }
    if (element === base2 || element.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element;
        element = this.finishNode(chainNode, "ChainExpression");
      }
      return element;
    }
    base2 = element;
  }
};
pp$5.parseSubscript = function(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional = optionalSupported && this.eat(types$1.questionDot);
  if (noCalls && optional) {
    this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  }
  var computed = this.eat(types$1.bracketL);
  if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.object = base2;
    if (computed) {
      node2.property = this.parseExpression();
      this.expect(types$1.bracketR);
    } else if (this.type === types$1.privateId && base2.type !== "Super") {
      node2.property = this.parsePrivateIdent();
    } else {
      node2.property = this.parseIdent(this.options.allowReserved !== "never");
    }
    node2.computed = !!computed;
    if (optionalSupported) {
      node2.optional = optional;
    }
    base2 = this.finishNode(node2, "MemberExpression");
  } else if (!noCalls && this.eat(types$1.parenL)) {
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0) {
        this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
      }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$12 = this.startNodeAt(startPos, startLoc);
    node$12.callee = base2;
    node$12.arguments = exprList;
    if (optionalSupported) {
      node$12.optional = optional;
    }
    base2 = this.finishNode(node$12, "CallExpression");
  } else if (this.type === types$1.backQuote) {
    if (optional || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base2;
    node$2.quasi = this.parseTemplate({ isTagged: true });
    base2 = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base2;
};
pp$5.parseExprAtom = function(refDestructuringErrors, forInit) {
  if (this.type === types$1.slash) {
    this.readRegexp();
  }
  var node2, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
    case types$1._super:
      if (!this.allowSuper) {
        this.raise(this.start, "'super' keyword outside a method");
      }
      node2 = this.startNode();
      this.next();
      if (this.type === types$1.parenL && !this.allowDirectSuper) {
        this.raise(node2.start, "super() call outside constructor of a subclass");
      }
      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
        this.unexpected();
      }
      return this.finishNode(node2, "Super");
    case types$1._this:
      node2 = this.startNode();
      this.next();
      return this.finishNode(node2, "ThisExpression");
    case types$1.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
        this.overrideContext(types.f_expr);
        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
      }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types$1.arrow)) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
        }
        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
          id = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
            this.unexpected();
          }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
        }
      }
      return id;
    case types$1.regexp:
      var value2 = this.value;
      node2 = this.parseLiteral(value2.value);
      node2.regex = { pattern: value2.pattern, flags: value2.flags };
      return node2;
    case types$1.num:
    case types$1.string:
      return this.parseLiteral(this.value);
    case types$1._null:
    case types$1._true:
    case types$1._false:
      node2 = this.startNode();
      node2.value = this.type === types$1._null ? null : this.type === types$1._true;
      node2.raw = this.type.keyword;
      this.next();
      return this.finishNode(node2, "Literal");
    case types$1.parenL:
      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
          refDestructuringErrors.parenthesizedAssign = start;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = start;
        }
      }
      return expr;
    case types$1.bracketL:
      node2 = this.startNode();
      this.next();
      node2.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node2, "ArrayExpression");
    case types$1.braceL:
      this.overrideContext(types.b_expr);
      return this.parseObj(false, refDestructuringErrors);
    case types$1._function:
      node2 = this.startNode();
      this.next();
      return this.parseFunction(node2, 0);
    case types$1._class:
      return this.parseClass(this.startNode(), false);
    case types$1._new:
      return this.parseNew();
    case types$1.backQuote:
      return this.parseTemplate();
    case types$1._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport();
      } else {
        return this.unexpected();
      }
    default:
      this.unexpected();
  }
};
pp$5.parseExprImport = function() {
  var node2 = this.startNode();
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword import");
  }
  var meta = this.parseIdent(true);
  switch (this.type) {
    case types$1.parenL:
      return this.parseDynamicImport(node2);
    case types$1.dot:
      node2.meta = meta;
      return this.parseImportMeta(node2);
    default:
      this.unexpected();
  }
};
pp$5.parseDynamicImport = function(node2) {
  this.next();
  node2.source = this.parseMaybeAssign();
  if (!this.eat(types$1.parenR)) {
    var errorPos = this.start;
    if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
      this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
    } else {
      this.unexpected(errorPos);
    }
  }
  return this.finishNode(node2, "ImportExpression");
};
pp$5.parseImportMeta = function(node2) {
  this.next();
  var containsEsc = this.containsEsc;
  node2.property = this.parseIdent(true);
  if (node2.property.name !== "meta") {
    this.raiseRecoverable(node2.property.start, "The only valid meta property for import is 'import.meta'");
  }
  if (containsEsc) {
    this.raiseRecoverable(node2.start, "'import.meta' must not contain escaped characters");
  }
  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
    this.raiseRecoverable(node2.start, "Cannot use 'import.meta' outside a module");
  }
  return this.finishNode(node2, "MetaProperty");
};
pp$5.parseLiteral = function(value2) {
  var node2 = this.startNode();
  node2.value = value2;
  node2.raw = this.input.slice(this.start, this.end);
  if (node2.raw.charCodeAt(node2.raw.length - 1) === 110) {
    node2.bigint = node2.raw.slice(0, -1).replace(/_/g, "");
  }
  this.next();
  return this.finishNode(node2, "Literal");
};
pp$5.parseParenExpression = function() {
  this.expect(types$1.parenL);
  var val = this.parseExpression();
  this.expect(types$1.parenR);
  return val;
};
pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first2 = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    while (this.type !== types$1.parenR) {
      first2 ? first2 = false : this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
        lastIsComma = true;
        break;
      } else if (this.type === types$1.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types$1.comma) {
          this.raise(this.start, "Comma is not permitted after the rest element");
        }
        break;
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
    this.expect(types$1.parenR);
    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
    }
    if (!exprList.length || lastIsComma) {
      this.unexpected(this.lastTokStart);
    }
    if (spreadStart) {
      this.unexpected(spreadStart);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }
  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};
pp$5.parseParenItem = function(item) {
  return item;
};
pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
};
var empty = [];
pp$5.parseNew = function() {
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  }
  var node2 = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
    node2.meta = meta;
    var containsEsc = this.containsEsc;
    node2.property = this.parseIdent(true);
    if (node2.property.name !== "target") {
      this.raiseRecoverable(node2.property.start, "The only valid meta property for new is 'new.target'");
    }
    if (containsEsc) {
      this.raiseRecoverable(node2.start, "'new.target' must not contain escaped characters");
    }
    if (!this.allowNewDotTarget) {
      this.raiseRecoverable(node2.start, "'new.target' can only be used in functions and class static block");
    }
    return this.finishNode(node2, "MetaProperty");
  }
  var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types$1._import;
  node2.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
  if (isImport && node2.callee.type === "ImportExpression") {
    this.raise(startPos, "Cannot use new with import()");
  }
  if (this.eat(types$1.parenL)) {
    node2.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
  } else {
    node2.arguments = empty;
  }
  return this.finishNode(node2, "NewExpression");
};
pp$5.parseTemplateElement = function(ref2) {
  var isTagged = ref2.isTagged;
  var elem = this.startNode();
  if (this.type === types$1.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types$1.backQuote;
  return this.finishNode(elem, "TemplateElement");
};
pp$5.parseTemplate = function(ref2) {
  if (ref2 === void 0)
    ref2 = {};
  var isTagged = ref2.isTagged;
  if (isTagged === void 0)
    isTagged = false;
  var node2 = this.startNode();
  this.next();
  node2.expressions = [];
  var curElt = this.parseTemplateElement({ isTagged });
  node2.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types$1.eof) {
      this.raise(this.pos, "Unterminated template literal");
    }
    this.expect(types$1.dollarBraceL);
    node2.expressions.push(this.parseExpression());
    this.expect(types$1.braceR);
    node2.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
  }
  this.next();
  return this.finishNode(node2, "TemplateLiteral");
};
pp$5.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$5.parseObj = function(isPattern, refDestructuringErrors) {
  var node2 = this.startNode(), first2 = true, propHash = {};
  node2.properties = [];
  this.next();
  while (!this.eat(types$1.braceR)) {
    if (!first2) {
      this.expect(types$1.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first2 = false;
    }
    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) {
      this.checkPropClash(prop, propHash, refDestructuringErrors);
    }
    node2.properties.push(prop);
  }
  return this.finishNode(node2, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types$1.comma) {
        this.raise(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop, "RestElement");
    }
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    return this.finishNode(prop, "SpreadElement");
  }
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern) {
      isGenerator = this.eat(types$1.star);
    }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
    this.parsePropertyName(prop, refDestructuringErrors);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property");
};
pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types$1.colon) {
    this.unexpected();
  }
  if (this.eat(types$1.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
    if (isPattern) {
      this.unexpected();
    }
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === "get") {
        this.raiseRecoverable(start, "getter should have no params");
      } else {
        this.raiseRecoverable(start, "setter should have exactly one param");
      }
    } else {
      if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
        this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
      }
    }
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.checkUnreserved(prop.key);
    if (prop.key.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = startPos;
    }
    prop.kind = "init";
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else if (this.type === types$1.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0) {
        refDestructuringErrors.shorthandAssign = this.start;
      }
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else {
      prop.value = this.copyNode(prop.key);
    }
    prop.shorthand = true;
  } else {
    this.unexpected();
  }
};
pp$5.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types$1.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types$1.bracketR);
      return prop.key;
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
pp$5.initFunction = function(node2) {
  node2.id = null;
  if (this.options.ecmaVersion >= 6) {
    node2.generator = node2.expression = false;
  }
  if (this.options.ecmaVersion >= 8) {
    node2.async = false;
  }
};
pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node2 = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.initFunction(node2);
  if (this.options.ecmaVersion >= 6) {
    node2.generator = isGenerator;
  }
  if (this.options.ecmaVersion >= 8) {
    node2.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node2.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
  this.expect(types$1.parenL);
  node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node2, false, true, false);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node2, "FunctionExpression");
};
pp$5.parseArrowExpression = function(node2, params, isAsync, forInit) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node2);
  if (this.options.ecmaVersion >= 8) {
    node2.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  node2.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node2, true, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node2, "ArrowFunctionExpression");
};
pp$5.parseFunctionBody = function(node2, isArrowFunction, isMethod, forInit) {
  var isExpression = isArrowFunction && this.type !== types$1.braceL;
  var oldStrict = this.strict, useStrict = false;
  if (isExpression) {
    node2.body = this.parseMaybeAssign(forInit);
    node2.expression = true;
    this.checkParams(node2, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node2.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      if (useStrict && nonSimple) {
        this.raiseRecoverable(node2.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      }
    }
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) {
      this.strict = true;
    }
    this.checkParams(node2, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node2.params));
    if (this.strict && node2.id) {
      this.checkLValSimple(node2.id, BIND_OUTSIDE);
    }
    node2.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
    node2.expression = false;
    this.adaptDirectivePrologue(node2.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();
};
pp$5.isSimpleParamList = function(params) {
  for (var i = 0, list = params; i < list.length; i += 1) {
    var param = list[i];
    if (param.type !== "Identifier") {
      return false;
    }
  }
  return true;
};
pp$5.checkParams = function(node2, allowDuplicates) {
  var nameHash = /* @__PURE__ */ Object.create(null);
  for (var i = 0, list = node2.params; i < list.length; i += 1) {
    var param = list[i];
    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};
pp$5.parseExprList = function(close2, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first2 = true;
  while (!this.eat(close2)) {
    if (!first2) {
      this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(close2)) {
        break;
      }
    } else {
      first2 = false;
    }
    var elt = void 0;
    if (allowEmpty && this.type === types$1.comma) {
      elt = null;
    } else if (this.type === types$1.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts;
};
pp$5.checkUnreserved = function(ref2) {
  var start = ref2.start;
  var end = ref2.end;
  var name = ref2.name;
  if (this.inGenerator && name === "yield") {
    this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
  }
  if (this.inAsync && name === "await") {
    this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
  }
  if (this.currentThisScope().inClassFieldInit && name === "arguments") {
    this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
  }
  if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
    this.raise(start, "Cannot use " + name + " in class static initialization block");
  }
  if (this.keywords.test(name)) {
    this.raise(start, "Unexpected keyword '" + name + "'");
  }
  if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
    return;
  }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
    if (!this.inAsync && name === "await") {
      this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
    }
    this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
  }
};
pp$5.parseIdent = function(liberal, isBinding) {
  var node2 = this.startNode();
  if (this.type === types$1.name) {
    node2.name = this.value;
  } else if (this.type.keyword) {
    node2.name = this.type.keyword;
    if ((node2.name === "class" || node2.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }
  this.next(!!liberal);
  this.finishNode(node2, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node2);
    if (node2.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = node2.start;
    }
  }
  return node2;
};
pp$5.parsePrivateIdent = function() {
  var node2 = this.startNode();
  if (this.type === types$1.privateId) {
    node2.name = this.value;
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node2, "PrivateIdentifier");
  if (this.privateNameStack.length === 0) {
    this.raise(node2.start, "Private field '#" + node2.name + "' must be declared in an enclosing class");
  } else {
    this.privateNameStack[this.privateNameStack.length - 1].used.push(node2);
  }
  return node2;
};
pp$5.parseYield = function(forInit) {
  if (!this.yieldPos) {
    this.yieldPos = this.start;
  }
  var node2 = this.startNode();
  this.next();
  if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
    node2.delegate = false;
    node2.argument = null;
  } else {
    node2.delegate = this.eat(types$1.star);
    node2.argument = this.parseMaybeAssign(forInit);
  }
  return this.finishNode(node2, "YieldExpression");
};
pp$5.parseAwait = function(forInit) {
  if (!this.awaitPos) {
    this.awaitPos = this.start;
  }
  var node2 = this.startNode();
  this.next();
  node2.argument = this.parseMaybeUnary(null, true, false, forInit);
  return this.finishNode(node2, "AwaitExpression");
};
var pp$4 = Parser.prototype;
pp$4.raise = function(pos2, message) {
  var loc = getLineInfo(this.input, pos2);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos2;
  err.loc = loc;
  err.raisedAt = this.pos;
  throw err;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart);
  }
};
var pp$3 = Parser.prototype;
var Scope = function Scope2(flags) {
  this.flags = flags;
  this.var = [];
  this.lexical = [];
  this.functions = [];
  this.inClassFieldInit = false;
};
pp$3.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};
pp$3.exitScope = function() {
  this.scopeStack.pop();
};
pp$3.treatFunctionsAsVarInScope = function(scope) {
  return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
};
pp$3.declareName = function(name, bindingType, pos2) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
    scope.lexical.push(name);
    if (this.inModule && scope.flags & SCOPE_TOP) {
      delete this.undefinedExports[name];
    }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar) {
      redeclared = scope$2.lexical.indexOf(name) > -1;
    } else {
      redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
    }
    scope$2.functions.push(name);
  } else {
    for (var i = this.scopeStack.length - 1; i >= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
        redeclared = true;
        break;
      }
      scope$3.var.push(name);
      if (this.inModule && scope$3.flags & SCOPE_TOP) {
        delete this.undefinedExports[name];
      }
      if (scope$3.flags & SCOPE_VAR) {
        break;
      }
    }
  }
  if (redeclared) {
    this.raiseRecoverable(pos2, "Identifier '" + name + "' has already been declared");
  }
};
pp$3.checkLocalExport = function(id) {
  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
    this.undefinedExports[id.name] = id;
  }
};
pp$3.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
pp$3.currentVarScope = function() {
  for (var i = this.scopeStack.length - 1; ; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR) {
      return scope;
    }
  }
};
pp$3.currentThisScope = function() {
  for (var i = this.scopeStack.length - 1; ; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
      return scope;
    }
  }
};
var Node = function Node2(parser2, pos2, loc) {
  this.type = "";
  this.start = pos2;
  this.end = 0;
  if (parser2.options.locations) {
    this.loc = new SourceLocation(parser2, loc);
  }
  if (parser2.options.directSourceFile) {
    this.sourceFile = parser2.options.directSourceFile;
  }
  if (parser2.options.ranges) {
    this.range = [pos2, 0];
  }
};
var pp$2 = Parser.prototype;
pp$2.startNode = function() {
  return new Node(this, this.start, this.startLoc);
};
pp$2.startNodeAt = function(pos2, loc) {
  return new Node(this, pos2, loc);
};
function finishNodeAt(node2, type, pos2, loc) {
  node2.type = type;
  node2.end = pos2;
  if (this.options.locations) {
    node2.loc.end = loc;
  }
  if (this.options.ranges) {
    node2.range[1] = pos2;
  }
  return node2;
}
pp$2.finishNode = function(node2, type) {
  return finishNodeAt.call(this, node2, type, this.lastTokEnd, this.lastTokEndLoc);
};
pp$2.finishNodeAt = function(node2, type, pos2, loc) {
  return finishNodeAt.call(this, node2, type, pos2, loc);
};
pp$2.copyNode = function(node2) {
  var newNode = new Node(this, node2.start, this.startLoc);
  for (var prop in node2) {
    newNode[prop] = node2[prop];
  }
  return newNode;
};
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties,
  12: ecma12BinaryProperties,
  13: ecma13BinaryProperties
};
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues,
  12: ecma12ScriptValues,
  13: ecma13ScriptValues
};
var data = {};
function buildUnicodeData(ecmaVersion) {
  var d = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;
  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
for (i$1 = 0, list = [9, 10, 11, 12, 13]; i$1 < list.length; i$1 += 1) {
  ecmaVersion = list[i$1];
  buildUnicodeData(ecmaVersion);
}
var ecmaVersion;
var i$1;
var list;
var pp$1 = Parser.prototype;
var RegExpValidationState = function RegExpValidationState2(parser2) {
  this.parser = parser2;
  this.validFlags = "gim" + (parser2.options.ecmaVersion >= 6 ? "uy" : "") + (parser2.options.ecmaVersion >= 9 ? "s" : "") + (parser2.options.ecmaVersion >= 13 ? "d" : "");
  this.unicodeProperties = data[parser2.options.ecmaVersion >= 13 ? 13 : parser2.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = [];
  this.backReferenceNames = [];
};
RegExpValidationState.prototype.reset = function reset(start, pattern2, flags) {
  var unicode2 = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern2 + "";
  this.flags = flags;
  this.switchU = unicode2 && this.parser.options.ecmaVersion >= 6;
  this.switchN = unicode2 && this.parser.options.ecmaVersion >= 9;
};
RegExpValidationState.prototype.raise = function raise(message) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
};
RegExpValidationState.prototype.at = function at(i, forceU) {
  if (forceU === void 0)
    forceU = false;
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return -1;
  }
  var c2 = s.charCodeAt(i);
  if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i + 1 >= l) {
    return c2;
  }
  var next = s.charCodeAt(i + 1);
  return next >= 56320 && next <= 57343 ? (c2 << 10) + next - 56613888 : c2;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
  if (forceU === void 0)
    forceU = false;
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return l;
  }
  var c2 = s.charCodeAt(i), next;
  if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 56320 || next > 57343) {
    return i + 1;
  }
  return i + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
  if (forceU === void 0)
    forceU = false;
  return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
  if (forceU === void 0)
    forceU = false;
  return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
  if (forceU === void 0)
    forceU = false;
  this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch, forceU) {
  if (forceU === void 0)
    forceU = false;
  if (this.current(forceU) === ch) {
    this.advance(forceU);
    return true;
  }
  return false;
};
pp$1.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;
  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
  }
};
pp$1.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);
  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};
pp$1.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;
  this.regexp_disjunction(state);
  if (state.pos !== state.source.length) {
    if (state.eat(41)) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(93) || state.eat(125)) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
    var name = list[i];
    if (state.groupNames.indexOf(name) === -1) {
      state.raise("Invalid named capture referenced");
    }
  }
};
pp$1.regexp_disjunction = function(state) {
  this.regexp_alternative(state);
  while (state.eat(124)) {
    this.regexp_alternative(state);
  }
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(123)) {
    state.raise("Lone quantifier brackets");
  }
};
pp$1.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
  }
};
pp$1.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true;
  }
  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true;
  }
  return false;
};
pp$1.regexp_eatAssertion = function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;
  if (state.eat(94) || state.eat(36)) {
    return true;
  }
  if (state.eat(92)) {
    if (state.eat(66) || state.eat(98)) {
      return true;
    }
    state.pos = start;
  }
  if (state.eat(40) && state.eat(63)) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(60);
    }
    if (state.eat(61) || state.eat(33)) {
      this.regexp_disjunction(state);
      if (!state.eat(41)) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true;
    }
  }
  state.pos = start;
  return false;
};
pp$1.regexp_eatQuantifier = function(state, noError) {
  if (noError === void 0)
    noError = false;
  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(63);
    return true;
  }
  return false;
};
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
  return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(123)) {
    var min2 = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min2 = state.lastIntValue;
      if (state.eat(44) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(125)) {
        if (max !== -1 && max < min2 && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true;
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatAtom = function(state) {
  return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(92)) {
    if (this.regexp_eatAtomEscape(state)) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatUncapturingGroup = function(state) {
  var start = state.pos;
  if (state.eat(40)) {
    if (state.eat(63) && state.eat(58)) {
      this.regexp_disjunction(state);
      if (state.eat(41)) {
        return true;
      }
      state.raise("Unterminated group");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatCapturingGroup = function(state) {
  if (state.eat(40)) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 63) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(41)) {
      state.numCapturingParens += 1;
      return true;
    }
    state.raise("Unterminated group");
  }
  return false;
};
pp$1.regexp_eatExtendedAtom = function(state) {
  return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
};
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false;
};
pp$1.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isSyntaxCharacter(ch) {
  return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatPatternCharacters = function(state) {
  var start = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start;
};
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_groupSpecifier = function(state) {
  if (state.eat(63)) {
    if (this.regexp_eatGroupName(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise("Duplicate capture group name");
      }
      state.groupNames.push(state.lastStringValue);
      return;
    }
    state.raise("Invalid group");
  }
};
pp$1.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(60)) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) {
      return true;
    }
    state.raise("Invalid capture group name");
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start;
  return false;
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
}
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start;
  return false;
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
}
pp$1.regexp_eatAtomEscape = function(state) {
  if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
    return true;
  }
  if (state.switchU) {
    if (state.current() === 99) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false;
};
pp$1.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n2 = state.lastIntValue;
    if (state.switchU) {
      if (n2 > state.maxBackReference) {
        state.maxBackReference = n2;
      }
      return true;
    }
    if (n2 <= state.numCapturingParens) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatKGroupName = function(state) {
  if (state.eat(107)) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true;
    }
    state.raise("Invalid named reference");
  }
  return false;
};
pp$1.regexp_eatCharacterEscape = function(state) {
  return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};
pp$1.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(99)) {
    if (this.regexp_eatControlLetter(state)) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatZero = function(state) {
  if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 116) {
    state.lastIntValue = 9;
    state.advance();
    return true;
  }
  if (ch === 110) {
    state.lastIntValue = 10;
    state.advance();
    return true;
  }
  if (ch === 118) {
    state.lastIntValue = 11;
    state.advance();
    return true;
  }
  if (ch === 102) {
    state.lastIntValue = 12;
    state.advance();
    return true;
  }
  if (ch === 114) {
    state.lastIntValue = 13;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
function isControlLetter(ch) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
  if (forceU === void 0)
    forceU = false;
  var start = state.pos;
  var switchU = forceU || state.switchU;
  if (state.eat(117)) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (switchU && lead >= 55296 && lead <= 56319) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 56320 && trail <= 57343) {
            state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
            return true;
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true;
    }
    if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode(state.lastIntValue)) {
      return true;
    }
    if (switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start;
  }
  return false;
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 1114111;
}
pp$1.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true;
    }
    if (state.eat(47)) {
      state.lastIntValue = 47;
      return true;
    }
    return false;
  }
  var ch = state.current();
  if (ch !== 99 && (!state.switchN || ch !== 107)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 49 && ch <= 57) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
      state.advance();
    } while ((ch = state.current()) >= 48 && ch <= 57);
    return true;
  }
  return false;
};
pp$1.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();
  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return true;
  }
  if (state.switchU && this.options.ecmaVersion >= 9 && (ch === 80 || ch === 112)) {
    state.lastIntValue = -1;
    state.advance();
    if (state.eat(123) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(125)) {
      return true;
    }
    state.raise("Invalid property name");
  }
  return false;
};
function isCharacterClassEscape(ch) {
  return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
}
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start = state.pos;
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
    var name = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value2 = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value2);
      return true;
    }
  }
  state.pos = start;
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
    return true;
  }
  return false;
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value2) {
  if (!hasOwn(state.unicodeProperties.nonBinary, name)) {
    state.raise("Invalid property name");
  }
  if (!state.unicodeProperties.nonBinary[name].test(value2)) {
    state.raise("Invalid property value");
  }
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (!state.unicodeProperties.binary.test(nameOrValue)) {
    state.raise("Invalid property name");
  }
};
pp$1.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 95;
}
pp$1.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state);
};
pp$1.regexp_eatCharacterClass = function(state) {
  if (state.eat(91)) {
    state.eat(94);
    this.regexp_classRanges(state);
    if (state.eat(93)) {
      return true;
    }
    state.raise("Unterminated character class");
  }
  return false;
};
pp$1.regexp_classRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(45) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};
pp$1.regexp_eatClassAtom = function(state) {
  var start = state.pos;
  if (state.eat(92)) {
    if (this.regexp_eatClassEscape(state)) {
      return true;
    }
    if (state.switchU) {
      var ch$1 = state.current();
      if (ch$1 === 99 || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  var ch = state.current();
  if (ch !== 93) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatClassEscape = function(state) {
  var start = state.pos;
  if (state.eat(98)) {
    state.lastIntValue = 8;
    return true;
  }
  if (state.switchU && state.eat(45)) {
    state.lastIntValue = 45;
    return true;
  }
  if (!state.switchU && state.eat(99)) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true;
    }
    state.pos = start;
  }
  return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
};
pp$1.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 95) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatHexEscapeSequence = function(state) {
  var start = state.pos;
  if (state.eat(120)) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true;
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatDecimalDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
    state.advance();
  }
  return state.pos !== start;
};
function isDecimalDigit(ch) {
  return ch >= 48 && ch <= 57;
}
pp$1.regexp_eatHexDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start;
};
function isHexDigit(ch) {
  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt(ch) {
  if (ch >= 65 && ch <= 70) {
    return 10 + (ch - 65);
  }
  if (ch >= 97 && ch <= 102) {
    return 10 + (ch - 97);
  }
  return ch - 48;
}
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 48;
    state.advance();
    return true;
  }
  state.lastIntValue = 0;
  return false;
};
function isOctalDigit(ch) {
  return ch >= 48 && ch <= 55;
}
pp$1.regexp_eatFixedHexDigits = function(state, length) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i < length; ++i) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start;
      return false;
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true;
};
var Token = function Token2(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations) {
    this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
  }
  if (p.options.ranges) {
    this.range = [p.start, p.end];
  }
};
var pp = Parser.prototype;
pp.next = function(ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
  }
  if (this.options.onToken) {
    this.options.onToken(new Token(this));
  }
  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};
pp.getToken = function() {
  this.next();
  return new Token(this);
};
if (typeof Symbol !== "undefined") {
  pp[Symbol.iterator] = function() {
    var this$1$1 = this;
    return {
      next: function() {
        var token2 = this$1$1.getToken();
        return {
          done: token2.type === types$1.eof,
          value: token2
        };
      }
    };
  };
}
pp.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) {
    this.skipSpace();
  }
  this.start = this.pos;
  if (this.options.locations) {
    this.startLoc = this.curPosition();
  }
  if (this.pos >= this.input.length) {
    return this.finishToken(types$1.eof);
  }
  if (curContext.override) {
    return curContext.override(this);
  } else {
    this.readToken(this.fullCharCodeAtPos());
  }
};
pp.readToken = function(code) {
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
    return this.readWord();
  }
  return this.getTokenFromCode(code);
};
pp.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 55295 || code >= 56320) {
    return code;
  }
  var next = this.input.charCodeAt(this.pos + 1);
  return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
};
pp.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) {
    this.raise(this.pos - 2, "Unterminated comment");
  }
  this.pos = end + 2;
  if (this.options.locations) {
    for (var nextBreak = void 0, pos2 = start; (nextBreak = nextLineBreak(this.input, pos2, this.pos)) > -1; ) {
      ++this.curLine;
      pos2 = this.lineStart = nextBreak;
    }
  }
  if (this.options.onComment) {
    this.options.onComment(
      true,
      this.input.slice(start + 2, end),
      start,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipLineComment = function(startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment) {
    this.options.onComment(
      false,
      this.input.slice(start + startSkip, this.pos),
      start,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipSpace = function() {
  loop:
    while (this.pos < this.input.length) {
      var ch = this.input.charCodeAt(this.pos);
      switch (ch) {
        case 32:
        case 160:
          ++this.pos;
          break;
        case 13:
          if (this.input.charCodeAt(this.pos + 1) === 10) {
            ++this.pos;
          }
        case 10:
        case 8232:
        case 8233:
          ++this.pos;
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          break;
        case 47:
          switch (this.input.charCodeAt(this.pos + 1)) {
            case 42:
              this.skipBlockComment();
              break;
            case 47:
              this.skipLineComment(2);
              break;
            default:
              break loop;
          }
          break;
        default:
          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
            ++this.pos;
          } else {
            break loop;
          }
      }
    }
};
pp.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) {
    this.endLoc = this.curPosition();
  }
  var prevType = this.type;
  this.type = type;
  this.value = val;
  this.updateContext(prevType);
};
pp.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) {
    return this.readNumber(true);
  }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
    this.pos += 3;
    return this.finishToken(types$1.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(types$1.dot);
  }
};
pp.readToken_slash = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;
    return this.readRegexp();
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.slash, 1);
};
pp.readToken_mult_modulo_exp = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types$1.star : types$1.modulo;
  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
    ++size;
    tokentype = types$1.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, size + 1);
  }
  return this.finishOp(tokentype, size);
};
pp.readToken_pipe_amp = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (this.options.ecmaVersion >= 12) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 === 61) {
        return this.finishOp(types$1.assign, 3);
      }
    }
    return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
};
pp.readToken_caret = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.bitwiseXOR, 1);
};
pp.readToken_plus_min = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(types$1.incDec, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.plusMin, 1);
};
pp.readToken_lt_gt = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) {
      return this.finishOp(types$1.assign, size + 1);
    }
    return this.finishOp(types$1.bitShift, size);
  }
  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next === 61) {
    size = 2;
  }
  return this.finishOp(types$1.relational, size);
};
pp.readToken_eq_excl = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  }
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
    this.pos += 2;
    return this.finishToken(types$1.arrow);
  }
  return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
};
pp.readToken_question = function() {
  var ecmaVersion = this.options.ecmaVersion;
  if (ecmaVersion >= 11) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 46) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 < 48 || next2 > 57) {
        return this.finishOp(types$1.questionDot, 2);
      }
    }
    if (next === 63) {
      if (ecmaVersion >= 12) {
        var next2$1 = this.input.charCodeAt(this.pos + 2);
        if (next2$1 === 61) {
          return this.finishOp(types$1.assign, 3);
        }
      }
      return this.finishOp(types$1.coalesce, 2);
    }
  }
  return this.finishOp(types$1.question, 1);
};
pp.readToken_numberSign = function() {
  var ecmaVersion = this.options.ecmaVersion;
  var code = 35;
  if (ecmaVersion >= 13) {
    ++this.pos;
    code = this.fullCharCodeAtPos();
    if (isIdentifierStart(code, true) || code === 92) {
      return this.finishToken(types$1.privateId, this.readWord1());
    }
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.getTokenFromCode = function(code) {
  switch (code) {
    case 46:
      return this.readToken_dot();
    case 40:
      ++this.pos;
      return this.finishToken(types$1.parenL);
    case 41:
      ++this.pos;
      return this.finishToken(types$1.parenR);
    case 59:
      ++this.pos;
      return this.finishToken(types$1.semi);
    case 44:
      ++this.pos;
      return this.finishToken(types$1.comma);
    case 91:
      ++this.pos;
      return this.finishToken(types$1.bracketL);
    case 93:
      ++this.pos;
      return this.finishToken(types$1.bracketR);
    case 123:
      ++this.pos;
      return this.finishToken(types$1.braceL);
    case 125:
      ++this.pos;
      return this.finishToken(types$1.braceR);
    case 58:
      ++this.pos;
      return this.finishToken(types$1.colon);
    case 96:
      if (this.options.ecmaVersion < 6) {
        break;
      }
      ++this.pos;
      return this.finishToken(types$1.backQuote);
    case 48:
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) {
        return this.readRadixNumber(16);
      }
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) {
          return this.readRadixNumber(8);
        }
        if (next === 98 || next === 66) {
          return this.readRadixNumber(2);
        }
      }
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(false);
    case 34:
    case 39:
      return this.readString(code);
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(code);
    case 124:
    case 38:
      return this.readToken_pipe_amp(code);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(code);
    case 60:
    case 62:
      return this.readToken_lt_gt(code);
    case 61:
    case 33:
      return this.readToken_eq_excl(code);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(types$1.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.finishOp = function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str);
};
pp.readRegexp = function() {
  var escaped2, inClass, start = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(start, "Unterminated regular expression");
    }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) {
      this.raise(start, "Unterminated regular expression");
    }
    if (!escaped2) {
      if (ch === "[") {
        inClass = true;
      } else if (ch === "]" && inClass) {
        inClass = false;
      } else if (ch === "/" && !inClass) {
        break;
      }
      escaped2 = ch === "\\";
    } else {
      escaped2 = false;
    }
    ++this.pos;
  }
  var pattern2 = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) {
    this.unexpected(flagsStart);
  }
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern2, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);
  var value2 = null;
  try {
    value2 = new RegExp(pattern2, flags);
  } catch (e) {
  }
  return this.finishToken(types$1.regexp, { pattern: pattern2, flags, value: value2 });
};
pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
  var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
  var start = this.pos, total = 0, lastCode = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
    var code = this.input.charCodeAt(this.pos), val = void 0;
    if (allowSeparators && code === 95) {
      if (isLegacyOctalNumericLiteral) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
      }
      if (lastCode === 95) {
        this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
      }
      if (i === 0) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
      }
      lastCode = code;
      continue;
    }
    if (code >= 97) {
      val = code - 97 + 10;
    } else if (code >= 65) {
      val = code - 65 + 10;
    } else if (code >= 48 && code <= 57) {
      val = code - 48;
    } else {
      val = Infinity;
    }
    if (val >= radix) {
      break;
    }
    lastCode = code;
    total = total * radix + val;
  }
  if (allowSeparators && lastCode === 95) {
    this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
  }
  if (this.pos === start || len != null && this.pos - start !== len) {
    return null;
  }
  return total;
};
function stringToNumber(str, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str, 8);
  }
  return parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt(str) {
  if (typeof BigInt !== "function") {
    return null;
  }
  return BigInt(str.replace(/_/g, ""));
}
pp.readRadixNumber = function(radix) {
  var start = this.pos;
  this.pos += 2;
  var val = this.readInt(radix);
  if (val == null) {
    this.raise(this.start + 2, "Expected number in radix " + radix);
  }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  return this.finishToken(types$1.num, val);
};
pp.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10, void 0, true) === null) {
    this.raise(start, "Invalid number");
  }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) {
    this.raise(start, "Invalid number");
  }
  var next = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
    var val$1 = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    return this.finishToken(types$1.num, val$1);
  }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
    octal = false;
  }
  if (next === 46 && !octal) {
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) {
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) {
      ++this.pos;
    }
    if (this.readInt(10) === null) {
      this.raise(start, "Invalid number");
    }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  var val = stringToNumber(this.input.slice(start, this.pos), octal);
  return this.finishToken(types$1.num, val);
};
pp.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;
  if (ch === 123) {
    if (this.options.ecmaVersion < 6) {
      this.unexpected();
    }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 1114111) {
      this.invalidStringToken(codePos, "Code point out of bounds");
    }
  } else {
    code = this.readHexChar(4);
  }
  return code;
};
pp.readString = function(quote) {
  var out2 = "", chunkStart = ++this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated string constant");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) {
      break;
    }
    if (ch === 92) {
      out2 += this.input.slice(chunkStart, this.pos);
      out2 += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else if (ch === 8232 || ch === 8233) {
      if (this.options.ecmaVersion < 10) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
      if (this.options.locations) {
        this.curLine++;
        this.lineStart = this.pos;
      }
    } else {
      if (isNewLine(ch)) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
    }
  }
  out2 += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types$1.string, out2);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err;
    }
  }
  this.inTemplateElement = false;
};
pp.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR;
  } else {
    this.raise(position, message);
  }
};
pp.readTmplToken = function() {
  var out2 = "", chunkStart = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated template");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types$1.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(types$1.backQuote);
        }
      }
      out2 += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types$1.template, out2);
    }
    if (ch === 92) {
      out2 += this.input.slice(chunkStart, this.pos);
      out2 += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out2 += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          out2 += "\n";
          break;
        default:
          out2 += String.fromCharCode(ch);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};
pp.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break;
        }
      case "`":
        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
    }
  }
  this.raise(this.start, "Unterminated template");
};
pp.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
    case 110:
      return "\n";
    case 114:
      return "\r";
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    case 117:
      return codePointToString(this.readCodePoint());
    case 116:
      return "	";
    case 98:
      return "\b";
    case 118:
      return "\v";
    case 102:
      return "\f";
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
      }
    case 10:
      if (this.options.locations) {
        this.lineStart = this.pos;
        ++this.curLine;
      }
      return "";
    case 56:
    case 57:
      if (this.strict) {
        this.invalidStringToken(
          this.pos - 1,
          "Invalid escape sequence"
        );
      }
      if (inTemplate) {
        var codePos = this.pos - 1;
        this.invalidStringToken(
          codePos,
          "Invalid escape sequence in template string"
        );
        return null;
      }
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal);
      }
      if (isNewLine(ch)) {
        return "";
      }
      return String.fromCharCode(ch);
  }
};
pp.readHexChar = function(len) {
  var codePos = this.pos;
  var n2 = this.readInt(16, len);
  if (n2 === null) {
    this.invalidStringToken(codePos, "Bad character escape sequence");
  }
  return n2;
};
pp.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first2 = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 65535 ? 1 : 2;
    } else if (ch === 92) {
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) {
        this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first2 ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
        this.invalidStringToken(escStart, "Invalid Unicode escape");
      }
      word += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break;
    }
    first2 = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function() {
  var word = this.readWord1();
  var type = types$1.name;
  if (this.keywords.test(word)) {
    type = keywords[word];
  }
  return this.finishToken(type, word);
};
var version2 = "8.8.1";
Parser.acorn = {
  Parser,
  version: version2,
  defaultOptions,
  Position,
  SourceLocation,
  getLineInfo,
  Node,
  TokenType,
  tokTypes: types$1,
  keywordTypes: keywords,
  TokContext,
  tokContexts: types,
  isIdentifierChar,
  isIdentifierStart,
  Token,
  isNewLine,
  lineBreak,
  lineBreakG,
  nonASCIIwhitespace
};
function parse$c(input, options3) {
  return Parser.parse(input, options3);
}
function parseExpressionAt2(input, pos2, options3) {
  return Parser.parseExpressionAt(input, pos2, options3);
}
function tokenizer2(input, options3) {
  return Parser.tokenizer(input, options3);
}
var acorn = {
  __proto__: null,
  Node,
  Parser,
  Position,
  SourceLocation,
  TokContext,
  Token,
  TokenType,
  defaultOptions,
  getLineInfo,
  isIdentifierChar,
  isIdentifierStart,
  isNewLine,
  keywordTypes: keywords,
  lineBreak,
  lineBreakG,
  nonASCIIwhitespace,
  parse: parse$c,
  parseExpressionAt: parseExpressionAt2,
  tokContexts: types,
  tokTypes: types$1,
  tokenizer: tokenizer2,
  version: version2
};
function stripLiteralAcorn(code) {
  const FILL = " ";
  let result = "";
  function fulfill(index2) {
    if (index2 > result.length)
      result += code.slice(result.length, index2).replace(/[^\n]/g, FILL);
  }
  const tokens = tokenizer2(code, {
    ecmaVersion: "latest",
    sourceType: "module",
    allowHashBang: true,
    allowAwaitOutsideFunction: true,
    allowImportExportEverywhere: true
  });
  const inter = tokens[Symbol.iterator]();
  while (true) {
    const { done, value: token2 } = inter.next();
    if (done)
      break;
    fulfill(token2.start);
    if (token2.type.label === "string")
      result += code[token2.start] + FILL.repeat(token2.end - token2.start - 2) + code[token2.end - 1];
    else if (token2.type.label === "template")
      result += FILL.repeat(token2.end - token2.start);
    else
      result += code.slice(token2.start, token2.end);
  }
  fulfill(code.length);
  return result;
}
var multilineCommentsRE = /\/\*.*?\*\//gms;
var singlelineCommentsRE = /(?:^|\n|\r)\s*\/\/.*(?:\r|\n|$)/gm;
var templateLiteralRE = /\$\{(\s*(?:(?!\$\{).|\n|\r)*?\s*)\}/g;
var quotesRE = [
  /(["'`])((?:\\\1|(?!\1)|.|\r)*?)\1/gm,
  /([`])((?:\\\1|(?!\1)|.|\n|\r)*?)\1/gm
];
function stripLiteralRegex(code) {
  code = code.replace(multilineCommentsRE, (s) => " ".repeat(s.length)).replace(singlelineCommentsRE, (s) => " ".repeat(s.length));
  let expanded = code;
  for (let i = 0; i < 16; i++) {
    const before = expanded;
    expanded = expanded.replace(templateLiteralRE, "` $1`");
    if (expanded === before)
      break;
  }
  quotesRE.forEach((re) => {
    expanded = expanded.replace(re, (s, quote, body, index2) => {
      code = code.slice(0, index2 + 1) + " ".repeat(s.length - 2) + code.slice(index2 + s.length - 1);
      return quote + " ".repeat(s.length - 2) + quote;
    });
  });
  return code;
}
function stripLiteral(code) {
  try {
    return stripLiteralAcorn(code);
  } catch (e) {
    return stripLiteralRegex(code);
  }
}
var mimes$1 = {
  "ez": "application/andrew-inset",
  "aw": "application/applixware",
  "atom": "application/atom+xml",
  "atomcat": "application/atomcat+xml",
  "atomdeleted": "application/atomdeleted+xml",
  "atomsvc": "application/atomsvc+xml",
  "dwd": "application/atsc-dwd+xml",
  "held": "application/atsc-held+xml",
  "rsat": "application/atsc-rsat+xml",
  "bdoc": "application/bdoc",
  "xcs": "application/calendar+xml",
  "ccxml": "application/ccxml+xml",
  "cdfx": "application/cdfx+xml",
  "cdmia": "application/cdmi-capability",
  "cdmic": "application/cdmi-container",
  "cdmid": "application/cdmi-domain",
  "cdmio": "application/cdmi-object",
  "cdmiq": "application/cdmi-queue",
  "cu": "application/cu-seeme",
  "mpd": "application/dash+xml",
  "davmount": "application/davmount+xml",
  "dbk": "application/docbook+xml",
  "dssc": "application/dssc+der",
  "xdssc": "application/dssc+xml",
  "es": "application/ecmascript",
  "ecma": "application/ecmascript",
  "emma": "application/emma+xml",
  "emotionml": "application/emotionml+xml",
  "epub": "application/epub+zip",
  "exi": "application/exi",
  "fdt": "application/fdt+xml",
  "pfr": "application/font-tdpfr",
  "geojson": "application/geo+json",
  "gml": "application/gml+xml",
  "gpx": "application/gpx+xml",
  "gxf": "application/gxf",
  "gz": "application/gzip",
  "hjson": "application/hjson",
  "stk": "application/hyperstudio",
  "ink": "application/inkml+xml",
  "inkml": "application/inkml+xml",
  "ipfix": "application/ipfix",
  "its": "application/its+xml",
  "jar": "application/java-archive",
  "war": "application/java-archive",
  "ear": "application/java-archive",
  "ser": "application/java-serialized-object",
  "class": "application/java-vm",
  "js": "application/javascript",
  "mjs": "application/javascript",
  "json": "application/json",
  "map": "application/json",
  "json5": "application/json5",
  "jsonml": "application/jsonml+json",
  "jsonld": "application/ld+json",
  "lgr": "application/lgr+xml",
  "lostxml": "application/lost+xml",
  "hqx": "application/mac-binhex40",
  "cpt": "application/mac-compactpro",
  "mads": "application/mads+xml",
  "webmanifest": "application/manifest+json",
  "mrc": "application/marc",
  "mrcx": "application/marcxml+xml",
  "ma": "application/mathematica",
  "nb": "application/mathematica",
  "mb": "application/mathematica",
  "mathml": "application/mathml+xml",
  "mbox": "application/mbox",
  "mscml": "application/mediaservercontrol+xml",
  "metalink": "application/metalink+xml",
  "meta4": "application/metalink4+xml",
  "mets": "application/mets+xml",
  "maei": "application/mmt-aei+xml",
  "musd": "application/mmt-usd+xml",
  "mods": "application/mods+xml",
  "m21": "application/mp21",
  "mp21": "application/mp21",
  "mp4s": "application/mp4",
  "m4p": "application/mp4",
  "doc": "application/msword",
  "dot": "application/msword",
  "mxf": "application/mxf",
  "nq": "application/n-quads",
  "nt": "application/n-triples",
  "cjs": "application/node",
  "bin": "application/octet-stream",
  "dms": "application/octet-stream",
  "lrf": "application/octet-stream",
  "mar": "application/octet-stream",
  "so": "application/octet-stream",
  "dist": "application/octet-stream",
  "distz": "application/octet-stream",
  "pkg": "application/octet-stream",
  "bpk": "application/octet-stream",
  "dump": "application/octet-stream",
  "elc": "application/octet-stream",
  "deploy": "application/octet-stream",
  "exe": "application/octet-stream",
  "dll": "application/octet-stream",
  "deb": "application/octet-stream",
  "dmg": "application/octet-stream",
  "iso": "application/octet-stream",
  "img": "application/octet-stream",
  "msi": "application/octet-stream",
  "msp": "application/octet-stream",
  "msm": "application/octet-stream",
  "buffer": "application/octet-stream",
  "oda": "application/oda",
  "opf": "application/oebps-package+xml",
  "ogx": "application/ogg",
  "omdoc": "application/omdoc+xml",
  "onetoc": "application/onenote",
  "onetoc2": "application/onenote",
  "onetmp": "application/onenote",
  "onepkg": "application/onenote",
  "oxps": "application/oxps",
  "relo": "application/p2p-overlay+xml",
  "xer": "application/patch-ops-error+xml",
  "pdf": "application/pdf",
  "pgp": "application/pgp-encrypted",
  "asc": "application/pgp-signature",
  "sig": "application/pgp-signature",
  "prf": "application/pics-rules",
  "p10": "application/pkcs10",
  "p7m": "application/pkcs7-mime",
  "p7c": "application/pkcs7-mime",
  "p7s": "application/pkcs7-signature",
  "p8": "application/pkcs8",
  "ac": "application/pkix-attr-cert",
  "cer": "application/pkix-cert",
  "crl": "application/pkix-crl",
  "pkipath": "application/pkix-pkipath",
  "pki": "application/pkixcmp",
  "pls": "application/pls+xml",
  "ai": "application/postscript",
  "eps": "application/postscript",
  "ps": "application/postscript",
  "provx": "application/provenance+xml",
  "cww": "application/prs.cww",
  "pskcxml": "application/pskc+xml",
  "raml": "application/raml+yaml",
  "rdf": "application/rdf+xml",
  "owl": "application/rdf+xml",
  "rif": "application/reginfo+xml",
  "rnc": "application/relax-ng-compact-syntax",
  "rl": "application/resource-lists+xml",
  "rld": "application/resource-lists-diff+xml",
  "rs": "application/rls-services+xml",
  "rapd": "application/route-apd+xml",
  "sls": "application/route-s-tsid+xml",
  "rusd": "application/route-usd+xml",
  "gbr": "application/rpki-ghostbusters",
  "mft": "application/rpki-manifest",
  "roa": "application/rpki-roa",
  "rsd": "application/rsd+xml",
  "rss": "application/rss+xml",
  "rtf": "application/rtf",
  "sbml": "application/sbml+xml",
  "scq": "application/scvp-cv-request",
  "scs": "application/scvp-cv-response",
  "spq": "application/scvp-vp-request",
  "spp": "application/scvp-vp-response",
  "sdp": "application/sdp",
  "senmlx": "application/senml+xml",
  "sensmlx": "application/sensml+xml",
  "setpay": "application/set-payment-initiation",
  "setreg": "application/set-registration-initiation",
  "shf": "application/shf+xml",
  "siv": "application/sieve",
  "sieve": "application/sieve",
  "smi": "application/smil+xml",
  "smil": "application/smil+xml",
  "rq": "application/sparql-query",
  "srx": "application/sparql-results+xml",
  "gram": "application/srgs",
  "grxml": "application/srgs+xml",
  "sru": "application/sru+xml",
  "ssdl": "application/ssdl+xml",
  "ssml": "application/ssml+xml",
  "swidtag": "application/swid+xml",
  "tei": "application/tei+xml",
  "teicorpus": "application/tei+xml",
  "tfi": "application/thraud+xml",
  "tsd": "application/timestamped-data",
  "toml": "application/toml",
  "trig": "application/trig",
  "ttml": "application/ttml+xml",
  "ubj": "application/ubjson",
  "rsheet": "application/urc-ressheet+xml",
  "td": "application/urc-targetdesc+xml",
  "vxml": "application/voicexml+xml",
  "wasm": "application/wasm",
  "wgt": "application/widget",
  "hlp": "application/winhlp",
  "wsdl": "application/wsdl+xml",
  "wspolicy": "application/wspolicy+xml",
  "xaml": "application/xaml+xml",
  "xav": "application/xcap-att+xml",
  "xca": "application/xcap-caps+xml",
  "xdf": "application/xcap-diff+xml",
  "xel": "application/xcap-el+xml",
  "xns": "application/xcap-ns+xml",
  "xenc": "application/xenc+xml",
  "xhtml": "application/xhtml+xml",
  "xht": "application/xhtml+xml",
  "xlf": "application/xliff+xml",
  "xml": "application/xml",
  "xsl": "application/xml",
  "xsd": "application/xml",
  "rng": "application/xml",
  "dtd": "application/xml-dtd",
  "xop": "application/xop+xml",
  "xpl": "application/xproc+xml",
  "xslt": "application/xml",
  "xspf": "application/xspf+xml",
  "mxml": "application/xv+xml",
  "xhvml": "application/xv+xml",
  "xvml": "application/xv+xml",
  "xvm": "application/xv+xml",
  "yang": "application/yang",
  "yin": "application/yin+xml",
  "zip": "application/zip",
  "3gpp": "video/3gpp",
  "adp": "audio/adpcm",
  "amr": "audio/amr",
  "au": "audio/basic",
  "snd": "audio/basic",
  "mid": "audio/midi",
  "midi": "audio/midi",
  "kar": "audio/midi",
  "rmi": "audio/midi",
  "mxmf": "audio/mobile-xmf",
  "mp3": "audio/mpeg",
  "m4a": "audio/mp4",
  "mp4a": "audio/mp4",
  "mpga": "audio/mpeg",
  "mp2": "audio/mpeg",
  "mp2a": "audio/mpeg",
  "m2a": "audio/mpeg",
  "m3a": "audio/mpeg",
  "oga": "audio/ogg",
  "ogg": "audio/ogg",
  "spx": "audio/ogg",
  "opus": "audio/ogg",
  "s3m": "audio/s3m",
  "sil": "audio/silk",
  "wav": "audio/wav",
  "weba": "audio/webm",
  "xm": "audio/xm",
  "ttc": "font/collection",
  "otf": "font/otf",
  "ttf": "font/ttf",
  "woff": "font/woff",
  "woff2": "font/woff2",
  "exr": "image/aces",
  "apng": "image/apng",
  "avif": "image/avif",
  "bmp": "image/bmp",
  "cgm": "image/cgm",
  "drle": "image/dicom-rle",
  "emf": "image/emf",
  "fits": "image/fits",
  "g3": "image/g3fax",
  "gif": "image/gif",
  "heic": "image/heic",
  "heics": "image/heic-sequence",
  "heif": "image/heif",
  "heifs": "image/heif-sequence",
  "hej2": "image/hej2k",
  "hsj2": "image/hsj2",
  "ief": "image/ief",
  "jls": "image/jls",
  "jp2": "image/jp2",
  "jpg2": "image/jp2",
  "jpeg": "image/jpeg",
  "jpg": "image/jpeg",
  "jpe": "image/jpeg",
  "jph": "image/jph",
  "jhc": "image/jphc",
  "jpm": "image/jpm",
  "jpx": "image/jpx",
  "jpf": "image/jpx",
  "jxr": "image/jxr",
  "jxra": "image/jxra",
  "jxrs": "image/jxrs",
  "jxs": "image/jxs",
  "jxsc": "image/jxsc",
  "jxsi": "image/jxsi",
  "jxss": "image/jxss",
  "ktx": "image/ktx",
  "ktx2": "image/ktx2",
  "png": "image/png",
  "btif": "image/prs.btif",
  "pti": "image/prs.pti",
  "sgi": "image/sgi",
  "svg": "image/svg+xml",
  "svgz": "image/svg+xml",
  "t38": "image/t38",
  "tif": "image/tiff",
  "tiff": "image/tiff",
  "tfx": "image/tiff-fx",
  "webp": "image/webp",
  "wmf": "image/wmf",
  "disposition-notification": "message/disposition-notification",
  "u8msg": "message/global",
  "u8dsn": "message/global-delivery-status",
  "u8mdn": "message/global-disposition-notification",
  "u8hdr": "message/global-headers",
  "eml": "message/rfc822",
  "mime": "message/rfc822",
  "3mf": "model/3mf",
  "gltf": "model/gltf+json",
  "glb": "model/gltf-binary",
  "igs": "model/iges",
  "iges": "model/iges",
  "msh": "model/mesh",
  "mesh": "model/mesh",
  "silo": "model/mesh",
  "mtl": "model/mtl",
  "obj": "model/obj",
  "stpz": "model/step+zip",
  "stpxz": "model/step-xml+zip",
  "stl": "model/stl",
  "wrl": "model/vrml",
  "vrml": "model/vrml",
  "x3db": "model/x3d+fastinfoset",
  "x3dbz": "model/x3d+binary",
  "x3dv": "model/x3d-vrml",
  "x3dvz": "model/x3d+vrml",
  "x3d": "model/x3d+xml",
  "x3dz": "model/x3d+xml",
  "appcache": "text/cache-manifest",
  "manifest": "text/cache-manifest",
  "ics": "text/calendar",
  "ifb": "text/calendar",
  "coffee": "text/coffeescript",
  "litcoffee": "text/coffeescript",
  "css": "text/css",
  "csv": "text/csv",
  "html": "text/html",
  "htm": "text/html",
  "shtml": "text/html",
  "jade": "text/jade",
  "jsx": "text/jsx",
  "less": "text/less",
  "markdown": "text/markdown",
  "md": "text/markdown",
  "mml": "text/mathml",
  "mdx": "text/mdx",
  "n3": "text/n3",
  "txt": "text/plain",
  "text": "text/plain",
  "conf": "text/plain",
  "def": "text/plain",
  "list": "text/plain",
  "log": "text/plain",
  "in": "text/plain",
  "ini": "text/plain",
  "dsc": "text/prs.lines.tag",
  "rtx": "text/richtext",
  "sgml": "text/sgml",
  "sgm": "text/sgml",
  "shex": "text/shex",
  "slim": "text/slim",
  "slm": "text/slim",
  "spdx": "text/spdx",
  "stylus": "text/stylus",
  "styl": "text/stylus",
  "tsv": "text/tab-separated-values",
  "t": "text/troff",
  "tr": "text/troff",
  "roff": "text/troff",
  "man": "text/troff",
  "me": "text/troff",
  "ms": "text/troff",
  "ttl": "text/turtle",
  "uri": "text/uri-list",
  "uris": "text/uri-list",
  "urls": "text/uri-list",
  "vcard": "text/vcard",
  "vtt": "text/vtt",
  "yaml": "text/yaml",
  "yml": "text/yaml",
  "3gp": "video/3gpp",
  "3g2": "video/3gpp2",
  "h261": "video/h261",
  "h263": "video/h263",
  "h264": "video/h264",
  "m4s": "video/iso.segment",
  "jpgv": "video/jpeg",
  "jpgm": "image/jpm",
  "mj2": "video/mj2",
  "mjp2": "video/mj2",
  "ts": "video/mp2t",
  "mp4": "video/mp4",
  "mp4v": "video/mp4",
  "mpg4": "video/mp4",
  "mpeg": "video/mpeg",
  "mpg": "video/mpeg",
  "mpe": "video/mpeg",
  "m1v": "video/mpeg",
  "m2v": "video/mpeg",
  "ogv": "video/ogg",
  "qt": "video/quicktime",
  "mov": "video/quicktime",
  "webm": "video/webm"
};
function lookup(extn) {
  let tmp = ("" + extn).trim().toLowerCase();
  let idx = tmp.lastIndexOf(".");
  return mimes$1[!~idx ? tmp : tmp.substring(++idx)];
}
var assetUrlRE = /__VITE_ASSET__([a-z\d]{8})__(?:\$_(.*?)__)?/g;
var duplicateAssets = /* @__PURE__ */ new WeakMap();
var rawRE = /(\?|&)raw(?:&|$)/;
var urlRE = /(\?|&)url(?:&|$)/;
var assetCache = /* @__PURE__ */ new WeakMap();
var assetHashToFilenameMap = /* @__PURE__ */ new WeakMap();
var emittedHashMap = /* @__PURE__ */ new WeakMap();
function registerCustomMime() {
  mimes$1["ico"] = "image/x-icon";
  mimes$1["flac"] = "audio/flac";
  mimes$1["aac"] = "audio/aac";
  mimes$1["eot"] = "application/vnd.ms-fontobject";
}
function renderAssetUrlInJS(ctx2, config2, chunk, opts, code) {
  const toRelativeRuntime = createToImportMetaURLBasedRelativeRuntime(opts.format);
  let match;
  let s;
  assetUrlRE.lastIndex = 0;
  while (match = assetUrlRE.exec(code)) {
    s || (s = new MagicString(code));
    const [full, hash, postfix = ""] = match;
    const file = getAssetFilename(hash, config2) || ctx2.getFileName(hash);
    chunk.viteMetadata.importedAssets.add(cleanUrl(file));
    const filename = file + postfix;
    const replacement = toOutputFilePathInJS(filename, "asset", chunk.fileName, "js", config2, toRelativeRuntime);
    const replacementString = typeof replacement === "string" ? JSON.stringify(replacement).slice(1, -1) : `"+${replacement.runtime}+"`;
    s.update(match.index, match.index + full.length, replacementString);
  }
  const publicAssetUrlMap = publicAssetUrlCache.get(config2);
  publicAssetUrlRE.lastIndex = 0;
  while (match = publicAssetUrlRE.exec(code)) {
    s || (s = new MagicString(code));
    const [full, hash] = match;
    const publicUrl = publicAssetUrlMap.get(hash).slice(1);
    const replacement = toOutputFilePathInJS(publicUrl, "public", chunk.fileName, "js", config2, toRelativeRuntime);
    const replacementString = typeof replacement === "string" ? JSON.stringify(replacement).slice(1, -1) : `"+${replacement.runtime}+"`;
    s.update(match.index, match.index + full.length, replacementString);
  }
  return s;
}
function assetPlugin(config2) {
  assetHashToFilenameMap.set(config2, /* @__PURE__ */ new Map());
  registerCustomMime();
  return {
    name: "vite:asset",
    buildStart() {
      assetCache.set(config2, /* @__PURE__ */ new Map());
      emittedHashMap.set(config2, /* @__PURE__ */ new Set());
      duplicateAssets.set(config2, /* @__PURE__ */ new Map());
    },
    resolveId(id) {
      if (!config2.assetsInclude(cleanUrl(id))) {
        return;
      }
      const publicFile = checkPublicFile(id, config2);
      if (publicFile) {
        return id;
      }
    },
    async load(id) {
      if (id.startsWith("\0")) {
        return;
      }
      if (rawRE.test(id)) {
        const file = checkPublicFile(id, config2) || cleanUrl(id);
        return `export default ${JSON.stringify(await import_node_fs.promises.readFile(file, "utf-8"))}`;
      }
      if (!config2.assetsInclude(cleanUrl(id)) && !urlRE.test(id)) {
        return;
      }
      id = id.replace(urlRE, "$1").replace(/[\?&]$/, "");
      const url2 = await fileToUrl(id, config2, this);
      return `export default ${JSON.stringify(url2)}`;
    },
    renderChunk(code, chunk, opts) {
      const s = renderAssetUrlInJS(this, config2, chunk, opts, code);
      if (s) {
        return {
          code: s.toString(),
          map: config2.build.sourcemap ? s.generateMap({ hires: true }) : null
        };
      } else {
        return null;
      }
    },
    generateBundle(_, bundle) {
      if (config2.command === "build" && config2.build.ssr) {
        for (const file in bundle) {
          if (bundle[file].type === "asset" && !file.includes("ssr-manifest.json")) {
            delete bundle[file];
          }
        }
      }
    }
  };
}
function checkPublicFile(url2, { publicDir }) {
  if (!publicDir || !url2.startsWith("/")) {
    return;
  }
  const publicFile = import_node_path2.default.join(publicDir, cleanUrl(url2));
  if (import_node_fs.default.existsSync(publicFile)) {
    return publicFile;
  } else {
    return;
  }
}
async function fileToUrl(id, config2, ctx2) {
  if (config2.command === "serve") {
    return fileToDevUrl(id, config2);
  } else {
    return fileToBuiltUrl(id, config2, ctx2);
  }
}
function fileToDevUrl(id, config2) {
  var _a, _b;
  let rtn;
  if (checkPublicFile(id, config2)) {
    rtn = id;
  } else if (id.startsWith(config2.root)) {
    rtn = "/" + import_node_path2.default.posix.relative(config2.root, id);
  } else {
    rtn = import_node_path2.default.posix.join(FS_PREFIX + id);
  }
  const base2 = joinUrlSegments((_b = (_a = config2.server) == null ? void 0 : _a.origin) != null ? _b : "", config2.base);
  return joinUrlSegments(base2, rtn.replace(/^\//, ""));
}
function getAssetFilename(hash, config2) {
  var _a;
  return (_a = assetHashToFilenameMap.get(config2)) == null ? void 0 : _a.get(hash);
}
function getPublicAssetFilename(hash, config2) {
  var _a;
  return (_a = publicAssetUrlCache.get(config2)) == null ? void 0 : _a.get(hash);
}
function resolveAssetFileNames(config2) {
  var _a, _b, _c, _d;
  const output = (_b = (_a = config2.build) == null ? void 0 : _a.rollupOptions) == null ? void 0 : _b.output;
  const defaultAssetFileNames = import_node_path2.default.posix.join(config2.build.assetsDir, "[name].[hash][extname]");
  let assetFileNames = (_c = output && !Array.isArray(output) ? output.assetFileNames : void 0) != null ? _c : defaultAssetFileNames;
  if (output && Array.isArray(output)) {
    assetFileNames = (_d = output[0].assetFileNames) != null ? _d : assetFileNames;
  }
  return assetFileNames;
}
function assetFileNamesToFileName(assetFileNames, file, contentHash, content) {
  const basename2 = import_node_path2.default.basename(file);
  const extname2 = import_node_path2.default.extname(basename2);
  const ext2 = extname2.substring(1);
  const name = basename2.slice(0, -extname2.length);
  const hash = contentHash;
  if (typeof assetFileNames === "function") {
    assetFileNames = assetFileNames({
      name: file,
      source: content,
      type: "asset"
    });
    if (typeof assetFileNames !== "string") {
      throw new TypeError("assetFileNames must return a string");
    }
  } else if (typeof assetFileNames !== "string") {
    throw new TypeError("assetFileNames must be a string or a function");
  }
  const fileName = assetFileNames.replace(/\[\w+\]/g, (placeholder) => {
    switch (placeholder) {
      case "[ext]":
        return ext2;
      case "[extname]":
        return extname2;
      case "[hash]":
        return hash;
      case "[name]":
        return sanitizeFileName(name);
    }
    throw new Error(`invalid placeholder ${placeholder} in assetFileNames "${assetFileNames}"`);
  });
  return fileName;
}
var INVALID_CHAR_REGEX = /[\x00-\x1F\x7F<>*#"{}|^[\]`;?:&=+$,]/g;
var DRIVE_LETTER_REGEX = /^[a-z]:/i;
function sanitizeFileName(name) {
  const match = DRIVE_LETTER_REGEX.exec(name);
  const driveLetter = match ? match[0] : "";
  return driveLetter + name.substr(driveLetter.length).replace(INVALID_CHAR_REGEX, "_");
}
var publicAssetUrlCache = /* @__PURE__ */ new WeakMap();
var publicAssetUrlRE = /__VITE_PUBLIC_ASSET__([a-z\d]{8})__/g;
function publicFileToBuiltUrl(url2, config2) {
  if (config2.command !== "build") {
    return joinUrlSegments(config2.base, url2);
  }
  const hash = getHash(url2);
  let cache = publicAssetUrlCache.get(config2);
  if (!cache) {
    cache = /* @__PURE__ */ new Map();
    publicAssetUrlCache.set(config2, cache);
  }
  if (!cache.get(hash)) {
    cache.set(hash, url2);
  }
  return `__VITE_PUBLIC_ASSET__${hash}__`;
}
var GIT_LFS_PREFIX = import_node_buffer.Buffer.from("version https://git-lfs.github.com");
function isGitLfsPlaceholder(content) {
  if (content.length < GIT_LFS_PREFIX.length)
    return false;
  return GIT_LFS_PREFIX.compare(content, 0, GIT_LFS_PREFIX.length) === 0;
}
async function fileToBuiltUrl(id, config2, pluginContext, skipPublicCheck = false) {
  var _a;
  if (!skipPublicCheck && checkPublicFile(id, config2)) {
    return publicFileToBuiltUrl(id, config2);
  }
  const cache = assetCache.get(config2);
  const cached = cache.get(id);
  if (cached) {
    return cached;
  }
  const file = cleanUrl(id);
  const content = await import_node_fs.promises.readFile(file);
  let url2;
  if (config2.build.lib || !file.endsWith(".svg") && !file.endsWith(".html") && content.length < Number(config2.build.assetsInlineLimit) && !isGitLfsPlaceholder(content)) {
    if (config2.build.lib && isGitLfsPlaceholder(content)) {
      config2.logger.warn(picocolors.exports.yellow(`Inlined file ${id} was not downloaded via Git LFS`));
    }
    const mimeType = (_a = lookup(file)) != null ? _a : "application/octet-stream";
    url2 = `data:${mimeType};base64,${content.toString("base64")}`;
  } else {
    const map2 = assetHashToFilenameMap.get(config2);
    const contentHash = getHash(content);
    const { search, hash } = (0, import_node_url2.parse)(id);
    const postfix = (search || "") + (hash || "");
    const fileName = assetFileNamesToFileName(resolveAssetFileNames(config2), file, contentHash, content);
    if (!map2.has(contentHash)) {
      map2.set(contentHash, fileName);
    }
    const emittedSet = emittedHashMap.get(config2);
    const duplicates = duplicateAssets.get(config2);
    const name = normalizePath$3(import_node_path2.default.relative(config2.root, file));
    if (!emittedSet.has(contentHash)) {
      pluginContext.emitFile({
        name,
        fileName,
        type: "asset",
        source: content
      });
      emittedSet.add(contentHash);
    } else {
      duplicates.set(name, {
        name,
        fileName: map2.get(contentHash),
        type: "asset",
        source: content,
        isAsset: true
      });
    }
    url2 = `__VITE_ASSET__${contentHash}__${postfix ? `$_${postfix}__` : ``}`;
  }
  cache.set(id, url2);
  return url2;
}
async function urlToBuiltUrl(url2, importer, config2, pluginContext) {
  if (checkPublicFile(url2, config2)) {
    return publicFileToBuiltUrl(url2, config2);
  }
  const file = url2.startsWith("/") ? import_node_path2.default.join(config2.root, url2) : import_node_path2.default.join(import_node_path2.default.dirname(importer), url2);
  return fileToBuiltUrl(
    file,
    config2,
    pluginContext,
    true
  );
}
var A = 1 === new Uint8Array(new Uint16Array([1]).buffer)[0];
function parse$b(E2, g = "@") {
  if (!C)
    return init.then(() => parse$b(E2));
  const I = E2.length + 1, K = (C.__heap_base.value || C.__heap_base) + 4 * I - C.memory.buffer.byteLength;
  K > 0 && C.memory.grow(Math.ceil(K / 65536));
  const k = C.sa(I - 1);
  if ((A ? B : Q)(E2, new Uint16Array(C.memory.buffer, k, I)), !C.parse())
    throw Object.assign(new Error(`Parse error ${g}:${E2.slice(0, C.e()).split("\n").length}:${C.e() - E2.lastIndexOf("\n", C.e() - 1)}`), { idx: C.e() });
  const o = [], D = [];
  for (; C.ri(); ) {
    const A2 = C.is(), Q2 = C.ie(), B2 = C.ai(), g2 = C.id(), I2 = C.ss(), K2 = C.se();
    let k2;
    C.ip() && (k2 = w(E2.slice(-1 === g2 ? A2 - 1 : A2, -1 === g2 ? Q2 + 1 : Q2))), o.push({ n: k2, s: A2, e: Q2, ss: I2, se: K2, d: g2, a: B2 });
  }
  for (; C.re(); ) {
    const A2 = C.es(), Q2 = C.ee(), B2 = C.els(), g2 = C.ele(), I2 = E2.slice(A2, Q2), K2 = I2[0], k2 = B2 < 0 ? void 0 : E2.slice(B2, g2), o2 = k2 ? k2[0] : "";
    D.push({ s: A2, e: Q2, ls: B2, le: g2, n: '"' === K2 || "'" === K2 ? w(I2) : I2, ln: '"' === o2 || "'" === o2 ? w(k2) : k2 });
  }
  function w(A2) {
    try {
      return (0, eval)(A2);
    } catch (A3) {
    }
  }
  return [o, D, !!C.f()];
}
function Q(A2, Q2) {
  const B2 = A2.length;
  let C2 = 0;
  for (; C2 < B2; ) {
    const B3 = A2.charCodeAt(C2);
    Q2[C2++] = (255 & B3) << 8 | B3 >>> 8;
  }
}
function B(A2, Q2) {
  const B2 = A2.length;
  let C2 = 0;
  for (; C2 < B2; )
    Q2[C2] = A2.charCodeAt(C2++);
}
var C;
var init = WebAssembly.compile((E = "AGFzbQEAAAABKghgAX8Bf2AEf39/fwBgAAF/YAAAYAF/AGADf39/AX9gAn9/AX9gAn9/AAMtLAABAQICAgICAgICAgICAgICAgIAAwMDBAQAAAADAAAAAAMDBQYAAAcABgIFBAUBcAEBAQUDAQABBg8CfwFBsPIAC38AQbDyAAsHcBMGbWVtb3J5AgACc2EAAAFlAAMCaXMABAJpZQAFAnNzAAYCc2UABwJhaQAIAmlkAAkCaXAACgJlcwALAmVlAAwDZWxzAA0DZWxlAA4CcmkADwJyZQAQAWYAEQVwYXJzZQASC19faGVhcF9iYXNlAwEKsjssaAEBf0EAIAA2AvgJQQAoAtQJIgEgAEEBdGoiAEEAOwEAQQAgAEECaiIANgL8CUEAIAA2AoAKQQBBADYC2AlBAEEANgLoCUEAQQA2AuAJQQBBADYC3AlBAEEANgLwCUEAQQA2AuQJIAELnwEBA39BACgC6AkhBEEAQQAoAoAKIgU2AugJQQAgBDYC7AlBACAFQSBqNgKACiAEQRxqQdgJIAQbIAU2AgBBACgCzAkhBEEAKALICSEGIAUgATYCACAFIAA2AgggBSACIAJBAmpBACAGIANGGyAEIANGGzYCDCAFIAM2AhQgBUEANgIQIAUgAjYCBCAFQQA2AhwgBUEAKALICSADRjoAGAtWAQF/QQAoAvAJIgRBEGpB3AkgBBtBACgCgAoiBDYCAEEAIAQ2AvAJQQAgBEEUajYCgAogBEEANgIQIAQgAzYCDCAEIAI2AgggBCABNgIEIAQgADYCAAsIAEEAKAKECgsVAEEAKALgCSgCAEEAKALUCWtBAXULHgEBf0EAKALgCSgCBCIAQQAoAtQJa0EBdUF/IAAbCxUAQQAoAuAJKAIIQQAoAtQJa0EBdQseAQF/QQAoAuAJKAIMIgBBACgC1AlrQQF1QX8gABsLHgEBf0EAKALgCSgCECIAQQAoAtQJa0EBdUF/IAAbCzsBAX8CQEEAKALgCSgCFCIAQQAoAsgJRw0AQX8PCwJAIABBACgCzAlHDQBBfg8LIABBACgC1AlrQQF1CwsAQQAoAuAJLQAYCxUAQQAoAuQJKAIAQQAoAtQJa0EBdQsVAEEAKALkCSgCBEEAKALUCWtBAXULHgEBf0EAKALkCSgCCCIAQQAoAtQJa0EBdUF/IAAbCx4BAX9BACgC5AkoAgwiAEEAKALUCWtBAXVBfyAAGwslAQF/QQBBACgC4AkiAEEcakHYCSAAGygCACIANgLgCSAAQQBHCyUBAX9BAEEAKALkCSIAQRBqQdwJIAAbKAIAIgA2AuQJIABBAEcLCABBAC0AiAoL5gwBBn8jAEGA0ABrIgAkAEEAQQE6AIgKQQBBACgC0Ak2ApAKQQBBACgC1AlBfmoiATYCpApBACABQQAoAvgJQQF0aiICNgKoCkEAQQA7AYoKQQBBADsBjApBAEEAOgCUCkEAQQA2AoQKQQBBADoA9AlBACAAQYAQajYCmApBACAANgKcCkEAQQA6AKAKAkACQAJAAkADQEEAIAFBAmoiAzYCpAogASACTw0BAkAgAy8BACICQXdqQQVJDQACQAJAAkACQAJAIAJBm39qDgUBCAgIAgALIAJBIEYNBCACQS9GDQMgAkE7Rg0CDAcLQQAvAYwKDQEgAxATRQ0BIAFBBGpBgghBChArDQEQFEEALQCICg0BQQBBACgCpAoiATYCkAoMBwsgAxATRQ0AIAFBBGpBjAhBChArDQAQFQtBAEEAKAKkCjYCkAoMAQsCQCABLwEEIgNBKkYNACADQS9HDQQQFgwBC0EBEBcLQQAoAqgKIQJBACgCpAohAQwACwtBACECIAMhAUEALQD0CQ0CDAELQQAgATYCpApBAEEAOgCICgsDQEEAIAFBAmoiAzYCpAoCQAJAAkACQAJAAkACQAJAAkAgAUEAKAKoCk8NACADLwEAIgJBd2pBBUkNCAJAAkACQAJAAkACQAJAAkACQAJAIAJBYGoOChIRBhEREREFAQIACwJAAkACQAJAIAJBoH9qDgoLFBQDFAEUFBQCAAsgAkGFf2oOAwUTBgkLQQAvAYwKDRIgAxATRQ0SIAFBBGpBgghBChArDRIQFAwSCyADEBNFDREgAUEEakGMCEEKECsNERAVDBELIAMQE0UNECABKQAEQuyAhIOwjsA5Ug0QIAEvAQwiA0F3aiIBQRdLDQ5BASABdEGfgIAEcUUNDgwPC0EAQQAvAYwKIgFBAWo7AYwKQQAoApgKIAFBA3RqIgFBATYCACABQQAoApAKNgIEDA8LQQAvAYwKIgJFDQtBACACQX9qIgQ7AYwKQQAvAYoKIgJFDQ4gAkECdEEAKAKcCmpBfGooAgAiBSgCFEEAKAKYCiAEQf//A3FBA3RqKAIERw0OAkAgBSgCBA0AIAUgAzYCBAtBACACQX9qOwGKCiAFIAFBBGo2AgwMDgsCQEEAKAKQCiIBLwEAQSlHDQBBACgC6AkiA0UNACADKAIEIAFHDQBBAEEAKALsCSIDNgLoCQJAIANFDQAgA0EANgIcDAELQQBBADYC2AkLQQBBAC8BjAoiA0EBajsBjApBACgCmAogA0EDdGoiA0EGQQJBAC0AoAobNgIAIAMgATYCBEEAQQA6AKAKDA0LQQAvAYwKIgFFDQlBACABQX9qIgE7AYwKQQAoApgKIAFB//8DcUEDdGooAgBBBEYNBAwMC0EnEBgMCwtBIhAYDAoLIAJBL0cNCQJAAkAgAS8BBCIBQSpGDQAgAUEvRw0BEBYMDAtBARAXDAsLAkACQEEAKAKQCiIBLwEAIgMQGUUNAAJAAkAgA0FVag4EAAgBAwgLIAFBfmovAQBBK0YNBgwHCyABQX5qLwEAQS1GDQUMBgsCQCADQf0ARg0AIANBKUcNBUEAKAKYCkEALwGMCkEDdGooAgQQGkUNBQwGC0EAKAKYCkEALwGMCkEDdGoiAigCBBAbDQUgAigCAEEGRg0FDAQLIAFBfmovAQBBUGpB//8DcUEKSQ0DDAQLQQAoApgKQQAvAYwKIgFBA3QiA2pBACgCkAo2AgRBACABQQFqOwGMCkEAKAKYCiADakEDNgIACxAcDAcLQQAtAPQJQQAvAYoKQQAvAYwKcnJFIQIMCQsgARAdDQAgA0UNACADQS9GQQAtAJQKQQBHcQ0AIAFBfmohAUEAKALUCSECAkADQCABQQJqIgQgAk0NAUEAIAE2ApAKIAEvAQAhAyABQX5qIgQhASADEB5FDQALIARBAmohBAtBASEFIANB//8DcRAfRQ0BIARBfmohAQJAA0AgAUECaiIDIAJNDQFBACABNgKQCiABLwEAIQMgAUF+aiIEIQEgAxAfDQALIARBAmohAwsgAxAgRQ0BECFBAEEAOgCUCgwFCxAhQQAhBQtBACAFOgCUCgwDCxAiQQAhAgwFCyADQaABRw0BC0EAQQE6AKAKC0EAQQAoAqQKNgKQCgtBACgCpAohAQwACwsgAEGA0ABqJAAgAgsdAAJAQQAoAtQJIABHDQBBAQ8LIABBfmovAQAQHgvFCgEHf0EAQQAoAqQKIgBBDGoiATYCpApBACgC8AkhAkEBECYhAwJAAkACQAJAAkACQAJAQQAoAqQKIgQgAUcNACADECVFDQELAkACQAJAAkAgA0EqRg0AIANB+wBHDQFBACAEQQJqNgKkCkEBECYhBEEAKAKkCiEBA0ACQAJAIARB//8DcSIDQSJGDQAgA0EnRg0AIAMQKBpBACgCpAohAwwBCyADEBhBAEEAKAKkCkECaiIDNgKkCgtBARAmGgJAIAEgAxApIgRBLEcNAEEAQQAoAqQKQQJqNgKkCkEBECYhBAtBACgCpAohAyAEQf0ARg0DIAMgAUYNCiADIQEgA0EAKAKoCk0NAAwKCwtBACAEQQJqNgKkCkEBECYaQQAoAqQKIgMgAxApGgwCC0EAQQA6AIgKAkACQAJAAkACQAJAIANBn39qDgwCCAQBCAMICAgICAUACyADQfYARg0EDAcLQQAgBEEOaiIANgKkCkHhACEDAkBBARAmIgJB4QBHDQBBACEBQQAoAqQKIgIQE0UNCyACKQACQvOA5IPgjcAxUg0LIAIvAQoQH0UNC0EAIAJBCmo2AqQKQQAQJiECC0HmACEDQQAhASACQeYARw0JQQAhAUEAKAKkCiICEBNFDQogAkECakGkCEEOECsNCiACLwEQIgVBd2oiBkEXSw0HQQEgBnRBn4CABHFFDQcMCAtBACAEQQpqNgKkCkEBECYaQQAoAqQKIQQLQQAgBEEQajYCpAoCQEEBECYiBEEqRw0AQQBBACgCpApBAmo2AqQKQQEQJiEEC0EAKAKkCiEDIAQQKBogA0EAKAKkCiIEIAMgBBACQQBBACgCpApBfmo2AqQKDwsCQCAEKQACQuyAhIOwjsA5Ug0AIAQvAQoQHkUNAEEAIARBCmo2AqQKQQEQJiEEQQAoAqQKIQMgBBAoGiADQQAoAqQKIgQgAyAEEAJBAEEAKAKkCkF+ajYCpAoPC0EAIARBBGoiBDYCpAoLQQAgBEEEaiIDNgKkCkEAQQA6AIgKAkADQEEAIANBAmo2AqQKQQEQJiEEQQAoAqQKIQMgBBAoQSByQfsARg0BQQAoAqQKIgQgA0YNBCADIAQgAyAEEAJBARAmQSxHDQFBACgCpAohAwwACwtBAEEAKAKkCkF+ajYCpAoPC0EAIANBAmo2AqQKC0EBECYhBEEAKAKkCiEDAkAgBEHmAEcNACADQQJqQZ4IQQYQKw0AQQAgA0EIajYCpAogAEEBECYQJyACQRBqQdwJIAIbIQMDQCADKAIAIgNFDQIgA0IANwIIIANBEGohAwwACwtBACADQX5qNgKkCgsPCwJAIAVBWGoOAwEDAQALIAVBoAFHDQILQQAgAkEQajYCpApBASEBAkBBARAmIgJBKkcNAEEAQQAoAqQKQQJqNgKkCkEBECYhAgsgAkEoRw0AIAQgAEEAQQAQAkEAIARBDGo2AqQKDwtB4wAhAwJAIAJB4wBGDQAgAiEDDAELQQAoAqQKIgIQE0UNACACKQACQuyAhIOwjsA5Ug0AAkACQCACLwEKIgVBd2oiBkEXSw0AQQEgBnRBn4CABHENAQsgBUGgAUYNACAFQfsARw0BC0EAIAJBCmo2AqQKQQEhAUEBECYiA0H7AEcNACAEIABBAEEAEAJBACAEQQxqNgKkCg8LQQAoAqQKIQIgAxAoGgJAAkAgAUUNAEEAKAKkCiIDIAJNDQAgBCAAIAIgAxACQQAoAqQKQX5qIQMMAQsgBCAAQQBBABACIARBDGohAwtBACADNgKkCg8LECILvgYBBH9BAEEAKAKkCiIAQQxqIgE2AqQKAkACQAJAAkACQAJAAkACQAJAAkBBARAmIgJBWWoOCAQCAQQBAQEDAAsgAkEiRg0DIAJB+wBGDQQLQQAoAqQKIAFHDQJBACAAQQpqNgKkCg8LQQAoApgKQQAvAYwKIgJBA3RqIgFBACgCpAo2AgRBACACQQFqOwGMCiABQQU2AgBBACgCkAovAQBBLkYNA0EAQQAoAqQKIgFBAmo2AqQKQQEQJiECIABBACgCpApBACABEAFBAEEALwGKCiIBQQFqOwGKCkEAKAKcCiABQQJ0akEAKALoCTYCAAJAIAJBIkYNACACQSdGDQBBAEEAKAKkCkF+ajYCpAoPCyACEBhBAEEAKAKkCkECaiICNgKkCgJAAkACQEEBECZBV2oOBAECAgACC0EAQQAoAqQKQQJqNgKkCkEBECYaQQAoAugJIgEgAjYCBCABQQE6ABggAUEAKAKkCiICNgIQQQAgAkF+ajYCpAoPC0EAKALoCSIBIAI2AgQgAUEBOgAYQQBBAC8BjApBf2o7AYwKIAFBACgCpApBAmo2AgxBAEEALwGKCkF/ajsBigoPC0EAQQAoAqQKQX5qNgKkCg8LQQBBACgCpApBAmo2AqQKQQEQJkHtAEcNAkEAKAKkCiICQQJqQZYIQQYQKw0CQQAoApAKLwEAQS5GDQIgACAAIAJBCGpBACgCzAkQAQ8LQQAvAYwKDQJBACgCpAohAkEAKAKoCiEDA0AgAiADTw0FAkACQCACLwEAIgFBJ0YNACABQSJHDQELIAAgARAnDwtBACACQQJqIgI2AqQKDAALC0EAKAKkCiECQQAvAYwKDQICQANAAkACQAJAIAJBACgCqApPDQBBARAmIgJBIkYNASACQSdGDQEgAkH9AEcNAkEAQQAoAqQKQQJqNgKkCgtBARAmGkEAKAKkCiICKQAAQuaAyIPwjcA2Ug0HQQAgAkEIajYCpApBARAmIgJBIkYNAyACQSdGDQMMBwsgAhAYC0EAQQAoAqQKQQJqIgI2AqQKDAALCyAAIAIQJwsPC0EAQQAoAqQKQX5qNgKkCg8LQQAgAkF+ajYCpAoPCxAiC0cBA39BACgCpApBAmohAEEAKAKoCiEBAkADQCAAIgJBfmogAU8NASACQQJqIQAgAi8BAEF2ag4EAQAAAQALC0EAIAI2AqQKC5gBAQN/QQBBACgCpAoiAUECajYCpAogAUEGaiEBQQAoAqgKIQIDQAJAAkACQCABQXxqIAJPDQAgAUF+ai8BACEDAkACQCAADQAgA0EqRg0BIANBdmoOBAIEBAIECyADQSpHDQMLIAEvAQBBL0cNAkEAIAFBfmo2AqQKDAELIAFBfmohAQtBACABNgKkCg8LIAFBAmohAQwACwuIAQEEf0EAKAKkCiEBQQAoAqgKIQICQAJAA0AgASIDQQJqIQEgAyACTw0BIAEvAQAiBCAARg0CAkAgBEHcAEYNACAEQXZqDgQCAQECAQsgA0EEaiEBIAMvAQRBDUcNACADQQZqIAEgAy8BBkEKRhshAQwACwtBACABNgKkChAiDwtBACABNgKkCgtsAQF/AkACQCAAQV9qIgFBBUsNAEEBIAF0QTFxDQELIABBRmpB//8DcUEGSQ0AIABBKUcgAEFYakH//wNxQQdJcQ0AAkAgAEGlf2oOBAEAAAEACyAAQf0ARyAAQYV/akH//wNxQQRJcQ8LQQELLgEBf0EBIQECQCAAQZgJQQUQIw0AIABBoglBAxAjDQAgAEGoCUECECMhAQsgAQuDAQECf0EBIQECQAJAAkACQAJAAkAgAC8BACICQUVqDgQFBAQBAAsCQCACQZt/ag4EAwQEAgALIAJBKUYNBCACQfkARw0DIABBfmpBtAlBBhAjDwsgAEF+ai8BAEE9Rg8LIABBfmpBrAlBBBAjDwsgAEF+akHACUEDECMPC0EAIQELIAEL3gEBBH9BACgCpAohAEEAKAKoCiEBAkACQAJAA0AgACICQQJqIQAgAiABTw0BAkACQAJAIAAvAQAiA0Gkf2oOBQIDAwMBAAsgA0EkRw0CIAIvAQRB+wBHDQJBACACQQRqIgA2AqQKQQBBAC8BjAoiAkEBajsBjApBACgCmAogAkEDdGoiAkEENgIAIAIgADYCBA8LQQAgADYCpApBAEEALwGMCkF/aiIAOwGMCkEAKAKYCiAAQf//A3FBA3RqKAIAQQNHDQMMBAsgAkEEaiEADAALC0EAIAA2AqQKCxAiCwu0AwECf0EAIQECQAJAAkACQAJAAkACQAJAAkACQCAALwEAQZx/ag4UAAECCQkJCQMJCQQFCQkGCQcJCQgJCwJAAkAgAEF+ai8BAEGXf2oOBAAKCgEKCyAAQXxqQbwIQQIQIw8LIABBfGpBwAhBAxAjDwsCQAJAAkAgAEF+ai8BAEGNf2oOAwABAgoLAkAgAEF8ai8BACICQeEARg0AIAJB7ABHDQogAEF6akHlABAkDwsgAEF6akHjABAkDwsgAEF8akHGCEEEECMPCyAAQXxqQc4IQQYQIw8LIABBfmovAQBB7wBHDQYgAEF8ai8BAEHlAEcNBgJAIABBemovAQAiAkHwAEYNACACQeMARw0HIABBeGpB2ghBBhAjDwsgAEF4akHmCEECECMPCyAAQX5qQeoIQQQQIw8LQQEhASAAQX5qIgBB6QAQJA0EIABB8ghBBRAjDwsgAEF+akHkABAkDwsgAEF+akH8CEEHECMPCyAAQX5qQYoJQQQQIw8LAkAgAEF+ai8BACICQe8ARg0AIAJB5QBHDQEgAEF8akHuABAkDwsgAEF8akGSCUEDECMhAQsgAQs0AQF/QQEhAQJAIABBd2pB//8DcUEFSQ0AIABBgAFyQaABRg0AIABBLkcgABAlcSEBCyABCzABAX8CQAJAIABBd2oiAUEXSw0AQQEgAXRBjYCABHENAQsgAEGgAUYNAEEADwtBAQtOAQJ/QQAhAQJAAkAgAC8BACICQeUARg0AIAJB6wBHDQEgAEF+akHqCEEEECMPCyAAQX5qLwEAQfUARw0AIABBfGpBzghBBhAjIQELIAELcAECfwJAAkADQEEAQQAoAqQKIgBBAmoiATYCpAogAEEAKAKoCk8NAQJAAkACQCABLwEAIgFBpX9qDgIBAgALAkAgAUF2ag4EBAMDBAALIAFBL0cNAgwECxAqGgwBC0EAIABBBGo2AqQKDAALCxAiCws1AQF/QQBBAToA9AlBACgCpAohAEEAQQAoAqgKQQJqNgKkCkEAIABBACgC1AlrQQF1NgKECgtJAQN/QQAhAwJAIAAgAkEBdCICayIEQQJqIgBBACgC1AkiBUkNACAAIAEgAhArDQACQCAAIAVHDQBBAQ8LIAQvAQAQHiEDCyADCz0BAn9BACECAkBBACgC1AkiAyAASw0AIAAvAQAgAUcNAAJAIAMgAEcNAEEBDwsgAEF+ai8BABAeIQILIAILaAECf0EBIQECQAJAIABBX2oiAkEFSw0AQQEgAnRBMXENAQsgAEH4/wNxQShGDQAgAEFGakH//wNxQQZJDQACQCAAQaV/aiICQQNLDQAgAkEBRw0BCyAAQYV/akH//wNxQQRJIQELIAELnAEBA39BACgCpAohAQJAA0ACQAJAIAEvAQAiAkEvRw0AAkAgAS8BAiIBQSpGDQAgAUEvRw0EEBYMAgsgABAXDAELAkACQCAARQ0AIAJBd2oiAUEXSw0BQQEgAXRBn4CABHFFDQEMAgsgAhAfRQ0DDAELIAJBoAFHDQILQQBBACgCpAoiA0ECaiIBNgKkCiADQQAoAqgKSQ0ACwsgAgvCAwEBfwJAIAFBIkYNACABQSdGDQAQIg8LQQAoAqQKIQIgARAYIAAgAkECakEAKAKkCkEAKALICRABQQBBACgCpApBAmo2AqQKQQAQJiEAQQAoAqQKIQECQAJAIABB4QBHDQAgAUECakGyCEEKECtFDQELQQAgAUF+ajYCpAoPC0EAIAFBDGo2AqQKAkBBARAmQfsARg0AQQAgATYCpAoPC0EAKAKkCiICIQADQEEAIABBAmo2AqQKAkACQAJAQQEQJiIAQSJGDQAgAEEnRw0BQScQGEEAQQAoAqQKQQJqNgKkCkEBECYhAAwCC0EiEBhBAEEAKAKkCkECajYCpApBARAmIQAMAQsgABAoIQALAkAgAEE6Rg0AQQAgATYCpAoPC0EAQQAoAqQKQQJqNgKkCgJAQQEQJiIAQSJGDQAgAEEnRg0AQQAgATYCpAoPCyAAEBhBAEEAKAKkCkECajYCpAoCQAJAQQEQJiIAQSxGDQAgAEH9AEYNAUEAIAE2AqQKDwtBAEEAKAKkCkECajYCpApBARAmQf0ARg0AQQAoAqQKIQAMAQsLQQAoAugJIgEgAjYCECABQQAoAqQKQQJqNgIMC20BAn8CQAJAA0ACQCAAQf//A3EiAUF3aiICQRdLDQBBASACdEGfgIAEcQ0CCyABQaABRg0BIAAhAiABECUNAkEAIQJBAEEAKAKkCiIAQQJqNgKkCiAALwECIgANAAwCCwsgACECCyACQf//A3ELqwEBBH8CQAJAQQAoAqQKIgIvAQAiA0HhAEYNACABIQQgACEFDAELQQAgAkEEajYCpApBARAmIQJBACgCpAohBQJAAkAgAkEiRg0AIAJBJ0YNACACECgaQQAoAqQKIQQMAQsgAhAYQQBBACgCpApBAmoiBDYCpAoLQQEQJiEDQQAoAqQKIQILAkAgAiAFRg0AIAUgBEEAIAAgACABRiICG0EAIAEgAhsQAgsgAwtyAQR/QQAoAqQKIQBBACgCqAohAQJAAkADQCAAQQJqIQIgACABTw0BAkACQCACLwEAIgNBpH9qDgIBBAALIAIhACADQXZqDgQCAQECAQsgAEEEaiEADAALC0EAIAI2AqQKECJBAA8LQQAgAjYCpApB3QALSQEDf0EAIQMCQCACRQ0AAkADQCAALQAAIgQgAS0AACIFRw0BIAFBAWohASAAQQFqIQAgAkF/aiICDQAMAgsLIAQgBWshAwsgAwsL5AECAEGACAvGAQAAeABwAG8AcgB0AG0AcABvAHIAdABlAHQAYQBmAHIAbwBtAHUAbgBjAHQAaQBvAG4AcwBzAGUAcgB0AHYAbwB5AGkAZQBkAGUAbABlAGMAbwBuAHQAaQBuAGkAbgBzAHQAYQBuAHQAeQBiAHIAZQBhAHIAZQB0AHUAcgBkAGUAYgB1AGcAZwBlAGEAdwBhAGkAdABoAHIAdwBoAGkAbABlAGYAbwByAGkAZgBjAGEAdABjAGYAaQBuAGEAbABsAGUAbABzAABByAkLEAEAAAACAAAAAAQAADA5AAA=", "undefined" != typeof Buffer ? Buffer.from(E, "base64") : Uint8Array.from(atob(E), (A2) => A2.charCodeAt(0)))).then(WebAssembly.instantiate).then(({ exports: A2 }) => {
  C = A2;
});
var E;
function loop(exports, keys) {
  if (typeof exports === "string") {
    return exports;
  }
  if (exports) {
    let idx, tmp;
    if (Array.isArray(exports)) {
      for (idx = 0; idx < exports.length; idx++) {
        if (tmp = loop(exports[idx], keys))
          return tmp;
      }
    } else {
      for (idx in exports) {
        if (keys.has(idx)) {
          return loop(exports[idx], keys);
        }
      }
    }
  }
}
function bail(name, entry2, condition) {
  throw new Error(
    condition ? `No known conditions for "${entry2}" entry in "${name}" package` : `Missing "${entry2}" export in "${name}" package`
  );
}
function toName(name, entry2) {
  return entry2 === name ? "." : entry2[0] === "." ? entry2 : entry2.replace(new RegExp("^" + name + "/"), "./");
}
function resolve2(pkg, entry2 = ".", options3 = {}) {
  let { name, exports } = pkg;
  if (exports) {
    let { browser: browser2, require: require3, unsafe, conditions = [] } = options3;
    let target = toName(name, entry2);
    if (target[0] !== ".")
      target = "./" + target;
    if (typeof exports === "string") {
      return target === "." ? exports : bail(name, target);
    }
    let allows = /* @__PURE__ */ new Set(["default", ...conditions]);
    unsafe || allows.add(require3 ? "require" : "import");
    unsafe || allows.add(browser2 ? "browser" : "node");
    let key2, tmp, isSingle = false;
    for (key2 in exports) {
      isSingle = key2[0] !== ".";
      break;
    }
    if (isSingle) {
      return target === "." ? loop(exports, allows) || bail(name, target, 1) : bail(name, target);
    }
    if (tmp = exports[target]) {
      return loop(tmp, allows) || bail(name, target, 1);
    }
    for (key2 in exports) {
      tmp = key2[key2.length - 1];
      if (tmp === "/" && target.startsWith(key2)) {
        return (tmp = loop(exports[key2], allows)) ? tmp + target.substring(key2.length) : bail(name, target, 1);
      }
      if (tmp === "*" && target.startsWith(key2.slice(0, -1))) {
        if (target.substring(key2.length - 1).length > 0) {
          return (tmp = loop(exports[key2], allows)) ? tmp.replace("*", target.substring(key2.length - 1)) : bail(name, target, 1);
        }
      }
    }
    return bail(name, target);
  }
}
var HASH_RE = /#/g;
var AMPERSAND_RE = /&/g;
var EQUAL_RE = /=/g;
var PLUS_RE = /\+/g;
var ENC_BRACKET_OPEN_RE = /%5B/gi;
var ENC_BRACKET_CLOSE_RE = /%5D/gi;
var ENC_CARET_RE = /%5E/gi;
var ENC_BACKTICK_RE = /%60/gi;
var ENC_CURLY_OPEN_RE = /%7B/gi;
var ENC_PIPE_RE = /%7C/gi;
var ENC_CURLY_CLOSE_RE = /%7D/gi;
var ENC_SPACE_RE = /%20/gi;
function encode(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
}
function encodeQueryValue(text) {
  return encode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function encodeQueryItem(key2, val) {
  if (typeof val === "number" || typeof val === "boolean") {
    val = String(val);
  }
  if (!val) {
    return encodeQueryKey(key2);
  }
  if (Array.isArray(val)) {
    return val.map((_val) => `${encodeQueryKey(key2)}=${encodeQueryValue(_val)}`).join("&");
  }
  return `${encodeQueryKey(key2)}=${encodeQueryValue(val)}`;
}
function stringifyQuery(query) {
  return Object.keys(query).map((k) => encodeQueryItem(k, query[k])).join("&");
}
function matchAll(regex, string2, addition) {
  const matches2 = [];
  for (const match of string2.matchAll(regex)) {
    matches2.push({
      ...addition,
      ...match.groups,
      code: match[0],
      start: match.index,
      end: match.index + match[0].length
    });
  }
  return matches2;
}
var isWindows$3 = process.platform === "win32";
var own$1 = {}.hasOwnProperty;
var messages = /* @__PURE__ */ new Map();
var nodeInternalPrefix = "__node_internal_";
var userStackTraceLimit;
createError(
  "ERR_INVALID_MODULE_SPECIFIER",
  (request, reason, base2 = void 0) => {
    return `Invalid module "${request}" ${reason}${base2 ? ` imported from ${base2}` : ""}`;
  },
  TypeError
);
createError(
  "ERR_INVALID_PACKAGE_CONFIG",
  (path4, base2, message) => {
    return `Invalid package config ${path4}${base2 ? ` while importing ${base2}` : ""}${message ? `. ${message}` : ""}`;
  },
  Error
);
createError(
  "ERR_INVALID_PACKAGE_TARGET",
  (pkgPath, key2, target, isImport = false, base2 = void 0) => {
    const relError = typeof target === "string" && !isImport && target.length > 0 && !target.startsWith("./");
    if (key2 === ".") {
      (0, import_assert.default)(isImport === false);
      return `Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${pkgPath}package.json${base2 ? ` imported from ${base2}` : ""}${relError ? '; targets must start with "./"' : ""}`;
    }
    return `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(
      target
    )} defined for '${key2}' in the package config ${pkgPath}package.json${base2 ? ` imported from ${base2}` : ""}${relError ? '; targets must start with "./"' : ""}`;
  },
  Error
);
createError(
  "ERR_MODULE_NOT_FOUND",
  (path4, base2, type = "package") => {
    return `Cannot find ${type} '${path4}' imported from ${base2}`;
  },
  Error
);
createError(
  "ERR_PACKAGE_IMPORT_NOT_DEFINED",
  (specifier, packagePath, base2) => {
    return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base2}`;
  },
  TypeError
);
createError(
  "ERR_PACKAGE_PATH_NOT_EXPORTED",
  (pkgPath, subpath, base2 = void 0) => {
    if (subpath === ".") {
      return `No "exports" main defined in ${pkgPath}package.json${base2 ? ` imported from ${base2}` : ""}`;
    }
    return `Package subpath '${subpath}' is not defined by "exports" in ${pkgPath}package.json${base2 ? ` imported from ${base2}` : ""}`;
  },
  Error
);
createError(
  "ERR_UNSUPPORTED_DIR_IMPORT",
  "Directory import '%s' is not supported resolving ES modules imported from %s",
  Error
);
createError(
  "ERR_UNKNOWN_FILE_EXTENSION",
  'Unknown file extension "%s" for %s',
  TypeError
);
createError(
  "ERR_INVALID_ARG_VALUE",
  (name, value2, reason = "is invalid") => {
    let inspected = (0, import_util.inspect)(value2);
    if (inspected.length > 128) {
      inspected = `${inspected.slice(0, 128)}...`;
    }
    const type = name.includes(".") ? "property" : "argument";
    return `The ${type} '${name}' ${reason}. Received ${inspected}`;
  },
  TypeError
);
createError(
  "ERR_UNSUPPORTED_ESM_URL_SCHEME",
  (url2) => {
    let message = "Only file and data URLs are supported by the default ESM loader";
    if (isWindows$3 && url2.protocol.length === 2) {
      message += ". On Windows, absolute paths must be valid file:// URLs";
    }
    message += `. Received protocol '${url2.protocol}'`;
    return message;
  },
  Error
);
function createError(sym, value2, def) {
  messages.set(sym, value2);
  return makeNodeErrorWithCode(def, sym);
}
function makeNodeErrorWithCode(Base, key2) {
  return NodeError;
  function NodeError(...args) {
    const limit = Error.stackTraceLimit;
    if (isErrorStackTraceLimitWritable()) {
      Error.stackTraceLimit = 0;
    }
    const error2 = new Base();
    if (isErrorStackTraceLimitWritable()) {
      Error.stackTraceLimit = limit;
    }
    const message = getMessage(key2, args, error2);
    Object.defineProperty(error2, "message", {
      value: message,
      enumerable: false,
      writable: true,
      configurable: true
    });
    Object.defineProperty(error2, "toString", {
      value() {
        return `${this.name} [${key2}]: ${this.message}`;
      },
      enumerable: false,
      writable: true,
      configurable: true
    });
    addCodeToName(error2, Base.name, key2);
    error2.code = key2;
    return error2;
  }
}
var addCodeToName = hideStackFrames(
  function(error2, name, code) {
    error2 = captureLargerStackTrace(error2);
    error2.name = `${name} [${code}]`;
    if (name === "SystemError") {
      Object.defineProperty(error2, "name", {
        value: name,
        enumerable: false,
        writable: true,
        configurable: true
      });
    } else {
      delete error2.name;
    }
  }
);
function isErrorStackTraceLimitWritable() {
  const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
  if (desc === void 0) {
    return Object.isExtensible(Error);
  }
  return own$1.call(desc, "writable") ? desc.writable : desc.set !== void 0;
}
function hideStackFrames(fn) {
  const hidden = nodeInternalPrefix + fn.name;
  Object.defineProperty(fn, "name", { value: hidden });
  return fn;
}
var captureLargerStackTrace = hideStackFrames(
  function(error2) {
    const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
    if (stackTraceLimitIsWritable) {
      userStackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = Number.POSITIVE_INFINITY;
    }
    Error.captureStackTrace(error2);
    if (stackTraceLimitIsWritable) {
      Error.stackTraceLimit = userStackTraceLimit;
    }
    return error2;
  }
);
function getMessage(key2, args, self2) {
  const message = messages.get(key2);
  if (typeof message === "function") {
    (0, import_assert.default)(
      message.length <= args.length,
      `Code: ${key2}; The provided arguments length (${args.length}) does not match the required ones (${message.length}).`
    );
    return Reflect.apply(message, self2, args);
  }
  const expectedLength = (message.match(/%[dfijoOs]/g) || []).length;
  (0, import_assert.default)(
    expectedLength === args.length,
    `Code: ${key2}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
  );
  if (args.length === 0) {
    return message;
  }
  args.unshift(message);
  return Reflect.apply(import_util.format, null, args);
}
Object.freeze(["node", "import"]);
(0, import_url.pathToFileURL)(process.cwd());
var ESM_STATIC_IMPORT_RE = new RegExp(`(?<=\\s|^|;)import\\s*(["'\\s]*(?<imports>[\\w*\${}\\n\\r\\t, /]+)from\\s*)?["']\\s*(?<specifier>(?<="\\s*)[^"]*[^"\\s](?=\\s*")|(?<='\\s*)[^']*[^'\\s](?=\\s*'))\\s*["'][\\s;]*`, "gm");
function findStaticImports(code) {
  return matchAll(ESM_STATIC_IMPORT_RE, code, { type: "static" });
}
function parseStaticImport(matched) {
  var _a, _b, _c, _d;
  const cleanedImports = (matched.imports || "").replace(/(\/\/[^\n]*\n|\/\*.*\*\/)/g, "").replace(/\s+/g, " ");
  const namedImports = {};
  for (const namedImport of ((_b = (_a = cleanedImports.match(/\{([^}]*)\}/)) == null ? void 0 : _a[1]) == null ? void 0 : _b.split(",")) || []) {
    const [, source2 = namedImport.trim(), importName = source2] = namedImport.match(/^\s*([^\s]*) as ([^\s]*)\s*$/) || [];
    if (source2) {
      namedImports[source2] = importName;
    }
  }
  const topLevelImports = cleanedImports.replace(/\{([^}]*)\}/, "");
  const namespacedImport = (_c = topLevelImports.match(/\* as \s*([^\s]*)/)) == null ? void 0 : _c[1];
  const defaultImport = ((_d = topLevelImports.split(",").find((i) => !i.match(/[*{}]/))) == null ? void 0 : _d.trim()) || void 0;
  return {
    ...matched,
    defaultImport,
    namespacedImport,
    namedImports
  };
}
var ESM_RE = /([\s;]|^)(import[\w,{}\s*]*from|import\s*['"*{]|export\b\s*(?:[*{]|default|class|type|function|const|var|let|async function)|import\.meta\b)/m;
function hasESMSyntax(code) {
  return ESM_RE.test(code);
}
var isDebug$5 = process.env.DEBUG;
var debug$d = createDebugger("vite:resolve-details", {
  onlyWhenFocused: true
});
function invalidatePackageData(packageCache, pkgPath) {
  packageCache.delete(pkgPath);
  const pkgDir = import_node_path2.default.dirname(pkgPath);
  packageCache.forEach((pkg, cacheKey) => {
    if (pkg.dir === pkgDir) {
      packageCache.delete(cacheKey);
    }
  });
}
function resolvePackageData(id, basedir, preserveSymlinks = false, packageCache) {
  let pkg;
  let cacheKey;
  if (packageCache) {
    cacheKey = `${id}&${basedir}&${preserveSymlinks}`;
    if (pkg = packageCache.get(cacheKey)) {
      return pkg;
    }
  }
  let pkgPath;
  try {
    pkgPath = resolveFrom(`${id}/package.json`, basedir, preserveSymlinks);
    pkg = loadPackageData(pkgPath, true, packageCache);
    if (packageCache) {
      packageCache.set(cacheKey, pkg);
    }
    return pkg;
  } catch (e) {
    if (e instanceof SyntaxError) {
      isDebug$5 && debug$d(`Parsing failed: ${pkgPath}`);
    } else if (e.code !== "MODULE_NOT_FOUND") {
      throw e;
    }
  }
  return null;
}
function loadPackageData(pkgPath, preserveSymlinks, packageCache) {
  if (!preserveSymlinks) {
    pkgPath = import_node_fs.default.realpathSync.native(pkgPath);
  }
  let cached;
  if (cached = packageCache == null ? void 0 : packageCache.get(pkgPath)) {
    return cached;
  }
  const data2 = JSON.parse(import_node_fs.default.readFileSync(pkgPath, "utf-8"));
  const pkgDir = import_node_path2.default.dirname(pkgPath);
  const { sideEffects } = data2;
  let hasSideEffects;
  if (typeof sideEffects === "boolean") {
    hasSideEffects = () => sideEffects;
  } else if (Array.isArray(sideEffects)) {
    hasSideEffects = createFilter3(sideEffects, null, { resolve: pkgDir });
  } else {
    hasSideEffects = () => true;
  }
  const pkg = {
    dir: pkgDir,
    data: data2,
    hasSideEffects,
    webResolvedImports: {},
    nodeResolvedImports: {},
    setResolvedCache(key2, entry2, targetWeb) {
      if (targetWeb) {
        pkg.webResolvedImports[key2] = entry2;
      } else {
        pkg.nodeResolvedImports[key2] = entry2;
      }
    },
    getResolvedCache(key2, targetWeb) {
      if (targetWeb) {
        return pkg.webResolvedImports[key2];
      } else {
        return pkg.nodeResolvedImports[key2];
      }
    }
  };
  packageCache == null ? void 0 : packageCache.set(pkgPath, pkg);
  return pkg;
}
function watchPackageDataPlugin(config2) {
  const watchQueue = /* @__PURE__ */ new Set();
  let watchFile = (id) => {
    watchQueue.add(id);
  };
  const { packageCache } = config2;
  const setPackageData = packageCache.set.bind(packageCache);
  packageCache.set = (id, pkg) => {
    if (id.endsWith(".json")) {
      watchFile(id);
    }
    return setPackageData(id, pkg);
  };
  return {
    name: "vite:watch-package-data",
    buildStart() {
      watchFile = this.addWatchFile;
      watchQueue.forEach(watchFile);
      watchQueue.clear();
    },
    buildEnd() {
      watchFile = (id) => watchQueue.add(id);
    },
    watchChange(id) {
      if (id.endsWith("/package.json")) {
        invalidatePackageData(packageCache, id);
      }
    }
  };
}
var WORKER_FILE_ID = "worker_file";
var workerCache = /* @__PURE__ */ new WeakMap();
function isWorkerRequest(id) {
  const query = parseRequest(id);
  if (query && query[WORKER_FILE_ID] != null) {
    return true;
  }
  return false;
}
function saveEmitWorkerAsset(config2, asset) {
  const fileName = asset.fileName;
  const workerMap = workerCache.get(config2.mainConfig || config2);
  workerMap.assets.set(fileName, asset);
}
async function bundleWorkerEntry(config2, id, query) {
  const { rollup } = await import("./rollup.browser-ZYVR36BO.js");
  const { plugins: plugins2, rollupOptions, format: format2 } = config2.worker;
  const bundle = await rollup({
    ...rollupOptions,
    input: cleanUrl(id),
    plugins: plugins2,
    onwarn(warning, warn2) {
      onRollupWarning(warning, warn2, config2);
    },
    preserveEntrySignatures: false
  });
  let chunk;
  try {
    const workerOutputConfig = config2.worker.rollupOptions.output;
    const workerConfig = workerOutputConfig ? Array.isArray(workerOutputConfig) ? workerOutputConfig[0] || {} : workerOutputConfig : {};
    const { output: [outputChunk, ...outputChunks] } = await bundle.generate({
      entryFileNames: import_node_path2.default.posix.join(config2.build.assetsDir, "[name].[hash].js"),
      chunkFileNames: import_node_path2.default.posix.join(config2.build.assetsDir, "[name].[hash].js"),
      assetFileNames: import_node_path2.default.posix.join(config2.build.assetsDir, "[name].[hash].[ext]"),
      ...workerConfig,
      format: format2,
      sourcemap: config2.build.sourcemap
    });
    chunk = outputChunk;
    outputChunks.forEach((outputChunk2) => {
      if (outputChunk2.type === "asset") {
        saveEmitWorkerAsset(config2, outputChunk2);
      } else if (outputChunk2.type === "chunk") {
        saveEmitWorkerAsset(config2, {
          fileName: outputChunk2.fileName,
          source: outputChunk2.code,
          type: "asset"
        });
      }
    });
  } finally {
    await bundle.close();
  }
  return emitSourcemapForWorkerEntry(config2, query, chunk);
}
function emitSourcemapForWorkerEntry(config2, query, chunk) {
  const { map: sourcemap } = chunk;
  if (sourcemap) {
    if (config2.build.sourcemap === "inline") {
      const dataUrl = sourcemap.toUrl();
      chunk.code += `//# sourceMappingURL=${dataUrl}`;
    } else if (config2.build.sourcemap === "hidden" || config2.build.sourcemap === true) {
      const data2 = sourcemap.toString();
      const mapFileName = chunk.fileName + ".map";
      saveEmitWorkerAsset(config2, {
        fileName: mapFileName,
        type: "asset",
        source: data2
      });
      if (config2.build.sourcemap === true) {
        const sourceMapUrl = (query == null ? void 0 : query.inline) != null ? mapFileName : import_node_path2.default.relative(config2.build.assetsDir, mapFileName);
        chunk.code += `//# sourceMappingURL=${sourceMapUrl}`;
      }
    }
  }
  return chunk;
}
var workerAssetUrlRE = /__VITE_WORKER_ASSET__([a-z\d]{8})__/g;
function encodeWorkerAssetFileName(fileName, workerCache2) {
  const { fileNameHash } = workerCache2;
  const hash = getHash(fileName);
  if (!fileNameHash.get(hash)) {
    fileNameHash.set(hash, fileName);
  }
  return `__VITE_WORKER_ASSET__${hash}__`;
}
async function workerFileToUrl(config2, id, query) {
  const workerMap = workerCache.get(config2.mainConfig || config2);
  let fileName = workerMap.bundle.get(id);
  if (!fileName) {
    const outputChunk = await bundleWorkerEntry(config2, id, query);
    fileName = outputChunk.fileName;
    saveEmitWorkerAsset(config2, {
      fileName,
      source: outputChunk.code,
      type: "asset"
    });
    workerMap.bundle.set(id, fileName);
  }
  return encodeWorkerAssetFileName(fileName, workerMap);
}
function webWorkerPlugin(config2) {
  const isBuild = config2.command === "build";
  let server2;
  const isWorker = config2.isWorker;
  return {
    name: "vite:worker",
    configureServer(_server) {
      server2 = _server;
    },
    buildStart() {
      if (isWorker) {
        return;
      }
      workerCache.set(config2, {
        assets: /* @__PURE__ */ new Map(),
        bundle: /* @__PURE__ */ new Map(),
        fileNameHash: /* @__PURE__ */ new Map()
      });
    },
    load(id) {
      var _a;
      if (isBuild) {
        const parsedQuery = parseRequest(id);
        if (parsedQuery && ((_a = parsedQuery.worker) != null ? _a : parsedQuery.sharedworker) != null) {
          return "";
        }
      }
    },
    async transform(raw, id, options3) {
      var _a, _b, _c;
      const ssr = (options3 == null ? void 0 : options3.ssr) === true;
      const query = parseRequest(id);
      if (query && query[WORKER_FILE_ID] != null) {
        const workerType2 = query["type"];
        let injectEnv = "";
        if (workerType2 === "classic") {
          injectEnv = `importScripts('${ENV_PUBLIC_PATH}')
`;
        } else if (workerType2 === "module") {
          injectEnv = `import '${ENV_PUBLIC_PATH}'
`;
        } else if (workerType2 === "ignore") {
          if (isBuild) {
            injectEnv = "";
          } else if (server2) {
            const { moduleGraph } = server2;
            const module2 = moduleGraph.getModuleById(ENV_ENTRY);
            injectEnv = ((_a = module2 == null ? void 0 : module2.transformResult) == null ? void 0 : _a.code) || "";
          }
        }
        return {
          code: injectEnv + raw
        };
      }
      if (query == null || query && ((_b = query.worker) != null ? _b : query.sharedworker) == null) {
        return;
      }
      let url2;
      const { format: format2 } = config2.worker;
      const workerConstructor = query.sharedworker != null ? "SharedWorker" : "Worker";
      const workerType = isBuild ? format2 === "es" ? "module" : "classic" : "module";
      const workerOptions = workerType === "classic" ? "" : ',{type: "module"}';
      if (isBuild) {
        (_c = getDepsOptimizer(config2, ssr)) == null ? void 0 : _c.registerWorkersSource(id);
        if (query.inline != null) {
          const chunk = await bundleWorkerEntry(config2, id, query);
          return {
            code: `const encodedJs = "${Buffer.from(chunk.code).toString("base64")}";
            const blob = typeof window !== "undefined" && window.Blob && new Blob([atob(encodedJs)], { type: "text/javascript;charset=utf-8" });
            export default function WorkerWrapper() {
              const objURL = blob && (window.URL || window.webkitURL).createObjectURL(blob);
              try {
                return objURL ? new ${workerConstructor}(objURL) : new ${workerConstructor}("data:application/javascript;base64," + encodedJs${workerOptions});
              } finally {
                objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);
              }
            }`,
            map: { mappings: "" }
          };
        } else {
          url2 = await workerFileToUrl(config2, id, query);
        }
      } else {
        url2 = await fileToUrl(cleanUrl(id), config2, this);
        url2 = injectQuery(url2, WORKER_FILE_ID);
        url2 = injectQuery(url2, `type=${workerType}`);
      }
      if (query.url != null) {
        return {
          code: `export default ${JSON.stringify(url2)}`,
          map: { mappings: "" }
        };
      }
      return {
        code: `export default function WorkerWrapper() {
          return new ${workerConstructor}(${JSON.stringify(url2)}${workerOptions})
        }`,
        map: { mappings: "" }
      };
    },
    renderChunk(code, chunk, outputOptions) {
      let s;
      const result = () => {
        return s && {
          code: s.toString(),
          map: config2.build.sourcemap ? s.generateMap({ hires: true }) : null
        };
      };
      if (code.match(workerAssetUrlRE) || code.includes("import.meta.url")) {
        const toRelativeRuntime = createToImportMetaURLBasedRelativeRuntime(outputOptions.format);
        let match;
        s = new MagicString(code);
        workerAssetUrlRE.lastIndex = 0;
        const workerMap = workerCache.get(config2.mainConfig || config2);
        const { fileNameHash } = workerMap;
        while (match = workerAssetUrlRE.exec(code)) {
          const [full, hash] = match;
          const filename = fileNameHash.get(hash);
          const replacement = toOutputFilePathInJS(filename, "asset", chunk.fileName, "js", config2, toRelativeRuntime);
          const replacementString = typeof replacement === "string" ? JSON.stringify(replacement).slice(1, -1) : `"+${replacement.runtime}+"`;
          s.update(match.index, match.index + full.length, replacementString);
        }
      }
      return result();
    },
    generateBundle(opts) {
      if (opts.__vite_skip_asset_emit__ || isWorker) {
        return;
      }
      const workerMap = workerCache.get(config2);
      workerMap.assets.forEach((asset) => {
        this.emitFile(asset);
        workerMap.assets.delete(asset.fileName);
      });
    }
  };
}
var normalizedClientEntry$1 = normalizePath$3(CLIENT_ENTRY);
var normalizedEnvEntry$1 = normalizePath$3(ENV_ENTRY);
var browserExternalId = "__vite-browser-external";
var optionalPeerDepId = "__vite-optional-peer-dep";
var nodeModulesInPathRE = /(^|\/)node_modules\//;
var isDebug$4 = process.env.DEBUG;
var debug$c = createDebugger("vite:resolve-details", {
  onlyWhenFocused: true
});
function resolvePlugin(resolveOptions) {
  const { root: root2, isProduction, asSrc, ssrConfig, preferRelative = false } = resolveOptions;
  const { target: ssrTarget, noExternal: ssrNoExternal } = ssrConfig != null ? ssrConfig : {};
  return {
    name: "vite:resolve",
    async resolveId(id, importer, resolveOpts) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
      const ssr = (resolveOpts == null ? void 0 : resolveOpts.ssr) === true;
      const depsOptimizer = (_a = resolveOptions.getDepsOptimizer) == null ? void 0 : _a.call(resolveOptions, ssr);
      if (id.startsWith(browserExternalId)) {
        return id;
      }
      const targetWeb = !ssr || ssrTarget === "webworker";
      const isRequire2 = (_d = (_c = (_b = resolveOpts == null ? void 0 : resolveOpts.custom) == null ? void 0 : _b["node-resolve"]) == null ? void 0 : _c.isRequire) != null ? _d : false;
      const options3 = {
        isRequire: isRequire2,
        ...resolveOptions,
        scan: (_e = resolveOpts == null ? void 0 : resolveOpts.scan) != null ? _e : resolveOptions.scan
      };
      if (importer) {
        const _importer = isWorkerRequest(importer) ? splitFileAndPostfix(importer).file : importer;
        if (isTsRequest(_importer) || ((_h = (_g = (_f = resolveOpts.custom) == null ? void 0 : _f.depScan) == null ? void 0 : _g.loader) == null ? void 0 : _h.startsWith("ts"))) {
          options3.isFromTsImporter = true;
        } else {
          const moduleLang = (_k = (_j = (_i = this.getModuleInfo(_importer)) == null ? void 0 : _i.meta) == null ? void 0 : _j.vite) == null ? void 0 : _k.lang;
          options3.isFromTsImporter = moduleLang && isTsRequest(`.${moduleLang}`);
        }
      }
      let res;
      if (asSrc && (depsOptimizer == null ? void 0 : depsOptimizer.isOptimizedDepUrl(id))) {
        const optimizedPath = id.startsWith(FS_PREFIX) ? fsPathFromId(id) : normalizePath$3(ensureVolumeInPath(import_node_path2.default.resolve(root2, id.slice(1))));
        return optimizedPath;
      }
      const ensureVersionQuery = (resolved) => {
        if (!options3.isBuild && depsOptimizer && !(resolved === normalizedClientEntry$1 || resolved === normalizedEnvEntry$1)) {
          const isNodeModule = nodeModulesInPathRE.test(normalizePath$3(id)) || nodeModulesInPathRE.test(normalizePath$3(resolved));
          if (isNodeModule && !resolved.match(DEP_VERSION_RE)) {
            const versionHash = depsOptimizer.metadata.browserHash;
            if (versionHash && isOptimizable(resolved, depsOptimizer.options)) {
              resolved = injectQuery(resolved, `v=${versionHash}`);
            }
          }
        }
        return resolved;
      };
      if (asSrc && id.startsWith(FS_PREFIX)) {
        const fsPath = fsPathFromId(id);
        res = tryFsResolve(fsPath, options3);
        isDebug$4 && debug$c(`[@fs] ${picocolors.exports.cyan(id)} -> ${picocolors.exports.dim(res)}`);
        return ensureVersionQuery(res || fsPath);
      }
      if (asSrc && id.startsWith("/")) {
        const fsPath = import_node_path2.default.resolve(root2, id.slice(1));
        if (res = tryFsResolve(fsPath, options3)) {
          isDebug$4 && debug$c(`[url] ${picocolors.exports.cyan(id)} -> ${picocolors.exports.dim(res)}`);
          return ensureVersionQuery(res);
        }
      }
      if (id.startsWith(".") || (preferRelative || (importer == null ? void 0 : importer.endsWith(".html"))) && /^\w/.test(id)) {
        const basedir = importer ? import_node_path2.default.dirname(importer) : process.cwd();
        const fsPath = import_node_path2.default.resolve(basedir, id);
        const normalizedFsPath = normalizePath$3(fsPath);
        if (depsOptimizer == null ? void 0 : depsOptimizer.isOptimizedDepFile(normalizedFsPath)) {
          if (!normalizedFsPath.match(DEP_VERSION_RE)) {
            const browserHash = (_l = optimizedDepInfoFromFile(depsOptimizer.metadata, normalizedFsPath)) == null ? void 0 : _l.browserHash;
            if (browserHash) {
              return injectQuery(normalizedFsPath, `v=${browserHash}`);
            }
          }
          return normalizedFsPath;
        }
        if (targetWeb && options3.browserField && (res = tryResolveBrowserMapping(fsPath, importer, options3, true))) {
          return res;
        }
        if (res = tryFsResolve(fsPath, options3)) {
          res = ensureVersionQuery(res);
          isDebug$4 && debug$c(`[relative] ${picocolors.exports.cyan(id)} -> ${picocolors.exports.dim(res)}`);
          const pkg = importer != null && idToPkgMap.get(importer);
          if (pkg) {
            idToPkgMap.set(res, pkg);
            return {
              id: res,
              moduleSideEffects: pkg.hasSideEffects(res)
            };
          }
          return res;
        }
      }
      if (isWindows$4 && id.startsWith("/")) {
        const basedir = importer ? import_node_path2.default.dirname(importer) : process.cwd();
        const fsPath = import_node_path2.default.resolve(basedir, id);
        if (res = tryFsResolve(fsPath, options3)) {
          isDebug$4 && debug$c(`[drive-relative] ${picocolors.exports.cyan(id)} -> ${picocolors.exports.dim(res)}`);
          return ensureVersionQuery(res);
        }
      }
      if (isNonDriveRelativeAbsolutePath(id) && (res = tryFsResolve(id, options3))) {
        isDebug$4 && debug$c(`[fs] ${picocolors.exports.cyan(id)} -> ${picocolors.exports.dim(res)}`);
        return ensureVersionQuery(res);
      }
      if (isExternalUrl(id)) {
        return {
          id,
          external: true
        };
      }
      if (isDataUrl(id)) {
        return null;
      }
      if (bareImportRE.test(id)) {
        const external = (_m = options3.shouldExternalize) == null ? void 0 : _m.call(options3, id);
        if (!external && asSrc && depsOptimizer && !options3.scan && (res = await tryOptimizedResolve(depsOptimizer, id, importer))) {
          return res;
        }
        if (targetWeb && options3.browserField && (res = tryResolveBrowserMapping(id, importer, options3, false, external))) {
          return res;
        }
        if (res = tryNodeResolve(id, importer, options3, targetWeb, depsOptimizer, ssr, external)) {
          return res;
        }
        if (isBuiltin(id)) {
          if (ssr) {
            if (ssrNoExternal === true) {
              let message = `Cannot bundle Node.js built-in "${id}"`;
              if (importer) {
                message += ` imported from "${import_node_path2.default.relative(process.cwd(), importer)}"`;
              }
              message += `. Consider disabling ssr.noExternal or remove the built-in dependency.`;
              this.error(message);
            }
            return {
              id,
              external: true
            };
          } else {
            if (!asSrc) {
              debug$c(`externalized node built-in "${id}" to empty module. (imported by: ${picocolors.exports.white(picocolors.exports.dim(importer))})`);
            }
            return isProduction ? browserExternalId : `${browserExternalId}:${id}`;
          }
        }
      }
      isDebug$4 && debug$c(`[fallthrough] ${picocolors.exports.dim(id)}`);
    },
    load(id) {
      if (id.startsWith(browserExternalId)) {
        if (isProduction) {
          return `export default {}`;
        } else {
          id = id.slice(browserExternalId.length + 1);
          return `export default new Proxy({}, {
  get(_, key) {
    throw new Error(\`Module "${id}" has been externalized for browser compatibility. Cannot access "${id}.\${key}" in client code.\`)
  }
})`;
        }
      }
      if (id.startsWith(optionalPeerDepId)) {
        if (isProduction) {
          return `export default {}`;
        } else {
          const [, peerDep, parentDep] = id.split(":");
          return `throw new Error(\`Could not resolve "${peerDep}" imported by "${parentDep}". Is it installed?\`)`;
        }
      }
    }
  };
}
function splitFileAndPostfix(path4) {
  let file = path4;
  let postfix = "";
  let postfixIndex = path4.indexOf("?");
  if (postfixIndex < 0) {
    postfixIndex = path4.indexOf("#");
  }
  if (postfixIndex > 0) {
    file = path4.slice(0, postfixIndex);
    postfix = path4.slice(postfixIndex);
  }
  return { file, postfix };
}
function tryFsResolve(fsPath, options3, tryIndex = true, targetWeb = true) {
  const { file, postfix } = splitFileAndPostfix(fsPath);
  let res;
  if (postfix && (res = tryResolveFile(fsPath, "", options3, false, targetWeb, options3.tryPrefix, options3.skipPackageJson))) {
    return res;
  }
  if (res = tryResolveFile(file, postfix, options3, false, targetWeb, options3.tryPrefix, options3.skipPackageJson)) {
    return res;
  }
  for (const ext2 of options3.extensions) {
    if (postfix && (res = tryResolveFile(fsPath + ext2, "", options3, false, targetWeb, options3.tryPrefix, options3.skipPackageJson))) {
      return res;
    }
    if (res = tryResolveFile(file + ext2, postfix, options3, false, targetWeb, options3.tryPrefix, options3.skipPackageJson)) {
      return res;
    }
  }
  if (postfix && (res = tryResolveFile(fsPath, "", options3, tryIndex, targetWeb, options3.tryPrefix, options3.skipPackageJson))) {
    return res;
  }
  if (res = tryResolveFile(file, postfix, options3, tryIndex, targetWeb, options3.tryPrefix, options3.skipPackageJson)) {
    return res;
  }
}
function tryResolveFile(file, postfix, options3, tryIndex, targetWeb, tryPrefix, skipPackageJson) {
  if (isFileReadable(file)) {
    if (!import_node_fs.default.statSync(file).isDirectory()) {
      return getRealPath(file, options3.preserveSymlinks) + postfix;
    } else if (tryIndex) {
      if (!skipPackageJson) {
        const pkgPath = file + "/package.json";
        try {
          const pkg = loadPackageData(pkgPath, options3.preserveSymlinks);
          const resolved = resolvePackageEntry(file, pkg, targetWeb, options3);
          return resolved;
        } catch (e) {
          if (e.code !== "ENOENT") {
            throw e;
          }
        }
      }
      const index2 = tryFsResolve(file + "/index", options3);
      if (index2)
        return index2 + postfix;
    }
  }
  const tryTsExtension = options3.isFromTsImporter && isPossibleTsOutput(file);
  if (tryTsExtension) {
    const tsSrcPaths = getPotentialTsSrcPaths(file);
    for (const srcPath of tsSrcPaths) {
      const res = tryResolveFile(srcPath, postfix, options3, tryIndex, targetWeb, tryPrefix, skipPackageJson);
      if (res)
        return res;
    }
    return;
  }
  if (tryPrefix) {
    const prefixed = `${import_node_path2.default.dirname(file)}/${tryPrefix}${import_node_path2.default.basename(file)}`;
    return tryResolveFile(prefixed, postfix, options3, tryIndex, targetWeb);
  }
}
var idToPkgMap = /* @__PURE__ */ new Map();
function tryNodeResolve(id, importer, options3, targetWeb, depsOptimizer, ssr, externalize, allowLinkedExternal = true) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const { root: root2, dedupe, isBuild, preserveSymlinks, packageCache } = options3;
  ssr != null ? ssr : ssr = false;
  const lastArrowIndex = id.lastIndexOf(">");
  const nestedRoot = id.substring(0, lastArrowIndex).trim();
  const nestedPath = id.substring(lastArrowIndex + 1).trim();
  const possiblePkgIds = [];
  for (let prevSlashIndex = -1; ; ) {
    let slashIndex = nestedPath.indexOf("/", prevSlashIndex + 1);
    if (slashIndex < 0) {
      slashIndex = nestedPath.length;
    }
    const part = nestedPath.slice(prevSlashIndex + 1, prevSlashIndex = slashIndex);
    if (!part) {
      break;
    }
    if (possiblePkgIds.length ? import_node_path2.default.extname(part) : part[0] === "@") {
      continue;
    }
    const possiblePkgId = nestedPath.slice(0, slashIndex);
    possiblePkgIds.push(possiblePkgId);
  }
  let basedir;
  if (dedupe == null ? void 0 : dedupe.some((id2) => possiblePkgIds.includes(id2))) {
    basedir = root2;
  } else if (importer && import_node_path2.default.isAbsolute(importer) && import_node_fs.default.existsSync(cleanUrl(importer))) {
    basedir = import_node_path2.default.dirname(importer);
  } else {
    basedir = root2;
  }
  if (nestedRoot) {
    basedir = nestedResolveFrom(nestedRoot, basedir, preserveSymlinks);
  }
  let nearestPkg;
  let pkg;
  let pkgId = possiblePkgIds.reverse().find((pkgId2) => {
    nearestPkg = resolvePackageData(pkgId2, basedir, preserveSymlinks, packageCache);
    return nearestPkg;
  });
  const rootPkgId = possiblePkgIds[0];
  const rootPkg = resolvePackageData(rootPkgId, basedir, preserveSymlinks, packageCache);
  if ((_a = rootPkg == null ? void 0 : rootPkg.data) == null ? void 0 : _a.exports) {
    pkg = rootPkg;
    pkgId = rootPkgId;
  } else {
    pkg = nearestPkg;
  }
  if (!pkg || !nearestPkg) {
    if (!options3.isHookNodeResolve && basedir !== root2 && !isBuiltin(nestedPath) && !nestedPath.includes("\0") && bareImportRE.test(nestedPath)) {
      const mainPackageJson = lookupFile(basedir, ["package.json"], {
        predicate: (content) => !!JSON.parse(content).name
      });
      if (mainPackageJson) {
        const mainPkg = JSON.parse(mainPackageJson);
        if (((_b = mainPkg.peerDependencies) == null ? void 0 : _b[nestedPath]) && ((_d = (_c = mainPkg.peerDependenciesMeta) == null ? void 0 : _c[nestedPath]) == null ? void 0 : _d.optional)) {
          return {
            id: `${optionalPeerDepId}:${nestedPath}:${mainPkg.name}`
          };
        }
      }
    }
    return;
  }
  let resolveId = resolvePackageEntry;
  let unresolvedId = pkgId;
  const isDeepImport = unresolvedId !== nestedPath;
  if (isDeepImport) {
    resolveId = resolveDeepImport;
    unresolvedId = "." + nestedPath.slice(pkgId.length);
  }
  let resolved;
  try {
    resolved = resolveId(unresolvedId, pkg, targetWeb, options3);
  } catch (err) {
    if (!options3.tryEsmOnly) {
      throw err;
    }
  }
  if (!resolved && options3.tryEsmOnly) {
    resolved = resolveId(unresolvedId, pkg, targetWeb, {
      ...options3,
      isRequire: false,
      mainFields: DEFAULT_MAIN_FIELDS,
      extensions: DEFAULT_EXTENSIONS
    });
  }
  if (!resolved) {
    return;
  }
  const processResult2 = (resolved2) => {
    if (!externalize) {
      return resolved2;
    }
    if (!allowLinkedExternal && !resolved2.id.includes("node_modules")) {
      return resolved2;
    }
    const resolvedExt = import_node_path2.default.extname(resolved2.id);
    if (resolvedExt && resolvedExt !== ".js" && resolvedExt !== ".mjs" && resolvedExt !== ".cjs") {
      return resolved2;
    }
    let resolvedId = id;
    if (isDeepImport) {
      if (!(pkg == null ? void 0 : pkg.data.exports) && import_node_path2.default.extname(id) !== resolvedExt) {
        resolvedId = resolved2.id.slice(resolved2.id.indexOf(id));
        isDebug$4 && debug$c(`[processResult] ${picocolors.exports.cyan(id)} -> ${picocolors.exports.dim(resolvedId)}`);
      }
    }
    return { ...resolved2, id: resolvedId, external: true };
  };
  idToPkgMap.set(resolved, pkg);
  if (isBuild && !depsOptimizer || externalize) {
    return processResult2({
      id: resolved,
      moduleSideEffects: pkg.hasSideEffects(resolved)
    });
  }
  const ext2 = import_node_path2.default.extname(resolved);
  const isCJS = ext2 === ".cjs" || ext2 === ".js" && nearestPkg.data.type !== "module";
  if (!options3.ssrOptimizeCheck && (!resolved.includes("node_modules") || !depsOptimizer || options3.scan)) {
    return { id: resolved };
  }
  const isJsType = depsOptimizer ? isOptimizable(resolved, depsOptimizer.options) : OPTIMIZABLE_ENTRY_RE.test(resolved);
  let exclude = depsOptimizer == null ? void 0 : depsOptimizer.options.exclude;
  let include = depsOptimizer == null ? void 0 : depsOptimizer.options.include;
  if (options3.ssrOptimizeCheck) {
    exclude = (_f = (_e = options3.ssrConfig) == null ? void 0 : _e.optimizeDeps) == null ? void 0 : _f.exclude;
    include = (_h = (_g = options3.ssrConfig) == null ? void 0 : _g.optimizeDeps) == null ? void 0 : _h.include;
  }
  const skipOptimization = !isJsType || (importer == null ? void 0 : importer.includes("node_modules")) || (exclude == null ? void 0 : exclude.includes(pkgId)) || (exclude == null ? void 0 : exclude.includes(nestedPath)) || SPECIAL_QUERY_RE.test(resolved) || !options3.ssrOptimizeCheck && !isBuild && ssr || ssr && !isCJS && !((include == null ? void 0 : include.includes(pkgId)) || (include == null ? void 0 : include.includes(nestedPath)));
  if (options3.ssrOptimizeCheck) {
    return {
      id: skipOptimization ? injectQuery(resolved, `__vite_skip_optimization`) : resolved
    };
  }
  if (skipOptimization) {
    if (!isBuild) {
      const versionHash = depsOptimizer.metadata.browserHash;
      if (versionHash && isJsType) {
        resolved = injectQuery(resolved, `v=${versionHash}`);
      }
    }
  } else {
    const optimizedInfo = depsOptimizer.registerMissingImport(id, resolved);
    resolved = depsOptimizer.getOptimizedDepId(optimizedInfo);
  }
  if (isBuild) {
    return {
      id: resolved,
      moduleSideEffects: pkg.hasSideEffects(resolved)
    };
  } else {
    return { id: resolved };
  }
}
async function tryOptimizedResolve(depsOptimizer, id, importer) {
  await depsOptimizer.scanProcessing;
  const metadata = depsOptimizer.metadata;
  const depInfo = optimizedDepInfoFromId(metadata, id);
  if (depInfo) {
    return depsOptimizer.getOptimizedDepId(depInfo);
  }
  if (!importer)
    return;
  let resolvedSrc;
  for (const optimizedData of metadata.depInfoList) {
    if (!optimizedData.src)
      continue;
    const pkgPath = optimizedData.id;
    if (!pkgPath.endsWith(id))
      continue;
    if (resolvedSrc == null) {
      try {
        resolvedSrc = normalizePath$3(resolveFrom(id, import_node_path2.default.dirname(importer)));
      } catch {
        break;
      }
    }
    if (optimizedData.src === resolvedSrc) {
      return depsOptimizer.getOptimizedDepId(optimizedData);
    }
  }
}
function resolvePackageEntry(id, { dir, data: data2, setResolvedCache, getResolvedCache }, targetWeb, options3) {
  const cached = getResolvedCache(".", targetWeb);
  if (cached) {
    return cached;
  }
  try {
    let entryPoint;
    if (data2.exports) {
      entryPoint = resolveExports(data2, ".", options3, targetWeb);
    }
    if (targetWeb && options3.browserField && (!entryPoint || entryPoint.endsWith(".mjs"))) {
      const browserEntry = typeof data2.browser === "string" ? data2.browser : isObject$1(data2.browser) && data2.browser["."];
      if (browserEntry) {
        if (!options3.isRequire && options3.mainFields.includes("module") && typeof data2.module === "string" && data2.module !== browserEntry) {
          const resolvedBrowserEntry = tryFsResolve(import_node_path2.default.join(dir, browserEntry), options3);
          if (resolvedBrowserEntry) {
            const content = import_node_fs.default.readFileSync(resolvedBrowserEntry, "utf-8");
            if (hasESMSyntax(content)) {
              entryPoint = browserEntry;
            } else {
              entryPoint = data2.module;
            }
          }
        } else {
          entryPoint = browserEntry;
        }
      }
    }
    if (!entryPoint || entryPoint.endsWith(".mjs")) {
      for (const field of options3.mainFields) {
        if (field === "browser")
          continue;
        if (typeof data2[field] === "string") {
          entryPoint = data2[field];
          break;
        }
      }
    }
    entryPoint || (entryPoint = data2.main);
    const entryPoints = entryPoint ? [entryPoint] : ["index.js", "index.json", "index.node"];
    for (let entry2 of entryPoints) {
      if (options3.mainFields[0] === "sass" && !options3.extensions.includes(import_node_path2.default.extname(entry2))) {
        entry2 = "";
        options3.skipPackageJson = true;
      }
      const { browser: browserField } = data2;
      if (targetWeb && options3.browserField && isObject$1(browserField)) {
        entry2 = mapWithBrowserField(entry2, browserField) || entry2;
      }
      const entryPointPath = import_node_path2.default.join(dir, entry2);
      const resolvedEntryPoint = tryFsResolve(entryPointPath, options3);
      if (resolvedEntryPoint) {
        isDebug$4 && debug$c(`[package entry] ${picocolors.exports.cyan(id)} -> ${picocolors.exports.dim(resolvedEntryPoint)}`);
        setResolvedCache(".", resolvedEntryPoint, targetWeb);
        return resolvedEntryPoint;
      }
    }
  } catch (e) {
    packageEntryFailure(id, e.message);
  }
  packageEntryFailure(id);
}
function packageEntryFailure(id, details) {
  throw new Error(`Failed to resolve entry for package "${id}". The package may have incorrect main/module/exports specified in its package.json` + (details ? ": " + details : "."));
}
var conditionalConditions = /* @__PURE__ */ new Set(["production", "development", "module"]);
function resolveExports(pkg, key2, options3, targetWeb) {
  const overrideConditions = options3.overrideConditions ? new Set(options3.overrideConditions) : void 0;
  const conditions = [];
  if ((!overrideConditions || overrideConditions.has("production")) && options3.isProduction) {
    conditions.push("production");
  }
  if ((!overrideConditions || overrideConditions.has("development")) && !options3.isProduction) {
    conditions.push("development");
  }
  if ((!overrideConditions || overrideConditions.has("module")) && !options3.isRequire) {
    conditions.push("module");
  }
  if (options3.overrideConditions) {
    conditions.push(...options3.overrideConditions.filter((condition) => conditionalConditions.has(condition)));
  } else if (options3.conditions.length > 0) {
    conditions.push(...options3.conditions);
  }
  return resolve2(pkg, key2, {
    browser: targetWeb && !conditions.includes("node"),
    require: options3.isRequire && !conditions.includes("import"),
    conditions
  });
}
function resolveDeepImport(id, { webResolvedImports, setResolvedCache, getResolvedCache, dir, data: data2 }, targetWeb, options3) {
  const cache = getResolvedCache(id, targetWeb);
  if (cache) {
    return cache;
  }
  let relativeId = id;
  const { exports: exportsField, browser: browserField } = data2;
  if (exportsField) {
    if (isObject$1(exportsField) && !Array.isArray(exportsField)) {
      const { file, postfix } = splitFileAndPostfix(relativeId);
      const exportsId = resolveExports(data2, file, options3, targetWeb);
      if (exportsId !== void 0) {
        relativeId = exportsId + postfix;
      } else {
        relativeId = void 0;
      }
    } else {
      relativeId = void 0;
    }
    if (!relativeId) {
      throw new Error(`Package subpath '${relativeId}' is not defined by "exports" in ${import_node_path2.default.join(dir, "package.json")}.`);
    }
  } else if (targetWeb && options3.browserField && isObject$1(browserField)) {
    const { file, postfix } = splitFileAndPostfix(relativeId);
    const mapped = mapWithBrowserField(file, browserField);
    if (mapped) {
      relativeId = mapped + postfix;
    } else if (mapped === false) {
      return webResolvedImports[id] = browserExternalId;
    }
  }
  if (relativeId) {
    const resolved = tryFsResolve(
      import_node_path2.default.join(dir, relativeId),
      options3,
      !exportsField,
      targetWeb
    );
    if (resolved) {
      isDebug$4 && debug$c(`[node/deep-import] ${picocolors.exports.cyan(id)} -> ${picocolors.exports.dim(resolved)}`);
      setResolvedCache(id, resolved, targetWeb);
      return resolved;
    }
  }
}
function tryResolveBrowserMapping(id, importer, options3, isFilePath, externalize) {
  let res;
  const pkg = importer && (idToPkgMap.get(importer) || resolvePkg(importer, options3));
  if (pkg && isObject$1(pkg.data.browser)) {
    const mapId = isFilePath ? "./" + slash$1(import_node_path2.default.relative(pkg.dir, id)) : id;
    const browserMappedPath = mapWithBrowserField(mapId, pkg.data.browser);
    if (browserMappedPath) {
      const fsPath = import_node_path2.default.join(pkg.dir, browserMappedPath);
      if (res = tryFsResolve(fsPath, options3)) {
        isDebug$4 && debug$c(`[browser mapped] ${picocolors.exports.cyan(id)} -> ${picocolors.exports.dim(res)}`);
        idToPkgMap.set(res, pkg);
        const result = {
          id: res,
          moduleSideEffects: pkg.hasSideEffects(res)
        };
        return externalize ? { ...result, external: true } : result;
      }
    } else if (browserMappedPath === false) {
      return browserExternalId;
    }
  }
}
function mapWithBrowserField(relativePathInPkgDir, map2) {
  const normalizedPath = import_node_path2.default.posix.normalize(relativePathInPkgDir);
  for (const key2 in map2) {
    const normalizedKey = import_node_path2.default.posix.normalize(key2);
    if (normalizedPath === normalizedKey || equalWithoutSuffix(normalizedPath, normalizedKey, ".js") || equalWithoutSuffix(normalizedPath, normalizedKey, "/index.js")) {
      return map2[key2];
    }
  }
}
function equalWithoutSuffix(path4, key2, suffix) {
  return key2.endsWith(suffix) && key2.slice(0, -suffix.length) === path4;
}
function getRealPath(resolved, preserveSymlinks) {
  resolved = ensureVolumeInPath(resolved);
  if (!preserveSymlinks && browserExternalId !== resolved) {
    resolved = import_node_fs.default.realpathSync(resolved);
  }
  return normalizePath$3(resolved);
}
function resolvePkg(importer, options3) {
  const { root: root2, preserveSymlinks, packageCache } = options3;
  if (importer.includes("\0")) {
    return null;
  }
  const possiblePkgIds = [];
  for (let prevSlashIndex = -1; ; ) {
    const slashIndex = importer.indexOf(isWindows$4 ? "\\" : "/", prevSlashIndex);
    if (slashIndex < 0) {
      break;
    }
    prevSlashIndex = slashIndex + 1;
    const possiblePkgId = importer.slice(0, slashIndex);
    possiblePkgIds.push(possiblePkgId);
  }
  let pkg;
  possiblePkgIds.reverse().find((pkgId) => {
    pkg = resolvePackageData(pkgId, root2, preserveSymlinks, packageCache);
    return pkg;
  });
  if (pkg) {
    idToPkgMap.set(importer, pkg);
  }
  return pkg;
}
var externalWithConversionNamespace = "vite:dep-pre-bundle:external-conversion";
var convertedExternalPrefix = "vite-dep-pre-bundle-external:";
var externalTypes = [
  "css",
  "less",
  "sass",
  "scss",
  "styl",
  "stylus",
  "pcss",
  "postcss",
  "wasm",
  "vue",
  "svelte",
  "marko",
  "astro",
  "imba",
  "jsx",
  "tsx",
  ...KNOWN_ASSET_TYPES
];
function esbuildDepPlugin(qualified, exportsData, external, config2, ssr) {
  const { extensions: extensions2 } = getDepOptimizationConfig(config2, ssr);
  const allExternalTypes = extensions2 ? externalTypes.filter((type) => !(extensions2 == null ? void 0 : extensions2.includes("." + type))) : externalTypes;
  const _resolve = config2.createResolver({ asSrc: false, scan: true });
  const _resolveRequire = config2.createResolver({
    asSrc: false,
    isRequire: true,
    scan: true
  });
  const resolve3 = (id, importer, kind, resolveDir) => {
    let _importer;
    if (resolveDir) {
      _importer = normalizePath$3(import_node_path2.default.join(resolveDir, "*"));
    } else {
      _importer = importer in qualified ? qualified[importer] : importer;
    }
    const resolver = kind.startsWith("require") ? _resolveRequire : _resolve;
    return resolver(id, _importer, void 0, ssr);
  };
  const resolveResult = (id, resolved) => {
    if (resolved.startsWith(browserExternalId)) {
      return {
        path: id,
        namespace: "browser-external"
      };
    }
    if (resolved.startsWith(optionalPeerDepId)) {
      return {
        path: resolved,
        namespace: "optional-peer-dep"
      };
    }
    if (ssr && isBuiltin(resolved)) {
      return;
    }
    if (isExternalUrl(resolved)) {
      return {
        path: resolved,
        external: true
      };
    }
    return {
      path: import_node_path2.default.resolve(resolved)
    };
  };
  return {
    name: "vite:dep-pre-bundle",
    setup(build2) {
      build2.onResolve({
        filter: new RegExp(`\\.(` + allExternalTypes.join("|") + `)(\\?.*)?$`)
      }, async ({ path: id, importer, kind }) => {
        if (id.startsWith(convertedExternalPrefix)) {
          return {
            path: id.slice(convertedExternalPrefix.length),
            external: true
          };
        }
        const resolved = await resolve3(id, importer, kind);
        if (resolved) {
          if (kind === "require-call") {
            return {
              path: resolved,
              namespace: externalWithConversionNamespace
            };
          }
          return {
            path: resolved,
            external: true
          };
        }
      });
      build2.onLoad({ filter: /./, namespace: externalWithConversionNamespace }, (args) => {
        return {
          contents: `export { default } from "${convertedExternalPrefix}${args.path}";export * from "${convertedExternalPrefix}${args.path}";`,
          loader: "js"
        };
      });
      function resolveEntry(id) {
        const flatId = flattenId(id);
        if (flatId in qualified) {
          return {
            path: qualified[flatId]
          };
        }
      }
      build2.onResolve({ filter: /^[\w@][^:]/ }, async ({ path: id, importer, kind }) => {
        if (moduleListContains(external, id)) {
          return {
            path: id,
            external: true
          };
        }
        let entry2;
        if (!importer) {
          if (entry2 = resolveEntry(id))
            return entry2;
          const aliased = await _resolve(id, void 0, true);
          if (aliased && (entry2 = resolveEntry(aliased))) {
            return entry2;
          }
        }
        const resolved = await resolve3(id, importer, kind);
        if (resolved) {
          return resolveResult(id, resolved);
        }
      });
      build2.onLoad({ filter: /.*/, namespace: "browser-external" }, ({ path: path4 }) => {
        if (config2.isProduction) {
          return {
            contents: "module.exports = {}"
          };
        } else {
          return {
            contents: `module.exports = Object.create(new Proxy({}, {
  get(_, key) {
    if (
      key !== '__esModule' &&
      key !== '__proto__' &&
      key !== 'constructor' &&
      key !== 'splice'
    ) {
      console.warn(\`Module "${path4}" has been externalized for browser compatibility. Cannot access "${path4}.\${key}" in client code.\`)
    }
  }
}))`
          };
        }
      });
      build2.onLoad({ filter: /.*/, namespace: "optional-peer-dep" }, ({ path: path4 }) => {
        if (config2.isProduction) {
          return {
            contents: "module.exports = {}"
          };
        } else {
          const [, peerDep, parentDep] = path4.split(":");
          return {
            contents: `throw new Error(\`Could not resolve "${peerDep}" imported by "${parentDep}". Is it installed?\`)`
          };
        }
      });
    }
  };
}
function esbuildCjsExternalPlugin(externals) {
  return {
    name: "cjs-external",
    setup(build2) {
      const escape2 = (text) => `^${text.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")}$`;
      const filter2 = new RegExp(externals.map(escape2).join("|"));
      build2.onResolve({ filter: /.*/, namespace: "external" }, (args) => ({
        path: args.path,
        external: true
      }));
      build2.onResolve({ filter: filter2 }, (args) => ({
        path: args.path,
        namespace: "external"
      }));
      build2.onLoad({ filter: /.*/, namespace: "external" }, (args) => ({
        contents: `export * from ${JSON.stringify(args.path)}`
      }));
    }
  };
}
var debug$b = createDebugger("vite:ssr-external");
function stripNesting(packages) {
  return packages.map((s) => {
    const arr = s.split(">");
    return arr[arr.length - 1].trim();
  });
}
function cjsSsrResolveExternals(config2, knownImports) {
  var _a;
  knownImports = stripNesting(knownImports);
  const ssrConfig = config2.ssr;
  if ((ssrConfig == null ? void 0 : ssrConfig.noExternal) === true) {
    return [];
  }
  const ssrExternals = /* @__PURE__ */ new Set();
  const seen2 = /* @__PURE__ */ new Set();
  (_a = ssrConfig == null ? void 0 : ssrConfig.external) == null ? void 0 : _a.forEach((id) => {
    ssrExternals.add(id);
    seen2.add(id);
  });
  cjsSsrCollectExternals(config2.root, config2.resolve, ssrExternals, seen2, config2.logger);
  const importedDeps = knownImports.map(getNpmPackageName).filter(isDefined);
  for (const dep of importedDeps) {
    if (!seen2.has(dep)) {
      ssrExternals.add(dep);
    }
  }
  ssrExternals.delete("vite");
  let externals = [...ssrExternals];
  if (ssrConfig == null ? void 0 : ssrConfig.noExternal) {
    externals = externals.filter(createFilter3(void 0, ssrConfig.noExternal, { resolve: false }));
  }
  return externals;
}
var CJS_CONTENT_RE = /\bmodule\.exports\b|\bexports[.\[]|\brequire\s*\(|\bObject\.(defineProperty|defineProperties|assign)\s*\(\s*exports\b/;
var _require$3 = (0, import_node_module.createRequire)(import.meta.url);
var isSsrExternalCache = /* @__PURE__ */ new WeakMap();
function shouldExternalizeForSSR(id, config2) {
  let isSsrExternal = isSsrExternalCache.get(config2);
  if (!isSsrExternal) {
    isSsrExternal = createIsSsrExternal(config2);
    isSsrExternalCache.set(config2, isSsrExternal);
  }
  return isSsrExternal(id);
}
function createIsConfiguredAsSsrExternal(config2) {
  const { ssr, root: root2 } = config2;
  const noExternal = ssr == null ? void 0 : ssr.noExternal;
  const noExternalFilter = noExternal !== "undefined" && typeof noExternal !== "boolean" && createFilter3(void 0, noExternal, { resolve: false });
  const resolveOptions = {
    ...config2.resolve,
    root: root2,
    isProduction: false,
    isBuild: true
  };
  const isExternalizable = (id, configuredAsExternal) => {
    var _a;
    if (!bareImportRE.test(id) || id.includes("\0")) {
      return false;
    }
    try {
      return !!((_a = tryNodeResolve(
        id,
        void 0,
        resolveOptions,
        (ssr == null ? void 0 : ssr.target) === "webworker",
        void 0,
        true,
        true,
        !!configuredAsExternal
      )) == null ? void 0 : _a.external);
    } catch (e) {
      debug$b(`Failed to node resolve "${id}". Skipping externalizing it by default.`);
      return false;
    }
  };
  return (id) => {
    var _a, _b;
    const { ssr: ssr2 } = config2;
    if (ssr2) {
      if ((_a = ssr2.external) == null ? void 0 : _a.includes(id)) {
        return true;
      }
      const pkgName = getNpmPackageName(id);
      if (!pkgName) {
        return isExternalizable(id);
      }
      if ((_b = ssr2.external) == null ? void 0 : _b.includes(pkgName)) {
        return isExternalizable(id, true);
      }
      if (typeof noExternal === "boolean") {
        return !noExternal;
      }
      if (noExternalFilter && !noExternalFilter(pkgName)) {
        return false;
      }
    }
    return isExternalizable(id);
  };
}
function createIsSsrExternal(config2) {
  const processedIds = /* @__PURE__ */ new Map();
  const isConfiguredAsExternal = createIsConfiguredAsSsrExternal(config2);
  return (id) => {
    if (processedIds.has(id)) {
      return processedIds.get(id);
    }
    let external = false;
    if (!id.startsWith(".") && !import_node_path2.default.isAbsolute(id)) {
      external = isBuiltin(id) || isConfiguredAsExternal(id);
    }
    processedIds.set(id, external);
    return external;
  };
}
function cjsSsrCollectExternals(root2, resolveOptions, ssrExternals, seen2, logger) {
  var _a;
  const rootPkgContent = lookupFile(root2, ["package.json"]);
  if (!rootPkgContent) {
    return;
  }
  const rootPkg = JSON.parse(rootPkgContent);
  const deps = {
    ...rootPkg.devDependencies,
    ...rootPkg.dependencies
  };
  const internalResolveOptions = {
    ...resolveOptions,
    root: root2,
    isProduction: false,
    isBuild: true
  };
  const depsToTrace = /* @__PURE__ */ new Set();
  for (const id in deps) {
    if (seen2.has(id))
      continue;
    seen2.add(id);
    let esmEntry;
    let requireEntry;
    try {
      esmEntry = (_a = tryNodeResolve(
        id,
        void 0,
        internalResolveOptions,
        true,
        void 0,
        true
      )) == null ? void 0 : _a.id;
      requireEntry = normalizePath$3(_require$3.resolve(id, { paths: [root2] }));
    } catch (e) {
      try {
        const pkgPath = resolveFrom(`${id}/package.json`, root2);
        if (pkgPath.includes("node_modules")) {
          ssrExternals.add(id);
        } else {
          depsToTrace.add(import_node_path2.default.dirname(pkgPath));
        }
        continue;
      } catch {
      }
      debug$b(`Failed to resolve entries for package "${id}"
`, e);
      continue;
    }
    if (!esmEntry) {
      ssrExternals.add(id);
    } else if (!esmEntry.includes("node_modules")) {
      const pkgPath = resolveFrom(`${id}/package.json`, root2);
      depsToTrace.add(import_node_path2.default.dirname(pkgPath));
    } else if (esmEntry !== requireEntry) {
      ssrExternals.add(id);
    } else if (/\.m?js$/.test(esmEntry)) {
      const pkgPath = resolveFrom(`${id}/package.json`, root2);
      const pkgContent = import_node_fs.default.readFileSync(pkgPath, "utf-8");
      if (!pkgContent) {
        continue;
      }
      const pkg = JSON.parse(pkgContent);
      if (pkg.type === "module" || esmEntry.endsWith(".mjs")) {
        ssrExternals.add(id);
        continue;
      }
      const content = import_node_fs.default.readFileSync(esmEntry, "utf-8");
      if (CJS_CONTENT_RE.test(content)) {
        ssrExternals.add(id);
        continue;
      }
      logger.warn(`${id} doesn't appear to be written in CJS, but also doesn't appear to be a valid ES module (i.e. it doesn't have "type": "module" or an .mjs extension for the entry point). Please contact the package author to fix.`);
    }
  }
  for (const depRoot of depsToTrace) {
    cjsSsrCollectExternals(depRoot, resolveOptions, ssrExternals, seen2, logger);
  }
}
function cjsShouldExternalizeForSSR(id, externals) {
  if (!externals) {
    return false;
  }
  const should = externals.some((e) => {
    if (id === e) {
      return true;
    }
    if (id.startsWith(e + "/") && (!import_node_path2.default.extname(id) || id.endsWith(".js"))) {
      return true;
    }
  });
  return should;
}
function getNpmPackageName(importPath) {
  const parts = importPath.split("/");
  if (parts[0].startsWith("@")) {
    if (!parts[1])
      return null;
    return `${parts[0]}/${parts[1]}`;
  } else {
    return parts[0];
  }
}
var jsonExtRE = /\.json($|\?)(?!commonjs-(proxy|external))/;
var jsonLangs = `\\.(json|json5)($|\\?)`;
var jsonLangRE = new RegExp(jsonLangs);
var isJSONRequest = (request) => jsonLangRE.test(request);
function jsonPlugin(options3 = {}, isBuild) {
  return {
    name: "vite:json",
    transform(json, id) {
      if (!jsonExtRE.test(id))
        return null;
      if (SPECIAL_QUERY_RE.test(id))
        return null;
      json = stripBomTag(json);
      try {
        if (options3.stringify) {
          if (isBuild) {
            return {
              code: `export default JSON.parse(${JSON.stringify(JSON.stringify(JSON.parse(json)))})`,
              map: { mappings: "" }
            };
          } else {
            return `export default JSON.parse(${JSON.stringify(json)})`;
          }
        }
        const parsed = JSON.parse(json);
        return {
          code: dataToEsm(parsed, {
            preferConst: true,
            namedExports: options3.namedExports
          }),
          map: { mappings: "" }
        };
      } catch (e) {
        const errorMessageList = /[\d]+/.exec(e.message);
        const position = errorMessageList && parseInt(errorMessageList[0], 10);
        const msg = position ? `, invalid JSON syntax found at line ${position}` : `.`;
        this.error(`Failed to parse JSON file` + msg, e.idx);
      }
    }
  };
}
var ERR_OPTIMIZE_DEPS_PROCESSING_ERROR = "ERR_OPTIMIZE_DEPS_PROCESSING_ERROR";
var ERR_OUTDATED_OPTIMIZED_DEP = "ERR_OUTDATED_OPTIMIZED_DEP";
var isDebug$3 = process.env.DEBUG;
var debug$a = createDebugger("vite:optimize-deps");
function optimizedDepsPlugin(config2) {
  return {
    name: "vite:optimized-deps",
    async resolveId(id, source2, { ssr }) {
      var _a;
      if ((_a = getDepsOptimizer(config2, ssr)) == null ? void 0 : _a.isOptimizedDepFile(id)) {
        return id;
      }
    },
    async load(id, options3) {
      const ssr = (options3 == null ? void 0 : options3.ssr) === true;
      const depsOptimizer = getDepsOptimizer(config2, ssr);
      if (depsOptimizer == null ? void 0 : depsOptimizer.isOptimizedDepFile(id)) {
        const metadata = depsOptimizer.metadata;
        const file = cleanUrl(id);
        const versionMatch = id.match(DEP_VERSION_RE);
        const browserHash = versionMatch ? versionMatch[1].split("=")[1] : void 0;
        const info = optimizedDepInfoFromFile(metadata, file);
        if (info) {
          if (browserHash && info.browserHash !== browserHash) {
            throwOutdatedRequest(id);
          }
          try {
            await info.processing;
          } catch {
            throwProcessingError(id);
            return;
          }
          const newMetadata = depsOptimizer.metadata;
          if (metadata !== newMetadata) {
            const currentInfo = optimizedDepInfoFromFile(newMetadata, file);
            if (info.browserHash !== (currentInfo == null ? void 0 : currentInfo.browserHash)) {
              throwOutdatedRequest(id);
            }
          }
        }
        isDebug$3 && debug$a(`load ${picocolors.exports.cyan(file)}`);
        try {
          return await import_node_fs.promises.readFile(file, "utf-8");
        } catch (e) {
          throwOutdatedRequest(id);
        }
      }
    }
  };
}
function optimizedDepsBuildPlugin(config2) {
  return {
    name: "vite:optimized-deps-build",
    buildStart() {
      var _a;
      if (!config2.isWorker) {
        (_a = getDepsOptimizer(config2)) == null ? void 0 : _a.resetRegisteredIds();
      }
    },
    async resolveId(id, importer, { ssr }) {
      var _a;
      if ((_a = getDepsOptimizer(config2, ssr)) == null ? void 0 : _a.isOptimizedDepFile(id)) {
        return id;
      }
    },
    transform(_code, id, options3) {
      var _a;
      const ssr = (options3 == null ? void 0 : options3.ssr) === true;
      (_a = getDepsOptimizer(config2, ssr)) == null ? void 0 : _a.delayDepsOptimizerUntil(id, async () => {
        await this.load({ id });
      });
    },
    async load(id, options3) {
      const ssr = (options3 == null ? void 0 : options3.ssr) === true;
      const depsOptimizer = getDepsOptimizer(config2, ssr);
      if (!(depsOptimizer == null ? void 0 : depsOptimizer.isOptimizedDepFile(id))) {
        return;
      }
      depsOptimizer == null ? void 0 : depsOptimizer.ensureFirstRun();
      const file = cleanUrl(id);
      const info = optimizedDepInfoFromFile(depsOptimizer.metadata, file);
      if (info) {
        try {
          await info.processing;
        } catch {
          return;
        }
        isDebug$3 && debug$a(`load ${picocolors.exports.cyan(file)}`);
      } else {
        return;
      }
      try {
        return await import_node_fs.promises.readFile(file, "utf-8");
      } catch (e) {
        return "";
      }
    }
  };
}
function throwProcessingError(id) {
  const err = new Error(`Something unexpected happened while optimizing "${id}". The current page should have reloaded by now`);
  err.code = ERR_OPTIMIZE_DEPS_PROCESSING_ERROR;
  throw err;
}
function throwOutdatedRequest(id) {
  const err = new Error(`There is a new version of the pre-bundle for "${id}", a page reload is going to ask for it.`);
  err.code = ERR_OUTDATED_OPTIMIZED_DEP;
  throw err;
}
function makeTest(test) {
  if (typeof test === "string") {
    return function(type) {
      return type === test;
    };
  } else if (!test) {
    return function() {
      return true;
    };
  } else {
    return test;
  }
}
var Found = function Found2(node2, state) {
  this.node = node2;
  this.state = state;
};
function findNodeAt(node2, start, end, test, baseVisitor, state) {
  if (!baseVisitor) {
    baseVisitor = base;
  }
  test = makeTest(test);
  try {
    (function c2(node3, st, override) {
      var type = override || node3.type;
      if ((start == null || node3.start <= start) && (end == null || node3.end >= end)) {
        baseVisitor[type](node3, st, c2);
      }
      if ((start == null || node3.start === start) && (end == null || node3.end === end) && test(type, node3)) {
        throw new Found(node3, st);
      }
    })(node2, state);
  } catch (e) {
    if (e instanceof Found) {
      return e;
    }
    throw e;
  }
}
function skipThrough(node2, st, c2) {
  c2(node2, st);
}
function ignore(_node, _st, _c) {
}
var base = {};
base.Program = base.BlockStatement = base.StaticBlock = function(node2, st, c2) {
  for (var i = 0, list = node2.body; i < list.length; i += 1) {
    var stmt = list[i];
    c2(stmt, st, "Statement");
  }
};
base.Statement = skipThrough;
base.EmptyStatement = ignore;
base.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression = function(node2, st, c2) {
  return c2(node2.expression, st, "Expression");
};
base.IfStatement = function(node2, st, c2) {
  c2(node2.test, st, "Expression");
  c2(node2.consequent, st, "Statement");
  if (node2.alternate) {
    c2(node2.alternate, st, "Statement");
  }
};
base.LabeledStatement = function(node2, st, c2) {
  return c2(node2.body, st, "Statement");
};
base.BreakStatement = base.ContinueStatement = ignore;
base.WithStatement = function(node2, st, c2) {
  c2(node2.object, st, "Expression");
  c2(node2.body, st, "Statement");
};
base.SwitchStatement = function(node2, st, c2) {
  c2(node2.discriminant, st, "Expression");
  for (var i$1 = 0, list$1 = node2.cases; i$1 < list$1.length; i$1 += 1) {
    var cs = list$1[i$1];
    if (cs.test) {
      c2(cs.test, st, "Expression");
    }
    for (var i = 0, list = cs.consequent; i < list.length; i += 1) {
      var cons = list[i];
      c2(cons, st, "Statement");
    }
  }
};
base.SwitchCase = function(node2, st, c2) {
  if (node2.test) {
    c2(node2.test, st, "Expression");
  }
  for (var i = 0, list = node2.consequent; i < list.length; i += 1) {
    var cons = list[i];
    c2(cons, st, "Statement");
  }
};
base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function(node2, st, c2) {
  if (node2.argument) {
    c2(node2.argument, st, "Expression");
  }
};
base.ThrowStatement = base.SpreadElement = function(node2, st, c2) {
  return c2(node2.argument, st, "Expression");
};
base.TryStatement = function(node2, st, c2) {
  c2(node2.block, st, "Statement");
  if (node2.handler) {
    c2(node2.handler, st);
  }
  if (node2.finalizer) {
    c2(node2.finalizer, st, "Statement");
  }
};
base.CatchClause = function(node2, st, c2) {
  if (node2.param) {
    c2(node2.param, st, "Pattern");
  }
  c2(node2.body, st, "Statement");
};
base.WhileStatement = base.DoWhileStatement = function(node2, st, c2) {
  c2(node2.test, st, "Expression");
  c2(node2.body, st, "Statement");
};
base.ForStatement = function(node2, st, c2) {
  if (node2.init) {
    c2(node2.init, st, "ForInit");
  }
  if (node2.test) {
    c2(node2.test, st, "Expression");
  }
  if (node2.update) {
    c2(node2.update, st, "Expression");
  }
  c2(node2.body, st, "Statement");
};
base.ForInStatement = base.ForOfStatement = function(node2, st, c2) {
  c2(node2.left, st, "ForInit");
  c2(node2.right, st, "Expression");
  c2(node2.body, st, "Statement");
};
base.ForInit = function(node2, st, c2) {
  if (node2.type === "VariableDeclaration") {
    c2(node2, st);
  } else {
    c2(node2, st, "Expression");
  }
};
base.DebuggerStatement = ignore;
base.FunctionDeclaration = function(node2, st, c2) {
  return c2(node2, st, "Function");
};
base.VariableDeclaration = function(node2, st, c2) {
  for (var i = 0, list = node2.declarations; i < list.length; i += 1) {
    var decl = list[i];
    c2(decl, st);
  }
};
base.VariableDeclarator = function(node2, st, c2) {
  c2(node2.id, st, "Pattern");
  if (node2.init) {
    c2(node2.init, st, "Expression");
  }
};
base.Function = function(node2, st, c2) {
  if (node2.id) {
    c2(node2.id, st, "Pattern");
  }
  for (var i = 0, list = node2.params; i < list.length; i += 1) {
    var param = list[i];
    c2(param, st, "Pattern");
  }
  c2(node2.body, st, node2.expression ? "Expression" : "Statement");
};
base.Pattern = function(node2, st, c2) {
  if (node2.type === "Identifier") {
    c2(node2, st, "VariablePattern");
  } else if (node2.type === "MemberExpression") {
    c2(node2, st, "MemberPattern");
  } else {
    c2(node2, st);
  }
};
base.VariablePattern = ignore;
base.MemberPattern = skipThrough;
base.RestElement = function(node2, st, c2) {
  return c2(node2.argument, st, "Pattern");
};
base.ArrayPattern = function(node2, st, c2) {
  for (var i = 0, list = node2.elements; i < list.length; i += 1) {
    var elt = list[i];
    if (elt) {
      c2(elt, st, "Pattern");
    }
  }
};
base.ObjectPattern = function(node2, st, c2) {
  for (var i = 0, list = node2.properties; i < list.length; i += 1) {
    var prop = list[i];
    if (prop.type === "Property") {
      if (prop.computed) {
        c2(prop.key, st, "Expression");
      }
      c2(prop.value, st, "Pattern");
    } else if (prop.type === "RestElement") {
      c2(prop.argument, st, "Pattern");
    }
  }
};
base.Expression = skipThrough;
base.ThisExpression = base.Super = base.MetaProperty = ignore;
base.ArrayExpression = function(node2, st, c2) {
  for (var i = 0, list = node2.elements; i < list.length; i += 1) {
    var elt = list[i];
    if (elt) {
      c2(elt, st, "Expression");
    }
  }
};
base.ObjectExpression = function(node2, st, c2) {
  for (var i = 0, list = node2.properties; i < list.length; i += 1) {
    var prop = list[i];
    c2(prop, st);
  }
};
base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
base.SequenceExpression = function(node2, st, c2) {
  for (var i = 0, list = node2.expressions; i < list.length; i += 1) {
    var expr = list[i];
    c2(expr, st, "Expression");
  }
};
base.TemplateLiteral = function(node2, st, c2) {
  for (var i = 0, list = node2.quasis; i < list.length; i += 1) {
    var quasi = list[i];
    c2(quasi, st);
  }
  for (var i$1 = 0, list$1 = node2.expressions; i$1 < list$1.length; i$1 += 1) {
    var expr = list$1[i$1];
    c2(expr, st, "Expression");
  }
};
base.TemplateElement = ignore;
base.UnaryExpression = base.UpdateExpression = function(node2, st, c2) {
  c2(node2.argument, st, "Expression");
};
base.BinaryExpression = base.LogicalExpression = function(node2, st, c2) {
  c2(node2.left, st, "Expression");
  c2(node2.right, st, "Expression");
};
base.AssignmentExpression = base.AssignmentPattern = function(node2, st, c2) {
  c2(node2.left, st, "Pattern");
  c2(node2.right, st, "Expression");
};
base.ConditionalExpression = function(node2, st, c2) {
  c2(node2.test, st, "Expression");
  c2(node2.consequent, st, "Expression");
  c2(node2.alternate, st, "Expression");
};
base.NewExpression = base.CallExpression = function(node2, st, c2) {
  c2(node2.callee, st, "Expression");
  if (node2.arguments) {
    for (var i = 0, list = node2.arguments; i < list.length; i += 1) {
      var arg = list[i];
      c2(arg, st, "Expression");
    }
  }
};
base.MemberExpression = function(node2, st, c2) {
  c2(node2.object, st, "Expression");
  if (node2.computed) {
    c2(node2.property, st, "Expression");
  }
};
base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function(node2, st, c2) {
  if (node2.declaration) {
    c2(node2.declaration, st, node2.type === "ExportNamedDeclaration" || node2.declaration.id ? "Statement" : "Expression");
  }
  if (node2.source) {
    c2(node2.source, st, "Expression");
  }
};
base.ExportAllDeclaration = function(node2, st, c2) {
  if (node2.exported) {
    c2(node2.exported, st);
  }
  c2(node2.source, st, "Expression");
};
base.ImportDeclaration = function(node2, st, c2) {
  for (var i = 0, list = node2.specifiers; i < list.length; i += 1) {
    var spec = list[i];
    c2(spec, st);
  }
  c2(node2.source, st, "Expression");
};
base.ImportExpression = function(node2, st, c2) {
  c2(node2.source, st, "Expression");
};
base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.PrivateIdentifier = base.Literal = ignore;
base.TaggedTemplateExpression = function(node2, st, c2) {
  c2(node2.tag, st, "Expression");
  c2(node2.quasi, st, "Expression");
};
base.ClassDeclaration = base.ClassExpression = function(node2, st, c2) {
  return c2(node2, st, "Class");
};
base.Class = function(node2, st, c2) {
  if (node2.id) {
    c2(node2.id, st, "Pattern");
  }
  if (node2.superClass) {
    c2(node2.superClass, st, "Expression");
  }
  c2(node2.body, st);
};
base.ClassBody = function(node2, st, c2) {
  for (var i = 0, list = node2.body; i < list.length; i += 1) {
    var elt = list[i];
    c2(elt, st);
  }
};
base.MethodDefinition = base.PropertyDefinition = base.Property = function(node2, st, c2) {
  if (node2.computed) {
    c2(node2.key, st, "Expression");
  }
  if (node2.value) {
    c2(node2.value, st, "Expression");
  }
};
var { isMatch: isMatch$1, scan } = micromatch_1;
function getAffectedGlobModules(file, server2) {
  const modules = [];
  for (const [id, allGlobs] of server2._importGlobMap) {
    if (allGlobs.some((glob) => isMatch$1(file, glob)))
      modules.push(...server2.moduleGraph.getModulesByFile(id) || []);
  }
  modules.forEach((i) => {
    if (i == null ? void 0 : i.file)
      server2.moduleGraph.onFileChange(i.file);
  });
  return modules;
}
function importGlobPlugin(config2) {
  let server2;
  return {
    name: "vite:import-glob",
    configureServer(_server) {
      server2 = _server;
      server2._importGlobMap.clear();
    },
    async transform(code, id) {
      if (!code.includes("import.meta.glob"))
        return;
      const result = await transformGlobImport(code, id, config2.root, (im) => this.resolve(im, id).then((i) => (i == null ? void 0 : i.id) || im), config2.experimental.importGlobRestoreExtension);
      if (result) {
        if (server2) {
          const allGlobs = result.matches.map((i) => i.globsResolved);
          server2._importGlobMap.set(id, allGlobs);
        }
        return transformStableResult(result.s, id, config2);
      }
    }
  };
}
var importGlobRE = /\bimport\.meta\.(glob|globEager|globEagerDefault)(?:<\w+>)?\s*\(/g;
var knownOptions = {
  as: "string",
  eager: "boolean",
  import: "string",
  exhaustive: "boolean"
};
var forceDefaultAs = ["raw", "url"];
async function parseImportGlob(code, importer, root2, resolveId) {
  let cleanCode;
  try {
    cleanCode = stripLiteral(code);
  } catch (e) {
    return [];
  }
  const matches2 = Array.from(cleanCode.matchAll(importGlobRE));
  const tasks2 = matches2.map(async (match, index2) => {
    const type = match[1];
    const start = match.index;
    const err = (msg) => {
      const e = new Error(`Invalid glob import syntax: ${msg}`);
      e.pos = start;
      return e;
    };
    let ast;
    let lastTokenPos;
    try {
      ast = parseExpressionAt2(code, start, {
        ecmaVersion: "latest",
        sourceType: "module",
        ranges: true,
        onToken: (token2) => {
          lastTokenPos = token2.end;
        }
      });
    } catch (e) {
      const _e = e;
      if (_e.message && _e.message.startsWith("Unterminated string constant"))
        return void 0;
      if (lastTokenPos == null || lastTokenPos <= start)
        throw _e;
      try {
        const statement = code.slice(start, lastTokenPos).replace(/[,\s]*$/, "");
        ast = parseExpressionAt2(
          " ".repeat(start) + statement,
          start,
          {
            ecmaVersion: "latest",
            sourceType: "module",
            ranges: true
          }
        );
      } catch {
        throw _e;
      }
    }
    const found2 = findNodeAt(ast, start, void 0, "CallExpression");
    if (!found2)
      throw err(`Expect CallExpression, got ${ast.type}`);
    ast = found2.node;
    if (ast.arguments.length < 1 || ast.arguments.length > 2)
      throw err(`Expected 1-2 arguments, but got ${ast.arguments.length}`);
    const arg1 = ast.arguments[0];
    const arg2 = ast.arguments[1];
    const globs = [];
    const validateLiteral = (element) => {
      if (!element)
        return;
      if (element.type === "Literal") {
        if (typeof element.value !== "string")
          throw err(`Expected glob to be a string, but got "${typeof element.value}"`);
        globs.push(element.value);
      } else if (element.type === "TemplateLiteral") {
        if (element.expressions.length !== 0) {
          throw err(`Expected glob to be a string, but got dynamic template literal`);
        }
        globs.push(element.quasis[0].value.raw);
      } else {
        throw err("Could only use literals");
      }
    };
    if (arg1.type === "ArrayExpression") {
      for (const element of arg1.elements) {
        validateLiteral(element);
      }
    } else {
      validateLiteral(arg1);
    }
    const options3 = {};
    if (arg2) {
      if (arg2.type !== "ObjectExpression")
        throw err(`Expected the second argument o to be a object literal, but got "${arg2.type}"`);
      for (const property of arg2.properties) {
        if (property.type === "SpreadElement" || property.key.type !== "Identifier" && property.key.type !== "Literal")
          throw err("Could only use literals");
        const name = property.key.name || property.key.value;
        if (name === "query") {
          if (property.value.type === "ObjectExpression") {
            const data2 = {};
            for (const prop of property.value.properties) {
              if (prop.type === "SpreadElement" || prop.key.type !== "Identifier" || prop.value.type !== "Literal")
                throw err("Could only use literals");
              data2[prop.key.name] = prop.value.value;
            }
            options3.query = data2;
          } else if (property.value.type === "Literal") {
            if (typeof property.value.value !== "string")
              throw err(`Expected query to be a string, but got "${typeof property.value.value}"`);
            options3.query = property.value.value;
          } else {
            throw err("Could only use literals");
          }
          continue;
        }
        if (!(name in knownOptions))
          throw err(`Unknown options ${name}`);
        if (property.value.type !== "Literal")
          throw err("Could only use literals");
        const valueType = typeof property.value.value;
        if (valueType === "undefined")
          continue;
        if (valueType !== knownOptions[name])
          throw err(`Expected the type of option "${name}" to be "${knownOptions[name]}", but got "${valueType}"`);
        options3[name] = property.value.value;
      }
    }
    if (options3.as && forceDefaultAs.includes(options3.as)) {
      if (options3.import && options3.import !== "default" && options3.import !== "*")
        throw err(`Option "import" can only be "default" or "*" when "as" is "${options3.as}", but got "${options3.import}"`);
      options3.import = options3.import || "default";
    }
    if (options3.as && options3.query)
      throw err('Options "as" and "query" cannot be used together');
    if (options3.as)
      options3.query = options3.as;
    const end = ast.range[1];
    const globsResolved = await Promise.all(globs.map((glob) => toAbsoluteGlob(glob, root2, importer, resolveId)));
    const isRelative2 = globs.every((i) => ".!".includes(i[0]));
    return {
      match,
      index: index2,
      globs,
      globsResolved,
      isRelative: isRelative2,
      options: options3,
      type,
      start,
      end
    };
  });
  return (await Promise.all(tasks2)).filter(Boolean);
}
var importPrefix = "__vite_glob_";
var { basename, dirname, relative, join } = import_node_path2.posix;
async function transformGlobImport(code, id, root2, resolveId, restoreQueryExtension = false) {
  id = slash$1(id);
  root2 = slash$1(root2);
  const isVirtual = isVirtualModule(id);
  const dir = isVirtual ? void 0 : dirname(id);
  const matches2 = await parseImportGlob(code, isVirtual ? void 0 : id, root2, resolveId);
  const matchedFiles = /* @__PURE__ */ new Set();
  matches2.forEach((i) => {
    if (i.type === "globEager")
      i.options.eager = true;
    if (i.type === "globEagerDefault") {
      i.options.eager = true;
      i.options.import = "default";
    }
  });
  if (!matches2.length)
    return null;
  const s = new MagicString(code);
  const staticImports = (await Promise.all(matches2.map(async ({ globsResolved, isRelative: isRelative2, options: options3, index: index2, start, end }) => {
    var _a, _b, _c;
    const cwd = (_a = getCommonBase(globsResolved)) != null ? _a : root2;
    const files = (await out(globsResolved, {
      cwd,
      absolute: true,
      dot: !!options3.exhaustive,
      ignore: options3.exhaustive ? [] : [join(cwd, "**/node_modules/**")]
    })).filter((file) => file !== id).sort();
    const objectProps = [];
    const staticImports2 = [];
    let query = !options3.query ? "" : typeof options3.query === "string" ? options3.query : stringifyQuery(options3.query);
    if (query && !query.startsWith("?"))
      query = `?${query}`;
    const resolvePaths = (file) => {
      if (!dir) {
        if (isRelative2)
          throw new Error("In virtual modules, all globs must start with '/'");
        const filePath2 = `/${relative(root2, file)}`;
        return { filePath: filePath2, importPath: filePath2 };
      }
      let importPath = relative(dir, file);
      if (!importPath.startsWith("."))
        importPath = `./${importPath}`;
      let filePath;
      if (isRelative2) {
        filePath = importPath;
      } else {
        filePath = relative(root2, file);
        if (!filePath.startsWith("."))
          filePath = `/${filePath}`;
      }
      return { filePath, importPath };
    };
    files.forEach((file, i) => {
      const paths = resolvePaths(file);
      const filePath = paths.filePath;
      let importPath = paths.importPath;
      let importQuery = query;
      if (importQuery && importQuery !== "?raw") {
        const fileExtension = basename(file).split(".").slice(-1)[0];
        if (fileExtension && restoreQueryExtension)
          importQuery = `${importQuery}&lang.${fileExtension}`;
      }
      importPath = `${importPath}${importQuery}`;
      const importKey = options3.import && options3.import !== "*" ? options3.import : void 0;
      if (options3.eager) {
        const variableName = `${importPrefix}${index2}_${i}`;
        const expression = importKey ? `{ ${importKey} as ${variableName} }` : `* as ${variableName}`;
        staticImports2.push(`import ${expression} from ${JSON.stringify(importPath)}`);
        objectProps.push(`${JSON.stringify(filePath)}: ${variableName}`);
      } else {
        let importStatement = `import(${JSON.stringify(importPath)})`;
        if (importKey)
          importStatement += `.then(m => m[${JSON.stringify(importKey)}])`;
        objectProps.push(`${JSON.stringify(filePath)}: () => ${importStatement}`);
      }
    });
    files.forEach((i) => matchedFiles.add(i));
    const originalLineBreakCount = (_c = (_b = code.slice(start, end).match(/\n/g)) == null ? void 0 : _b.length) != null ? _c : 0;
    const lineBreaks = originalLineBreakCount > 0 ? "\n".repeat(originalLineBreakCount) : "";
    const replacement = `/* #__PURE__ */ Object.assign({${objectProps.join(",")}${lineBreaks}})`;
    s.overwrite(start, end, replacement);
    return staticImports2;
  }))).flat();
  if (staticImports.length)
    s.prepend(`${staticImports.join(";")};`);
  return {
    s,
    matches: matches2,
    files: matchedFiles
  };
}
function globSafePath(path4) {
  return out.escapePath(normalizePath$3(path4));
}
function lastNthChar(str, n2) {
  return str.charAt(str.length - 1 - n2);
}
function globSafeResolvedPath(resolved, glob) {
  let numEqual = 0;
  const maxEqual = Math.min(resolved.length, glob.length);
  while (numEqual < maxEqual && lastNthChar(resolved, numEqual) === lastNthChar(glob, numEqual)) {
    numEqual += 1;
  }
  const staticPartEnd = resolved.length - numEqual;
  const staticPart = resolved.slice(0, staticPartEnd);
  const dynamicPart = resolved.slice(staticPartEnd);
  return globSafePath(staticPart) + dynamicPart;
}
async function toAbsoluteGlob(glob, root2, importer, resolveId) {
  let pre = "";
  if (glob.startsWith("!")) {
    pre = "!";
    glob = glob.slice(1);
  }
  root2 = globSafePath(root2);
  const dir = importer ? globSafePath(dirname(importer)) : root2;
  if (glob.startsWith("/"))
    return pre + import_node_path2.posix.join(root2, glob.slice(1));
  if (glob.startsWith("./"))
    return pre + import_node_path2.posix.join(dir, glob.slice(2));
  if (glob.startsWith("../"))
    return pre + import_node_path2.posix.join(dir, glob);
  if (glob.startsWith("**"))
    return pre + glob;
  const resolved = normalizePath$3(await resolveId(glob, importer) || glob);
  if ((0, import_node_path2.isAbsolute)(resolved)) {
    return pre + globSafeResolvedPath(resolved, glob);
  }
  throw new Error(`Invalid glob: "${glob}" (resolved: "${resolved}"). It must start with '/' or './'`);
}
function getCommonBase(globsResolved) {
  const bases = globsResolved.filter((g) => !g.startsWith("!")).map((glob) => {
    let { base: base2 } = scan(glob);
    if (import_node_path2.posix.basename(base2).includes("."))
      base2 = import_node_path2.posix.dirname(base2);
    return base2;
  });
  if (!bases.length)
    return null;
  let commonAncestor = "";
  const dirS = bases[0].split("/");
  for (let i = 0; i < dirS.length; i++) {
    const candidate = dirS.slice(0, i + 1).join("/");
    if (bases.every((base2) => base2.startsWith(candidate)))
      commonAncestor = candidate;
    else
      break;
  }
  if (!commonAncestor)
    commonAncestor = "/";
  return commonAncestor;
}
function isVirtualModule(id) {
  return id.startsWith("virtual:") || id.startsWith("\0") || !id.includes("/");
}
var debugHmr = createDebugger("vite:hmr");
var normalizedClientDir = normalizePath$3(CLIENT_DIR);
function getShortName(file, root2) {
  return file.startsWith(root2 + "/") ? import_node_path2.default.posix.relative(root2, file) : file;
}
async function handleHMRUpdate(file, server2) {
  const { ws, config: config2, moduleGraph } = server2;
  const shortFile = getShortName(file, config2.root);
  const fileName = import_node_path2.default.basename(file);
  const isConfig = file === config2.configFile;
  const isConfigDependency = config2.configFileDependencies.some((name) => file === name);
  const isEnv = config2.inlineConfig.envFile !== false && (fileName === ".env" || fileName.startsWith(".env."));
  if (isConfig || isConfigDependency || isEnv) {
    debugHmr(`[config change] ${picocolors.exports.dim(shortFile)}`);
    config2.logger.info(picocolors.exports.green(`${import_node_path2.default.relative(process.cwd(), file)} changed, restarting server...`), { clear: true, timestamp: true });
    try {
      await server2.restart();
    } catch (e) {
      config2.logger.error(picocolors.exports.red(e));
    }
    return;
  }
  debugHmr(`[file change] ${picocolors.exports.dim(shortFile)}`);
  if (file.startsWith(normalizedClientDir)) {
    ws.send({
      type: "full-reload",
      path: "*"
    });
    return;
  }
  const mods = moduleGraph.getModulesByFile(file);
  const timestamp2 = Date.now();
  const hmrContext = {
    file,
    timestamp: timestamp2,
    modules: mods ? [...mods] : [],
    read: () => readModifiedFile(file),
    server: server2
  };
  for (const hook of config2.getSortedPluginHooks("handleHotUpdate")) {
    const filteredModules = await hook(hmrContext);
    if (filteredModules) {
      hmrContext.modules = filteredModules;
    }
  }
  if (!hmrContext.modules.length) {
    if (file.endsWith(".html")) {
      config2.logger.info(picocolors.exports.green(`page reload `) + picocolors.exports.dim(shortFile), {
        clear: true,
        timestamp: true
      });
      ws.send({
        type: "full-reload",
        path: config2.server.middlewareMode ? "*" : "/" + normalizePath$3(import_node_path2.default.relative(config2.root, file))
      });
    } else {
      debugHmr(`[no modules matched] ${picocolors.exports.dim(shortFile)}`);
    }
    return;
  }
  updateModules(shortFile, hmrContext.modules, timestamp2, server2);
}
function updateModules(file, modules, timestamp2, { config: config2, ws }) {
  const updates = [];
  const invalidatedModules = /* @__PURE__ */ new Set();
  let needFullReload = false;
  for (const mod of modules) {
    invalidate(mod, timestamp2, invalidatedModules);
    if (needFullReload) {
      continue;
    }
    const boundaries = /* @__PURE__ */ new Set();
    const hasDeadEnd = propagateUpdate(mod, boundaries);
    if (hasDeadEnd) {
      needFullReload = true;
      continue;
    }
    updates.push(...[...boundaries].map(({ boundary, acceptedVia }) => ({
      type: `${boundary.type}-update`,
      timestamp: timestamp2,
      path: normalizeHmrUrl(boundary.url),
      explicitImportRequired: boundary.type === "js" ? isExplicitImportRequired(acceptedVia.url) : void 0,
      acceptedPath: normalizeHmrUrl(acceptedVia.url)
    })));
  }
  if (needFullReload) {
    config2.logger.info(picocolors.exports.green(`page reload `) + picocolors.exports.dim(file), {
      clear: true,
      timestamp: true
    });
    ws.send({
      type: "full-reload"
    });
    return;
  }
  if (updates.length === 0) {
    debugHmr(picocolors.exports.yellow(`no update happened `) + picocolors.exports.dim(file));
    return;
  }
  config2.logger.info(updates.map(({ path: path4 }) => picocolors.exports.green(`hmr update `) + picocolors.exports.dim(path4)).join("\n"), { clear: true, timestamp: true });
  ws.send({
    type: "update",
    updates
  });
}
async function handleFileAddUnlink(file, server2) {
  const modules = [...server2.moduleGraph.getModulesByFile(file) || []];
  modules.push(...getAffectedGlobModules(file, server2));
  if (modules.length > 0) {
    updateModules(getShortName(file, server2.config.root), unique(modules), Date.now(), server2);
  }
}
function areAllImportsAccepted(importedBindings, acceptedExports) {
  for (const binding of importedBindings) {
    if (!acceptedExports.has(binding)) {
      return false;
    }
  }
  return true;
}
function propagateUpdate(node2, boundaries, currentChain = [node2]) {
  if (node2.id && node2.isSelfAccepting === void 0) {
    debugHmr(`[propagate update] stop propagation because not analyzed: ${picocolors.exports.dim(node2.id)}`);
    return false;
  }
  if (node2.isSelfAccepting) {
    boundaries.add({
      boundary: node2,
      acceptedVia: node2
    });
    for (const importer of node2.importers) {
      if (isCSSRequest(importer.url) && !currentChain.includes(importer)) {
        propagateUpdate(importer, boundaries, currentChain.concat(importer));
      }
    }
    return false;
  }
  if (node2.acceptedHmrExports) {
    boundaries.add({
      boundary: node2,
      acceptedVia: node2
    });
  } else {
    if (!node2.importers.size) {
      return true;
    }
    if (!isCSSRequest(node2.url) && [...node2.importers].every((i) => isCSSRequest(i.url))) {
      return true;
    }
  }
  for (const importer of node2.importers) {
    const subChain = currentChain.concat(importer);
    if (importer.acceptedHmrDeps.has(node2)) {
      boundaries.add({
        boundary: importer,
        acceptedVia: node2
      });
      continue;
    }
    if (node2.id && node2.acceptedHmrExports && importer.importedBindings) {
      const importedBindingsFromNode = importer.importedBindings.get(node2.id);
      if (importedBindingsFromNode && areAllImportsAccepted(importedBindingsFromNode, node2.acceptedHmrExports)) {
        continue;
      }
    }
    if (currentChain.includes(importer)) {
      return true;
    }
    if (propagateUpdate(importer, boundaries, subChain)) {
      return true;
    }
  }
  return false;
}
function invalidate(mod, timestamp2, seen2) {
  if (seen2.has(mod)) {
    return;
  }
  seen2.add(mod);
  mod.lastHMRTimestamp = timestamp2;
  mod.transformResult = null;
  mod.ssrModule = null;
  mod.ssrError = null;
  mod.ssrTransformResult = null;
  mod.importers.forEach((importer) => {
    if (!importer.acceptedHmrDeps.has(mod)) {
      invalidate(importer, timestamp2, seen2);
    }
  });
}
function handlePrunedModules(mods, { ws }) {
  const t = Date.now();
  mods.forEach((mod) => {
    mod.lastHMRTimestamp = t;
    debugHmr(`[dispose] ${picocolors.exports.dim(mod.file)}`);
  });
  ws.send({
    type: "prune",
    paths: [...mods].map((m) => m.url)
  });
}
function lexAcceptedHmrDeps(code, start, urls) {
  let state = 0;
  let prevState = 0;
  let currentDep = "";
  function addDep(index2) {
    urls.add({
      url: currentDep,
      start: index2 - currentDep.length - 1,
      end: index2 + 1
    });
    currentDep = "";
  }
  for (let i = start; i < code.length; i++) {
    const char = code.charAt(i);
    switch (state) {
      case 0:
      case 4:
        if (char === `'`) {
          prevState = state;
          state = 1;
        } else if (char === `"`) {
          prevState = state;
          state = 2;
        } else if (char === "`") {
          prevState = state;
          state = 3;
        } else if (/\s/.test(char)) {
          continue;
        } else {
          if (state === 0) {
            if (char === `[`) {
              state = 4;
            } else {
              return true;
            }
          } else if (state === 4) {
            if (char === `]`) {
              return false;
            } else if (char === ",") {
              continue;
            } else {
              error$1(i);
            }
          }
        }
        break;
      case 1:
        if (char === `'`) {
          addDep(i);
          if (prevState === 0) {
            return false;
          } else {
            state = prevState;
          }
        } else {
          currentDep += char;
        }
        break;
      case 2:
        if (char === `"`) {
          addDep(i);
          if (prevState === 0) {
            return false;
          } else {
            state = prevState;
          }
        } else {
          currentDep += char;
        }
        break;
      case 3:
        if (char === "`") {
          addDep(i);
          if (prevState === 0) {
            return false;
          } else {
            state = prevState;
          }
        } else if (char === "$" && code.charAt(i + 1) === "{") {
          error$1(i);
        } else {
          currentDep += char;
        }
        break;
      default:
        throw new Error("unknown import.meta.hot lexer state");
    }
  }
  return false;
}
function lexAcceptedHmrExports(code, start, exportNames) {
  const urls = /* @__PURE__ */ new Set();
  lexAcceptedHmrDeps(code, start, urls);
  for (const { url: url2 } of urls) {
    exportNames.add(url2);
  }
  return urls.size > 0;
}
function normalizeHmrUrl(url2) {
  if (!url2.startsWith(".") && !url2.startsWith("/")) {
    url2 = wrapId(url2);
  }
  return url2;
}
function error$1(pos2) {
  const err = new Error(`import.meta.hot.accept() can only accept string literals or an Array of string literals.`);
  err.pos = pos2;
  throw err;
}
async function readModifiedFile(file) {
  const content = import_node_fs.default.readFileSync(file, "utf-8");
  if (!content) {
    const mtime = import_node_fs.default.statSync(file).mtimeMs;
    await new Promise((r) => {
      let n2 = 0;
      const poll = async () => {
        n2++;
        const newMtime = import_node_fs.default.statSync(file).mtimeMs;
        if (newMtime !== mtime || n2 > 10) {
          r(0);
        } else {
          setTimeout(poll, 10);
        }
      };
      setTimeout(poll, 10);
    });
    return import_node_fs.default.readFileSync(file, "utf-8");
  } else {
    return content;
  }
}
var etag_1 = etag;
var crypto = import_crypto.default;
var Stats = import_fs.default.Stats;
var toString = Object.prototype.toString;
function entitytag(entity) {
  if (entity.length === 0) {
    return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
  }
  var hash = crypto.createHash("sha1").update(entity, "utf8").digest("base64").substring(0, 27);
  var len = typeof entity === "string" ? Buffer.byteLength(entity, "utf8") : entity.length;
  return '"' + len.toString(16) + "-" + hash + '"';
}
function etag(entity, options3) {
  if (entity == null) {
    throw new TypeError("argument entity is required");
  }
  var isStats = isstats(entity);
  var weak = options3 && typeof options3.weak === "boolean" ? options3.weak : isStats;
  if (!isStats && typeof entity !== "string" && !Buffer.isBuffer(entity)) {
    throw new TypeError("argument entity must be string, Buffer, or fs.Stats");
  }
  var tag = isStats ? stattag(entity) : entitytag(entity);
  return weak ? "W/" + tag : tag;
}
function isstats(obj) {
  if (typeof Stats === "function" && obj instanceof Stats) {
    return true;
  }
  return obj && typeof obj === "object" && "ctime" in obj && toString.call(obj.ctime) === "[object Date]" && "mtime" in obj && toString.call(obj.mtime) === "[object Date]" && "ino" in obj && typeof obj.ino === "number" && "size" in obj && typeof obj.size === "number";
}
function stattag(stat2) {
  var mtime = stat2.mtime.getTime().toString(16);
  var size = stat2.size.toString(16);
  return '"' + size + "-" + mtime + '"';
}
var convertSourceMap = {};
(function(exports) {
  var fs2 = import_fs.default;
  var path4 = import_path.default;
  Object.defineProperty(exports, "commentRegex", {
    get: function getCommentRegex() {
      return /^\s*\/(?:\/|\*)[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/mg;
    }
  });
  Object.defineProperty(exports, "mapFileCommentRegex", {
    get: function getMapFileCommentRegex() {
      return /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"`]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/mg;
    }
  });
  var decodeBase64;
  if (typeof Buffer !== "undefined") {
    if (typeof Buffer.from === "function") {
      decodeBase64 = decodeBase64WithBufferFrom;
    } else {
      decodeBase64 = decodeBase64WithNewBuffer;
    }
  } else {
    decodeBase64 = decodeBase64WithAtob;
  }
  function decodeBase64WithBufferFrom(base64) {
    return Buffer.from(base64, "base64").toString();
  }
  function decodeBase64WithNewBuffer(base64) {
    if (typeof value === "number") {
      throw new TypeError("The value to decode must not be of type number.");
    }
    return new Buffer(base64, "base64").toString();
  }
  function decodeBase64WithAtob(base64) {
    return decodeURIComponent(escape(atob(base64)));
  }
  function stripComment(sm) {
    return sm.split(",").pop();
  }
  function readFromFileMap(sm, dir) {
    var r = exports.mapFileCommentRegex.exec(sm);
    var filename = r[1] || r[2];
    var filepath = path4.resolve(dir, filename);
    try {
      return fs2.readFileSync(filepath, "utf8");
    } catch (e) {
      throw new Error("An error occurred while trying to read the map file at " + filepath + "\n" + e);
    }
  }
  function Converter(sm, opts) {
    opts = opts || {};
    if (opts.isFileComment)
      sm = readFromFileMap(sm, opts.commentFileDir);
    if (opts.hasComment)
      sm = stripComment(sm);
    if (opts.isEncoded)
      sm = decodeBase64(sm);
    if (opts.isJSON || opts.isEncoded)
      sm = JSON.parse(sm);
    this.sourcemap = sm;
  }
  Converter.prototype.toJSON = function(space) {
    return JSON.stringify(this.sourcemap, null, space);
  };
  if (typeof Buffer !== "undefined") {
    if (typeof Buffer.from === "function") {
      Converter.prototype.toBase64 = encodeBase64WithBufferFrom;
    } else {
      Converter.prototype.toBase64 = encodeBase64WithNewBuffer;
    }
  } else {
    Converter.prototype.toBase64 = encodeBase64WithBtoa;
  }
  function encodeBase64WithBufferFrom() {
    var json = this.toJSON();
    return Buffer.from(json, "utf8").toString("base64");
  }
  function encodeBase64WithNewBuffer() {
    var json = this.toJSON();
    if (typeof json === "number") {
      throw new TypeError("The json to encode must not be of type number.");
    }
    return new Buffer(json, "utf8").toString("base64");
  }
  function encodeBase64WithBtoa() {
    var json = this.toJSON();
    return btoa(unescape(encodeURIComponent(json)));
  }
  Converter.prototype.toComment = function(options3) {
    var base64 = this.toBase64();
    var data2 = "sourceMappingURL=data:application/json;charset=utf-8;base64," + base64;
    return options3 && options3.multiline ? "/*# " + data2 + " */" : "//# " + data2;
  };
  Converter.prototype.toObject = function() {
    return JSON.parse(this.toJSON());
  };
  Converter.prototype.addProperty = function(key2, value2) {
    if (this.sourcemap.hasOwnProperty(key2))
      throw new Error('property "' + key2 + '" already exists on the sourcemap, use set property instead');
    return this.setProperty(key2, value2);
  };
  Converter.prototype.setProperty = function(key2, value2) {
    this.sourcemap[key2] = value2;
    return this;
  };
  Converter.prototype.getProperty = function(key2) {
    return this.sourcemap[key2];
  };
  exports.fromObject = function(obj) {
    return new Converter(obj);
  };
  exports.fromJSON = function(json) {
    return new Converter(json, { isJSON: true });
  };
  exports.fromBase64 = function(base64) {
    return new Converter(base64, { isEncoded: true });
  };
  exports.fromComment = function(comment) {
    comment = comment.replace(/^\/\*/g, "//").replace(/\*\/$/g, "");
    return new Converter(comment, { isEncoded: true, hasComment: true });
  };
  exports.fromMapFileComment = function(comment, dir) {
    return new Converter(comment, { commentFileDir: dir, isFileComment: true, isJSON: true });
  };
  exports.fromSource = function(content) {
    var m = content.match(exports.commentRegex);
    return m ? exports.fromComment(m.pop()) : null;
  };
  exports.fromMapFileSource = function(content, dir) {
    var m = content.match(exports.mapFileCommentRegex);
    return m ? exports.fromMapFileComment(m.pop(), dir) : null;
  };
  exports.removeComments = function(src2) {
    return src2.replace(exports.commentRegex, "");
  };
  exports.removeMapFileComments = function(src2) {
    return src2.replace(exports.mapFileCommentRegex, "");
  };
  exports.generateMapFileComment = function(file, options3) {
    var data2 = "sourceMappingURL=" + file;
    return options3 && options3.multiline ? "/*# " + data2 + " */" : "//# " + data2;
  };
})(convertSourceMap);
function totalist(dir, callback, pre = "") {
  dir = (0, import_path.resolve)(".", dir);
  let arr = (0, import_fs.readdirSync)(dir);
  let i = 0, abs, stats;
  for (; i < arr.length; i++) {
    abs = (0, import_path.join)(dir, arr[i]);
    stats = (0, import_fs.statSync)(abs);
    stats.isDirectory() ? totalist(abs, callback, (0, import_path.join)(pre, arr[i])) : callback((0, import_path.join)(pre, arr[i]), abs, stats);
  }
}
function parse$a(req2) {
  let raw = req2.url;
  if (raw == null)
    return;
  let prev = req2._parsedUrl;
  if (prev && prev.raw === raw)
    return prev;
  let pathname = raw, search = "", query;
  if (raw.length > 1) {
    let idx = raw.indexOf("?", 1);
    if (idx !== -1) {
      search = raw.substring(idx);
      pathname = raw.substring(0, idx);
      if (search.length > 1) {
        query = qs.parse(search.substring(1));
      }
    }
  }
  return req2._parsedUrl = { pathname, search, query, raw };
}
var noop$2 = () => {
};
function isMatch(uri, arr) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i].test(uri))
      return true;
  }
}
function toAssume(uri, extns) {
  let i = 0, x, len = uri.length - 1;
  if (uri.charCodeAt(len) === 47) {
    uri = uri.substring(0, len);
  }
  let arr = [], tmp = `${uri}/index`;
  for (; i < extns.length; i++) {
    x = extns[i] ? `.${extns[i]}` : "";
    if (uri)
      arr.push(uri + x);
    arr.push(tmp + x);
  }
  return arr;
}
function viaCache(cache, uri, extns) {
  let i = 0, data2, arr = toAssume(uri, extns);
  for (; i < arr.length; i++) {
    if (data2 = cache[arr[i]])
      return data2;
  }
}
function viaLocal(dir, isEtag, uri, extns) {
  let i = 0, arr = toAssume(uri, extns);
  let abs, stats, name, headers;
  for (; i < arr.length; i++) {
    abs = (0, import_path.normalize)((0, import_path.join)(dir, name = arr[i]));
    if (abs.startsWith(dir) && require$$0$2.existsSync(abs)) {
      stats = require$$0$2.statSync(abs);
      if (stats.isDirectory())
        continue;
      headers = toHeaders(name, stats, isEtag);
      headers["Cache-Control"] = isEtag ? "no-cache" : "no-store";
      return { abs, stats, headers };
    }
  }
}
function is404(req2, res) {
  return res.statusCode = 404, res.end();
}
function send$2(req2, res, file, stats, headers) {
  let code = 200, tmp, opts = {};
  headers = { ...headers };
  for (let key2 in headers) {
    tmp = res.getHeader(key2);
    if (tmp)
      headers[key2] = tmp;
  }
  if (tmp = res.getHeader("content-type")) {
    headers["Content-Type"] = tmp;
  }
  if (req2.headers.range) {
    code = 206;
    let [x, y] = req2.headers.range.replace("bytes=", "").split("-");
    let end = opts.end = parseInt(y, 10) || stats.size - 1;
    let start = opts.start = parseInt(x, 10) || 0;
    if (start >= stats.size || end >= stats.size) {
      res.setHeader("Content-Range", `bytes */${stats.size}`);
      res.statusCode = 416;
      return res.end();
    }
    headers["Content-Range"] = `bytes ${start}-${end}/${stats.size}`;
    headers["Content-Length"] = end - start + 1;
    headers["Accept-Ranges"] = "bytes";
  }
  res.writeHead(code, headers);
  require$$0$2.createReadStream(file, opts).pipe(res);
}
var ENCODING = {
  ".br": "br",
  ".gz": "gzip"
};
function toHeaders(name, stats, isEtag) {
  let enc = ENCODING[name.slice(-3)];
  let ctype = lookup(name.slice(0, enc && -3)) || "";
  if (ctype === "text/html")
    ctype += ";charset=utf-8";
  let headers = {
    "Content-Length": stats.size,
    "Content-Type": ctype,
    "Last-Modified": stats.mtime.toUTCString()
  };
  if (enc)
    headers["Content-Encoding"] = enc;
  if (isEtag)
    headers["ETag"] = `W/"${stats.size}-${stats.mtime.getTime()}"`;
  return headers;
}
function sirv(dir, opts = {}) {
  dir = (0, import_path.resolve)(dir || ".");
  let isNotFound = opts.onNoMatch || is404;
  let setHeaders2 = opts.setHeaders || noop$2;
  let extensions2 = opts.extensions || ["html", "htm"];
  let gzips = opts.gzip && extensions2.map((x) => `${x}.gz`).concat("gz");
  let brots = opts.brotli && extensions2.map((x) => `${x}.br`).concat("br");
  const FILES = {};
  let fallback = "/";
  let isEtag = !!opts.etag;
  let isSPA = !!opts.single;
  if (typeof opts.single === "string") {
    let idx = opts.single.lastIndexOf(".");
    fallback += !!~idx ? opts.single.substring(0, idx) : opts.single;
  }
  let ignores = [];
  if (opts.ignores !== false) {
    ignores.push(/[/]([A-Za-z\s\d~$._-]+\.\w+){1,}$/);
    if (opts.dotfiles)
      ignores.push(/\/\.\w/);
    else
      ignores.push(/\/\.well-known/);
    [].concat(opts.ignores || []).forEach((x) => {
      ignores.push(new RegExp(x, "i"));
    });
  }
  let cc = opts.maxAge != null && `public,max-age=${opts.maxAge}`;
  if (cc && opts.immutable)
    cc += ",immutable";
  else if (cc && opts.maxAge === 0)
    cc += ",must-revalidate";
  if (!opts.dev) {
    totalist(dir, (name, abs, stats) => {
      if (/\.well-known[\\+\/]/.test(name))
        ;
      else if (!opts.dotfiles && /(^\.|[\\+|\/+]\.)/.test(name))
        return;
      let headers = toHeaders(name, stats, isEtag);
      if (cc)
        headers["Cache-Control"] = cc;
      FILES["/" + name.normalize().replace(/\\+/g, "/")] = { abs, stats, headers };
    });
  }
  let lookup2 = opts.dev ? viaLocal.bind(0, dir, isEtag) : viaCache.bind(0, FILES);
  return function(req2, res, next) {
    let extns = [""];
    let pathname = parse$a(req2).pathname;
    let val = req2.headers["accept-encoding"] || "";
    if (gzips && val.includes("gzip"))
      extns.unshift(...gzips);
    if (brots && /(br|brotli)/i.test(val))
      extns.unshift(...brots);
    extns.push(...extensions2);
    if (pathname.indexOf("%") !== -1) {
      try {
        pathname = decodeURIComponent(pathname);
      } catch (err) {
      }
    }
    let data2 = lookup2(pathname, extns) || isSPA && !isMatch(pathname, ignores) && lookup2(fallback, extns);
    if (!data2)
      return next ? next() : isNotFound(req2, res);
    if (isEtag && req2.headers["if-none-match"] === data2.headers["ETag"]) {
      res.writeHead(304);
      return res.end();
    }
    if (gzips || brots) {
      res.setHeader("Vary", "Accept-Encoding");
    }
    setHeaders2(res, pathname, data2.stats);
    send$2(req2, res, data2.abs, data2.stats, data2.headers);
  };
}
var sirvOptions = (headers) => {
  return {
    dev: true,
    etag: true,
    extensions: [],
    setHeaders(res, pathname) {
      if (/\.[tj]sx?$/.test(pathname)) {
        res.setHeader("Content-Type", "application/javascript");
      }
      if (headers) {
        for (const name in headers) {
          res.setHeader(name, headers[name]);
        }
      }
    }
  };
};
function servePublicMiddleware(dir, headers) {
  const serve = sirv(dir, sirvOptions(headers));
  return function viteServePublicMiddleware(req2, res, next) {
    if (isImportRequest(req2.url) || isInternalRequest(req2.url)) {
      return next();
    }
    serve(req2, res, next);
  };
}
function serveStaticMiddleware(dir, server2) {
  const serve = sirv(dir, sirvOptions(server2.config.server.headers));
  return function viteServeStaticMiddleware(req2, res, next) {
    const cleanedUrl = cleanUrl(req2.url);
    if (cleanedUrl.endsWith("/") || import_node_path2.default.extname(cleanedUrl) === ".html" || isInternalRequest(req2.url)) {
      return next();
    }
    const url2 = new URL(req2.url, "http://example.com");
    const pathname = decodeURIComponent(url2.pathname);
    let redirectedPathname;
    for (const { find: find2, replacement } of server2.config.resolve.alias) {
      const matches2 = typeof find2 === "string" ? pathname.startsWith(find2) : find2.test(pathname);
      if (matches2) {
        redirectedPathname = pathname.replace(find2, replacement);
        break;
      }
    }
    if (redirectedPathname) {
      if (redirectedPathname.startsWith(dir)) {
        redirectedPathname = redirectedPathname.slice(dir.length);
      }
    }
    const resolvedPathname = redirectedPathname || pathname;
    let fileUrl = import_node_path2.default.resolve(dir, resolvedPathname.replace(/^\//, ""));
    if (resolvedPathname.endsWith("/") && !fileUrl.endsWith("/")) {
      fileUrl = fileUrl + "/";
    }
    if (!ensureServingAccess(fileUrl, server2, res, next)) {
      return;
    }
    if (redirectedPathname) {
      url2.pathname = encodeURIComponent(redirectedPathname);
      req2.url = url2.href.slice(url2.origin.length);
    }
    serve(req2, res, next);
  };
}
function serveRawFsMiddleware(server2) {
  const serveFromRoot = sirv("/", sirvOptions(server2.config.server.headers));
  return function viteServeRawFsMiddleware(req2, res, next) {
    const url2 = new URL(req2.url, "http://example.com");
    if (url2.pathname.startsWith(FS_PREFIX)) {
      const pathname = decodeURIComponent(url2.pathname);
      if (!ensureServingAccess(slash$1(import_node_path2.default.resolve(fsPathFromId(pathname))), server2, res, next)) {
        return;
      }
      let newPathname = pathname.slice(FS_PREFIX.length);
      if (isWindows$4)
        newPathname = newPathname.replace(/^[A-Z]:/i, "");
      url2.pathname = encodeURIComponent(newPathname);
      req2.url = url2.href.slice(url2.origin.length);
      serveFromRoot(req2, res, next);
    } else {
      next();
    }
  };
}
function isFileServingAllowed(url2, server2) {
  if (!server2.config.server.fs.strict)
    return true;
  const file = fsPathFromUrl(url2);
  if (server2._fsDenyGlob(file))
    return false;
  if (server2.moduleGraph.safeModulesPath.has(file))
    return true;
  if (server2.config.server.fs.allow.some((dir) => isParentDirectory(dir, file)))
    return true;
  return false;
}
function ensureServingAccess(url2, server2, res, next) {
  if (isFileServingAllowed(url2, server2)) {
    return true;
  }
  if (isFileReadable(cleanUrl(url2))) {
    const urlMessage = `The request url "${url2}" is outside of Vite serving allow list.`;
    const hintMessage = `
${server2.config.server.fs.allow.map((i) => `- ${i}`).join("\n")}

Refer to docs https://vitejs.dev/config/server-options.html#server-fs-allow for configurations and more details.`;
    server2.config.logger.error(urlMessage);
    server2.config.logger.warnOnce(hintMessage + "\n");
    res.statusCode = 403;
    res.write(renderRestrictedErrorHTML(urlMessage + "\n" + hintMessage));
    res.end();
  } else {
    next();
  }
  return false;
}
function renderRestrictedErrorHTML(msg) {
  const html = String.raw;
  return html`
    <body>
      <h1>403 Restricted</h1>
      <p>${msg.replace(/\n/g, "<br/>")}</p>
      <style>
        body {
          padding: 1em 2em;
        }
      </style>
    </body>
  `;
}
var debugLoad = createDebugger("vite:load");
var debugTransform = createDebugger("vite:transform");
var debugCache$1 = createDebugger("vite:cache");
var isDebug$2 = !!process.env.DEBUG;
function transformRequest(url2, server2, options3 = {}) {
  const cacheKey = (options3.ssr ? "ssr:" : options3.html ? "html:" : "") + url2;
  const timestamp2 = Date.now();
  const pending = server2._pendingRequests.get(cacheKey);
  if (pending) {
    return server2.moduleGraph.getModuleByUrl(removeTimestampQuery(url2), options3.ssr).then((module2) => {
      if (!module2 || pending.timestamp > module2.lastInvalidationTimestamp) {
        return pending.request;
      } else {
        pending.abort();
        return transformRequest(url2, server2, options3);
      }
    });
  }
  const request = doTransform(url2, server2, options3, timestamp2);
  let cleared = false;
  const clearCache = () => {
    if (!cleared) {
      server2._pendingRequests.delete(cacheKey);
      cleared = true;
    }
  };
  server2._pendingRequests.set(cacheKey, {
    request,
    timestamp: timestamp2,
    abort: clearCache
  });
  request.then(clearCache, clearCache);
  return request;
}
async function doTransform(url2, server2, options3, timestamp2) {
  var _a, _b;
  url2 = removeTimestampQuery(url2);
  const { config: config2, pluginContainer } = server2;
  const prettyUrl = isDebug$2 ? prettifyUrl(url2, config2.root) : "";
  const ssr = !!options3.ssr;
  const module2 = await server2.moduleGraph.getModuleByUrl(url2, ssr);
  const cached = module2 && (ssr ? module2.ssrTransformResult : module2.transformResult);
  if (cached) {
    isDebug$2 && debugCache$1(`[memory] ${prettyUrl}`);
    return cached;
  }
  const id = ((_a = await pluginContainer.resolveId(url2, void 0, { ssr })) == null ? void 0 : _a.id) || url2;
  const result = loadAndTransform(id, url2, server2, options3, timestamp2);
  (_b = getDepsOptimizer(config2, ssr)) == null ? void 0 : _b.delayDepsOptimizerUntil(id, () => result);
  return result;
}
async function loadAndTransform(id, url2, server2, options3, timestamp2) {
  var _a;
  const { config: config2, pluginContainer, moduleGraph, watcher } = server2;
  const { root: root2, logger } = config2;
  const prettyUrl = isDebug$2 ? prettifyUrl(url2, config2.root) : "";
  const ssr = !!options3.ssr;
  const file = cleanUrl(id);
  let code = null;
  let map2 = null;
  const loadStart = isDebug$2 ? import_node_perf_hooks.performance.now() : 0;
  const loadResult = await pluginContainer.load(id, { ssr });
  if (loadResult == null) {
    if (options3.html && !id.endsWith(".html")) {
      return null;
    }
    if (options3.ssr || isFileServingAllowed(file, server2)) {
      try {
        code = await import_node_fs.promises.readFile(file, "utf-8");
        isDebug$2 && debugLoad(`${timeFrom(loadStart)} [fs] ${prettyUrl}`);
      } catch (e) {
        if (e.code !== "ENOENT") {
          throw e;
        }
      }
    }
    if (code) {
      try {
        map2 = (_a = convertSourceMap.fromSource(code) || convertSourceMap.fromMapFileSource(code, import_node_path2.default.dirname(file))) == null ? void 0 : _a.toObject();
        code = code.replace(convertSourceMap.mapFileCommentRegex, blankReplacer);
      } catch (e) {
        logger.warn(`Failed to load source map for ${url2}.`, {
          timestamp: true
        });
      }
    }
  } else {
    isDebug$2 && debugLoad(`${timeFrom(loadStart)} [plugin] ${prettyUrl}`);
    if (isObject$1(loadResult)) {
      code = loadResult.code;
      map2 = loadResult.map;
    } else {
      code = loadResult;
    }
  }
  if (code == null) {
    if (checkPublicFile(url2, config2)) {
      throw new Error(`Failed to load url ${url2} (resolved id: ${id}). This file is in /public and will be copied as-is during build without going through the plugin transforms, and therefore should not be imported from source code. It can only be referenced via HTML tags.`);
    } else {
      return null;
    }
  }
  const mod = await moduleGraph.ensureEntryFromUrl(url2, ssr);
  ensureWatchedFile(watcher, mod.file, root2);
  const transformStart = isDebug$2 ? import_node_perf_hooks.performance.now() : 0;
  const transformResult = await pluginContainer.transform(code, id, {
    inMap: map2,
    ssr
  });
  const originalCode = code;
  if (transformResult == null || isObject$1(transformResult) && transformResult.code == null) {
    isDebug$2 && debugTransform(timeFrom(transformStart) + picocolors.exports.dim(` [skipped] ${prettyUrl}`));
  } else {
    isDebug$2 && debugTransform(`${timeFrom(transformStart)} ${prettyUrl}`);
    code = transformResult.code;
    map2 = transformResult.map;
  }
  if (map2 && mod.file) {
    map2 = typeof map2 === "string" ? JSON.parse(map2) : map2;
    if (map2.mappings && !map2.sourcesContent) {
      await injectSourcesContent(map2, mod.file, logger);
    }
  }
  const result = ssr ? await server2.ssrTransform(code, map2, url2, originalCode) : {
    code,
    map: map2,
    etag: etag_1(code, { weak: true })
  };
  if (timestamp2 > mod.lastInvalidationTimestamp) {
    if (ssr)
      mod.ssrTransformResult = result;
    else
      mod.transformResult = result;
  }
  return result;
}
var isDebug$1 = !!process.env.DEBUG;
var debug$9 = createDebugger("vite:import-analysis");
var clientDir = normalizePath$3(CLIENT_DIR);
var skipRE = /\.(map|json)($|\?)/;
var canSkipImportAnalysis = (id) => skipRE.test(id) || isDirectCSSRequest(id);
var optimizedDepChunkRE$1 = /\/chunk-[A-Z0-9]{8}\.js/;
var optimizedDepDynamicRE$1 = /-[A-Z0-9]{8}\.js/;
function isExplicitImportRequired(url2) {
  return !isJSRequest(cleanUrl(url2)) && !isCSSRequest(url2);
}
function markExplicitImport(url2) {
  if (isExplicitImportRequired(url2)) {
    return injectQuery(url2, "import");
  }
  return url2;
}
function extractImportedBindings(id, source2, importSpec, importedBindings) {
  let bindings = importedBindings.get(id);
  if (!bindings) {
    bindings = /* @__PURE__ */ new Set();
    importedBindings.set(id, bindings);
  }
  const isDynamic = importSpec.d > -1;
  const isMeta = importSpec.d === -2;
  if (isDynamic || isMeta) {
    bindings.add("*");
    return;
  }
  const exp = source2.slice(importSpec.ss, importSpec.se);
  const [match0] = findStaticImports(exp);
  if (!match0) {
    return;
  }
  const parsed = parseStaticImport(match0);
  if (!parsed) {
    return;
  }
  if (parsed.namespacedImport) {
    bindings.add("*");
  }
  if (parsed.defaultImport) {
    bindings.add("default");
  }
  if (parsed.namedImports) {
    for (const name of Object.keys(parsed.namedImports)) {
      bindings.add(name);
    }
  }
}
function importAnalysisPlugin(config2) {
  var _a;
  const { root: root2, base: base2 } = config2;
  const clientPublicPath = import_node_path2.default.posix.join(base2, CLIENT_PUBLIC_PATH);
  const enablePartialAccept = (_a = config2.experimental) == null ? void 0 : _a.hmrPartialAccept;
  let server2;
  return {
    name: "vite:import-analysis",
    configureServer(_server) {
      server2 = _server;
    },
    async transform(source2, importer, options3) {
      var _a2;
      if (!server2) {
        return null;
      }
      const ssr = (options3 == null ? void 0 : options3.ssr) === true;
      const prettyImporter = prettifyUrl(importer, root2);
      if (canSkipImportAnalysis(importer)) {
        isDebug$1 && debug$9(picocolors.exports.dim(`[skipped] ${prettyImporter}`));
        return null;
      }
      const start = import_node_perf_hooks.performance.now();
      await init;
      let imports;
      let exports;
      source2 = stripBomTag(source2);
      try {
        [imports, exports] = parse$b(source2);
      } catch (e) {
        const isVue = importer.endsWith(".vue");
        const maybeJSX = !isVue && isJSRequest(importer);
        const msg = isVue ? `Install @vitejs/plugin-vue to handle .vue files.` : maybeJSX ? `If you are using JSX, make sure to name the file with the .jsx or .tsx extension.` : `You may need to install appropriate plugins to handle the ${import_node_path2.default.extname(importer)} file format, or if it's an asset, add "**/*${import_node_path2.default.extname(importer)}" to \`assetsInclude\` in your configuration.`;
        this.error(`Failed to parse source for import analysis because the content contains invalid JS syntax. ` + msg, e.idx);
      }
      const depsOptimizer = getDepsOptimizer(config2, ssr);
      const { moduleGraph } = server2;
      const importerModule = moduleGraph.getModuleById(importer);
      if (!importerModule && (depsOptimizer == null ? void 0 : depsOptimizer.isOptimizedDepFile(importer))) {
        throwOutdatedRequest(importer);
      }
      if (!imports.length) {
        importerModule.isSelfAccepting = false;
        isDebug$1 && debug$9(`${timeFrom(start)} ${picocolors.exports.dim(`[no imports] ${prettyImporter}`)}`);
        return source2;
      }
      let hasHMR = false;
      let isSelfAccepting = false;
      let hasEnv = false;
      let needQueryInjectHelper = false;
      let s;
      const str = () => s || (s = new MagicString(source2));
      const importedUrls = /* @__PURE__ */ new Set();
      const staticImportedUrls = /* @__PURE__ */ new Set();
      const acceptedUrls = /* @__PURE__ */ new Set();
      let isPartiallySelfAccepting = false;
      const acceptedExports = /* @__PURE__ */ new Set();
      const importedBindings = enablePartialAccept ? /* @__PURE__ */ new Map() : null;
      const toAbsoluteUrl = (url2) => import_node_path2.default.posix.resolve(import_node_path2.default.posix.dirname(importerModule.url), url2);
      const normalizeUrl = async (url2, pos2) => {
        if (base2 !== "/" && url2.startsWith(base2)) {
          url2 = url2.replace(base2, "/");
        }
        let importerFile = importer;
        const optimizeDeps2 = getDepOptimizationConfig(config2, ssr);
        if (moduleListContains(optimizeDeps2 == null ? void 0 : optimizeDeps2.exclude, url2)) {
          if (depsOptimizer) {
            await depsOptimizer.scanProcessing;
            for (const optimizedModule of depsOptimizer.metadata.depInfoList) {
              if (!optimizedModule.src)
                continue;
              if (optimizedModule.file === importerModule.file) {
                importerFile = optimizedModule.src;
              }
            }
          }
        }
        const resolved = await this.resolve(url2, importerFile);
        if (!resolved) {
          if (ssr) {
            return [url2, url2];
          }
          importerModule.isSelfAccepting = false;
          return this.error(`Failed to resolve import "${url2}" from "${import_node_path2.default.relative(process.cwd(), importerFile)}". Does the file exist?`, pos2);
        }
        const isRelative2 = url2.startsWith(".");
        const isSelfImport = !isRelative2 && cleanUrl(url2) === cleanUrl(importer);
        if (resolved.id.startsWith(root2 + "/")) {
          url2 = resolved.id.slice(root2.length);
        } else if (resolved.id.startsWith(getDepsCacheDirPrefix(config2)) || import_node_fs.default.existsSync(cleanUrl(resolved.id))) {
          url2 = import_node_path2.default.posix.join(FS_PREFIX + resolved.id);
        } else {
          url2 = resolved.id;
        }
        if (isExternalUrl(url2)) {
          return [url2, url2];
        }
        if (!url2.startsWith(".") && !url2.startsWith("/")) {
          url2 = wrapId(resolved.id);
        }
        if (!ssr) {
          url2 = markExplicitImport(url2);
          if ((isRelative2 || isSelfImport) && !/[\?&]import=?\b/.test(url2) && !url2.match(DEP_VERSION_RE)) {
            const versionMatch = importer.match(DEP_VERSION_RE);
            if (versionMatch) {
              url2 = injectQuery(url2, versionMatch[1]);
            }
          }
          try {
            const depModule = await moduleGraph.ensureEntryFromUrl(unwrapId(url2), ssr, canSkipImportAnalysis(url2));
            if (depModule.lastHMRTimestamp > 0) {
              url2 = injectQuery(url2, `t=${depModule.lastHMRTimestamp}`);
            }
          } catch (e) {
            e.pos = pos2;
            throw e;
          }
          url2 = base2 + url2.replace(/^\//, "");
        }
        return [url2, resolved.id];
      };
      for (let index2 = 0; index2 < imports.length; index2++) {
        const {
          s: start2,
          e: end,
          ss: expStart,
          se: expEnd,
          d: dynamicIndex,
          n: specifier,
          a: assertIndex
        } = imports[index2];
        const rawUrl = source2.slice(start2, end);
        if (rawUrl === "import.meta") {
          const prop = source2.slice(end, end + 4);
          if (prop === ".hot") {
            hasHMR = true;
            if (source2.slice(end + 4, end + 11) === ".accept") {
              if (source2.slice(end + 4, end + 18) === ".acceptExports") {
                lexAcceptedHmrExports(source2, source2.indexOf("(", end + 18) + 1, acceptedExports);
                isPartiallySelfAccepting = true;
              } else if (lexAcceptedHmrDeps(source2, source2.indexOf("(", end + 11) + 1, acceptedUrls)) {
                isSelfAccepting = true;
              }
            }
          } else if (prop === ".env") {
            hasEnv = true;
          }
          continue;
        }
        const isDynamicImport = dynamicIndex > -1;
        if (!isDynamicImport && assertIndex > -1) {
          str().remove(end + 1, expEnd);
        }
        if (specifier) {
          if (isExternalUrl(specifier) || isDataUrl(specifier)) {
            continue;
          }
          if (ssr) {
            if ((_a2 = config2.legacy) == null ? void 0 : _a2.buildSsrCjsExternalHeuristics) {
              if (cjsShouldExternalizeForSSR(specifier, server2._ssrExternals)) {
                continue;
              }
            } else if (shouldExternalizeForSSR(specifier, config2)) {
              continue;
            }
            if (isBuiltin(specifier)) {
              continue;
            }
          }
          if (specifier === clientPublicPath) {
            continue;
          }
          if (specifier.startsWith("/") && !config2.assetsInclude(cleanUrl(specifier)) && !specifier.endsWith(".json") && checkPublicFile(specifier, config2)) {
            throw new Error(`Cannot import non-asset file ${specifier} which is inside /public.JS/CSS files inside /public are copied as-is on build and can only be referenced via <script src> or <link href> in html.`);
          }
          const [url2, resolvedId] = await normalizeUrl(specifier, start2);
          server2 == null ? void 0 : server2.moduleGraph.safeModulesPath.add(fsPathFromUrl(url2));
          if (url2 !== specifier) {
            let rewriteDone = false;
            if ((depsOptimizer == null ? void 0 : depsOptimizer.isOptimizedDepFile(resolvedId)) && !resolvedId.match(optimizedDepChunkRE$1)) {
              const file = cleanUrl(resolvedId);
              const needsInterop2 = await optimizedDepNeedsInterop(depsOptimizer.metadata, file, config2, ssr);
              if (needsInterop2 === void 0) {
                if (!file.match(optimizedDepDynamicRE$1)) {
                  config2.logger.error(picocolors.exports.red(`Vite Error, ${url2} optimized info should be defined`));
                }
              } else if (needsInterop2) {
                debug$9(`${url2} needs interop`);
                interopNamedImports(str(), imports[index2], url2, index2);
                rewriteDone = true;
              }
            } else if (url2.includes(browserExternalId) && source2.slice(expStart, start2).includes("{")) {
              interopNamedImports(str(), imports[index2], url2, index2);
              rewriteDone = true;
            }
            if (!rewriteDone) {
              let rewrittenUrl = JSON.stringify(url2);
              if (!isDynamicImport)
                rewrittenUrl = rewrittenUrl.slice(1, -1);
              str().overwrite(start2, end, rewrittenUrl, {
                contentOnly: true
              });
            }
          }
          const hmrUrl = unwrapId(url2.replace(base2, "/"));
          importedUrls.add(hmrUrl);
          if (enablePartialAccept && importedBindings) {
            extractImportedBindings(resolvedId, source2, imports[index2], importedBindings);
          }
          if (!isDynamicImport) {
            staticImportedUrls.add({ url: hmrUrl, id: resolvedId });
          }
        } else if (!importer.startsWith(clientDir)) {
          if (!importer.includes("node_modules")) {
            const hasViteIgnore = /\/\*\s*@vite-ignore\s*\*\//.test(
              source2.slice(dynamicIndex + 1, end)
            );
            if (!hasViteIgnore) {
              this.warn(`
` + picocolors.exports.cyan(importerModule.file) + `
` + generateCodeFrame(source2, start2) + `
The above dynamic import cannot be analyzed by Vite.
See ${picocolors.exports.blue(`https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars#limitations`)} for supported dynamic import formats. If this is intended to be left as-is, you can use the /* @vite-ignore */ comment inside the import() call to suppress this warning.
`);
            }
          }
          if (!ssr) {
            const url2 = rawUrl.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, "").trim();
            if (!/^('.*'|".*"|`.*`)$/.test(url2) || isExplicitImportRequired(url2.slice(1, -1))) {
              needQueryInjectHelper = true;
              str().overwrite(start2, end, `__vite__injectQuery(${url2}, 'import')`, { contentOnly: true });
            }
          }
        }
      }
      if (hasEnv) {
        let env2 = `import.meta.env = ${JSON.stringify({
          ...config2.env,
          SSR: !!ssr
        })};`;
        for (const key2 in config2.define) {
          if (key2.startsWith(`import.meta.env.`)) {
            const val = config2.define[key2];
            env2 += `${key2} = ${typeof val === "string" ? val : JSON.stringify(val)};`;
          }
        }
        str().prepend(env2);
      }
      if (hasHMR && !ssr) {
        debugHmr(`${isSelfAccepting ? `[self-accepts]` : isPartiallySelfAccepting ? `[accepts-exports]` : acceptedUrls.size ? `[accepts-deps]` : `[detected api usage]`} ${prettyImporter}`);
        str().prepend(`import { createHotContext as __vite__createHotContext } from "${clientPublicPath}";import.meta.hot = __vite__createHotContext(${JSON.stringify(normalizeHmrUrl(importerModule.url))});`);
      }
      if (needQueryInjectHelper) {
        str().prepend(`import { injectQuery as __vite__injectQuery } from "${clientPublicPath}";`);
      }
      const normalizedAcceptedUrls = /* @__PURE__ */ new Set();
      for (const { url: url2, start: start2, end } of acceptedUrls) {
        const [normalized] = await moduleGraph.resolveUrl(toAbsoluteUrl(markExplicitImport(url2)), ssr);
        normalizedAcceptedUrls.add(normalized);
        str().overwrite(start2, end, JSON.stringify(normalized), {
          contentOnly: true
        });
      }
      if (!isCSSRequest(importer)) {
        const pluginImports = this._addedImports;
        if (pluginImports) {
          (await Promise.all([...pluginImports].map((id) => normalizeUrl(id, 0)))).forEach(([url2]) => importedUrls.add(url2));
        }
        if (ssr && importerModule.isSelfAccepting) {
          isSelfAccepting = true;
        }
        if (!isSelfAccepting && isPartiallySelfAccepting && acceptedExports.size >= exports.length && exports.every((e) => acceptedExports.has(e.n))) {
          isSelfAccepting = true;
        }
        const prunedImports = await moduleGraph.updateModuleInfo(importerModule, importedUrls, importedBindings, normalizedAcceptedUrls, isPartiallySelfAccepting ? acceptedExports : null, isSelfAccepting, ssr);
        if (hasHMR && prunedImports) {
          handlePrunedModules(prunedImports, server2);
        }
      }
      isDebug$1 && debug$9(`${timeFrom(start)} ${picocolors.exports.dim(`[${importedUrls.size} imports rewritten] ${prettyImporter}`)}`);
      if (config2.server.preTransformRequests && staticImportedUrls.size) {
        staticImportedUrls.forEach(({ url: url2, id }) => {
          url2 = removeImportQuery(url2);
          transformRequest(url2, server2, { ssr }).catch((e) => {
            if ((e == null ? void 0 : e.code) === ERR_OUTDATED_OPTIMIZED_DEP) {
              return;
            }
            config2.logger.error(e.message);
          });
        });
      }
      if (s) {
        return transformStableResult(s, importer, config2);
      } else {
        return source2;
      }
    }
  };
}
function interopNamedImports(str, importSpecifier, rewrittenUrl, importIndex) {
  const source2 = str.original;
  const { s: start, e: end, ss: expStart, se: expEnd, d: dynamicIndex } = importSpecifier;
  if (dynamicIndex > -1) {
    str.overwrite(expStart, expEnd, `import('${rewrittenUrl}').then(m => m.default && m.default.__esModule ? m.default : ({ ...m.default, default: m.default }))`, { contentOnly: true });
  } else {
    const exp = source2.slice(expStart, expEnd);
    const rawUrl = source2.slice(start, end);
    const rewritten = transformCjsImport(exp, rewrittenUrl, rawUrl, importIndex);
    if (rewritten) {
      str.overwrite(expStart, expEnd, rewritten, { contentOnly: true });
    } else {
      str.overwrite(start, end, rewrittenUrl, { contentOnly: true });
    }
  }
}
function transformCjsImport(importExp, url2, rawUrl, importIndex) {
  const node2 = parse$c(importExp, {
    ecmaVersion: "latest",
    sourceType: "module"
  }).body[0];
  if (node2.type === "ImportDeclaration" || node2.type === "ExportNamedDeclaration") {
    if (!node2.specifiers.length) {
      return `import "${url2}"`;
    }
    const importNames = [];
    const exportNames = [];
    let defaultExports = "";
    for (const spec of node2.specifiers) {
      if (spec.type === "ImportSpecifier" && spec.imported.type === "Identifier") {
        const importedName = spec.imported.name;
        const localName = spec.local.name;
        importNames.push({ importedName, localName });
      } else if (spec.type === "ImportDefaultSpecifier") {
        importNames.push({
          importedName: "default",
          localName: spec.local.name
        });
      } else if (spec.type === "ImportNamespaceSpecifier") {
        importNames.push({ importedName: "*", localName: spec.local.name });
      } else if (spec.type === "ExportSpecifier" && spec.exported.type === "Identifier") {
        const importedName = spec.local.name;
        const exportedName = spec.exported.name;
        if (exportedName === "default") {
          defaultExports = makeLegalIdentifier2(`__vite__cjsExportDefault_${importIndex}`);
          importNames.push({ importedName, localName: defaultExports });
        } else {
          const localName = makeLegalIdentifier2(`__vite__cjsExport_${exportedName}`);
          importNames.push({ importedName, localName });
          exportNames.push(`${localName} as ${exportedName}`);
        }
      }
    }
    const cjsModuleName = makeLegalIdentifier2(`__vite__cjsImport${importIndex}_${rawUrl}`);
    const lines = [`import ${cjsModuleName} from "${url2}"`];
    importNames.forEach(({ importedName, localName }) => {
      if (importedName === "*") {
        lines.push(`const ${localName} = ${cjsModuleName}`);
      } else if (importedName === "default") {
        lines.push(`const ${localName} = ${cjsModuleName}.__esModule ? ${cjsModuleName}.default : ${cjsModuleName}`);
      } else {
        lines.push(`const ${localName} = ${cjsModuleName}["${importedName}"]`);
      }
    });
    if (defaultExports) {
      lines.push(`export default ${defaultExports}`);
    }
    if (exportNames.length) {
      lines.push(`export { ${exportNames.join(", ")} }`);
    }
    return lines.join("; ");
  }
}
var normalizedClientEntry = normalizePath$3(CLIENT_ENTRY);
var normalizedEnvEntry = normalizePath$3(ENV_ENTRY);
function clientInjectionsPlugin(config2) {
  return {
    name: "vite:client-inject",
    async transform(code, id, options3) {
      var _a;
      if (id === normalizedClientEntry || id === normalizedEnvEntry) {
        const resolvedServerHostname = (await resolveHostname(config2.server.host)).name;
        const resolvedServerPort = config2.server.port;
        const devBase = config2.base;
        const serverHost = `${resolvedServerHostname}:${resolvedServerPort}${devBase}`;
        let hmrConfig = config2.server.hmr;
        hmrConfig = isObject$1(hmrConfig) ? hmrConfig : void 0;
        const host = (hmrConfig == null ? void 0 : hmrConfig.host) || null;
        const protocol = (hmrConfig == null ? void 0 : hmrConfig.protocol) || null;
        const timeout2 = (hmrConfig == null ? void 0 : hmrConfig.timeout) || 3e4;
        const overlay = (hmrConfig == null ? void 0 : hmrConfig.overlay) !== false;
        let port = (hmrConfig == null ? void 0 : hmrConfig.clientPort) || (hmrConfig == null ? void 0 : hmrConfig.port) || null;
        if (config2.server.middlewareMode) {
          port || (port = 24678);
        }
        let directTarget = (hmrConfig == null ? void 0 : hmrConfig.host) || resolvedServerHostname;
        directTarget += `:${(hmrConfig == null ? void 0 : hmrConfig.port) || resolvedServerPort}`;
        directTarget += devBase;
        let hmrBase = devBase;
        if (hmrConfig == null ? void 0 : hmrConfig.path) {
          hmrBase = import_node_path2.default.posix.join(hmrBase, hmrConfig.path);
        }
        return code.replace(`__MODE__`, JSON.stringify(config2.mode)).replace(`__BASE__`, JSON.stringify(devBase)).replace(`__DEFINES__`, serializeDefine(config2.define || {})).replace(`__SERVER_HOST__`, JSON.stringify(serverHost)).replace(`__HMR_PROTOCOL__`, JSON.stringify(protocol)).replace(`__HMR_HOSTNAME__`, JSON.stringify(host)).replace(`__HMR_PORT__`, JSON.stringify(port)).replace(`__HMR_DIRECT_TARGET__`, JSON.stringify(directTarget)).replace(`__HMR_BASE__`, JSON.stringify(hmrBase)).replace(`__HMR_TIMEOUT__`, JSON.stringify(timeout2)).replace(`__HMR_ENABLE_OVERLAY__`, JSON.stringify(overlay));
      } else if (!(options3 == null ? void 0 : options3.ssr) && code.includes("process.env.NODE_ENV")) {
        return code.replace(/\bprocess\.env\.NODE_ENV\b/g, ((_a = config2.define) == null ? void 0 : _a["process.env.NODE_ENV"]) || JSON.stringify("development"));
      }
    }
  };
}
function serializeDefine(define) {
  let res = `{`;
  for (const key2 in define) {
    const val = define[key2];
    res += `${JSON.stringify(key2)}: ${typeof val === "string" ? `(${val})` : JSON.stringify(val)}, `;
  }
  return res + `}`;
}
var wasmHelperId = "/__vite-wasm-helper";
var wasmHelper = async (opts = {}, url2) => {
  let result;
  if (url2.startsWith("data:")) {
    const urlContent = url2.replace(/^data:.*?base64,/, "");
    let bytes;
    if (typeof Buffer === "function" && typeof Buffer.from === "function") {
      bytes = Buffer.from(urlContent, "base64");
    } else if (typeof atob === "function") {
      const binaryString = atob(urlContent);
      bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
    } else {
      throw new Error("Failed to decode base64-encoded data URL, Buffer and atob are not supported");
    }
    result = await WebAssembly.instantiate(bytes, opts);
  } else {
    const response = await fetch(url2);
    const contentType = response.headers.get("Content-Type") || "";
    if ("instantiateStreaming" in WebAssembly && contentType.startsWith("application/wasm")) {
      result = await WebAssembly.instantiateStreaming(response, opts);
    } else {
      const buffer2 = await response.arrayBuffer();
      result = await WebAssembly.instantiate(buffer2, opts);
    }
  }
  return result.instance;
};
var wasmHelperCode = wasmHelper.toString();
var wasmHelperPlugin = (config2) => {
  return {
    name: "vite:wasm-helper",
    resolveId(id) {
      if (id === wasmHelperId) {
        return id;
      }
    },
    async load(id) {
      if (id === wasmHelperId) {
        return `export default ${wasmHelperCode}`;
      }
      if (!id.endsWith(".wasm?init")) {
        return;
      }
      const url2 = await fileToUrl(id, config2, this);
      return `
import initWasm from "${wasmHelperId}"
export default opts => initWasm(opts, ${JSON.stringify(url2)})
`;
    }
  };
};
var wasmFallbackPlugin = () => {
  return {
    name: "vite:wasm-fallback",
    async load(id) {
      if (!id.endsWith(".wasm")) {
        return;
      }
      throw new Error('"ESM integration proposal for Wasm" is not supported currently. Use vite-plugin-wasm or other community plugins to handle this. Alternatively, you can use `.wasm?init` or `.wasm?url`. See https://vitejs.dev/guide/features.html#webassembly for more details.');
    }
  };
};
function preAliasPlugin(config2) {
  const findPatterns = getAliasPatterns(config2.resolve.alias);
  const isConfiguredAsExternal = createIsConfiguredAsSsrExternal(config2);
  const isBuild = config2.command === "build";
  return {
    name: "vite:pre-alias",
    async resolveId(id, importer, options3) {
      var _a;
      const ssr = (options3 == null ? void 0 : options3.ssr) === true;
      const depsOptimizer = getDepsOptimizer(config2, ssr);
      if (importer && depsOptimizer && bareImportRE.test(id) && !(options3 == null ? void 0 : options3.scan) && id !== "@vite/client" && id !== "@vite/env") {
        if (findPatterns.find((pattern2) => matches(pattern2, id))) {
          const optimizedId = await tryOptimizedResolve(depsOptimizer, id, importer);
          if (optimizedId) {
            return optimizedId;
          }
          const resolved = await this.resolve(id, importer, {
            skipSelf: true,
            ...options3
          });
          if (resolved && !depsOptimizer.isOptimizedDepFile(resolved.id)) {
            const optimizeDeps2 = depsOptimizer.options;
            const resolvedId = cleanUrl(resolved.id);
            const isVirtual = resolvedId === id || resolvedId.includes("\0");
            if (!isVirtual && import_node_fs.default.existsSync(resolvedId) && !moduleListContains(optimizeDeps2.exclude, id) && import_node_path2.default.isAbsolute(resolvedId) && (resolvedId.includes("node_modules") || ((_a = optimizeDeps2.include) == null ? void 0 : _a.includes(id))) && isOptimizable(resolvedId, optimizeDeps2) && !(isBuild && ssr && isConfiguredAsExternal(id)) && (!ssr || optimizeAliasReplacementForSSR(resolvedId, optimizeDeps2))) {
              const optimizedInfo = depsOptimizer.registerMissingImport(id, resolvedId);
              return { id: depsOptimizer.getOptimizedDepId(optimizedInfo) };
            }
          }
          return resolved;
        }
      }
    }
  };
}
function optimizeAliasReplacementForSSR(id, optimizeDeps2) {
  var _a;
  if ((_a = optimizeDeps2.include) == null ? void 0 : _a.includes(id)) {
    return true;
  }
  return false;
}
function matches(pattern2, importee) {
  if (pattern2 instanceof RegExp) {
    return pattern2.test(importee);
  }
  if (importee.length < pattern2.length) {
    return false;
  }
  if (importee === pattern2) {
    return true;
  }
  return importee.startsWith(pattern2 + "/");
}
function getAliasPatterns(entries) {
  if (!entries) {
    return [];
  }
  if (Array.isArray(entries)) {
    return entries.map((entry2) => entry2.find);
  }
  return Object.entries(entries).map(([find2]) => find2);
}
var nonJsRe = /\.(json)($|\?)/;
var isNonJsRequest = (request) => nonJsRe.test(request);
function definePlugin(config2) {
  const isBuild = config2.command === "build";
  const isBuildLib = isBuild && config2.build.lib;
  const processEnv = {};
  const processNodeEnv = {};
  if (!isBuildLib) {
    const nodeEnv = "development";
    Object.assign(processEnv, {
      "process.env.": `({}).`,
      "global.process.env.": `({}).`,
      "globalThis.process.env.": `({}).`
    });
    Object.assign(processNodeEnv, {
      "process.env.NODE_ENV": JSON.stringify(nodeEnv),
      "global.process.env.NODE_ENV": JSON.stringify(nodeEnv),
      "globalThis.process.env.NODE_ENV": JSON.stringify(nodeEnv),
      __vite_process_env_NODE_ENV: JSON.stringify(nodeEnv)
    });
  }
  const userDefine = {};
  for (const key2 in config2.define) {
    const val = config2.define[key2];
    userDefine[key2] = typeof val === "string" ? val : JSON.stringify(val);
  }
  const importMetaKeys = {};
  const importMetaFallbackKeys = {};
  if (isBuild) {
    const env2 = {
      ...config2.env,
      SSR: !!config2.build.ssr
    };
    for (const key2 in env2) {
      importMetaKeys[`import.meta.env.${key2}`] = JSON.stringify(env2[key2]);
    }
    Object.assign(importMetaFallbackKeys, {
      "import.meta.env.": `({}).`,
      "import.meta.env": JSON.stringify(config2.env),
      "import.meta.hot": `false`
    });
  }
  function generatePattern(ssr) {
    var _a;
    const replaceProcessEnv = !ssr || ((_a = config2.ssr) == null ? void 0 : _a.target) === "webworker";
    const replacements = {
      ...replaceProcessEnv ? processNodeEnv : {},
      ...importMetaKeys,
      ...userDefine,
      ...importMetaFallbackKeys,
      ...replaceProcessEnv ? processEnv : {}
    };
    if (isBuild && !replaceProcessEnv) {
      replacements["__vite_process_env_NODE_ENV"] = "process.env.NODE_ENV";
    }
    const replacementsKeys = Object.keys(replacements);
    const pattern2 = replacementsKeys.length ? new RegExp(
      "(?<![\\p{L}\\p{N}_$]|(?<!\\.\\.)\\.)(" + replacementsKeys.map((str) => {
        return str.replace(/[-[\]/{}()*+?.\\^$|]/g, "\\$&");
      }).join("|") + ")(?:(?<=\\.)|(?![\\p{L}\\p{N}_$]|\\s*?=[^=]))",
      "gu"
    ) : null;
    return [replacements, pattern2];
  }
  const defaultPattern = generatePattern(false);
  const ssrPattern = generatePattern(true);
  return {
    name: "vite:define",
    transform(code, id, options3) {
      const ssr = (options3 == null ? void 0 : options3.ssr) === true;
      if (!ssr && !isBuild) {
        return;
      }
      if (isHTMLRequest(id) || isCSSRequest(id) || isNonJsRequest(id) || config2.assetsInclude(id)) {
        return;
      }
      const [replacements, pattern2] = ssr ? ssrPattern : defaultPattern;
      if (!pattern2) {
        return null;
      }
      if (ssr && !isBuild) {
        return code.replace(pattern2, (_, match2) => {
          return "" + replacements[match2];
        });
      }
      const s = new MagicString(code);
      let hasReplaced = false;
      let match;
      while (match = pattern2.exec(code)) {
        hasReplaced = true;
        const start = match.index;
        const end = start + match[0].length;
        const replacement = "" + replacements[match[1]];
        s.update(start, end, replacement);
      }
      if (!hasReplaced) {
        return null;
      }
      return transformStableResult(s, id, config2);
    }
  };
}
function ssrRequireHookPlugin(config2) {
  var _a, _b;
  if (config2.command !== "build" || !config2.build.ssr || !config2.resolve.dedupe.length || ((_a = config2.ssr) == null ? void 0 : _a.noExternal) === true || ((_b = config2.ssr) == null ? void 0 : _b.format) !== "cjs" || isBuildOutputEsm(config2)) {
    return null;
  }
  return {
    name: "vite:ssr-require-hook",
    transform(code, id) {
      const moduleInfo = this.getModuleInfo(id);
      if (moduleInfo == null ? void 0 : moduleInfo.isEntry) {
        const s = new MagicString(code);
        s.prepend(`;(${dedupeRequire.toString()})(${JSON.stringify(config2.resolve.dedupe)});
`);
        return {
          code: s.toString(),
          map: s.generateMap({
            source: id,
            hires: true
          })
        };
      }
    }
  };
}
function dedupeRequire(dedupe) {
  const Module = require2("node:module");
  const resolveFilename = Module._resolveFilename;
  Module._resolveFilename = function(request, parent, isMain, options3) {
    if (request[0] !== "." && request[0] !== "/") {
      const parts = request.split("/");
      const pkgName = parts[0][0] === "@" ? parts[0] + "/" + parts[1] : parts[0];
      if (dedupe.includes(pkgName)) {
        parent = module;
      }
    }
    return resolveFilename(request, parent, isMain, options3);
  };
}
var _require$2 = (0, import_node_module.createRequire)(import.meta.url);
function hookNodeResolve(getResolver) {
  const Module = _require$2("module");
  const prevResolver = Module._resolveFilename;
  Module._resolveFilename = getResolver(prevResolver);
  return () => {
    Module._resolveFilename = prevResolver;
  };
}
function isBuildOutputEsm(config2) {
  var _a;
  const outputs = arraify((_a = config2.build.rollupOptions) == null ? void 0 : _a.output);
  return outputs.some((output) => (output == null ? void 0 : output.format) === "es" || (output == null ? void 0 : output.format) === "esm");
}
var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
var ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
var ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
var unicode = {
  Space_Separator,
  ID_Start,
  ID_Continue
};
var util = {
  isSpaceSeparator(c2) {
    return typeof c2 === "string" && unicode.Space_Separator.test(c2);
  },
  isIdStartChar(c2) {
    return typeof c2 === "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 === "$" || c2 === "_" || unicode.ID_Start.test(c2));
  },
  isIdContinueChar(c2) {
    return typeof c2 === "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 >= "0" && c2 <= "9" || c2 === "$" || c2 === "_" || c2 === "\u200C" || c2 === "\u200D" || unicode.ID_Continue.test(c2));
  },
  isDigit(c2) {
    return typeof c2 === "string" && /[0-9]/.test(c2);
  },
  isHexDigit(c2) {
    return typeof c2 === "string" && /[0-9A-Fa-f]/.test(c2);
  }
};
var source;
var parseState;
var stack;
var pos;
var line;
var column;
var token;
var key;
var root;
var parse$9 = function parse4(text, reviver) {
  source = String(text);
  parseState = "start";
  stack = [];
  pos = 0;
  line = 1;
  column = 0;
  token = void 0;
  key = void 0;
  root = void 0;
  do {
    token = lex();
    parseStates[parseState]();
  } while (token.type !== "eof");
  if (typeof reviver === "function") {
    return internalize({ "": root }, "", reviver);
  }
  return root;
};
function internalize(holder, name, reviver) {
  const value2 = holder[name];
  if (value2 != null && typeof value2 === "object") {
    for (const key2 in value2) {
      const replacement = internalize(value2, key2, reviver);
      if (replacement === void 0) {
        delete value2[key2];
      } else {
        value2[key2] = replacement;
      }
    }
  }
  return reviver.call(holder, name, value2);
}
var lexState;
var buffer;
var doubleQuote;
var sign;
var c;
function lex() {
  lexState = "default";
  buffer = "";
  doubleQuote = false;
  sign = 1;
  for (; ; ) {
    c = peek();
    const token2 = lexStates[lexState]();
    if (token2) {
      return token2;
    }
  }
}
function peek() {
  if (source[pos]) {
    return String.fromCodePoint(source.codePointAt(pos));
  }
}
function read() {
  const c2 = peek();
  if (c2 === "\n") {
    line++;
    column = 0;
  } else if (c2) {
    column += c2.length;
  } else {
    column++;
  }
  if (c2) {
    pos += c2.length;
  }
  return c2;
}
var lexStates = {
  default() {
    switch (c) {
      case "	":
      case "\v":
      case "\f":
      case " ":
      case "\xA0":
      case "\uFEFF":
      case "\n":
      case "\r":
      case "\u2028":
      case "\u2029":
        read();
        return;
      case "/":
        read();
        lexState = "comment";
        return;
      case void 0:
        read();
        return newToken("eof");
    }
    if (util.isSpaceSeparator(c)) {
      read();
      return;
    }
    return lexStates[parseState]();
  },
  comment() {
    switch (c) {
      case "*":
        read();
        lexState = "multiLineComment";
        return;
      case "/":
        read();
        lexState = "singleLineComment";
        return;
    }
    throw invalidChar(read());
  },
  multiLineComment() {
    switch (c) {
      case "*":
        read();
        lexState = "multiLineCommentAsterisk";
        return;
      case void 0:
        throw invalidChar(read());
    }
    read();
  },
  multiLineCommentAsterisk() {
    switch (c) {
      case "*":
        read();
        return;
      case "/":
        read();
        lexState = "default";
        return;
      case void 0:
        throw invalidChar(read());
    }
    read();
    lexState = "multiLineComment";
  },
  singleLineComment() {
    switch (c) {
      case "\n":
      case "\r":
      case "\u2028":
      case "\u2029":
        read();
        lexState = "default";
        return;
      case void 0:
        read();
        return newToken("eof");
    }
    read();
  },
  value() {
    switch (c) {
      case "{":
      case "[":
        return newToken("punctuator", read());
      case "n":
        read();
        literal("ull");
        return newToken("null", null);
      case "t":
        read();
        literal("rue");
        return newToken("boolean", true);
      case "f":
        read();
        literal("alse");
        return newToken("boolean", false);
      case "-":
      case "+":
        if (read() === "-") {
          sign = -1;
        }
        lexState = "sign";
        return;
      case ".":
        buffer = read();
        lexState = "decimalPointLeading";
        return;
      case "0":
        buffer = read();
        lexState = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        buffer = read();
        lexState = "decimalInteger";
        return;
      case "I":
        read();
        literal("nfinity");
        return newToken("numeric", Infinity);
      case "N":
        read();
        literal("aN");
        return newToken("numeric", NaN);
      case '"':
      case "'":
        doubleQuote = read() === '"';
        buffer = "";
        lexState = "string";
        return;
    }
    throw invalidChar(read());
  },
  identifierNameStartEscape() {
    if (c !== "u") {
      throw invalidChar(read());
    }
    read();
    const u = unicodeEscape();
    switch (u) {
      case "$":
      case "_":
        break;
      default:
        if (!util.isIdStartChar(u)) {
          throw invalidIdentifier();
        }
        break;
    }
    buffer += u;
    lexState = "identifierName";
  },
  identifierName() {
    switch (c) {
      case "$":
      case "_":
      case "\u200C":
      case "\u200D":
        buffer += read();
        return;
      case "\\":
        read();
        lexState = "identifierNameEscape";
        return;
    }
    if (util.isIdContinueChar(c)) {
      buffer += read();
      return;
    }
    return newToken("identifier", buffer);
  },
  identifierNameEscape() {
    if (c !== "u") {
      throw invalidChar(read());
    }
    read();
    const u = unicodeEscape();
    switch (u) {
      case "$":
      case "_":
      case "\u200C":
      case "\u200D":
        break;
      default:
        if (!util.isIdContinueChar(u)) {
          throw invalidIdentifier();
        }
        break;
    }
    buffer += u;
    lexState = "identifierName";
  },
  sign() {
    switch (c) {
      case ".":
        buffer = read();
        lexState = "decimalPointLeading";
        return;
      case "0":
        buffer = read();
        lexState = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        buffer = read();
        lexState = "decimalInteger";
        return;
      case "I":
        read();
        literal("nfinity");
        return newToken("numeric", sign * Infinity);
      case "N":
        read();
        literal("aN");
        return newToken("numeric", NaN);
    }
    throw invalidChar(read());
  },
  zero() {
    switch (c) {
      case ".":
        buffer += read();
        lexState = "decimalPoint";
        return;
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
      case "x":
      case "X":
        buffer += read();
        lexState = "hexadecimal";
        return;
    }
    return newToken("numeric", sign * 0);
  },
  decimalInteger() {
    switch (c) {
      case ".":
        buffer += read();
        lexState = "decimalPoint";
        return;
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  decimalPointLeading() {
    if (util.isDigit(c)) {
      buffer += read();
      lexState = "decimalFraction";
      return;
    }
    throw invalidChar(read());
  },
  decimalPoint() {
    switch (c) {
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      lexState = "decimalFraction";
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  decimalFraction() {
    switch (c) {
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  decimalExponent() {
    switch (c) {
      case "+":
      case "-":
        buffer += read();
        lexState = "decimalExponentSign";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      lexState = "decimalExponentInteger";
      return;
    }
    throw invalidChar(read());
  },
  decimalExponentSign() {
    if (util.isDigit(c)) {
      buffer += read();
      lexState = "decimalExponentInteger";
      return;
    }
    throw invalidChar(read());
  },
  decimalExponentInteger() {
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  hexadecimal() {
    if (util.isHexDigit(c)) {
      buffer += read();
      lexState = "hexadecimalInteger";
      return;
    }
    throw invalidChar(read());
  },
  hexadecimalInteger() {
    if (util.isHexDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  string() {
    switch (c) {
      case "\\":
        read();
        buffer += escape$2();
        return;
      case '"':
        if (doubleQuote) {
          read();
          return newToken("string", buffer);
        }
        buffer += read();
        return;
      case "'":
        if (!doubleQuote) {
          read();
          return newToken("string", buffer);
        }
        buffer += read();
        return;
      case "\n":
      case "\r":
        throw invalidChar(read());
      case "\u2028":
      case "\u2029":
        separatorChar(c);
        break;
      case void 0:
        throw invalidChar(read());
    }
    buffer += read();
  },
  start() {
    switch (c) {
      case "{":
      case "[":
        return newToken("punctuator", read());
    }
    lexState = "value";
  },
  beforePropertyName() {
    switch (c) {
      case "$":
      case "_":
        buffer = read();
        lexState = "identifierName";
        return;
      case "\\":
        read();
        lexState = "identifierNameStartEscape";
        return;
      case "}":
        return newToken("punctuator", read());
      case '"':
      case "'":
        doubleQuote = read() === '"';
        lexState = "string";
        return;
    }
    if (util.isIdStartChar(c)) {
      buffer += read();
      lexState = "identifierName";
      return;
    }
    throw invalidChar(read());
  },
  afterPropertyName() {
    if (c === ":") {
      return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  beforePropertyValue() {
    lexState = "value";
  },
  afterPropertyValue() {
    switch (c) {
      case ",":
      case "}":
        return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  beforeArrayValue() {
    if (c === "]") {
      return newToken("punctuator", read());
    }
    lexState = "value";
  },
  afterArrayValue() {
    switch (c) {
      case ",":
      case "]":
        return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  end() {
    throw invalidChar(read());
  }
};
function newToken(type, value2) {
  return {
    type,
    value: value2,
    line,
    column
  };
}
function literal(s) {
  for (const c2 of s) {
    const p = peek();
    if (p !== c2) {
      throw invalidChar(read());
    }
    read();
  }
}
function escape$2() {
  const c2 = peek();
  switch (c2) {
    case "b":
      read();
      return "\b";
    case "f":
      read();
      return "\f";
    case "n":
      read();
      return "\n";
    case "r":
      read();
      return "\r";
    case "t":
      read();
      return "	";
    case "v":
      read();
      return "\v";
    case "0":
      read();
      if (util.isDigit(peek())) {
        throw invalidChar(read());
      }
      return "\0";
    case "x":
      read();
      return hexEscape();
    case "u":
      read();
      return unicodeEscape();
    case "\n":
    case "\u2028":
    case "\u2029":
      read();
      return "";
    case "\r":
      read();
      if (peek() === "\n") {
        read();
      }
      return "";
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7":
    case "8":
    case "9":
      throw invalidChar(read());
    case void 0:
      throw invalidChar(read());
  }
  return read();
}
function hexEscape() {
  let buffer2 = "";
  let c2 = peek();
  if (!util.isHexDigit(c2)) {
    throw invalidChar(read());
  }
  buffer2 += read();
  c2 = peek();
  if (!util.isHexDigit(c2)) {
    throw invalidChar(read());
  }
  buffer2 += read();
  return String.fromCodePoint(parseInt(buffer2, 16));
}
function unicodeEscape() {
  let buffer2 = "";
  let count = 4;
  while (count-- > 0) {
    const c2 = peek();
    if (!util.isHexDigit(c2)) {
      throw invalidChar(read());
    }
    buffer2 += read();
  }
  return String.fromCodePoint(parseInt(buffer2, 16));
}
var parseStates = {
  start() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    push$1();
  },
  beforePropertyName() {
    switch (token.type) {
      case "identifier":
      case "string":
        key = token.value;
        parseState = "afterPropertyName";
        return;
      case "punctuator":
        pop();
        return;
      case "eof":
        throw invalidEOF();
    }
  },
  afterPropertyName() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    parseState = "beforePropertyValue";
  },
  beforePropertyValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    push$1();
  },
  beforeArrayValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    if (token.type === "punctuator" && token.value === "]") {
      pop();
      return;
    }
    push$1();
  },
  afterPropertyValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    switch (token.value) {
      case ",":
        parseState = "beforePropertyName";
        return;
      case "}":
        pop();
    }
  },
  afterArrayValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    switch (token.value) {
      case ",":
        parseState = "beforeArrayValue";
        return;
      case "]":
        pop();
    }
  },
  end() {
  }
};
function push$1() {
  let value2;
  switch (token.type) {
    case "punctuator":
      switch (token.value) {
        case "{":
          value2 = {};
          break;
        case "[":
          value2 = [];
          break;
      }
      break;
    case "null":
    case "boolean":
    case "numeric":
    case "string":
      value2 = token.value;
      break;
  }
  if (root === void 0) {
    root = value2;
  } else {
    const parent = stack[stack.length - 1];
    if (Array.isArray(parent)) {
      parent.push(value2);
    } else {
      parent[key] = value2;
    }
  }
  if (value2 !== null && typeof value2 === "object") {
    stack.push(value2);
    if (Array.isArray(value2)) {
      parseState = "beforeArrayValue";
    } else {
      parseState = "beforePropertyName";
    }
  } else {
    const current2 = stack[stack.length - 1];
    if (current2 == null) {
      parseState = "end";
    } else if (Array.isArray(current2)) {
      parseState = "afterArrayValue";
    } else {
      parseState = "afterPropertyValue";
    }
  }
}
function pop() {
  stack.pop();
  const current2 = stack[stack.length - 1];
  if (current2 == null) {
    parseState = "end";
  } else if (Array.isArray(current2)) {
    parseState = "afterArrayValue";
  } else {
    parseState = "afterPropertyValue";
  }
}
function invalidChar(c2) {
  if (c2 === void 0) {
    return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
  }
  return syntaxError(`JSON5: invalid character '${formatChar(c2)}' at ${line}:${column}`);
}
function invalidEOF() {
  return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
}
function invalidIdentifier() {
  column -= 5;
  return syntaxError(`JSON5: invalid identifier character at ${line}:${column}`);
}
function separatorChar(c2) {
  console.warn(`JSON5: '${formatChar(c2)}' in strings is not valid ECMAScript; consider escaping`);
}
function formatChar(c2) {
  const replacements = {
    "'": "\\'",
    '"': '\\"',
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "\v": "\\v",
    "\0": "\\0",
    "\u2028": "\\u2028",
    "\u2029": "\\u2029"
  };
  if (replacements[c2]) {
    return replacements[c2];
  }
  if (c2 < " ") {
    const hexString = c2.charCodeAt(0).toString(16);
    return "\\x" + ("00" + hexString).substring(hexString.length);
  }
  return c2;
}
function syntaxError(message) {
  const err = new SyntaxError(message);
  err.lineNumber = line;
  err.columnNumber = column;
  return err;
}
var stringify = function stringify2(value2, replacer, space) {
  const stack2 = [];
  let indent = "";
  let propertyList;
  let replacerFunc;
  let gap = "";
  let quote;
  if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {
    space = replacer.space;
    quote = replacer.quote;
    replacer = replacer.replacer;
  }
  if (typeof replacer === "function") {
    replacerFunc = replacer;
  } else if (Array.isArray(replacer)) {
    propertyList = [];
    for (const v of replacer) {
      let item;
      if (typeof v === "string") {
        item = v;
      } else if (typeof v === "number" || v instanceof String || v instanceof Number) {
        item = String(v);
      }
      if (item !== void 0 && propertyList.indexOf(item) < 0) {
        propertyList.push(item);
      }
    }
  }
  if (space instanceof Number) {
    space = Number(space);
  } else if (space instanceof String) {
    space = String(space);
  }
  if (typeof space === "number") {
    if (space > 0) {
      space = Math.min(10, Math.floor(space));
      gap = "          ".substr(0, space);
    }
  } else if (typeof space === "string") {
    gap = space.substr(0, 10);
  }
  return serializeProperty("", { "": value2 });
  function serializeProperty(key2, holder) {
    let value3 = holder[key2];
    if (value3 != null) {
      if (typeof value3.toJSON5 === "function") {
        value3 = value3.toJSON5(key2);
      } else if (typeof value3.toJSON === "function") {
        value3 = value3.toJSON(key2);
      }
    }
    if (replacerFunc) {
      value3 = replacerFunc.call(holder, key2, value3);
    }
    if (value3 instanceof Number) {
      value3 = Number(value3);
    } else if (value3 instanceof String) {
      value3 = String(value3);
    } else if (value3 instanceof Boolean) {
      value3 = value3.valueOf();
    }
    switch (value3) {
      case null:
        return "null";
      case true:
        return "true";
      case false:
        return "false";
    }
    if (typeof value3 === "string") {
      return quoteString(value3);
    }
    if (typeof value3 === "number") {
      return String(value3);
    }
    if (typeof value3 === "object") {
      return Array.isArray(value3) ? serializeArray2(value3) : serializeObject2(value3);
    }
    return void 0;
  }
  function quoteString(value3) {
    const quotes = {
      "'": 0.1,
      '"': 0.2
    };
    const replacements = {
      "'": "\\'",
      '"': '\\"',
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\v": "\\v",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    let product = "";
    for (let i = 0; i < value3.length; i++) {
      const c2 = value3[i];
      switch (c2) {
        case "'":
        case '"':
          quotes[c2]++;
          product += c2;
          continue;
        case "\0":
          if (util.isDigit(value3[i + 1])) {
            product += "\\x00";
            continue;
          }
      }
      if (replacements[c2]) {
        product += replacements[c2];
        continue;
      }
      if (c2 < " ") {
        let hexString = c2.charCodeAt(0).toString(16);
        product += "\\x" + ("00" + hexString).substring(hexString.length);
        continue;
      }
      product += c2;
    }
    const quoteChar = quote || Object.keys(quotes).reduce((a, b) => quotes[a] < quotes[b] ? a : b);
    product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]);
    return quoteChar + product + quoteChar;
  }
  function serializeObject2(value3) {
    if (stack2.indexOf(value3) >= 0) {
      throw TypeError("Converting circular structure to JSON5");
    }
    stack2.push(value3);
    let stepback = indent;
    indent = indent + gap;
    let keys = propertyList || Object.keys(value3);
    let partial2 = [];
    for (const key2 of keys) {
      const propertyString = serializeProperty(key2, value3);
      if (propertyString !== void 0) {
        let member = serializeKey(key2) + ":";
        if (gap !== "") {
          member += " ";
        }
        member += propertyString;
        partial2.push(member);
      }
    }
    let final;
    if (partial2.length === 0) {
      final = "{}";
    } else {
      let properties;
      if (gap === "") {
        properties = partial2.join(",");
        final = "{" + properties + "}";
      } else {
        let separator = ",\n" + indent;
        properties = partial2.join(separator);
        final = "{\n" + indent + properties + ",\n" + stepback + "}";
      }
    }
    stack2.pop();
    indent = stepback;
    return final;
  }
  function serializeKey(key2) {
    if (key2.length === 0) {
      return quoteString(key2);
    }
    const firstChar = String.fromCodePoint(key2.codePointAt(0));
    if (!util.isIdStartChar(firstChar)) {
      return quoteString(key2);
    }
    for (let i = firstChar.length; i < key2.length; i++) {
      if (!util.isIdContinueChar(String.fromCodePoint(key2.codePointAt(i)))) {
        return quoteString(key2);
      }
    }
    return key2;
  }
  function serializeArray2(value3) {
    if (stack2.indexOf(value3) >= 0) {
      throw TypeError("Converting circular structure to JSON5");
    }
    stack2.push(value3);
    let stepback = indent;
    indent = indent + gap;
    let partial2 = [];
    for (let i = 0; i < value3.length; i++) {
      const propertyString = serializeProperty(String(i), value3);
      partial2.push(propertyString !== void 0 ? propertyString : "null");
    }
    let final;
    if (partial2.length === 0) {
      final = "[]";
    } else {
      if (gap === "") {
        let properties = partial2.join(",");
        final = "[" + properties + "]";
      } else {
        let separator = ",\n" + indent;
        let properties = partial2.join(separator);
        final = "[\n" + indent + properties + ",\n" + stepback + "]";
      }
    }
    stack2.pop();
    indent = stepback;
    return final;
  }
};
var JSON5 = {
  parse: parse$9,
  stringify
};
var lib$2 = JSON5;
var ignoreFlagRE = /\/\*\s*@vite-ignore\s*\*\//;
function getWorkerType(raw, clean, i) {
  function err(e, pos2) {
    const error2 = new Error(e);
    error2.pos = pos2;
    throw error2;
  }
  const commaIndex = clean.indexOf(",", i);
  if (commaIndex === -1) {
    return "classic";
  }
  const endIndex = clean.indexOf(")", i);
  if (commaIndex > endIndex) {
    return "classic";
  }
  const workerOptString = raw.substring(commaIndex + 1, endIndex).replace(/}[^]*,/g, "}");
  const hasViteIgnore = ignoreFlagRE.test(workerOptString);
  if (hasViteIgnore) {
    return "ignore";
  }
  const cleanWorkerOptString = clean.substring(commaIndex + 1, endIndex).trim();
  if (!cleanWorkerOptString.length) {
    return "classic";
  }
  let workerOpts = { type: "classic" };
  try {
    workerOpts = lib$2.parse(workerOptString);
  } catch (e) {
    err("Vite is unable to parse the worker options as the value is not static.To ignore this error, please use /* @vite-ignore */ in the worker options.", commaIndex + 1);
  }
  if (["classic", "module"].includes(workerOpts.type)) {
    return workerOpts.type;
  }
  return "classic";
}
function workerImportMetaUrlPlugin(config2) {
  const isBuild = config2.command === "build";
  let workerResolver;
  return {
    name: "vite:worker-import-meta-url",
    async transform(code, id, options3) {
      var _a;
      const ssr = (options3 == null ? void 0 : options3.ssr) === true;
      if (!(options3 == null ? void 0 : options3.ssr) && (code.includes("new Worker") || code.includes("new SharedWorker")) && code.includes("new URL") && code.includes(`import.meta.url`)) {
        const query = parseRequest(id);
        let s;
        const cleanString = stripLiteral(code);
        const workerImportMetaUrlRE = /\bnew\s+(Worker|SharedWorker)\s*\(\s*(new\s+URL\s*\(\s*('[^']+'|"[^"]+"|`[^`]+`)\s*,\s*import\.meta\.url\s*\))/g;
        let match;
        while (match = workerImportMetaUrlRE.exec(cleanString)) {
          const { 0: allExp, 2: exp, 3: emptyUrl, index: index2 } = match;
          const urlIndex = allExp.indexOf(exp) + index2;
          const urlStart = cleanString.indexOf(emptyUrl, index2);
          const urlEnd = urlStart + emptyUrl.length;
          const rawUrl = code.slice(urlStart, urlEnd);
          if (rawUrl[0] === "`" && /\$\{/.test(rawUrl)) {
            this.error(`\`new URL(url, import.meta.url)\` is not supported in dynamic template string.`, urlIndex);
          }
          s || (s = new MagicString(code));
          const workerType = getWorkerType(code, cleanString, index2 + allExp.length);
          const url2 = rawUrl.slice(1, -1);
          let file;
          if (url2.startsWith(".")) {
            file = import_node_path2.default.resolve(import_node_path2.default.dirname(id), url2);
          } else {
            workerResolver != null ? workerResolver : workerResolver = config2.createResolver({
              extensions: [],
              tryIndex: false,
              preferRelative: true
            });
            file = await workerResolver(url2, id);
            file != null ? file : file = url2.startsWith("/") ? slash$1(import_node_path2.default.join(config2.publicDir, url2)) : slash$1(import_node_path2.default.resolve(import_node_path2.default.dirname(id), url2));
          }
          let builtUrl;
          if (isBuild) {
            (_a = getDepsOptimizer(config2, ssr)) == null ? void 0 : _a.registerWorkersSource(id);
            builtUrl = await workerFileToUrl(config2, file, query);
          } else {
            builtUrl = await fileToUrl(cleanUrl(file), config2, this);
            builtUrl = injectQuery(builtUrl, WORKER_FILE_ID);
            builtUrl = injectQuery(builtUrl, `type=${workerType}`);
          }
          s.update(urlIndex, urlIndex + exp.length, `new URL(${JSON.stringify(builtUrl)}, self.location)`);
        }
        if (s) {
          return transformStableResult(s, id, config2);
        }
        return null;
      }
    }
  };
}
function assetImportMetaUrlPlugin(config2) {
  const normalizedPublicDir = normalizePath$3(config2.publicDir);
  let assetResolver;
  return {
    name: "vite:asset-import-meta-url",
    async transform(code, id, options3) {
      if (!(options3 == null ? void 0 : options3.ssr) && id !== preloadHelperId && code.includes("new URL") && code.includes(`import.meta.url`)) {
        let s;
        const assetImportMetaUrlRE = /\bnew\s+URL\s*\(\s*('[^']+'|"[^"]+"|`[^`]+`)\s*,\s*import\.meta\.url\s*,?\s*\)/g;
        const cleanString = stripLiteral(code);
        let match;
        while (match = assetImportMetaUrlRE.exec(cleanString)) {
          const { 0: exp, 1: emptyUrl, index: index2 } = match;
          const urlStart = cleanString.indexOf(emptyUrl, index2);
          const urlEnd = urlStart + emptyUrl.length;
          const rawUrl = code.slice(urlStart, urlEnd);
          if (!s)
            s = new MagicString(code);
          if (rawUrl[0] === "`" && /\$\{/.test(rawUrl)) {
            const ast = this.parse(rawUrl);
            const templateLiteral = ast.body[0].expression;
            if (templateLiteral.expressions.length) {
              const pattern2 = JSON.stringify(buildGlobPattern(templateLiteral));
              s.update(index2, index2 + exp.length, `new URL((import.meta.glob(${pattern2}, { eager: true, import: 'default', as: 'url' }))[${rawUrl}], self.location)`);
              continue;
            }
          }
          const url2 = rawUrl.slice(1, -1);
          let file;
          if (url2.startsWith(".")) {
            file = slash$1(import_node_path2.default.resolve(import_node_path2.default.dirname(id), url2));
          } else {
            assetResolver != null ? assetResolver : assetResolver = config2.createResolver({
              extensions: [],
              mainFields: [],
              tryIndex: false,
              preferRelative: true
            });
            file = await assetResolver(url2, id);
            file != null ? file : file = url2.startsWith("/") ? slash$1(import_node_path2.default.join(config2.publicDir, url2)) : slash$1(import_node_path2.default.resolve(import_node_path2.default.dirname(id), url2));
          }
          let builtUrl;
          if (file) {
            try {
              if (isParentDirectory(normalizedPublicDir, file)) {
                const publicPath = "/" + import_node_path2.default.posix.relative(normalizedPublicDir, file);
                builtUrl = await fileToUrl(publicPath, config2, this);
              } else {
                builtUrl = await fileToUrl(file, config2, this);
              }
            } catch {
            }
          }
          if (!builtUrl) {
            const rawExp = code.slice(index2, index2 + exp.length);
            config2.logger.warnOnce(`
${rawExp} doesn't exist at build time, it will remain unchanged to be resolved at runtime`);
            builtUrl = url2;
          }
          s.update(index2, index2 + exp.length, `new URL(${JSON.stringify(builtUrl)}, self.location)`);
        }
        if (s) {
          return transformStableResult(s, id, config2);
        }
      }
      return null;
    }
  };
}
function buildGlobPattern(ast) {
  let pattern2 = "";
  let lastElementIndex = -1;
  for (const exp of ast.expressions) {
    for (let i = lastElementIndex + 1; i < ast.quasis.length; i++) {
      const el = ast.quasis[i];
      if (el.end < exp.start) {
        pattern2 += el.value.raw;
        lastElementIndex = i;
      }
    }
    pattern2 += "**";
  }
  for (let i = lastElementIndex + 1; i < ast.quasis.length; i++) {
    pattern2 += ast.quasis[i].value.raw;
  }
  return pattern2;
}
function ensureWatchPlugin() {
  return {
    name: "vite:ensure-watch",
    load(id) {
      if (queryRE.test(id)) {
        this.addWatchFile(cleanUrl(id));
      }
      return null;
    }
  };
}
function metadataPlugin() {
  return {
    name: "vite:build-metadata",
    async renderChunk(_code, chunk) {
      chunk.viteMetadata = {
        importedAssets: /* @__PURE__ */ new Set(),
        importedCss: /* @__PURE__ */ new Set()
      };
      return null;
    }
  };
}
var VariableDynamicImportError = class extends Error {
};
var example = "For example: import(`./foo/${bar}.js`).";
function sanitizeString(str) {
  if (str.includes("*")) {
    throw new VariableDynamicImportError("A dynamic import cannot contain * characters.");
  }
  return str;
}
function templateLiteralToGlob(node2) {
  let glob = "";
  for (let i = 0; i < node2.quasis.length; i += 1) {
    glob += sanitizeString(node2.quasis[i].value.raw);
    if (node2.expressions[i]) {
      glob += expressionToGlob(node2.expressions[i]);
    }
  }
  return glob;
}
function callExpressionToGlob(node2) {
  const { callee } = node2;
  if (callee.type === "MemberExpression" && callee.property.type === "Identifier" && callee.property.name === "concat") {
    return `${expressionToGlob(callee.object)}${node2.arguments.map(expressionToGlob).join("")}`;
  }
  return "*";
}
function binaryExpressionToGlob(node2) {
  if (node2.operator !== "+") {
    throw new VariableDynamicImportError(`${node2.operator} operator is not supported.`);
  }
  return `${expressionToGlob(node2.left)}${expressionToGlob(node2.right)}`;
}
function expressionToGlob(node2) {
  switch (node2.type) {
    case "TemplateLiteral":
      return templateLiteralToGlob(node2);
    case "CallExpression":
      return callExpressionToGlob(node2);
    case "BinaryExpression":
      return binaryExpressionToGlob(node2);
    case "Literal": {
      return sanitizeString(node2.value);
    }
    default:
      return "*";
  }
}
var defaultProtocol = "file:";
var ignoredProtocols = ["data:", "http:", "https:"];
function shouldIgnore(glob) {
  const containsAsterisk = glob.includes("*");
  const globURL = new URL(glob, defaultProtocol);
  const containsIgnoredProtocol = ignoredProtocols.some(
    (ignoredProtocol) => ignoredProtocol === globURL.protocol
  );
  return !containsAsterisk || containsIgnoredProtocol;
}
function dynamicImportToGlob(node2, sourceString) {
  let glob = expressionToGlob(node2);
  if (shouldIgnore(glob)) {
    return null;
  }
  glob = glob.replace(/\*\*/g, "*");
  if (glob.startsWith("*")) {
    throw new VariableDynamicImportError(
      `invalid import "${sourceString}". It cannot be statically analyzed. Variable dynamic imports must start with ./ and be limited to a specific directory. ${example}`
    );
  }
  if (glob.startsWith("/")) {
    throw new VariableDynamicImportError(
      `invalid import "${sourceString}". Variable absolute imports are not supported, imports must start with ./ in the static part of the import. ${example}`
    );
  }
  if (!glob.startsWith("./") && !glob.startsWith("../")) {
    throw new VariableDynamicImportError(
      `invalid import "${sourceString}". Variable bare imports are not supported, imports must start with ./ in the static part of the import. ${example}`
    );
  }
  const ownDirectoryStarExtension = /^\.\/\*\.[\w]+$/;
  if (ownDirectoryStarExtension.test(glob)) {
    throw new VariableDynamicImportError(
      `${`invalid import "${sourceString}". Variable imports cannot import their own directory, place imports in a separate directory or make the import filename more specific. `}${example}`
    );
  }
  if (import_path.default.extname(glob) === "") {
    throw new VariableDynamicImportError(
      `invalid import "${sourceString}". A file extension must be included in the static part of the import. ${example}`
    );
  }
  return glob;
}
var dynamicImportHelperId = "/@vite/dynamic-import-helper";
var dynamicImportHelper = (glob, path4) => {
  const v = glob[path4];
  if (v) {
    return typeof v === "function" ? v() : Promise.resolve(v);
  }
  return new Promise((_, reject) => {
    (typeof queueMicrotask === "function" ? queueMicrotask : setTimeout)(reject.bind(null, new Error("Unknown variable dynamic import: " + path4)));
  });
};
function parseDynamicImportPattern(strings) {
  const filename = strings.slice(1, -1);
  const rawQuery = parseRequest(filename);
  let globParams = null;
  const ast = parse$c(strings, {
    ecmaVersion: "latest",
    sourceType: "module"
  }).body[0].expression;
  const userPatternQuery = dynamicImportToGlob(ast, filename);
  if (!userPatternQuery) {
    return null;
  }
  const [userPattern] = userPatternQuery.split(requestQuerySplitRE, 2);
  const [rawPattern] = filename.split(requestQuerySplitRE, 2);
  if ((rawQuery == null ? void 0 : rawQuery.raw) !== void 0) {
    globParams = { as: "raw" };
  }
  if ((rawQuery == null ? void 0 : rawQuery.url) !== void 0) {
    globParams = { as: "url" };
  }
  if ((rawQuery == null ? void 0 : rawQuery.worker) !== void 0) {
    globParams = { as: "worker" };
  }
  return {
    globParams,
    userPattern,
    rawPattern
  };
}
async function transformDynamicImport(importSource, importer, resolve3, root2) {
  if (importSource[1] !== "." && importSource[1] !== "/") {
    const resolvedFileName = await resolve3(importSource.slice(1, -1), importer);
    if (!resolvedFileName) {
      return null;
    }
    const relativeFileName = import_node_path2.posix.relative(import_node_path2.posix.dirname(normalizePath$3(importer)), normalizePath$3(resolvedFileName));
    importSource = normalizePath$3("`" + (relativeFileName[0] === "." ? "" : "./") + relativeFileName + "`");
  }
  const dynamicImportPattern = parseDynamicImportPattern(importSource);
  if (!dynamicImportPattern) {
    return null;
  }
  const { globParams, rawPattern, userPattern } = dynamicImportPattern;
  const params = globParams ? `, ${JSON.stringify({ ...globParams, import: "*" })}` : "";
  let newRawPattern = import_node_path2.posix.relative(import_node_path2.posix.dirname(importer), await toAbsoluteGlob(rawPattern, root2, importer, resolve3));
  if (!/^\.{1,2}\//.test(newRawPattern)) {
    newRawPattern = `./${newRawPattern}`;
  }
  const exp = `(import.meta.glob(${JSON.stringify(userPattern)}${params}))`;
  return {
    rawPattern: newRawPattern,
    pattern: userPattern,
    glob: exp
  };
}
function dynamicImportVarsPlugin(config2) {
  const resolve3 = config2.createResolver({
    preferRelative: true,
    tryIndex: false,
    extensions: []
  });
  const { include, exclude, warnOnError } = config2.build.dynamicImportVarsOptions;
  const filter2 = createFilter3(include, exclude);
  return {
    name: "vite:dynamic-import-vars",
    resolveId(id) {
      if (id === dynamicImportHelperId) {
        return id;
      }
    },
    load(id) {
      if (id === dynamicImportHelperId) {
        return "export default " + dynamicImportHelper.toString();
      }
    },
    async transform(source2, importer) {
      if (!filter2(importer)) {
        return;
      }
      await init;
      let imports = [];
      try {
        imports = parse$b(source2)[0];
      } catch (e) {
        return null;
      }
      if (!imports.length) {
        return null;
      }
      let s;
      let needDynamicImportHelper = false;
      for (let index2 = 0; index2 < imports.length; index2++) {
        const { s: start, e: end, ss: expStart, se: expEnd, d: dynamicIndex } = imports[index2];
        if (dynamicIndex === -1 || source2[start] !== "`") {
          continue;
        }
        s || (s = new MagicString(source2));
        let result;
        try {
          const importSource = removeComments(source2.slice(start, end)).trim();
          result = await transformDynamicImport(importSource, importer, resolve3, config2.root);
        } catch (error2) {
          if (warnOnError) {
            this.warn(error2);
          } else {
            this.error(error2);
          }
        }
        if (!result) {
          continue;
        }
        const { rawPattern, glob } = result;
        needDynamicImportHelper = true;
        s.overwrite(expStart, expEnd, `__variableDynamicImportRuntimeHelper(${glob}, \`${rawPattern}\`)`);
      }
      if (s) {
        if (needDynamicImportHelper) {
          s.prepend(`import __variableDynamicImportRuntimeHelper from "${dynamicImportHelperId}";`);
        }
        return transformStableResult(s, importer, config2);
      }
    }
  };
}
async function resolvePlugins(config2, prePlugins, normalPlugins, postPlugins) {
  var _a;
  const isBuild = config2.command === "build";
  const isWatch = isBuild && !!config2.build.watch;
  const buildPlugins = isBuild ? (await Promise.resolve().then(function() {
    return build$1;
  })).resolveBuildPlugins(config2) : { pre: [], post: [] };
  const { modulePreload } = config2.build;
  return [
    isWatch ? ensureWatchPlugin() : null,
    isBuild ? metadataPlugin() : null,
    preAliasPlugin(config2),
    alias$1({ entries: config2.resolve.alias }),
    ...prePlugins,
    modulePreload === true || typeof modulePreload === "object" && modulePreload.polyfill ? modulePreloadPolyfillPlugin(config2) : null,
    ...isDepsOptimizerEnabled(config2, false) || isDepsOptimizerEnabled(config2, true) ? [
      isBuild ? optimizedDepsBuildPlugin(config2) : optimizedDepsPlugin(config2)
    ] : [],
    resolvePlugin({
      ...config2.resolve,
      root: config2.root,
      isProduction: config2.isProduction,
      isBuild,
      packageCache: config2.packageCache,
      ssrConfig: config2.ssr,
      asSrc: true,
      getDepsOptimizer: (ssr) => getDepsOptimizer(config2, ssr),
      shouldExternalize: isBuild && config2.build.ssr && ((_a = config2.ssr) == null ? void 0 : _a.format) !== "cjs" ? (id) => shouldExternalizeForSSR(id, config2) : void 0
    }),
    htmlInlineProxyPlugin(config2),
    cssPlugin(config2),
    config2.esbuild !== false ? esbuildPlugin(config2.esbuild) : null,
    jsonPlugin({
      namedExports: true,
      ...config2.json
    }, isBuild),
    wasmHelperPlugin(config2),
    webWorkerPlugin(config2),
    assetPlugin(config2),
    ...normalPlugins,
    wasmFallbackPlugin(),
    definePlugin(config2),
    cssPostPlugin(config2),
    isBuild && config2.build.ssr ? ssrRequireHookPlugin(config2) : null,
    isBuild && buildHtmlPlugin(config2),
    workerImportMetaUrlPlugin(config2),
    assetImportMetaUrlPlugin(config2),
    ...buildPlugins.pre,
    dynamicImportVarsPlugin(config2),
    importGlobPlugin(config2),
    ...postPlugins,
    ...buildPlugins.post,
    ...isBuild ? [] : [clientInjectionsPlugin(config2), importAnalysisPlugin(config2)]
  ].filter(Boolean);
}
function createPluginHookUtils(plugins2) {
  const sortedPluginsCache = /* @__PURE__ */ new Map();
  function getSortedPlugins(hookName) {
    if (sortedPluginsCache.has(hookName))
      return sortedPluginsCache.get(hookName);
    const sorted = getSortedPluginsByHook(hookName, plugins2);
    sortedPluginsCache.set(hookName, sorted);
    return sorted;
  }
  function getSortedPluginHooks(hookName) {
    const plugins3 = getSortedPlugins(hookName);
    return plugins3.map((p) => {
      const hook = p[hookName];
      return "handler" in hook ? hook.handler : hook;
    }).filter(Boolean);
  }
  return {
    getSortedPlugins,
    getSortedPluginHooks
  };
}
function getSortedPluginsByHook(hookName, plugins2) {
  const pre = [];
  const normal = [];
  const post = [];
  for (const plugin of plugins2) {
    const hook = plugin[hookName];
    if (hook) {
      if (typeof hook === "object") {
        if (hook.order === "pre") {
          pre.push(plugin);
          continue;
        }
        if (hook.order === "post") {
          post.push(plugin);
          continue;
        }
      }
      normal.push(plugin);
    }
  }
  return [...pre, ...normal, ...post];
}
function ansiRegex({ onlyFirst = false } = {}) {
  const pattern2 = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
  ].join("|");
  return new RegExp(pattern2, onlyFirst ? void 0 : "g");
}
function stripAnsi(string2) {
  if (typeof string2 !== "string") {
    throw new TypeError(`Expected a \`string\`, got \`${typeof string2}\``);
  }
  return string2.replace(ansiRegex(), "");
}
function prepareError(err) {
  return {
    message: stripAnsi(err.message),
    stack: stripAnsi(cleanStack(err.stack || "")),
    id: err.id,
    frame: stripAnsi(err.frame || ""),
    plugin: err.plugin,
    pluginCode: err.pluginCode,
    loc: err.loc
  };
}
function buildErrorMessage(err, args = [], includeStack = true) {
  if (err.plugin)
    args.push(`  Plugin: ${picocolors.exports.magenta(err.plugin)}`);
  const loc = err.loc ? `:${err.loc.line}:${err.loc.column}` : "";
  if (err.id)
    args.push(`  File: ${picocolors.exports.cyan(err.id)}${loc}`);
  if (err.frame)
    args.push(picocolors.exports.yellow(pad$1(err.frame)));
  if (includeStack && err.stack)
    args.push(pad$1(cleanStack(err.stack)));
  return args.join("\n");
}
function cleanStack(stack2) {
  return stack2.split(/\n/g).filter((l) => /^\s*at/.test(l)).join("\n");
}
function logError(server2, err) {
  const msg = buildErrorMessage(err, [
    picocolors.exports.red(`Internal server error: ${err.message}`)
  ]);
  server2.config.logger.error(msg, {
    clear: true,
    timestamp: true,
    error: err
  });
  server2.ws.send({
    type: "error",
    err: prepareError(err)
  });
}
function errorMiddleware(server2, allowNext = false) {
  return function viteErrorMiddleware(err, _req, res, next) {
    logError(server2, err);
    if (allowNext) {
      next();
    } else {
      res.statusCode = 500;
      res.end(`
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="UTF-8" />
            <title>Error</title>
            <script type="module">
              import { ErrorOverlay } from '/@vite/client'
              document.body.appendChild(new ErrorOverlay(${JSON.stringify(prepareError(err)).replace(/</g, "\\u003c")}))
            <\/script>
          </head>
          <body>
          </body>
        </html>
      `);
    }
  };
}
var parser = Parser;
async function createPluginContainer(config2, moduleGraph, watcher) {
  var _a;
  const isDebug2 = process.env.DEBUG;
  const { plugins: plugins2, logger, root: root2, build: { rollupOptions } } = config2;
  const { getSortedPluginHooks, getSortedPlugins } = createPluginHookUtils(plugins2);
  const seenResolves = {};
  const debugResolve = createDebugger("vite:resolve");
  const debugPluginResolve = createDebugger("vite:plugin-resolve", {
    onlyWhenFocused: "vite:plugin"
  });
  const debugPluginTransform = createDebugger("vite:plugin-transform", {
    onlyWhenFocused: "vite:plugin"
  });
  const debugSourcemapCombineFlag = "vite:sourcemap-combine";
  const isDebugSourcemapCombineFocused = (_a = process.env.DEBUG) == null ? void 0 : _a.includes(debugSourcemapCombineFlag);
  const debugSourcemapCombineFilter = process.env.DEBUG_VITE_SOURCEMAP_COMBINE_FILTER;
  const debugSourcemapCombine = createDebugger("vite:sourcemap-combine", {
    onlyWhenFocused: true
  });
  const watchFiles = /* @__PURE__ */ new Set();
  const _require2 = (0, import_node_module.createRequire)(import.meta.url);
  const rollupPkgPath = (0, import_node_path2.resolve)(_require2.resolve("rollup"), "../../package.json");
  const minimalContext = {
    meta: {
      rollupVersion: JSON.parse(import_node_fs.default.readFileSync(rollupPkgPath, "utf-8")).version,
      watchMode: true
    }
  };
  function warnIncompatibleMethod(method, plugin) {
    logger.warn(picocolors.exports.cyan(`[plugin:${plugin}] `) + picocolors.exports.yellow(`context method ${picocolors.exports.bold(`${method}()`)} is not supported in serve mode. This plugin is likely not vite-compatible.`));
  }
  async function hookParallel(hookName, context, args) {
    const parallelPromises = [];
    for (const plugin of getSortedPlugins(hookName)) {
      const hook = plugin[hookName];
      if (!hook)
        continue;
      const handler = "handler" in hook ? hook.handler : hook;
      if (hook.sequential) {
        await Promise.all(parallelPromises);
        parallelPromises.length = 0;
        await handler.apply(context(plugin), args(plugin));
      } else {
        parallelPromises.push(handler.apply(context(plugin), args(plugin)));
      }
    }
    await Promise.all(parallelPromises);
  }
  const ModuleInfoProxy = {
    get(info, key2) {
      if (key2 in info) {
        return info[key2];
      }
      throw Error(`[vite] The "${key2}" property of ModuleInfo is not supported.`);
    }
  };
  const EMPTY_OBJECT = Object.freeze({});
  function getModuleInfo(id) {
    const module2 = moduleGraph == null ? void 0 : moduleGraph.getModuleById(id);
    if (!module2) {
      return null;
    }
    if (!module2.info) {
      module2.info = new Proxy({ id, meta: module2.meta || EMPTY_OBJECT }, ModuleInfoProxy);
    }
    return module2.info;
  }
  function updateModuleInfo(id, { meta }) {
    if (meta) {
      const moduleInfo = getModuleInfo(id);
      if (moduleInfo) {
        moduleInfo.meta = { ...moduleInfo.meta, ...meta };
      }
    }
  }
  class Context {
    constructor(initialPlugin) {
      this.meta = minimalContext.meta;
      this.ssr = false;
      this._scan = false;
      this._activeId = null;
      this._activeCode = null;
      this._addedImports = null;
      this._activePlugin = initialPlugin || null;
    }
    parse(code, opts = {}) {
      return parser.parse(code, {
        sourceType: "module",
        ecmaVersion: "latest",
        locations: true,
        ...opts
      });
    }
    async resolve(id, importer, options3) {
      let skip;
      if ((options3 == null ? void 0 : options3.skipSelf) && this._activePlugin) {
        skip = new Set(this._resolveSkips);
        skip.add(this._activePlugin);
      }
      let out2 = await container.resolveId(id, importer, {
        custom: options3 == null ? void 0 : options3.custom,
        isEntry: !!(options3 == null ? void 0 : options3.isEntry),
        skip,
        ssr: this.ssr,
        scan: this._scan
      });
      if (typeof out2 === "string")
        out2 = { id: out2 };
      return out2;
    }
    getModuleInfo(id) {
      return getModuleInfo(id);
    }
    getModuleIds() {
      return moduleGraph ? moduleGraph.idToModuleMap.keys() : Array.prototype[Symbol.iterator]();
    }
    addWatchFile(id) {
      watchFiles.add(id);
      (this._addedImports || (this._addedImports = /* @__PURE__ */ new Set())).add(id);
      if (watcher)
        ensureWatchedFile(watcher, id, root2);
    }
    getWatchFiles() {
      return [...watchFiles];
    }
    emitFile(assetOrFile) {
      warnIncompatibleMethod(`emitFile`, this._activePlugin.name);
      return "";
    }
    setAssetSource() {
      warnIncompatibleMethod(`setAssetSource`, this._activePlugin.name);
    }
    getFileName() {
      warnIncompatibleMethod(`getFileName`, this._activePlugin.name);
      return "";
    }
    warn(e, position) {
      const err = formatError(e, position, this);
      const msg = buildErrorMessage(err, [picocolors.exports.yellow(`warning: ${err.message}`)], false);
      logger.warn(msg, {
        clear: true,
        timestamp: true
      });
    }
    error(e, position) {
      throw formatError(e, position, this);
    }
  }
  function formatError(e, position, ctx2) {
    const err = typeof e === "string" ? new Error(e) : e;
    if (err.pluginCode) {
      return err;
    }
    if (err.file && err.name === "CssSyntaxError") {
      err.id = normalizePath$3(err.file);
    }
    if (ctx2._activePlugin)
      err.plugin = ctx2._activePlugin.name;
    if (ctx2._activeId && !err.id)
      err.id = ctx2._activeId;
    if (ctx2._activeCode) {
      err.pluginCode = ctx2._activeCode;
      const pos2 = position != null ? position : err.pos != null ? err.pos : err.position;
      if (pos2 != null) {
        let errLocation;
        try {
          errLocation = numberToPos(ctx2._activeCode, pos2);
        } catch (err2) {
          logger.error(
            picocolors.exports.red(`Error in error handler:
${err2.stack || err2.message}
`),
            { error: err2 }
          );
          throw err;
        }
        err.loc = err.loc || {
          file: err.id,
          ...errLocation
        };
        err.frame = err.frame || generateCodeFrame(ctx2._activeCode, pos2);
      } else if (err.loc) {
        if (!err.frame) {
          let code = ctx2._activeCode;
          if (err.loc.file) {
            err.id = normalizePath$3(err.loc.file);
            try {
              code = import_node_fs.default.readFileSync(err.loc.file, "utf-8");
            } catch {
            }
          }
          err.frame = generateCodeFrame(code, err.loc);
        }
      } else if (err.line && err.column) {
        err.loc = {
          file: err.id,
          line: err.line,
          column: err.column
        };
        err.frame = err.frame || generateCodeFrame(err.id, err.loc);
      }
      if (err.loc && ctx2 instanceof TransformContext) {
        const rawSourceMap = ctx2._getCombinedSourcemap();
        if (rawSourceMap) {
          const traced = new TraceMap(rawSourceMap);
          const { source: source2, line: line2, column: column2 } = originalPositionFor$1(traced, {
            line: Number(err.loc.line),
            column: Number(err.loc.column)
          });
          if (source2 && line2 != null && column2 != null) {
            err.loc = { file: source2, line: line2, column: column2 };
          }
        }
      }
    }
    return err;
  }
  class TransformContext extends Context {
    constructor(filename, code, inMap) {
      super();
      this.originalSourcemap = null;
      this.sourcemapChain = [];
      this.combinedMap = null;
      this.filename = filename;
      this.originalCode = code;
      if (inMap) {
        if (isDebugSourcemapCombineFocused) {
          inMap.name = "$inMap";
        }
        this.sourcemapChain.push(inMap);
      }
    }
    _getCombinedSourcemap(createIfNull = false) {
      if (debugSourcemapCombineFilter && this.filename.includes(debugSourcemapCombineFilter)) {
        debugSourcemapCombine("----------", this.filename);
        debugSourcemapCombine(this.combinedMap);
        debugSourcemapCombine(this.sourcemapChain);
        debugSourcemapCombine("----------");
      }
      let combinedMap = this.combinedMap;
      for (let m of this.sourcemapChain) {
        if (typeof m === "string")
          m = JSON.parse(m);
        if (!("version" in m)) {
          combinedMap = this.combinedMap = null;
          this.sourcemapChain.length = 0;
          break;
        }
        if (!combinedMap) {
          combinedMap = m;
        } else {
          combinedMap = combineSourcemaps(cleanUrl(this.filename), [
            {
              ...m,
              sourcesContent: combinedMap.sourcesContent
            },
            combinedMap
          ]);
        }
      }
      if (!combinedMap) {
        return createIfNull ? new MagicString(this.originalCode).generateMap({
          includeContent: true,
          hires: true,
          source: cleanUrl(this.filename)
        }) : null;
      }
      if (combinedMap !== this.combinedMap) {
        this.combinedMap = combinedMap;
        this.sourcemapChain.length = 0;
      }
      return this.combinedMap;
    }
    getCombinedSourcemap() {
      return this._getCombinedSourcemap(true);
    }
  }
  let closed = false;
  const container = {
    options: await (async () => {
      let options3 = rollupOptions;
      for (const optionsHook of getSortedPluginHooks("options")) {
        options3 = await optionsHook.call(minimalContext, options3) || options3;
      }
      if (options3.acornInjectPlugins) {
        parser = Parser.extend(...arraify(options3.acornInjectPlugins));
      }
      return {
        acorn,
        acornInjectPlugins: [],
        ...options3
      };
    })(),
    getModuleInfo,
    async buildStart() {
      await hookParallel("buildStart", (plugin) => new Context(plugin), () => [container.options]);
    },
    async resolveId(rawId, importer = (0, import_node_path2.join)(root2, "index.html"), options3) {
      const skip = options3 == null ? void 0 : options3.skip;
      const ssr = options3 == null ? void 0 : options3.ssr;
      const scan2 = !!(options3 == null ? void 0 : options3.scan);
      const ctx2 = new Context();
      ctx2.ssr = !!ssr;
      ctx2._scan = scan2;
      ctx2._resolveSkips = skip;
      const resolveStart = isDebug2 ? import_node_perf_hooks.performance.now() : 0;
      let id = null;
      const partial2 = {};
      for (const plugin of getSortedPlugins("resolveId")) {
        if (!plugin.resolveId)
          continue;
        if (skip == null ? void 0 : skip.has(plugin))
          continue;
        ctx2._activePlugin = plugin;
        const pluginResolveStart = isDebug2 ? import_node_perf_hooks.performance.now() : 0;
        const handler = "handler" in plugin.resolveId ? plugin.resolveId.handler : plugin.resolveId;
        const result = await handler.call(ctx2, rawId, importer, {
          custom: options3 == null ? void 0 : options3.custom,
          isEntry: !!(options3 == null ? void 0 : options3.isEntry),
          ssr,
          scan: scan2
        });
        if (!result)
          continue;
        if (typeof result === "string") {
          id = result;
        } else {
          id = result.id;
          Object.assign(partial2, result);
        }
        isDebug2 && debugPluginResolve(timeFrom(pluginResolveStart), plugin.name, prettifyUrl(id, root2));
        break;
      }
      if (isDebug2 && rawId !== id && !rawId.startsWith(FS_PREFIX)) {
        const key2 = rawId + id;
        if (!seenResolves[key2]) {
          seenResolves[key2] = true;
          debugResolve(`${timeFrom(resolveStart)} ${picocolors.exports.cyan(rawId)} -> ${picocolors.exports.dim(id)}`);
        }
      }
      if (id) {
        partial2.id = isExternalUrl(id) ? id : normalizePath$3(id);
        return partial2;
      } else {
        return null;
      }
    },
    async load(id, options3) {
      const ssr = options3 == null ? void 0 : options3.ssr;
      const ctx2 = new Context();
      ctx2.ssr = !!ssr;
      for (const plugin of getSortedPlugins("load")) {
        if (!plugin.load)
          continue;
        ctx2._activePlugin = plugin;
        const handler = "handler" in plugin.load ? plugin.load.handler : plugin.load;
        const result = await handler.call(ctx2, id, { ssr });
        if (result != null) {
          if (isObject$1(result)) {
            updateModuleInfo(id, result);
          }
          return result;
        }
      }
      return null;
    },
    async transform(code, id, options3) {
      const inMap = options3 == null ? void 0 : options3.inMap;
      const ssr = options3 == null ? void 0 : options3.ssr;
      const ctx2 = new TransformContext(id, code, inMap);
      ctx2.ssr = !!ssr;
      for (const plugin of getSortedPlugins("transform")) {
        if (!plugin.transform)
          continue;
        ctx2._activePlugin = plugin;
        ctx2._activeId = id;
        ctx2._activeCode = code;
        const start = isDebug2 ? import_node_perf_hooks.performance.now() : 0;
        let result;
        const handler = "handler" in plugin.transform ? plugin.transform.handler : plugin.transform;
        try {
          result = await handler.call(ctx2, code, id, { ssr });
        } catch (e) {
          ctx2.error(e);
        }
        if (!result)
          continue;
        isDebug2 && debugPluginTransform(timeFrom(start), plugin.name, prettifyUrl(id, root2));
        if (isObject$1(result)) {
          if (result.code !== void 0) {
            code = result.code;
            if (result.map) {
              if (isDebugSourcemapCombineFocused) {
                result.map.name = plugin.name;
              }
              ctx2.sourcemapChain.push(result.map);
            }
          }
          updateModuleInfo(id, result);
        } else {
          code = result;
        }
      }
      return {
        code,
        map: ctx2._getCombinedSourcemap()
      };
    },
    async close() {
      if (closed)
        return;
      const ctx2 = new Context();
      await hookParallel("buildEnd", () => ctx2, () => []);
      await hookParallel("closeBundle", () => ctx2, () => []);
      closed = true;
    }
  };
  return container;
}
var debug$8 = createDebugger("vite:deps");
var htmlTypesRE = /\.(html|vue|svelte|astro|imba)$/;
var importsRE = new RegExp(`(?<!\\/\\/.*)(?<=^|;|\\*\\/)\\s*import(?!\\s+type)(?:[\\w*{}\\n\\r\\t, ]+from\\s*)?\\s*("[^"]+"|'[^']+')\\s*(?=$|;|\\/\\/|\\/\\*)`, "gm");
async function scanImports(config2) {
  var _a, _b, _c;
  const start = import_node_perf_hooks.performance.now();
  let entries = [];
  const explicitEntryPatterns = config2.optimizeDeps.entries;
  const buildInput = (_a = config2.build.rollupOptions) == null ? void 0 : _a.input;
  if (explicitEntryPatterns) {
    entries = await globEntries(explicitEntryPatterns, config2);
  } else if (buildInput) {
    const resolvePath = (p) => import_node_path2.default.resolve(config2.root, p);
    if (typeof buildInput === "string") {
      entries = [resolvePath(buildInput)];
    } else if (Array.isArray(buildInput)) {
      entries = buildInput.map(resolvePath);
    } else if (isObject$1(buildInput)) {
      entries = Object.values(buildInput).map(resolvePath);
    } else {
      throw new Error("invalid rollupOptions.input value.");
    }
  } else {
    entries = await globEntries("**/*.html", config2);
  }
  entries = entries.filter((entry2) => isScannable(entry2) && import_node_fs.default.existsSync(entry2));
  if (!entries.length) {
    if (!explicitEntryPatterns && !config2.optimizeDeps.include) {
      config2.logger.warn(picocolors.exports.yellow("(!) Could not auto-determine entry point from rollupOptions or html files and there are no explicit optimizeDeps.include patterns. Skipping dependency pre-bundling."));
    }
    return { deps: {}, missing: {} };
  } else {
    debug$8(`Crawling dependencies using entries:
  ${entries.join("\n  ")}`);
  }
  const deps = {};
  const missing = {};
  const container = await createPluginContainer(config2);
  const plugin = esbuildScanPlugin(config2, container, deps, missing, entries);
  const { plugins: plugins2 = [], ...esbuildOptions } = (_c = (_b = config2.optimizeDeps) == null ? void 0 : _b.esbuildOptions) != null ? _c : {};
  await Promise.all(entries.map((entry2) => (0, import_esbuild.build)({
    absWorkingDir: process.cwd(),
    write: false,
    entryPoints: [entry2],
    bundle: true,
    format: "esm",
    logLevel: "error",
    plugins: [...plugins2, plugin],
    ...esbuildOptions
  })));
  debug$8(`Scan completed in ${(import_node_perf_hooks.performance.now() - start).toFixed(2)}ms:`, deps);
  return {
    deps: orderedDependencies(deps),
    missing
  };
}
function orderedDependencies(deps) {
  const depsList = Object.entries(deps);
  depsList.sort((a, b) => a[0].localeCompare(b[0]));
  return Object.fromEntries(depsList);
}
function globEntries(pattern2, config2) {
  return out(pattern2, {
    cwd: config2.root,
    ignore: [
      "**/node_modules/**",
      `**/${config2.build.outDir}/**`,
      ...config2.optimizeDeps.entries ? [] : [`**/__tests__/**`, `**/coverage/**`]
    ],
    absolute: true,
    suppressErrors: true
  });
}
var scriptModuleRE = /(<script\b[^>]*type\s*=\s*(?:"module"|'module')[^>]*>)(.*?)<\/script>/gims;
var scriptRE = /(<script\b(?:\s[^>]*>|>))(.*?)<\/script>/gims;
var commentRE$1 = /<!--.*?-->/gs;
var srcRE = /\bsrc\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/im;
var typeRE = /\btype\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/im;
var langRE = /\blang\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/im;
var contextRE = /\bcontext\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/im;
function esbuildScanPlugin(config2, container, depImports, missing, entries) {
  var _a, _b;
  const seen2 = /* @__PURE__ */ new Map();
  const resolve3 = async (id, importer, options3) => {
    const key2 = id + (importer && import_node_path2.default.dirname(importer));
    if (seen2.has(key2)) {
      return seen2.get(key2);
    }
    const resolved = await container.resolveId(id, importer && normalizePath$3(importer), {
      ...options3,
      scan: true
    });
    const res = resolved == null ? void 0 : resolved.id;
    seen2.set(key2, res);
    return res;
  };
  const include = (_a = config2.optimizeDeps) == null ? void 0 : _a.include;
  const exclude = [
    ...((_b = config2.optimizeDeps) == null ? void 0 : _b.exclude) || [],
    "@vite/client",
    "@vite/env"
  ];
  const externalUnlessEntry = ({ path: path4 }) => ({
    path: path4,
    external: !entries.includes(path4)
  });
  const doTransformGlobImport = async (contents, id, loader) => {
    let transpiledContents;
    if (loader !== "js") {
      transpiledContents = (await (0, import_esbuild.transform)(contents, { loader })).code;
    } else {
      transpiledContents = contents;
    }
    const result = await transformGlobImport(transpiledContents, id, config2.root, resolve3);
    return (result == null ? void 0 : result.s.toString()) || transpiledContents;
  };
  return {
    name: "vite:dep-scan",
    setup(build2) {
      const scripts = {};
      build2.onResolve({ filter: externalRE }, ({ path: path4 }) => ({
        path: path4,
        external: true
      }));
      build2.onResolve({ filter: dataUrlRE }, ({ path: path4 }) => ({
        path: path4,
        external: true
      }));
      build2.onResolve({ filter: virtualModuleRE }, ({ path: path4 }) => {
        return {
          path: path4.replace(virtualModulePrefix, ""),
          namespace: "script"
        };
      });
      build2.onLoad({ filter: /.*/, namespace: "script" }, ({ path: path4 }) => {
        return scripts[path4];
      });
      build2.onResolve({ filter: htmlTypesRE }, async ({ path: path4, importer }) => {
        const resolved = await resolve3(path4, importer);
        if (!resolved)
          return;
        if (resolved.includes("node_modules") && isOptimizable(resolved, config2.optimizeDeps))
          return;
        return {
          path: resolved,
          namespace: "html"
        };
      });
      build2.onLoad({ filter: htmlTypesRE, namespace: "html" }, async ({ path: path4 }) => {
        let raw = import_node_fs.default.readFileSync(path4, "utf-8");
        raw = raw.replace(commentRE$1, "<!---->");
        const isHtml = path4.endsWith(".html");
        const regex = isHtml ? scriptModuleRE : scriptRE;
        regex.lastIndex = 0;
        let js = "";
        let scriptId = 0;
        let match;
        while (match = regex.exec(raw)) {
          const [, openTag, content] = match;
          const typeMatch = openTag.match(typeRE);
          const type = typeMatch && (typeMatch[1] || typeMatch[2] || typeMatch[3]);
          const langMatch = openTag.match(langRE);
          const lang = langMatch && (langMatch[1] || langMatch[2] || langMatch[3]);
          if (type && !(type.includes("javascript") || type.includes("ecmascript") || type === "module")) {
            continue;
          }
          let loader = "js";
          if (lang === "ts" || lang === "tsx" || lang === "jsx") {
            loader = lang;
          } else if (path4.endsWith(".astro")) {
            loader = "ts";
          }
          const srcMatch = openTag.match(srcRE);
          if (srcMatch) {
            const src2 = srcMatch[1] || srcMatch[2] || srcMatch[3];
            js += `import ${JSON.stringify(src2)}
`;
          } else if (content.trim()) {
            const contents = content + (loader.startsWith("ts") ? extractImportPaths(content) : "");
            const key2 = `${path4}?id=${scriptId++}`;
            if (contents.includes("import.meta.glob")) {
              scripts[key2] = {
                loader: "js",
                contents: await doTransformGlobImport(contents, path4, loader),
                pluginData: {
                  htmlType: { loader }
                }
              };
            } else {
              scripts[key2] = {
                loader,
                contents,
                pluginData: {
                  htmlType: { loader }
                }
              };
            }
            const virtualModulePath = JSON.stringify(virtualModulePrefix + key2);
            const contextMatch = openTag.match(contextRE);
            const context = contextMatch && (contextMatch[1] || contextMatch[2] || contextMatch[3]);
            if (path4.endsWith(".svelte") && context !== "module") {
              js += `import ${virtualModulePath}
`;
            } else {
              js += `export * from ${virtualModulePath}
`;
            }
          }
        }
        if (!path4.endsWith(".vue") || !js.includes("export default")) {
          js += "\nexport default {}";
        }
        return {
          loader: "js",
          contents: js
        };
      });
      build2.onResolve({
        filter: /^[\w@][^:]/
      }, async ({ path: id, importer, pluginData }) => {
        var _a2;
        if (moduleListContains(exclude, id)) {
          return externalUnlessEntry({ path: id });
        }
        if (depImports[id]) {
          return externalUnlessEntry({ path: id });
        }
        const resolved = await resolve3(id, importer, {
          custom: {
            depScan: { loader: (_a2 = pluginData == null ? void 0 : pluginData.htmlType) == null ? void 0 : _a2.loader }
          }
        });
        if (resolved) {
          if (shouldExternalizeDep(resolved, id)) {
            return externalUnlessEntry({ path: id });
          }
          if (resolved.includes("node_modules") || (include == null ? void 0 : include.includes(id))) {
            if (isOptimizable(resolved, config2.optimizeDeps)) {
              depImports[id] = resolved;
            }
            return externalUnlessEntry({ path: id });
          } else if (isScannable(resolved)) {
            const namespace = htmlTypesRE.test(resolved) ? "html" : void 0;
            return {
              path: import_node_path2.default.resolve(resolved),
              namespace
            };
          } else {
            return externalUnlessEntry({ path: id });
          }
        } else {
          missing[id] = normalizePath$3(importer);
        }
      });
      build2.onResolve({
        filter: /\.(css|less|sass|scss|styl|stylus|pcss|postcss|sss|json|wasm)$/
      }, externalUnlessEntry);
      build2.onResolve({
        filter: new RegExp(`\\.(${KNOWN_ASSET_TYPES.join("|")})$`)
      }, externalUnlessEntry);
      build2.onResolve({ filter: SPECIAL_QUERY_RE }, ({ path: path4 }) => ({
        path: path4,
        external: true
      }));
      build2.onResolve({
        filter: /.*/
      }, async ({ path: id, importer, pluginData }) => {
        var _a2;
        const resolved = await resolve3(id, importer, {
          custom: {
            depScan: { loader: (_a2 = pluginData == null ? void 0 : pluginData.htmlType) == null ? void 0 : _a2.loader }
          }
        });
        if (resolved) {
          if (shouldExternalizeDep(resolved, id) || !isScannable(resolved)) {
            return externalUnlessEntry({ path: id });
          }
          const namespace = htmlTypesRE.test(resolved) ? "html" : void 0;
          return {
            path: import_node_path2.default.resolve(cleanUrl(resolved)),
            namespace
          };
        } else {
          return externalUnlessEntry({ path: id });
        }
      });
      build2.onLoad({ filter: JS_TYPES_RE }, async ({ path: id }) => {
        var _a2, _b2, _c;
        let ext2 = import_node_path2.default.extname(id).slice(1);
        if (ext2 === "mjs")
          ext2 = "js";
        let contents = import_node_fs.default.readFileSync(id, "utf-8");
        if (ext2.endsWith("x") && config2.esbuild && config2.esbuild.jsxInject) {
          contents = config2.esbuild.jsxInject + `
` + contents;
        }
        const loader = ((_c = (_b2 = (_a2 = config2.optimizeDeps) == null ? void 0 : _a2.esbuildOptions) == null ? void 0 : _b2.loader) == null ? void 0 : _c[`.${ext2}`]) || ext2;
        if (contents.includes("import.meta.glob")) {
          return {
            loader: "js",
            contents: await doTransformGlobImport(contents, id, loader)
          };
        }
        return {
          loader,
          contents
        };
      });
    }
  };
}
function extractImportPaths(code) {
  code = code.replace(multilineCommentsRE$1, "/* */").replace(singlelineCommentsRE$1, "");
  let js = "";
  let m;
  importsRE.lastIndex = 0;
  while ((m = importsRE.exec(code)) != null) {
    js += `
import ${m[1]}`;
  }
  return js;
}
function shouldExternalizeDep(resolvedId, rawId) {
  if (!import_node_path2.default.isAbsolute(resolvedId)) {
    return true;
  }
  if (resolvedId === rawId || resolvedId.includes("\0")) {
    return true;
  }
  return false;
}
function isScannable(id) {
  return JS_TYPES_RE.test(id) || htmlTypesRE.test(id);
}
var isDebugEnabled$1 = _debug("vite:deps").enabled;
var debounceMs = 100;
var depsOptimizerMap = /* @__PURE__ */ new WeakMap();
var devSsrDepsOptimizerMap = /* @__PURE__ */ new WeakMap();
function getDepsOptimizer(config2, ssr) {
  const isDevSsr = ssr && config2.command !== "build";
  return (isDevSsr ? devSsrDepsOptimizerMap : depsOptimizerMap).get(config2.mainConfig || config2);
}
async function initDepsOptimizer(config2, server2) {
  const ssr = config2.command === "build" && !!config2.build.ssr;
  if (!getDepsOptimizer(config2, ssr)) {
    await createDepsOptimizer(config2, server2);
  }
}
var creatingDevSsrOptimizer;
async function initDevSsrDepsOptimizer(config2, server2) {
  if (getDepsOptimizer(config2, true)) {
    return;
  }
  if (creatingDevSsrOptimizer) {
    return creatingDevSsrOptimizer;
  }
  creatingDevSsrOptimizer = async function() {
    const ssr = false;
    if (!getDepsOptimizer(config2, ssr)) {
      await initDepsOptimizer(config2, server2);
    }
    await getDepsOptimizer(config2, ssr).scanProcessing;
    await createDevSsrDepsOptimizer(config2);
    creatingDevSsrOptimizer = void 0;
  }();
  return await creatingDevSsrOptimizer;
}
async function createDepsOptimizer(config2, server2) {
  const { logger } = config2;
  const isBuild = config2.command === "build";
  const ssr = isBuild && !!config2.build.ssr;
  const sessionTimestamp = Date.now().toString();
  const cachedMetadata = loadCachedDepOptimizationMetadata(config2, ssr);
  let handle2;
  let closed = false;
  let metadata = cachedMetadata || initDepsOptimizerMetadata(config2, ssr, sessionTimestamp);
  const depsOptimizer = {
    metadata,
    registerMissingImport,
    run: () => debouncedProcessing(0),
    isOptimizedDepFile: (id) => isOptimizedDepFile(id, config2),
    isOptimizedDepUrl: createIsOptimizedDepUrl(config2),
    getOptimizedDepId: (depInfo) => isBuild ? depInfo.file : `${depInfo.file}?v=${depInfo.browserHash}`,
    registerWorkersSource,
    delayDepsOptimizerUntil,
    resetRegisteredIds,
    ensureFirstRun,
    close: close2,
    options: getDepOptimizationConfig(config2, ssr)
  };
  depsOptimizerMap.set(config2, depsOptimizer);
  let newDepsDiscovered = false;
  let newDepsToLog = [];
  let newDepsToLogHandle;
  const logNewlyDiscoveredDeps = () => {
    if (newDepsToLog.length) {
      config2.logger.info(picocolors.exports.green(`\u2728 new dependencies optimized: ${depsLogString(newDepsToLog)}`), {
        timestamp: true
      });
      newDepsToLog = [];
    }
  };
  let depOptimizationProcessing = newDepOptimizationProcessing();
  let depOptimizationProcessingQueue = [];
  const resolveEnqueuedProcessingPromises = () => {
    for (const processing of depOptimizationProcessingQueue) {
      processing.resolve();
    }
    depOptimizationProcessingQueue = [];
  };
  let enqueuedRerun;
  let currentlyProcessing = false;
  let firstRunCalled = !!cachedMetadata;
  let postScanOptimizationResult;
  let optimizingNewDeps;
  async function close2() {
    closed = true;
    await postScanOptimizationResult;
    await optimizingNewDeps;
  }
  if (!cachedMetadata) {
    currentlyProcessing = true;
    const deps = {};
    await addManuallyIncludedOptimizeDeps(deps, config2, ssr);
    const discovered = await toDiscoveredDependencies(config2, deps, ssr, sessionTimestamp);
    for (const depInfo of Object.values(discovered)) {
      addOptimizedDepInfo(metadata, "discovered", {
        ...depInfo,
        processing: depOptimizationProcessing.promise
      });
      newDepsDiscovered = true;
    }
    if (!isBuild) {
      const scanPhaseProcessing = newDepOptimizationProcessing();
      depsOptimizer.scanProcessing = scanPhaseProcessing.promise;
      setTimeout(async () => {
        try {
          debuggerViteDeps(picocolors.exports.green(`scanning for dependencies...`));
          const deps2 = await discoverProjectDependencies(config2);
          debuggerViteDeps(picocolors.exports.green(Object.keys(deps2).length > 0 ? `dependencies found by scanner: ${depsLogString(Object.keys(deps2))}` : `no dependencies found by scanner`));
          for (const id of Object.keys(deps2)) {
            if (!metadata.discovered[id]) {
              addMissingDep(id, deps2[id]);
            }
          }
          if (!isBuild) {
            const knownDeps = prepareKnownDeps();
            postScanOptimizationResult = runOptimizeDeps(config2, knownDeps);
          }
        } catch (e) {
          logger.error(e.message);
        } finally {
          scanPhaseProcessing.resolve();
          depsOptimizer.scanProcessing = void 0;
        }
      }, 0);
    }
  }
  function startNextDiscoveredBatch() {
    newDepsDiscovered = false;
    depOptimizationProcessingQueue.push(depOptimizationProcessing);
    depOptimizationProcessing = newDepOptimizationProcessing();
  }
  async function optimizeNewDeps() {
    const knownDeps = prepareKnownDeps();
    startNextDiscoveredBatch();
    return await runOptimizeDeps(config2, knownDeps);
  }
  function prepareKnownDeps() {
    const knownDeps = {};
    for (const dep of Object.keys(metadata.optimized)) {
      knownDeps[dep] = { ...metadata.optimized[dep] };
    }
    for (const dep of Object.keys(metadata.discovered)) {
      const { processing, ...info } = metadata.discovered[dep];
      knownDeps[dep] = info;
    }
    return knownDeps;
  }
  async function runOptimizer(preRunResult) {
    const isRerun = firstRunCalled;
    firstRunCalled = true;
    enqueuedRerun = void 0;
    if (handle2)
      clearTimeout(handle2);
    if (closed || Object.keys(metadata.discovered).length === 0) {
      currentlyProcessing = false;
      return;
    }
    currentlyProcessing = true;
    try {
      const processingResult = preRunResult != null ? preRunResult : await (optimizingNewDeps = optimizeNewDeps());
      optimizingNewDeps = void 0;
      if (closed) {
        currentlyProcessing = false;
        processingResult.cancel();
        resolveEnqueuedProcessingPromises();
        return;
      }
      const newData = processingResult.metadata;
      const needsInteropMismatch = findInteropMismatches(metadata.discovered, newData.optimized);
      const needsReload = needsInteropMismatch.length > 0 || metadata.hash !== newData.hash || Object.keys(metadata.optimized).some((dep) => {
        return metadata.optimized[dep].fileHash !== newData.optimized[dep].fileHash;
      });
      const commitProcessing = async () => {
        await processingResult.commit();
        for (const id in metadata.discovered) {
          if (!newData.optimized[id]) {
            addOptimizedDepInfo(newData, "discovered", metadata.discovered[id]);
          }
        }
        if (!needsReload) {
          newData.browserHash = metadata.browserHash;
          for (const dep in newData.chunks) {
            newData.chunks[dep].browserHash = metadata.browserHash;
          }
          for (const dep in newData.optimized) {
            newData.optimized[dep].browserHash = (metadata.optimized[dep] || metadata.discovered[dep]).browserHash;
          }
        }
        for (const o in newData.optimized) {
          const discovered = metadata.discovered[o];
          if (discovered) {
            const optimized = newData.optimized[o];
            discovered.browserHash = optimized.browserHash;
            discovered.fileHash = optimized.fileHash;
            discovered.needsInterop = optimized.needsInterop;
            discovered.processing = void 0;
          }
        }
        if (isRerun) {
          newDepsToLog.push(...Object.keys(newData.optimized).filter((dep) => !metadata.optimized[dep]));
        }
        metadata = depsOptimizer.metadata = newData;
        resolveEnqueuedProcessingPromises();
      };
      if (!needsReload) {
        await commitProcessing();
        if (!isDebugEnabled$1) {
          if (newDepsToLogHandle)
            clearTimeout(newDepsToLogHandle);
          newDepsToLogHandle = setTimeout(() => {
            newDepsToLogHandle = void 0;
            logNewlyDiscoveredDeps();
          }, 2 * debounceMs);
        } else {
          debuggerViteDeps(picocolors.exports.green(`\u2728 ${!isRerun ? `dependencies optimized` : `optimized dependencies unchanged`}`));
        }
      } else {
        if (newDepsDiscovered) {
          processingResult.cancel();
          debuggerViteDeps(picocolors.exports.green(`\u2728 delaying reload as new dependencies have been found...`));
        } else {
          await commitProcessing();
          if (!isDebugEnabled$1) {
            if (newDepsToLogHandle)
              clearTimeout(newDepsToLogHandle);
            newDepsToLogHandle = void 0;
            logNewlyDiscoveredDeps();
          }
          logger.info(picocolors.exports.green(`\u2728 optimized dependencies changed. reloading`), {
            timestamp: true
          });
          if (needsInteropMismatch.length > 0) {
            config2.logger.warn(`Mixed ESM and CJS detected in ${picocolors.exports.yellow(needsInteropMismatch.join(", "))}, add ${needsInteropMismatch.length === 1 ? "it" : "them"} to optimizeDeps.needsInterop to speed up cold start`, {
              timestamp: true
            });
          }
          fullReload();
        }
      }
    } catch (e) {
      logger.error(picocolors.exports.red(`error while updating dependencies:
${e.stack}`), { timestamp: true, error: e });
      resolveEnqueuedProcessingPromises();
      metadata.discovered = {};
    }
    currentlyProcessing = false;
    enqueuedRerun == null ? void 0 : enqueuedRerun();
  }
  function fullReload() {
    if (server2) {
      server2.moduleGraph.invalidateAll();
      server2.ws.send({
        type: "full-reload",
        path: "*"
      });
    }
  }
  async function rerun() {
    const deps = Object.keys(metadata.discovered);
    const depsString = depsLogString(deps);
    debuggerViteDeps(picocolors.exports.green(`new dependencies found: ${depsString}`));
    runOptimizer();
  }
  function getDiscoveredBrowserHash(hash, deps, missing) {
    return getHash(hash + JSON.stringify(deps) + JSON.stringify(missing) + sessionTimestamp);
  }
  function registerMissingImport(id, resolved) {
    const optimized = metadata.optimized[id];
    if (optimized) {
      return optimized;
    }
    const chunk = metadata.chunks[id];
    if (chunk) {
      return chunk;
    }
    let missing = metadata.discovered[id];
    if (missing) {
      return missing;
    }
    missing = addMissingDep(id, resolved);
    if (firstRunCalled) {
      debouncedProcessing();
    }
    return missing;
  }
  function addMissingDep(id, resolved) {
    newDepsDiscovered = true;
    return addOptimizedDepInfo(metadata, "discovered", {
      id,
      file: getOptimizedDepPath(id, config2, ssr),
      src: resolved,
      browserHash: getDiscoveredBrowserHash(metadata.hash, depsFromOptimizedDepInfo(metadata.optimized), depsFromOptimizedDepInfo(metadata.discovered)),
      processing: depOptimizationProcessing.promise,
      exportsData: extractExportsData(resolved, config2, ssr)
    });
  }
  function debouncedProcessing(timeout2 = debounceMs) {
    if (!newDepsDiscovered) {
      return;
    }
    enqueuedRerun = void 0;
    if (handle2)
      clearTimeout(handle2);
    if (newDepsToLogHandle)
      clearTimeout(newDepsToLogHandle);
    newDepsToLogHandle = void 0;
    handle2 = setTimeout(() => {
      handle2 = void 0;
      enqueuedRerun = rerun;
      if (!currentlyProcessing) {
        enqueuedRerun();
      }
    }, timeout2);
  }
  async function onCrawlEnd() {
    debuggerViteDeps(picocolors.exports.green(`\u2728 static imports crawl ended`));
    if (firstRunCalled) {
      return;
    }
    currentlyProcessing = false;
    const crawlDeps = Object.keys(metadata.discovered);
    await depsOptimizer.scanProcessing;
    if (!isBuild && postScanOptimizationResult) {
      const result = await postScanOptimizationResult;
      postScanOptimizationResult = void 0;
      const scanDeps = Object.keys(result.metadata.optimized);
      if (scanDeps.length === 0 && crawlDeps.length === 0) {
        debuggerViteDeps(picocolors.exports.green(`\u2728 no dependencies found by the scanner or crawling static imports`));
        result.cancel();
        firstRunCalled = true;
        return;
      }
      const needsInteropMismatch = findInteropMismatches(metadata.discovered, result.metadata.optimized);
      const scannerMissedDeps = crawlDeps.some((dep) => !scanDeps.includes(dep));
      const outdatedResult = needsInteropMismatch.length > 0 || scannerMissedDeps;
      if (outdatedResult) {
        result.cancel();
        for (const dep of scanDeps) {
          if (!crawlDeps.includes(dep)) {
            addMissingDep(dep, result.metadata.optimized[dep].src);
          }
        }
        if (scannerMissedDeps) {
          debuggerViteDeps(picocolors.exports.yellow(`\u2728 new dependencies were found while crawling that weren't detected by the scanner`));
        }
        debuggerViteDeps(picocolors.exports.green(`\u2728 re-running optimizer`));
        debouncedProcessing(0);
      } else {
        debuggerViteDeps(picocolors.exports.green(`\u2728 using post-scan optimizer result, the scanner found every used dependency`));
        startNextDiscoveredBatch();
        runOptimizer(result);
      }
    } else {
      if (crawlDeps.length === 0) {
        debuggerViteDeps(picocolors.exports.green(`\u2728 no dependencies found while crawling the static imports`));
        firstRunCalled = true;
      } else {
        debouncedProcessing(0);
      }
    }
  }
  const runOptimizerIfIdleAfterMs = 100;
  let registeredIds = [];
  let seenIds = /* @__PURE__ */ new Set();
  let workersSources = /* @__PURE__ */ new Set();
  let waitingOn;
  let firstRunEnsured = false;
  function resetRegisteredIds() {
    registeredIds = [];
    seenIds = /* @__PURE__ */ new Set();
    workersSources = /* @__PURE__ */ new Set();
    waitingOn = void 0;
    firstRunEnsured = false;
  }
  function ensureFirstRun() {
    if (!firstRunEnsured && !firstRunCalled && registeredIds.length === 0) {
      setTimeout(() => {
        if (!closed && registeredIds.length === 0) {
          onCrawlEnd();
        }
      }, runOptimizerIfIdleAfterMs);
    }
    firstRunEnsured = true;
  }
  function registerWorkersSource(id) {
    workersSources.add(id);
    registeredIds = registeredIds.filter((registered) => registered.id !== id);
    if (waitingOn === id) {
      waitingOn = void 0;
      runOptimizerWhenIdle();
    }
  }
  function delayDepsOptimizerUntil(id, done) {
    if (!depsOptimizer.isOptimizedDepFile(id) && !seenIds.has(id)) {
      seenIds.add(id);
      registeredIds.push({ id, done });
      runOptimizerWhenIdle();
    }
  }
  function runOptimizerWhenIdle() {
    if (!waitingOn) {
      const next = registeredIds.pop();
      if (next) {
        waitingOn = next.id;
        const afterLoad = () => {
          waitingOn = void 0;
          if (!closed && !workersSources.has(next.id)) {
            if (registeredIds.length > 0) {
              runOptimizerWhenIdle();
            } else {
              onCrawlEnd();
            }
          }
        };
        next.done().then(() => {
          setTimeout(afterLoad, registeredIds.length > 0 ? 0 : runOptimizerIfIdleAfterMs);
        }).catch(afterLoad);
      }
    }
  }
}
async function createDevSsrDepsOptimizer(config2) {
  const metadata = await optimizeServerSsrDeps(config2);
  const depsOptimizer = {
    metadata,
    isOptimizedDepFile: (id) => isOptimizedDepFile(id, config2),
    isOptimizedDepUrl: createIsOptimizedDepUrl(config2),
    getOptimizedDepId: (depInfo) => `${depInfo.file}?v=${depInfo.browserHash}`,
    registerMissingImport: () => {
      throw new Error("Vite Internal Error: registerMissingImport is not supported in dev SSR");
    },
    run: () => {
    },
    registerWorkersSource: (id) => {
    },
    delayDepsOptimizerUntil: (id, done) => {
    },
    resetRegisteredIds: () => {
    },
    ensureFirstRun: () => {
    },
    close: async () => {
    },
    options: config2.ssr.optimizeDeps
  };
  devSsrDepsOptimizerMap.set(config2, depsOptimizer);
}
function findInteropMismatches(discovered, optimized) {
  const needsInteropMismatch = [];
  for (const dep in discovered) {
    const discoveredDepInfo = discovered[dep];
    const depInfo = optimized[dep];
    if (depInfo) {
      if (discoveredDepInfo.needsInterop !== void 0 && depInfo.needsInterop !== discoveredDepInfo.needsInterop) {
        needsInteropMismatch.push(dep);
        debuggerViteDeps(picocolors.exports.cyan(`\u2728 needsInterop mismatch detected for ${dep}`));
      }
    }
  }
  return needsInteropMismatch;
}
var debuggerViteDeps = createDebugger("vite:deps");
var debug$7 = debuggerViteDeps;
var isDebugEnabled = _debug("vite:deps").enabled;
var jsExtensionRE = /\.js$/i;
var jsMapExtensionRE = /\.js\.map$/i;
async function optimizeDeps(config2, force = config2.optimizeDeps.force, asCommand = false) {
  const log2 = asCommand ? config2.logger.info : debug$7;
  const ssr = config2.command === "build" && !!config2.build.ssr;
  const cachedMetadata = loadCachedDepOptimizationMetadata(config2, ssr, force, asCommand);
  if (cachedMetadata) {
    return cachedMetadata;
  }
  const deps = await discoverProjectDependencies(config2);
  const depsString = depsLogString(Object.keys(deps));
  log2(picocolors.exports.green(`Optimizing dependencies:
  ${depsString}`));
  await addManuallyIncludedOptimizeDeps(deps, config2, ssr);
  const depsInfo = toDiscoveredDependencies(config2, deps, ssr);
  const result = await runOptimizeDeps(config2, depsInfo);
  await result.commit();
  return result.metadata;
}
async function optimizeServerSsrDeps(config2) {
  var _a;
  const ssr = true;
  const cachedMetadata = loadCachedDepOptimizationMetadata(config2, ssr, config2.optimizeDeps.force, false);
  if (cachedMetadata) {
    return cachedMetadata;
  }
  let alsoInclude;
  let noExternalFilter;
  const { exclude } = getDepOptimizationConfig(config2, ssr);
  const noExternal = (_a = config2.ssr) == null ? void 0 : _a.noExternal;
  if (noExternal) {
    alsoInclude = arraify(noExternal).filter((ne) => typeof ne === "string");
    noExternalFilter = noExternal === true ? (dep) => true : createFilter$1(void 0, exclude, {
      resolve: false
    });
  }
  const deps = {};
  await addManuallyIncludedOptimizeDeps(deps, config2, ssr, alsoInclude, noExternalFilter);
  const depsInfo = toDiscoveredDependencies(config2, deps, true);
  const result = await runOptimizeDeps(config2, depsInfo, true);
  await result.commit();
  return result.metadata;
}
function initDepsOptimizerMetadata(config2, ssr, timestamp2) {
  const hash = getDepHash(config2, ssr);
  return {
    hash,
    browserHash: getOptimizedBrowserHash(hash, {}, timestamp2),
    optimized: {},
    chunks: {},
    discovered: {},
    depInfoList: []
  };
}
function addOptimizedDepInfo(metadata, type, depInfo) {
  metadata[type][depInfo.id] = depInfo;
  metadata.depInfoList.push(depInfo);
  return depInfo;
}
function loadCachedDepOptimizationMetadata(config2, ssr, force = config2.optimizeDeps.force, asCommand = false) {
  const log2 = asCommand ? config2.logger.info : debug$7;
  if (import_node_fs.default.existsSync(import_node_path2.default.join(config2.cacheDir, "_metadata.json"))) {
    emptyDir(config2.cacheDir);
  }
  const depsCacheDir = getDepsCacheDir(config2, ssr);
  if (!force) {
    let cachedMetadata;
    try {
      const cachedMetadataPath = import_node_path2.default.join(depsCacheDir, "_metadata.json");
      cachedMetadata = parseDepsOptimizerMetadata(import_node_fs.default.readFileSync(cachedMetadataPath, "utf-8"), depsCacheDir);
    } catch (e) {
    }
    if (cachedMetadata && cachedMetadata.hash === getDepHash(config2, ssr)) {
      log2("Hash is consistent. Skipping. Use --force to override.");
      return cachedMetadata;
    }
  } else {
    config2.logger.info("Forced re-optimization of dependencies");
  }
  import_node_fs.default.rmSync(depsCacheDir, { recursive: true, force: true });
}
async function discoverProjectDependencies(config2) {
  const { deps, missing } = await scanImports(config2);
  const missingIds = Object.keys(missing);
  if (missingIds.length) {
    throw new Error(`The following dependencies are imported but could not be resolved:

  ${missingIds.map((id) => `${picocolors.exports.cyan(id)} ${picocolors.exports.white(picocolors.exports.dim(`(imported by ${missing[id]})`))}`).join(`
  `)}

Are they installed?`);
  }
  return deps;
}
function toDiscoveredDependencies(config2, deps, ssr, timestamp2) {
  const browserHash = getOptimizedBrowserHash(getDepHash(config2, ssr), deps, timestamp2);
  const discovered = {};
  for (const id in deps) {
    const src2 = deps[id];
    discovered[id] = {
      id,
      file: getOptimizedDepPath(id, config2, ssr),
      src: src2,
      browserHash,
      exportsData: extractExportsData(src2, config2, ssr)
    };
  }
  return discovered;
}
function depsLogString(qualifiedIds) {
  if (isDebugEnabled) {
    return picocolors.exports.yellow(qualifiedIds.join(`, `));
  } else {
    const total = qualifiedIds.length;
    const maxListed = 5;
    const listed = Math.min(total, maxListed);
    const extra = Math.max(0, total - maxListed);
    return picocolors.exports.yellow(qualifiedIds.slice(0, listed).join(`, `) + (extra > 0 ? `, ...and ${extra} more` : ``));
  }
}
async function runOptimizeDeps(resolvedConfig, depsInfo, ssr = resolvedConfig.command === "build" && !!resolvedConfig.build.ssr) {
  var _a, _b, _c, _d, _e, _f;
  const isBuild = resolvedConfig.command === "build";
  const config2 = {
    ...resolvedConfig,
    command: "build"
  };
  const depsCacheDir = getDepsCacheDir(resolvedConfig, ssr);
  const processingCacheDir = getProcessingDepsCacheDir(resolvedConfig, ssr);
  if (import_node_fs.default.existsSync(processingCacheDir)) {
    emptyDir(processingCacheDir);
  } else {
    import_node_fs.default.mkdirSync(processingCacheDir, { recursive: true });
  }
  writeFile(import_node_path2.default.resolve(processingCacheDir, "package.json"), JSON.stringify({ type: "module" }));
  const metadata = initDepsOptimizerMetadata(config2, ssr);
  metadata.browserHash = getOptimizedBrowserHash(metadata.hash, depsFromOptimizedDepInfo(depsInfo));
  const qualifiedIds = Object.keys(depsInfo);
  const processingResult = {
    metadata,
    async commit() {
      await removeDir(depsCacheDir);
      await renameDir(processingCacheDir, depsCacheDir);
    },
    cancel() {
      import_node_fs.default.rmSync(processingCacheDir, { recursive: true, force: true });
    }
  };
  if (!qualifiedIds.length) {
    return processingResult;
  }
  const flatIdDeps = {};
  const idToExports = {};
  const flatIdToExports = {};
  const optimizeDeps2 = getDepOptimizationConfig(config2, ssr);
  const { plugins: pluginsFromConfig = [], ...esbuildOptions } = (_a = optimizeDeps2 == null ? void 0 : optimizeDeps2.esbuildOptions) != null ? _a : {};
  for (const id in depsInfo) {
    const src2 = depsInfo[id].src;
    const exportsData = await ((_b = depsInfo[id].exportsData) != null ? _b : extractExportsData(src2, config2, ssr));
    if (exportsData.jsxLoader) {
      esbuildOptions.loader = {
        ".js": "jsx",
        ...esbuildOptions.loader
      };
    }
    const flatId = flattenId(id);
    flatIdDeps[flatId] = src2;
    idToExports[id] = exportsData;
    flatIdToExports[flatId] = exportsData;
  }
  const define = {
    "process.env.NODE_ENV": isBuild ? "__vite_process_env_NODE_ENV" : JSON.stringify("development")
  };
  const platform2 = ssr && ((_c = config2.ssr) == null ? void 0 : _c.target) !== "webworker" ? "node" : "browser";
  const external = [...(_d = optimizeDeps2 == null ? void 0 : optimizeDeps2.exclude) != null ? _d : []];
  if (isBuild) {
    let rollupOptionsExternal = (_f = (_e = config2 == null ? void 0 : config2.build) == null ? void 0 : _e.rollupOptions) == null ? void 0 : _f.external;
    if (rollupOptionsExternal) {
      if (typeof rollupOptionsExternal === "string") {
        rollupOptionsExternal = [rollupOptionsExternal];
      }
      if (!Array.isArray(rollupOptionsExternal) || rollupOptionsExternal.some((ext2) => typeof ext2 !== "string")) {
        throw new Error(`[vite] 'build.rollupOptions.external' can only be an array of strings or a string when using esbuild optimization at build time.`);
      }
      external.push(...rollupOptionsExternal);
    }
  }
  const plugins2 = [...pluginsFromConfig];
  if (external.length) {
    plugins2.push(esbuildCjsExternalPlugin(external));
  }
  plugins2.push(esbuildDepPlugin(flatIdDeps, flatIdToExports, external, config2, ssr));
  const start = import_node_perf_hooks.performance.now();
  const result = await (0, import_esbuild.build)({
    absWorkingDir: process.cwd(),
    entryPoints: Object.keys(flatIdDeps),
    bundle: true,
    platform: platform2,
    define,
    format: "esm",
    banner: platform2 === "node" ? {
      js: `import { createRequire } from 'module';const require = createRequire(import.meta.url);`
    } : void 0,
    target: isBuild ? config2.build.target || void 0 : ESBUILD_MODULES_TARGET,
    external,
    logLevel: "error",
    splitting: true,
    sourcemap: true,
    outdir: processingCacheDir,
    ignoreAnnotations: !isBuild,
    metafile: true,
    plugins: plugins2,
    ...esbuildOptions,
    supported: {
      "dynamic-import": true,
      "import-meta": true,
      ...esbuildOptions.supported
    }
  });
  const meta = result.metafile;
  const processingCacheDirOutputPath = import_node_path2.default.relative(process.cwd(), processingCacheDir);
  for (const id in depsInfo) {
    const output = esbuildOutputFromId(meta.outputs, id, processingCacheDir);
    const { exportsData, ...info } = depsInfo[id];
    addOptimizedDepInfo(metadata, "optimized", {
      ...info,
      fileHash: getHash(metadata.hash + depsInfo[id].file + JSON.stringify(output.imports)),
      browserHash: metadata.browserHash,
      needsInterop: needsInterop(config2, ssr, id, idToExports[id], output)
    });
  }
  for (const o of Object.keys(meta.outputs)) {
    if (!o.match(jsMapExtensionRE)) {
      const id = import_node_path2.default.relative(processingCacheDirOutputPath, o).replace(jsExtensionRE, "");
      const file = getOptimizedDepPath(id, resolvedConfig, ssr);
      if (!findOptimizedDepInfoInRecord(metadata.optimized, (depInfo) => depInfo.file === file)) {
        addOptimizedDepInfo(metadata, "chunks", {
          id,
          file,
          needsInterop: false,
          browserHash: metadata.browserHash
        });
      }
    }
  }
  const dataPath = import_node_path2.default.join(processingCacheDir, "_metadata.json");
  writeFile(dataPath, stringifyDepsOptimizerMetadata(metadata, depsCacheDir));
  debug$7(`deps bundled in ${(import_node_perf_hooks.performance.now() - start).toFixed(2)}ms`);
  return processingResult;
}
async function findKnownImports(config2, ssr) {
  const deps = (await scanImports(config2)).deps;
  await addManuallyIncludedOptimizeDeps(deps, config2, ssr);
  return Object.keys(deps);
}
async function addManuallyIncludedOptimizeDeps(deps, config2, ssr, extra = [], filter2) {
  var _a;
  const { logger } = config2;
  const optimizeDeps2 = getDepOptimizationConfig(config2, ssr);
  const optimizeDepsInclude = (_a = optimizeDeps2 == null ? void 0 : optimizeDeps2.include) != null ? _a : [];
  if (optimizeDepsInclude.length || extra.length) {
    const unableToOptimize = (id, msg) => {
      if (optimizeDepsInclude.includes(id)) {
        logger.warn(`${msg}: ${picocolors.exports.cyan(id)}, present in '${ssr ? "ssr." : ""}optimizeDeps.include'`);
      }
    };
    const resolve3 = config2.createResolver({
      asSrc: false,
      scan: true,
      ssrOptimizeCheck: ssr,
      ssrConfig: config2.ssr
    });
    for (const id of [...optimizeDepsInclude, ...extra]) {
      const normalizedId = normalizeId(id);
      if (!deps[normalizedId] && (filter2 == null ? void 0 : filter2(normalizedId)) !== false) {
        const entry2 = await resolve3(id, void 0, void 0, ssr);
        if (entry2) {
          if (isOptimizable(entry2, optimizeDeps2)) {
            if (!entry2.endsWith("?__vite_skip_optimization")) {
              deps[normalizedId] = entry2;
            }
          } else {
            unableToOptimize(entry2, "Cannot optimize dependency");
          }
        } else {
          unableToOptimize(id, "Failed to resolve dependency");
        }
      }
    }
  }
}
function newDepOptimizationProcessing() {
  let resolve3;
  const promise2 = new Promise((_resolve) => {
    resolve3 = _resolve;
  });
  return { promise: promise2, resolve: resolve3 };
}
function depsFromOptimizedDepInfo(depsInfo) {
  return Object.fromEntries(Object.entries(depsInfo).map((d) => [d[0], d[1].src]));
}
function getOptimizedDepPath(id, config2, ssr) {
  return normalizePath$3(import_node_path2.default.resolve(getDepsCacheDir(config2, ssr), flattenId(id) + ".js"));
}
function getDepsCacheSuffix(config2, ssr) {
  let suffix = "";
  if (config2.command === "build") {
    const { outDir } = config2.build;
    const buildId = outDir.length > 8 || outDir.includes("/") ? getHash(outDir) : outDir;
    suffix += `_build-${buildId}`;
  }
  if (ssr) {
    suffix += "_ssr";
  }
  return suffix;
}
function getDepsCacheDir(config2, ssr) {
  return getDepsCacheDirPrefix(config2) + getDepsCacheSuffix(config2, ssr);
}
function getProcessingDepsCacheDir(config2, ssr) {
  return getDepsCacheDirPrefix(config2) + getDepsCacheSuffix(config2, ssr) + "_temp";
}
function getDepsCacheDirPrefix(config2) {
  return normalizePath$3(import_node_path2.default.resolve(config2.cacheDir, "deps"));
}
function isOptimizedDepFile(id, config2) {
  return id.startsWith(getDepsCacheDirPrefix(config2));
}
function createIsOptimizedDepUrl(config2) {
  const { root: root2 } = config2;
  const depsCacheDir = getDepsCacheDirPrefix(config2);
  const depsCacheDirRelative = normalizePath$3(import_node_path2.default.relative(root2, depsCacheDir));
  const depsCacheDirPrefix = depsCacheDirRelative.startsWith("../") ? `/@fs/${normalizePath$3(depsCacheDir).replace(/^\//, "")}` : `/${depsCacheDirRelative}`;
  return function isOptimizedDepUrl(url2) {
    return url2.startsWith(depsCacheDirPrefix);
  };
}
function parseDepsOptimizerMetadata(jsonMetadata, depsCacheDir) {
  const { hash, browserHash, optimized, chunks } = JSON.parse(jsonMetadata, (key2, value2) => {
    if (key2 === "file" || key2 === "src") {
      return normalizePath$3(import_node_path2.default.resolve(depsCacheDir, value2));
    }
    return value2;
  });
  if (!chunks || Object.values(optimized).some((depInfo) => !depInfo.fileHash)) {
    return;
  }
  const metadata = {
    hash,
    browserHash,
    optimized: {},
    discovered: {},
    chunks: {},
    depInfoList: []
  };
  for (const id of Object.keys(optimized)) {
    addOptimizedDepInfo(metadata, "optimized", {
      ...optimized[id],
      id,
      browserHash
    });
  }
  for (const id of Object.keys(chunks)) {
    addOptimizedDepInfo(metadata, "chunks", {
      ...chunks[id],
      id,
      browserHash,
      needsInterop: false
    });
  }
  return metadata;
}
function stringifyDepsOptimizerMetadata(metadata, depsCacheDir) {
  const { hash, browserHash, optimized, chunks } = metadata;
  return JSON.stringify({
    hash,
    browserHash,
    optimized: Object.fromEntries(Object.values(optimized).map(({ id, src: src2, file, fileHash, needsInterop: needsInterop2 }) => [
      id,
      {
        src: src2,
        file,
        fileHash,
        needsInterop: needsInterop2
      }
    ])),
    chunks: Object.fromEntries(Object.values(chunks).map(({ id, file }) => [id, { file }]))
  }, (key2, value2) => {
    if (key2 === "file" || key2 === "src") {
      return normalizePath$3(import_node_path2.default.relative(depsCacheDir, value2));
    }
    return value2;
  }, 2);
}
function esbuildOutputFromId(outputs, id, cacheDirOutputPath) {
  const cwd = process.cwd();
  const flatId = flattenId(id) + ".js";
  const normalizedOutputPath = normalizePath$3(import_node_path2.default.relative(cwd, import_node_path2.default.join(cacheDirOutputPath, flatId)));
  const output = outputs[normalizedOutputPath];
  if (output) {
    return output;
  }
  for (const [key2, value2] of Object.entries(outputs)) {
    if (normalizePath$3(import_node_path2.default.relative(cwd, key2)) === normalizedOutputPath) {
      return value2;
    }
  }
}
async function extractExportsData(filePath, config2, ssr) {
  var _a, _b, _c;
  await init;
  const optimizeDeps2 = getDepOptimizationConfig(config2, ssr);
  const esbuildOptions = (_a = optimizeDeps2 == null ? void 0 : optimizeDeps2.esbuildOptions) != null ? _a : {};
  if ((_b = optimizeDeps2.extensions) == null ? void 0 : _b.some((ext2) => filePath.endsWith(ext2))) {
    const result = await (0, import_esbuild.build)({
      ...esbuildOptions,
      entryPoints: [filePath],
      write: false,
      format: "esm"
    });
    const [imports2, exports2, facade2] = parse$b(result.outputFiles[0].text);
    return {
      hasImports: imports2.length > 0,
      exports: exports2.map((e) => e.n),
      facade: facade2
    };
  }
  let parseResult;
  let usedJsxLoader = false;
  const entryContent = import_node_fs.default.readFileSync(filePath, "utf-8");
  try {
    parseResult = parse$b(entryContent);
  } catch {
    const loader = ((_c = esbuildOptions.loader) == null ? void 0 : _c[import_node_path2.default.extname(filePath)]) || "jsx";
    debug$7(`Unable to parse: ${filePath}.
 Trying again with a ${loader} transform.`);
    const transformed = await transformWithEsbuild(entryContent, filePath, {
      loader
    });
    esbuildOptions.loader = {
      ".js": "jsx",
      ...esbuildOptions.loader
    };
    parseResult = parse$b(transformed.code);
    usedJsxLoader = true;
  }
  const [imports, exports, facade] = parseResult;
  const exportsData = {
    hasImports: imports.length > 0,
    exports: exports.map((e) => e.n),
    facade,
    hasReExports: imports.some(({ ss, se }) => {
      const exp = entryContent.slice(ss, se);
      return /export\s+\*\s+from/.test(exp);
    }),
    jsxLoader: usedJsxLoader
  };
  return exportsData;
}
var KNOWN_INTEROP_IDS = /* @__PURE__ */ new Set(["moment"]);
function needsInterop(config2, ssr, id, exportsData, output) {
  var _a, _b;
  if (((_b = (_a = getDepOptimizationConfig(config2, ssr)) == null ? void 0 : _a.needsInterop) == null ? void 0 : _b.includes(id)) || KNOWN_INTEROP_IDS.has(id)) {
    return true;
  }
  const { hasImports, exports } = exportsData;
  if (!exports.length && !hasImports) {
    return true;
  }
  if (output) {
    const generatedExports = output.exports;
    if (!generatedExports || isSingleDefaultExport(generatedExports) && !isSingleDefaultExport(exports)) {
      return true;
    }
  }
  return false;
}
function isSingleDefaultExport(exports) {
  return exports.length === 1 && exports[0] === "default";
}
var lockfileFormats = [
  "package-lock.json",
  "yarn.lock",
  "pnpm-lock.yaml",
  "bun.lockb"
];
function getDepHash(config2, ssr) {
  var _a, _b;
  let content = lookupFile(config2.root, lockfileFormats) || "";
  const optimizeDeps2 = getDepOptimizationConfig(config2, ssr);
  content += JSON.stringify({
    mode: "development",
    root: config2.root,
    resolve: config2.resolve,
    buildTarget: config2.build.target,
    assetsInclude: config2.assetsInclude,
    plugins: config2.plugins.map((p) => p.name),
    optimizeDeps: {
      include: optimizeDeps2 == null ? void 0 : optimizeDeps2.include,
      exclude: optimizeDeps2 == null ? void 0 : optimizeDeps2.exclude,
      esbuildOptions: {
        ...optimizeDeps2 == null ? void 0 : optimizeDeps2.esbuildOptions,
        plugins: (_b = (_a = optimizeDeps2 == null ? void 0 : optimizeDeps2.esbuildOptions) == null ? void 0 : _a.plugins) == null ? void 0 : _b.map((p) => p.name)
      }
    }
  }, (_, value2) => {
    if (typeof value2 === "function" || value2 instanceof RegExp) {
      return value2.toString();
    }
    return value2;
  });
  return getHash(content);
}
function getOptimizedBrowserHash(hash, deps, timestamp2 = "") {
  return getHash(hash + JSON.stringify(deps) + timestamp2);
}
function optimizedDepInfoFromId(metadata, id) {
  return metadata.optimized[id] || metadata.discovered[id] || metadata.chunks[id];
}
function optimizedDepInfoFromFile(metadata, file) {
  return metadata.depInfoList.find((depInfo) => depInfo.file === file);
}
function findOptimizedDepInfoInRecord(dependenciesInfo, callbackFn) {
  for (const o of Object.keys(dependenciesInfo)) {
    const info = dependenciesInfo[o];
    if (callbackFn(info, o)) {
      return info;
    }
  }
}
async function optimizedDepNeedsInterop(metadata, file, config2, ssr) {
  var _a;
  const depInfo = optimizedDepInfoFromFile(metadata, file);
  if ((depInfo == null ? void 0 : depInfo.src) && depInfo.needsInterop === void 0) {
    (_a = depInfo.exportsData) != null ? _a : depInfo.exportsData = extractExportsData(depInfo.src, config2, ssr);
    depInfo.needsInterop = needsInterop(config2, ssr, depInfo.id, await depInfo.exportsData);
  }
  return depInfo == null ? void 0 : depInfo.needsInterop;
}
var index$1 = {
  __proto__: null,
  debuggerViteDeps,
  optimizeDeps,
  optimizeServerSsrDeps,
  initDepsOptimizerMetadata,
  addOptimizedDepInfo,
  loadCachedDepOptimizationMetadata,
  discoverProjectDependencies,
  toDiscoveredDependencies,
  depsLogString,
  runOptimizeDeps,
  findKnownImports,
  addManuallyIncludedOptimizeDeps,
  newDepOptimizationProcessing,
  depsFromOptimizedDepInfo,
  getOptimizedDepPath,
  getDepsCacheDir,
  getDepsCacheDirPrefix,
  isOptimizedDepFile,
  createIsOptimizedDepUrl,
  extractExportsData,
  getDepHash,
  optimizedDepInfoFromId,
  optimizedDepInfoFromFile,
  optimizedDepNeedsInterop,
  initDepsOptimizer,
  initDevSsrDepsOptimizer,
  getDepsOptimizer
};
var isModernFlag = `__VITE_IS_MODERN__`;
var preloadMethod = `__vitePreload`;
var preloadMarker = `__VITE_PRELOAD__`;
var preloadHelperId = "\0vite/preload-helper";
var preloadMarkerWithQuote = `"${preloadMarker}"`;
var dynamicImportPrefixRE = /import\s*\(/;
var optimizedDepChunkRE = /\/chunk-[A-Z0-9]{8}\.js/;
var optimizedDepDynamicRE = /-[A-Z0-9]{8}\.js/;
function toRelativePath(filename, importer) {
  const relPath = import_node_path2.default.relative(import_node_path2.default.dirname(importer), filename);
  return relPath.startsWith(".") ? relPath : `./${relPath}`;
}
function detectScriptRel() {
  const relList = document.createElement("link").relList;
  return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
}
function preload(baseModule, deps, importerUrl) {
  if (!__VITE_IS_MODERN__ || !deps || deps.length === 0) {
    return baseModule();
  }
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep, importerUrl);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i = links.length - 1; i >= 0; i--) {
        const link2 = links[i];
        if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule());
}
function buildImportAnalysisPlugin(config2) {
  const ssr = !!config2.build.ssr;
  const isWorker = config2.isWorker;
  const insertPreload = !(ssr || !!config2.build.lib || isWorker || config2.build.modulePreload === false);
  const resolveModulePreloadDependencies = config2.build.modulePreload && config2.build.modulePreload.resolveDependencies;
  const renderBuiltUrl = config2.experimental.renderBuiltUrl;
  const customModulePreloadPaths = !!(resolveModulePreloadDependencies || renderBuiltUrl);
  const isRelativeBase = config2.base === "./" || config2.base === "";
  const optimizeModulePreloadRelativePaths = isRelativeBase && !customModulePreloadPaths;
  const { modulePreload } = config2.build;
  const scriptRel2 = modulePreload && modulePreload.polyfill ? `'modulepreload'` : `(${detectScriptRel.toString()})()`;
  const assetsURL2 = customModulePreloadPaths ? `function(dep, importerUrl) { return dep.startsWith('.') ? new URL(dep, importerUrl).href : dep }` : optimizeModulePreloadRelativePaths ? `function(dep, importerUrl) { return new URL(dep, importerUrl).href }` : `function(dep) { return ${JSON.stringify(config2.base)}+dep }`;
  const preloadCode = `const scriptRel = ${scriptRel2};const assetsURL = ${assetsURL2};const seen = {};export const ${preloadMethod} = ${preload.toString()}`;
  return {
    name: "vite:build-import-analysis",
    resolveId(id) {
      if (id === preloadHelperId) {
        return id;
      }
    },
    load(id) {
      if (id === preloadHelperId) {
        return preloadCode;
      }
    },
    async transform(source2, importer) {
      if (importer.includes("node_modules") && !dynamicImportPrefixRE.test(source2)) {
        return;
      }
      await init;
      let imports = [];
      try {
        imports = parse$b(source2)[0];
      } catch (e) {
        this.error(e, e.idx);
      }
      if (!imports.length) {
        return null;
      }
      const { root: root2 } = config2;
      const depsOptimizer = getDepsOptimizer(config2, ssr);
      const normalizeUrl = async (url2, pos2) => {
        let importerFile = importer;
        const optimizeDeps2 = getDepOptimizationConfig(config2, ssr);
        if (moduleListContains(optimizeDeps2 == null ? void 0 : optimizeDeps2.exclude, url2)) {
          if (depsOptimizer) {
            await depsOptimizer.scanProcessing;
            for (const optimizedModule of depsOptimizer.metadata.depInfoList) {
              if (!optimizedModule.src)
                continue;
              if (optimizedModule.file === importer) {
                importerFile = optimizedModule.src;
              }
            }
          }
        }
        const resolved = await this.resolve(url2, importerFile);
        if (!resolved) {
          if (ssr) {
            return [url2, url2];
          }
          return this.error(`Failed to resolve import "${url2}" from "${import_node_path2.default.relative(process.cwd(), importerFile)}". Does the file exist?`, pos2);
        }
        if (resolved.id.startsWith(root2 + "/")) {
          url2 = resolved.id.slice(root2.length);
        } else {
          url2 = resolved.id;
        }
        if (isExternalUrl(url2)) {
          return [url2, url2];
        }
        return [url2, resolved.id];
      };
      let s;
      const str = () => s || (s = new MagicString(source2));
      let needPreloadHelper = false;
      for (let index2 = 0; index2 < imports.length; index2++) {
        const { s: start, e: end, ss: expStart, se: expEnd, n: specifier, d: dynamicIndex, a: assertIndex } = imports[index2];
        const isDynamicImport = dynamicIndex > -1;
        if (!isDynamicImport && assertIndex > -1) {
          str().remove(end + 1, expEnd);
        }
        if (isDynamicImport && insertPreload) {
          needPreloadHelper = true;
          str().prependLeft(expStart, `${preloadMethod}(() => `);
          str().appendRight(expEnd, `,${isModernFlag}?"${preloadMarker}":void 0${optimizeModulePreloadRelativePaths || customModulePreloadPaths ? ",import.meta.url" : ""})`);
        }
        if (depsOptimizer && specifier) {
          if (isExternalUrl(specifier) || isDataUrl(specifier)) {
            continue;
          }
          const [url2, resolvedId] = await normalizeUrl(specifier, start);
          if (url2 !== specifier) {
            if (depsOptimizer.isOptimizedDepFile(resolvedId) && !resolvedId.match(optimizedDepChunkRE)) {
              const file = cleanUrl(resolvedId);
              const needsInterop2 = await optimizedDepNeedsInterop(depsOptimizer.metadata, file, config2, ssr);
              let rewriteDone = false;
              if (needsInterop2 === void 0) {
                if (!file.match(optimizedDepDynamicRE)) {
                  config2.logger.error(picocolors.exports.red(`Vite Error, ${url2} optimized info should be defined`));
                }
              } else if (needsInterop2) {
                interopNamedImports(str(), imports[index2], url2, index2);
                rewriteDone = true;
              }
              if (!rewriteDone) {
                let rewrittenUrl = JSON.stringify(file);
                if (!isDynamicImport)
                  rewrittenUrl = rewrittenUrl.slice(1, -1);
                str().update(start, end, rewrittenUrl);
              }
            }
          }
        }
        if (specifier && isCSSRequest(specifier) && (source2.slice(expStart, start).includes("from") || isDynamicImport) && !specifier.match(/\?used(&|$)/) && !(bareImportRE.test(specifier) && !specifier.includes("/"))) {
          const url2 = specifier.replace(/\?|$/, (m) => `?used${m ? "&" : ""}`);
          str().update(start, end, isDynamicImport ? `'${url2}'` : url2);
        }
      }
      if (needPreloadHelper && insertPreload && !source2.includes(`const ${preloadMethod} =`)) {
        str().prepend(`import { ${preloadMethod} } from "${preloadHelperId}";`);
      }
      if (s) {
        return {
          code: s.toString(),
          map: config2.build.sourcemap ? s.generateMap({ hires: true }) : null
        };
      }
    },
    renderChunk(code, _, { format: format2 }) {
      if (code.indexOf(isModernFlag) > -1) {
        const re = new RegExp(isModernFlag, "g");
        const isModern = String(format2 === "es");
        if (config2.build.sourcemap) {
          const s = new MagicString(code);
          let match;
          while (match = re.exec(code)) {
            s.update(match.index, match.index + isModernFlag.length, isModern);
          }
          return {
            code: s.toString(),
            map: s.generateMap({ hires: true })
          };
        } else {
          return code.replace(re, isModern);
        }
      }
      return null;
    },
    generateBundle({ format: format2 }, bundle) {
      if (format2 !== "es" || ssr || isWorker || config2.build.modulePreload === false) {
        return;
      }
      for (const file in bundle) {
        const chunk = bundle[file];
        if (chunk.type === "chunk" && chunk.code.indexOf(preloadMarker) > -1) {
          const code = chunk.code;
          let imports;
          try {
            imports = parse$b(code)[0].filter((i) => i.d > -1);
          } catch (e) {
            this.error(e, e.idx);
          }
          const s = new MagicString(code);
          const rewroteMarkerStartPos = /* @__PURE__ */ new Set();
          if (imports.length) {
            for (let index2 = 0; index2 < imports.length; index2++) {
              const { n: name, s: start, e: end, ss: expStart, se: expEnd } = imports[index2];
              let url2 = name;
              if (!url2) {
                const rawUrl = code.slice(start, end);
                if (rawUrl[0] === `"` && rawUrl[rawUrl.length - 1] === `"`)
                  url2 = rawUrl.slice(1, -1);
              }
              const deps = /* @__PURE__ */ new Set();
              let hasRemovedPureCssChunk = false;
              let normalizedFile = void 0;
              if (url2) {
                normalizedFile = import_node_path2.default.posix.join(import_node_path2.default.posix.dirname(chunk.fileName), url2);
                const ownerFilename = chunk.fileName;
                const analyzed = /* @__PURE__ */ new Set();
                const addDeps = (filename) => {
                  if (filename === ownerFilename)
                    return;
                  if (analyzed.has(filename))
                    return;
                  analyzed.add(filename);
                  const chunk2 = bundle[filename];
                  if (chunk2) {
                    deps.add(chunk2.fileName);
                    chunk2.imports.forEach(addDeps);
                    chunk2.viteMetadata.importedCss.forEach((file2) => {
                      deps.add(file2);
                    });
                  } else {
                    const removedPureCssFiles = removedPureCssFilesCache.get(config2);
                    const chunk3 = removedPureCssFiles.get(filename);
                    if (chunk3) {
                      if (chunk3.viteMetadata.importedCss.size) {
                        chunk3.viteMetadata.importedCss.forEach((file2) => {
                          deps.add(file2);
                        });
                        hasRemovedPureCssChunk = true;
                      }
                      s.update(expStart, expEnd, "Promise.resolve({})");
                    }
                  }
                };
                addDeps(normalizedFile);
              }
              let markerStartPos2 = code.indexOf(preloadMarkerWithQuote, end);
              if (markerStartPos2 === -1 && imports.length === 1) {
                markerStartPos2 = code.indexOf(preloadMarkerWithQuote);
              }
              if (markerStartPos2 > 0) {
                const depsArray = deps.size > 1 || hasRemovedPureCssChunk && deps.size > 0 ? [...deps] : [];
                let renderedDeps;
                if (normalizedFile && customModulePreloadPaths) {
                  const { modulePreload: modulePreload2 } = config2.build;
                  const resolveDependencies = modulePreload2 && modulePreload2.resolveDependencies;
                  let resolvedDeps;
                  if (resolveDependencies) {
                    const cssDeps = [];
                    const otherDeps = [];
                    for (const dep of depsArray) {
                      (dep.endsWith(".css") ? cssDeps : otherDeps).push(dep);
                    }
                    resolvedDeps = [
                      ...resolveDependencies(normalizedFile, otherDeps, {
                        hostId: file,
                        hostType: "js"
                      }),
                      ...cssDeps
                    ];
                  } else {
                    resolvedDeps = depsArray;
                  }
                  renderedDeps = resolvedDeps.map((dep) => {
                    const replacement = toOutputFilePathInJS(dep, "asset", chunk.fileName, "js", config2, toRelativePath);
                    const replacementString = typeof replacement === "string" ? JSON.stringify(replacement) : replacement.runtime;
                    return replacementString;
                  });
                } else {
                  renderedDeps = depsArray.map((d) => JSON.stringify(optimizeModulePreloadRelativePaths ? toRelativePath(d, file) : d));
                }
                s.update(markerStartPos2, markerStartPos2 + preloadMarkerWithQuote.length, `[${renderedDeps.join(",")}]`);
                rewroteMarkerStartPos.add(markerStartPos2);
              }
            }
          }
          let markerStartPos = code.indexOf(preloadMarkerWithQuote);
          while (markerStartPos >= 0) {
            if (!rewroteMarkerStartPos.has(markerStartPos)) {
              s.update(markerStartPos, markerStartPos + preloadMarkerWithQuote.length, "void 0");
            }
            markerStartPos = code.indexOf(preloadMarkerWithQuote, markerStartPos + preloadMarkerWithQuote.length);
          }
          if (s.hasChanged()) {
            chunk.code = s.toString();
            if (config2.build.sourcemap && chunk.map) {
              const nextMap = s.generateMap({
                source: chunk.fileName,
                hires: true
              });
              const map2 = combineSourcemaps(chunk.fileName, [nextMap, chunk.map], false);
              map2.toUrl = () => genSourceMapUrl(map2);
              chunk.map = map2;
            }
          }
        }
      }
    }
  };
}
var modulePreloadPolyfillId = "vite/modulepreload-polyfill";
function modulePreloadPolyfillPlugin(config2) {
  const skip = config2.command !== "build" || config2.build.ssr;
  let polyfillString;
  return {
    name: "vite:modulepreload-polyfill",
    resolveId(id) {
      if (id === modulePreloadPolyfillId) {
        return id;
      }
    },
    load(id) {
      if (id === modulePreloadPolyfillId) {
        if (skip) {
          return "";
        }
        if (!polyfillString) {
          polyfillString = `${isModernFlag}&&(${polyfill.toString()}());`;
        }
        return polyfillString;
      }
    }
  };
}
function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node2 of mutation.addedNodes) {
        if (node2.tagName === "LINK" && node2.rel === "modulepreload")
          processPreload(node2);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(script) {
    const fetchOpts = {};
    if (script.integrity)
      fetchOpts.integrity = script.integrity;
    if (script.referrerpolicy)
      fetchOpts.referrerPolicy = script.referrerpolicy;
    if (script.crossorigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (script.crossorigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
}
var htmlProxyRE$1 = /\?html-proxy=?(?:&inline-css)?&index=(\d+)\.(js|css)$/;
var inlineCSSRE$1 = /__VITE_INLINE_CSS__([a-z\d]{8}_\d+)__/g;
var inlineImportRE = new RegExp(`(?<!(?<!\\.\\.)\\.)\\bimport\\s*\\(("([^"]|(?<=\\\\)")*"|'([^']|(?<=\\\\)')*')\\)`, "g");
var htmlLangRE = /\.(html|htm)$/;
var importMapRE = /[ \t]*<script[^>]*type\s*=\s*["']?importmap["']?[^>]*>.*?<\/script>/is;
var moduleScriptRE = /[ \t]*<script[^>]*type\s*=\s*["']?module["']?[^>]*>/is;
var isHTMLProxy = (id) => htmlProxyRE$1.test(id);
var isHTMLRequest = (request) => htmlLangRE.test(request);
var htmlProxyMap = /* @__PURE__ */ new WeakMap();
var htmlProxyResult = /* @__PURE__ */ new Map();
function htmlInlineProxyPlugin(config2) {
  htmlProxyMap.set(config2, /* @__PURE__ */ new Map());
  return {
    name: "vite:html-inline-proxy",
    resolveId(id) {
      if (htmlProxyRE$1.test(id)) {
        return id;
      }
    },
    load(id) {
      const proxyMatch = id.match(htmlProxyRE$1);
      if (proxyMatch) {
        const index2 = Number(proxyMatch[1]);
        const file = cleanUrl(id);
        const url2 = file.replace(normalizePath$3(config2.root), "");
        const result = htmlProxyMap.get(config2).get(url2)[index2];
        if (result) {
          return result;
        } else {
          throw new Error(`No matching HTML proxy module found from ${id}`);
        }
      }
    }
  };
}
function addToHTMLProxyCache(config2, filePath, index2, result) {
  if (!htmlProxyMap.get(config2)) {
    htmlProxyMap.set(config2, /* @__PURE__ */ new Map());
  }
  if (!htmlProxyMap.get(config2).get(filePath)) {
    htmlProxyMap.get(config2).set(filePath, []);
  }
  htmlProxyMap.get(config2).get(filePath)[index2] = result;
}
function addToHTMLProxyTransformResult(hash, code) {
  htmlProxyResult.set(hash, code);
}
var assetAttrsConfig = {
  link: ["href"],
  video: ["src", "poster"],
  source: ["src", "srcset"],
  img: ["src", "srcset"],
  image: ["xlink:href", "href"],
  use: ["xlink:href", "href"]
};
var isAsyncScriptMap = /* @__PURE__ */ new WeakMap();
function nodeIsElement(node2) {
  return node2.nodeName[0] !== "#";
}
function traverseNodes(node2, visitor) {
  visitor(node2);
  if (nodeIsElement(node2) || node2.nodeName === "#document" || node2.nodeName === "#document-fragment") {
    node2.childNodes.forEach((childNode) => traverseNodes(childNode, visitor));
  }
}
async function traverseHtml(html, filePath, visitor) {
  const { parse: parse6 } = await import("./dep-19c40c50-E2P3FXAL.js");
  const ast = parse6(html, {
    sourceCodeLocationInfo: true,
    onParseError: (e) => {
      handleParseError(e, html, filePath);
    }
  });
  traverseNodes(ast, visitor);
}
function getScriptInfo(node2) {
  var _a;
  let src2;
  let sourceCodeLocation;
  let isModule = false;
  let isAsync = false;
  for (const p of node2.attrs) {
    if (p.prefix !== void 0)
      continue;
    if (p.name === "src") {
      if (!src2) {
        src2 = p;
        sourceCodeLocation = (_a = node2.sourceCodeLocation) == null ? void 0 : _a.attrs["src"];
      }
    } else if (p.name === "type" && p.value && p.value === "module") {
      isModule = true;
    } else if (p.name === "async") {
      isAsync = true;
    }
  }
  return { src: src2, sourceCodeLocation, isModule, isAsync };
}
var attrValueStartRE = /=[\s\t\n\r]*(.)/;
function overwriteAttrValue(s, sourceCodeLocation, newValue) {
  const srcString = s.slice(sourceCodeLocation.startOffset, sourceCodeLocation.endOffset);
  const valueStart = srcString.match(attrValueStartRE);
  if (!valueStart) {
    throw new Error(`[vite:html] internal error, failed to overwrite attribute value`);
  }
  const wrapOffset = valueStart[1] === '"' || valueStart[1] === "'" ? 1 : 0;
  const valueOffset = valueStart.index + valueStart[0].length - 1;
  s.update(sourceCodeLocation.startOffset + valueOffset + wrapOffset, sourceCodeLocation.endOffset - wrapOffset, newValue);
  return s;
}
function formatParseError(parserError, id, html) {
  const formattedError = {
    code: parserError.code,
    message: `parse5 error code ${parserError.code}`
  };
  formattedError.frame = generateCodeFrame(html, parserError.startOffset);
  formattedError.loc = {
    file: id,
    line: parserError.startLine,
    column: parserError.startCol
  };
  return formattedError;
}
function handleParseError(parserError, html, filePath) {
  switch (parserError.code) {
    case "missing-doctype":
      return;
    case "abandoned-head-element-child":
      return;
    case "duplicate-attribute":
      return;
    case "non-void-html-element-start-tag-with-trailing-solidus":
      return;
  }
  const parseError = {
    loc: filePath,
    frame: "",
    ...formatParseError(parserError, filePath, html)
  };
  throw new Error(`Unable to parse HTML; ${parseError.message}
 at ${JSON.stringify(parseError.loc)}
${parseError.frame}`);
}
function buildHtmlPlugin(config2) {
  const [preHooks, postHooks] = resolveHtmlTransforms(config2.plugins);
  preHooks.unshift(preImportMapHook(config2));
  postHooks.push(postImportMapHook());
  const processedHtml = /* @__PURE__ */ new Map();
  const isExcludedUrl = (url2) => url2.startsWith("#") || isExternalUrl(url2) || isDataUrl(url2) || checkPublicFile(url2, config2);
  isAsyncScriptMap.set(config2, /* @__PURE__ */ new Map());
  return {
    name: "vite:build-html",
    async transform(html, id) {
      var _a, _b;
      if (id.endsWith(".html")) {
        const relativeUrlPath = import_node_path2.default.posix.relative(config2.root, normalizePath$3(id));
        const publicPath = `/${relativeUrlPath}`;
        const publicBase = getBaseInHTML(relativeUrlPath, config2);
        const publicToRelative = (filename, importer) => publicBase + filename;
        const toOutputPublicFilePath = (url2) => toOutputFilePathInHtml(url2.slice(1), "public", relativeUrlPath, "html", config2, publicToRelative);
        html = await applyHtmlTransforms(html, preHooks, {
          path: publicPath,
          filename: id
        });
        let js = "";
        const s = new MagicString(html);
        const assetUrls = [];
        const scriptUrls = [];
        const styleUrls = [];
        let inlineModuleIndex = -1;
        let everyScriptIsAsync = true;
        let someScriptsAreAsync = false;
        let someScriptsAreDefer = false;
        await traverseHtml(html, id, (node2) => {
          if (!nodeIsElement(node2)) {
            return;
          }
          let shouldRemove = false;
          if (node2.nodeName === "script") {
            const { src: src2, sourceCodeLocation, isModule, isAsync } = getScriptInfo(node2);
            const url2 = src2 && src2.value;
            const isPublicFile = !!(url2 && checkPublicFile(url2, config2));
            if (isPublicFile) {
              overwriteAttrValue(s, sourceCodeLocation, toOutputPublicFilePath(url2));
            }
            if (isModule) {
              inlineModuleIndex++;
              if (url2 && !isExcludedUrl(url2)) {
                js += `
import ${JSON.stringify(url2)}`;
                shouldRemove = true;
              } else if (node2.childNodes.length) {
                const scriptNode = node2.childNodes.pop();
                const contents = scriptNode.value;
                const filePath = id.replace(normalizePath$3(config2.root), "");
                addToHTMLProxyCache(config2, filePath, inlineModuleIndex, {
                  code: contents
                });
                js += `
import "${id}?html-proxy&index=${inlineModuleIndex}.js"`;
                shouldRemove = true;
              }
              everyScriptIsAsync && (everyScriptIsAsync = isAsync);
              someScriptsAreAsync || (someScriptsAreAsync = isAsync);
              someScriptsAreDefer || (someScriptsAreDefer = !isAsync);
            } else if (url2 && !isPublicFile) {
              if (!isExcludedUrl(url2)) {
                config2.logger.warn(`<script src="${url2}"> in "${publicPath}" can't be bundled without type="module" attribute`);
              }
            } else if (node2.childNodes.length) {
              const scriptNode = node2.childNodes.pop();
              const cleanCode = stripLiteral(scriptNode.value);
              let match;
              inlineImportRE.lastIndex = 0;
              while (match = inlineImportRE.exec(cleanCode)) {
                const { 1: url3, index: index2 } = match;
                const startUrl = cleanCode.indexOf(url3, index2);
                const start = startUrl + 1;
                const end = start + url3.length - 2;
                const startOffset = scriptNode.sourceCodeLocation.startOffset;
                scriptUrls.push({
                  start: start + startOffset,
                  end: end + startOffset,
                  url: scriptNode.value.slice(start, end)
                });
              }
            }
          }
          const assetAttrs = assetAttrsConfig[node2.nodeName];
          if (assetAttrs) {
            for (const p of node2.attrs) {
              const attrKey = getAttrKey(p);
              if (p.value && assetAttrs.includes(attrKey)) {
                const attrSourceCodeLocation = node2.sourceCodeLocation.attrs[attrKey];
                const url2 = decodeURI(p.value);
                if (!isExcludedUrl(url2)) {
                  if (node2.nodeName === "link" && isCSSRequest(url2) && !node2.attrs.some((p2) => p2.prefix === void 0 && (p2.name === "media" || p2.name === "disabled"))) {
                    const importExpression = `
import ${JSON.stringify(url2)}`;
                    styleUrls.push({
                      url: url2,
                      start: node2.sourceCodeLocation.startOffset,
                      end: node2.sourceCodeLocation.endOffset
                    });
                    js += importExpression;
                  } else {
                    assetUrls.push({
                      attr: p,
                      sourceCodeLocation: attrSourceCodeLocation
                    });
                  }
                } else if (checkPublicFile(url2, config2)) {
                  overwriteAttrValue(s, attrSourceCodeLocation, toOutputPublicFilePath(url2));
                }
              }
            }
          }
          const inlineStyle = node2.attrs.find(
            (prop) => prop.prefix === void 0 && prop.name === "style" && prop.value.includes("url(")
          );
          if (inlineStyle) {
            inlineModuleIndex++;
            const code = inlineStyle.value;
            const filePath = id.replace(normalizePath$3(config2.root), "");
            addToHTMLProxyCache(config2, filePath, inlineModuleIndex, { code });
            js += `
import "${id}?html-proxy&inline-css&index=${inlineModuleIndex}.css"`;
            const hash = getHash(cleanUrl(id));
            const sourceCodeLocation = node2.sourceCodeLocation.attrs["style"];
            overwriteAttrValue(s, sourceCodeLocation, `__VITE_INLINE_CSS__${hash}_${inlineModuleIndex}__`);
          }
          if (node2.nodeName === "style" && node2.childNodes.length) {
            const styleNode = node2.childNodes.pop();
            const filePath = id.replace(normalizePath$3(config2.root), "");
            inlineModuleIndex++;
            addToHTMLProxyCache(config2, filePath, inlineModuleIndex, {
              code: styleNode.value
            });
            js += `
import "${id}?html-proxy&inline-css&index=${inlineModuleIndex}.css"`;
            const hash = getHash(cleanUrl(id));
            s.update(styleNode.sourceCodeLocation.startOffset, styleNode.sourceCodeLocation.endOffset, `__VITE_INLINE_CSS__${hash}_${inlineModuleIndex}__`);
          }
          if (shouldRemove) {
            s.remove(node2.sourceCodeLocation.startOffset, node2.sourceCodeLocation.endOffset);
          }
        });
        isAsyncScriptMap.get(config2).set(id, everyScriptIsAsync);
        if (someScriptsAreAsync && someScriptsAreDefer) {
          config2.logger.warn(`
Mixed async and defer script modules in ${id}, output script will fallback to defer. Every script, including inline ones, need to be marked as async for your output script to be async.`);
        }
        const namedOutput = Object.keys(((_b = (_a = config2 == null ? void 0 : config2.build) == null ? void 0 : _a.rollupOptions) == null ? void 0 : _b.input) || {});
        for (const { attr, sourceCodeLocation } of assetUrls) {
          const content = decodeURI(attr.value);
          if (content !== "" && !namedOutput.includes(content) && !namedOutput.includes(content.replace(/^\//, ""))) {
            try {
              const url2 = attr.prefix === void 0 && attr.name === "srcset" ? await processSrcSet(content, ({ url: url3 }) => urlToBuiltUrl(url3, id, config2, this)) : await urlToBuiltUrl(content, id, config2, this);
              overwriteAttrValue(s, sourceCodeLocation, url2);
            } catch (e) {
              if (e.code !== "ENOENT") {
                throw e;
              }
            }
          }
        }
        for (const { start, end, url: url2 } of scriptUrls) {
          if (!isExcludedUrl(url2)) {
            s.update(start, end, await urlToBuiltUrl(url2, id, config2, this));
          } else if (checkPublicFile(url2, config2)) {
            s.update(start, end, toOutputPublicFilePath(url2));
          }
        }
        const resolvedStyleUrls = await Promise.all(styleUrls.map(async (styleUrl) => ({
          ...styleUrl,
          resolved: await this.resolve(styleUrl.url, id)
        })));
        for (const { start, end, url: url2, resolved } of resolvedStyleUrls) {
          if (resolved == null) {
            config2.logger.warnOnce(`
${url2} doesn't exist at build time, it will remain unchanged to be resolved at runtime`);
            const importExpression = `
import ${JSON.stringify(url2)}`;
            js = js.replace(importExpression, "");
          } else {
            s.remove(start, end);
          }
        }
        processedHtml.set(id, s.toString());
        const { modulePreload } = config2.build;
        if ((modulePreload === true || typeof modulePreload === "object" && modulePreload.polyfill) && (someScriptsAreAsync || someScriptsAreDefer)) {
          js = `import "${modulePreloadPolyfillId}";
${js}`;
        }
        return js;
      }
    },
    async generateBundle(options3, bundle) {
      const analyzedChunk = /* @__PURE__ */ new Map();
      const getImportedChunks = (chunk, seen2 = /* @__PURE__ */ new Set()) => {
        const chunks = [];
        chunk.imports.forEach((file) => {
          const importee = bundle[file];
          if ((importee == null ? void 0 : importee.type) === "chunk" && !seen2.has(file)) {
            seen2.add(file);
            chunks.push(...getImportedChunks(importee, seen2));
            chunks.push(importee);
          }
        });
        return chunks;
      };
      const toScriptTag = (chunk, toOutputPath, isAsync) => ({
        tag: "script",
        attrs: {
          ...isAsync ? { async: true } : {},
          type: "module",
          crossorigin: true,
          src: toOutputPath(chunk.fileName)
        }
      });
      const toPreloadTag = (filename, toOutputPath) => ({
        tag: "link",
        attrs: {
          rel: "modulepreload",
          crossorigin: true,
          href: toOutputPath(filename)
        }
      });
      const getCssTagsForChunk = (chunk, toOutputPath, seen2 = /* @__PURE__ */ new Set()) => {
        const tags = [];
        if (!analyzedChunk.has(chunk)) {
          analyzedChunk.set(chunk, 1);
          chunk.imports.forEach((file) => {
            const importee = bundle[file];
            if ((importee == null ? void 0 : importee.type) === "chunk") {
              tags.push(...getCssTagsForChunk(importee, toOutputPath, seen2));
            }
          });
        }
        chunk.viteMetadata.importedCss.forEach((file) => {
          if (!seen2.has(file)) {
            seen2.add(file);
            tags.push({
              tag: "link",
              attrs: {
                rel: "stylesheet",
                href: toOutputPath(file)
              }
            });
          }
        });
        return tags;
      };
      for (const [id, html] of processedHtml) {
        const relativeUrlPath = import_node_path2.default.posix.relative(config2.root, normalizePath$3(id));
        const assetsBase = getBaseInHTML(relativeUrlPath, config2);
        const toOutputFilePath = (filename, type) => {
          if (isExternalUrl(filename)) {
            return filename;
          } else {
            return toOutputFilePathInHtml(filename, type, relativeUrlPath, "html", config2, (filename2, importer) => assetsBase + filename2);
          }
        };
        const toOutputAssetFilePath = (filename) => toOutputFilePath(filename, "asset");
        const toOutputPublicAssetFilePath = (filename) => toOutputFilePath(filename, "public");
        const isAsync = isAsyncScriptMap.get(config2).get(id);
        let result = html;
        const chunk = Object.values(bundle).find((chunk2) => chunk2.type === "chunk" && chunk2.isEntry && chunk2.facadeModuleId === id);
        let canInlineEntry = false;
        if (chunk) {
          if (options3.format === "es" && isEntirelyImport(chunk.code)) {
            canInlineEntry = true;
          }
          const imports = getImportedChunks(chunk);
          let assetTags;
          if (canInlineEntry) {
            assetTags = imports.map((chunk2) => toScriptTag(chunk2, toOutputAssetFilePath, isAsync));
          } else {
            const { modulePreload } = config2.build;
            const resolveDependencies = typeof modulePreload === "object" && modulePreload.resolveDependencies;
            const importsFileNames = imports.map((chunk2) => chunk2.fileName);
            const resolvedDeps = resolveDependencies ? resolveDependencies(chunk.fileName, importsFileNames, {
              hostId: relativeUrlPath,
              hostType: "html"
            }) : importsFileNames;
            assetTags = [
              toScriptTag(chunk, toOutputAssetFilePath, isAsync),
              ...resolvedDeps.map((i) => toPreloadTag(i, toOutputAssetFilePath))
            ];
          }
          assetTags.push(...getCssTagsForChunk(chunk, toOutputAssetFilePath));
          result = injectToHead(result, assetTags);
        }
        if (!config2.build.cssCodeSplit) {
          const cssChunk = Object.values(bundle).find((chunk2) => chunk2.type === "asset" && chunk2.name === "style.css");
          if (cssChunk) {
            result = injectToHead(result, [
              {
                tag: "link",
                attrs: {
                  rel: "stylesheet",
                  href: toOutputAssetFilePath(cssChunk.fileName)
                }
              }
            ]);
          }
        }
        let match;
        let s;
        inlineCSSRE$1.lastIndex = 0;
        while (match = inlineCSSRE$1.exec(result)) {
          s || (s = new MagicString(result));
          const { 0: full, 1: scopedName } = match;
          const cssTransformedCode = htmlProxyResult.get(scopedName);
          s.update(match.index, match.index + full.length, cssTransformedCode);
        }
        if (s) {
          result = s.toString();
        }
        result = await applyHtmlTransforms(result, postHooks, {
          path: "/" + relativeUrlPath,
          filename: id,
          bundle,
          chunk
        });
        result = result.replace(assetUrlRE, (_, fileHash, postfix = "") => {
          return toOutputAssetFilePath(getAssetFilename(fileHash, config2)) + postfix;
        });
        result = result.replace(publicAssetUrlRE, (_, fileHash) => {
          return normalizePath$3(toOutputPublicAssetFilePath(getPublicAssetFilename(fileHash, config2)));
        });
        if (chunk && canInlineEntry) {
          delete bundle[chunk.fileName];
        }
        const shortEmitName = normalizePath$3(import_node_path2.default.relative(config2.root, id));
        this.emitFile({
          type: "asset",
          fileName: shortEmitName,
          source: result
        });
      }
    }
  };
}
function preImportMapHook(config2) {
  return (html, ctx2) => {
    var _a, _b;
    const importMapIndex = (_a = html.match(importMapRE)) == null ? void 0 : _a.index;
    if (importMapIndex === void 0)
      return;
    const moduleScriptIndex = (_b = html.match(moduleScriptRE)) == null ? void 0 : _b.index;
    if (moduleScriptIndex === void 0)
      return;
    if (moduleScriptIndex < importMapIndex) {
      const relativeHtml = normalizePath$3(import_node_path2.default.relative(config2.root, ctx2.filename));
      config2.logger.warnOnce(picocolors.exports.yellow(picocolors.exports.bold(`(!) <script type="importmap"> should come before <script type="module"> in /${relativeHtml}`)));
    }
  };
}
function postImportMapHook() {
  return (html) => {
    if (!moduleScriptRE.test(html))
      return;
    let importMap;
    html = html.replace(importMapRE, (match) => {
      importMap = match;
      return "";
    });
    if (importMap) {
      html = html.replace(moduleScriptRE, (match) => `${importMap}
${match}`);
    }
    return html;
  };
}
function resolveHtmlTransforms(plugins2) {
  const preHooks = [];
  const postHooks = [];
  for (const plugin of plugins2) {
    const hook = plugin.transformIndexHtml;
    if (hook) {
      if (typeof hook === "function") {
        postHooks.push(hook);
      } else if (hook.enforce === "pre") {
        preHooks.push(hook.transform);
      } else {
        postHooks.push(hook.transform);
      }
    }
  }
  return [preHooks, postHooks];
}
async function applyHtmlTransforms(html, hooks, ctx2) {
  for (const hook of hooks) {
    const res = await hook(html, ctx2);
    if (!res) {
      continue;
    }
    if (typeof res === "string") {
      html = res;
    } else {
      let tags;
      if (Array.isArray(res)) {
        tags = res;
      } else {
        html = res.html || html;
        tags = res.tags;
      }
      const headTags = [];
      const headPrependTags = [];
      const bodyTags = [];
      const bodyPrependTags = [];
      for (const tag of tags) {
        if (tag.injectTo === "body") {
          bodyTags.push(tag);
        } else if (tag.injectTo === "body-prepend") {
          bodyPrependTags.push(tag);
        } else if (tag.injectTo === "head") {
          headTags.push(tag);
        } else {
          headPrependTags.push(tag);
        }
      }
      html = injectToHead(html, headPrependTags, true);
      html = injectToHead(html, headTags);
      html = injectToBody(html, bodyPrependTags, true);
      html = injectToBody(html, bodyTags);
    }
  }
  return html;
}
var importRE = /\bimport\s*("[^"]*[^\\]"|'[^']*[^\\]');*/g;
var commentRE = /\/\*[\s\S]*?\*\/|\/\/.*$/gm;
function isEntirelyImport(code) {
  return !code.replace(importRE, "").replace(commentRE, "").trim().length;
}
function getBaseInHTML(urlRelativePath, config2) {
  return config2.base === "./" || config2.base === "" ? import_node_path2.default.posix.join(import_node_path2.default.posix.relative(urlRelativePath, "").slice(0, -2), "./") : config2.base;
}
var headInjectRE = /([ \t]*)<\/head>/i;
var headPrependInjectRE = /([ \t]*)<head[^>]*>/i;
var htmlInjectRE = /<\/html>/i;
var htmlPrependInjectRE = /([ \t]*)<html[^>]*>/i;
var bodyInjectRE = /([ \t]*)<\/body>/i;
var bodyPrependInjectRE = /([ \t]*)<body[^>]*>/i;
var doctypePrependInjectRE = /<!doctype html>/i;
function injectToHead(html, tags, prepend = false) {
  if (tags.length === 0)
    return html;
  if (prepend) {
    if (headPrependInjectRE.test(html)) {
      return html.replace(headPrependInjectRE, (match, p1) => `${match}
${serializeTags(tags, incrementIndent(p1))}`);
    }
  } else {
    if (headInjectRE.test(html)) {
      return html.replace(headInjectRE, (match, p1) => `${serializeTags(tags, incrementIndent(p1))}${match}`);
    }
    if (bodyPrependInjectRE.test(html)) {
      return html.replace(bodyPrependInjectRE, (match, p1) => `${serializeTags(tags, p1)}
${match}`);
    }
  }
  return prependInjectFallback(html, tags);
}
function injectToBody(html, tags, prepend = false) {
  if (tags.length === 0)
    return html;
  if (prepend) {
    if (bodyPrependInjectRE.test(html)) {
      return html.replace(bodyPrependInjectRE, (match, p1) => `${match}
${serializeTags(tags, incrementIndent(p1))}`);
    }
    if (headInjectRE.test(html)) {
      return html.replace(headInjectRE, (match, p1) => `${match}
${serializeTags(tags, p1)}`);
    }
    return prependInjectFallback(html, tags);
  } else {
    if (bodyInjectRE.test(html)) {
      return html.replace(bodyInjectRE, (match, p1) => `${serializeTags(tags, incrementIndent(p1))}${match}`);
    }
    if (htmlInjectRE.test(html)) {
      return html.replace(htmlInjectRE, `${serializeTags(tags)}
$&`);
    }
    return html + `
` + serializeTags(tags);
  }
}
function prependInjectFallback(html, tags) {
  if (htmlPrependInjectRE.test(html)) {
    return html.replace(htmlPrependInjectRE, `$&
${serializeTags(tags)}`);
  }
  if (doctypePrependInjectRE.test(html)) {
    return html.replace(doctypePrependInjectRE, `$&
${serializeTags(tags)}`);
  }
  return serializeTags(tags) + html;
}
var unaryTags = /* @__PURE__ */ new Set(["link", "meta", "base"]);
function serializeTag({ tag, attrs, children }, indent = "") {
  if (unaryTags.has(tag)) {
    return `<${tag}${serializeAttrs(attrs)}>`;
  } else {
    return `<${tag}${serializeAttrs(attrs)}>${serializeTags(children, incrementIndent(indent))}</${tag}>`;
  }
}
function serializeTags(tags, indent = "") {
  if (typeof tags === "string") {
    return tags;
  } else if (tags && tags.length) {
    return tags.map((tag) => `${indent}${serializeTag(tag, indent)}
`).join("");
  }
  return "";
}
function serializeAttrs(attrs) {
  let res = "";
  for (const key2 in attrs) {
    if (typeof attrs[key2] === "boolean") {
      res += attrs[key2] ? ` ${key2}` : ``;
    } else {
      res += ` ${key2}=${JSON.stringify(attrs[key2])}`;
    }
  }
  return res;
}
function incrementIndent(indent = "") {
  return `${indent}${indent[0] === "	" ? "	" : "  "}`;
}
function getAttrKey(attr) {
  return attr.prefix === void 0 ? attr.name : `${attr.prefix}:${attr.name}`;
}
var cssLangs = `\\.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)($|\\?)`;
var cssLangRE = new RegExp(cssLangs);
var cssModuleRE = new RegExp(`\\.module${cssLangs}`);
var directRequestRE = /(\?|&)direct\b/;
var htmlProxyRE = /(\?|&)html-proxy\b/;
var commonjsProxyRE = /\?commonjs-proxy/;
var inlineRE = /(\?|&)inline\b/;
var inlineCSSRE = /(\?|&)inline-css\b/;
var usedRE = /(\?|&)used\b/;
var varRE = /^var\(/i;
var cssBundleName = "style.css";
var isCSSRequest = (request) => cssLangRE.test(request);
var isDirectCSSRequest = (request) => cssLangRE.test(request) && directRequestRE.test(request);
var isDirectRequest = (request) => directRequestRE.test(request);
var cssModulesCache = /* @__PURE__ */ new WeakMap();
var removedPureCssFilesCache = /* @__PURE__ */ new WeakMap();
var cssEntryFilesCache = /* @__PURE__ */ new WeakMap();
var postcssConfigCache = {};
function encodePublicUrlsInCSS(config2) {
  return config2.command === "build";
}
function cssPlugin(config2) {
  let server2;
  let moduleCache;
  const resolveUrl = config2.createResolver({
    preferRelative: true,
    tryIndex: false,
    extensions: []
  });
  return {
    name: "vite:css",
    configureServer(_server) {
      server2 = _server;
    },
    buildStart() {
      moduleCache = /* @__PURE__ */ new Map();
      cssModulesCache.set(config2, moduleCache);
      removedPureCssFilesCache.set(config2, /* @__PURE__ */ new Map());
      cssEntryFilesCache.set(config2, /* @__PURE__ */ new Set());
    },
    async transform(raw, id, options3) {
      var _a, _b;
      if (!isCSSRequest(id) || commonjsProxyRE.test(id) || SPECIAL_QUERY_RE.test(id)) {
        return;
      }
      const ssr = (options3 == null ? void 0 : options3.ssr) === true;
      const urlReplacer = async (url2, importer) => {
        if (checkPublicFile(url2, config2)) {
          if (encodePublicUrlsInCSS(config2)) {
            return publicFileToBuiltUrl(url2, config2);
          } else {
            return joinUrlSegments(config2.base, url2);
          }
        }
        const resolved = await resolveUrl(url2, importer);
        if (resolved) {
          return fileToUrl(resolved, config2, this);
        }
        if (config2.command === "build") {
          config2.logger.warnOnce(`
${url2} referenced in ${id} didn't resolve at build time, it will remain unchanged to be resolved at runtime`);
        }
        return url2;
      };
      const { code: css, modules, deps, map: map2 } = await compileCSS(id, raw, config2, urlReplacer);
      if (modules) {
        moduleCache.set(id, modules);
      }
      if (config2.command === "build" && config2.build.watch && deps) {
        for (const file of deps) {
          this.addWatchFile(file);
        }
      }
      if (server2) {
        const { moduleGraph } = server2;
        const thisModule = moduleGraph.getModuleById(id);
        if (thisModule) {
          const isSelfAccepting = !modules && !inlineRE.test(id) && !htmlProxyRE.test(id);
          if (deps) {
            const depModules = /* @__PURE__ */ new Set();
            const devBase = config2.base;
            for (const file of deps) {
              depModules.add(isCSSRequest(file) ? moduleGraph.createFileOnlyEntry(file) : await moduleGraph.ensureEntryFromUrl((await fileToUrl(file, config2, this)).replace(((_b = (_a = config2.server) == null ? void 0 : _a.origin) != null ? _b : "") + devBase, "/"), ssr));
            }
            moduleGraph.updateModuleInfo(
              thisModule,
              depModules,
              null,
              /* @__PURE__ */ new Set(),
              null,
              isSelfAccepting,
              ssr
            );
            for (const file of deps) {
              this.addWatchFile(file);
            }
          } else {
            thisModule.isSelfAccepting = isSelfAccepting;
          }
        }
      }
      return {
        code: css,
        map: map2
      };
    }
  };
}
function cssPostPlugin(config2) {
  var _a;
  const styles = /* @__PURE__ */ new Map();
  let pureCssChunks;
  let outputToExtractedCSSMap;
  let hasEmitted = false;
  const rollupOptionsOutput = config2.build.rollupOptions.output;
  const assetFileNames = (_a = Array.isArray(rollupOptionsOutput) ? rollupOptionsOutput[0] : rollupOptionsOutput) == null ? void 0 : _a.assetFileNames;
  const getCssAssetDirname = (cssAssetName) => {
    if (!assetFileNames) {
      return config2.build.assetsDir;
    } else if (typeof assetFileNames === "string") {
      return import_node_path2.default.dirname(assetFileNames);
    } else {
      return import_node_path2.default.dirname(assetFileNames({
        name: cssAssetName,
        type: "asset",
        source: "/* vite internal call, ignore */"
      }));
    }
  };
  return {
    name: "vite:css-post",
    buildStart() {
      pureCssChunks = /* @__PURE__ */ new Set();
      outputToExtractedCSSMap = /* @__PURE__ */ new Map();
      hasEmitted = false;
    },
    async transform(css, id, options3) {
      if (!isCSSRequest(id) || commonjsProxyRE.test(id) || SPECIAL_QUERY_RE.test(id)) {
        return;
      }
      css = stripBomTag(css);
      const inlined = inlineRE.test(id);
      const modules = cssModulesCache.get(config2).get(id);
      const modulesCode = modules && !inlined && dataToEsm(modules, { namedExports: true, preferConst: true });
      if (config2.command === "serve") {
        const getContentWithSourcemap = async (content) => {
          var _a2;
          if ((_a2 = config2.css) == null ? void 0 : _a2.devSourcemap) {
            const sourcemap = this.getCombinedSourcemap();
            await injectSourcesContent(sourcemap, cleanUrl(id), config2.logger);
            return getCodeWithSourcemap("css", content, sourcemap);
          }
          return content;
        };
        if (isDirectCSSRequest(id)) {
          return await getContentWithSourcemap(css);
        }
        if (options3 == null ? void 0 : options3.ssr) {
          return modulesCode || `export default ${JSON.stringify(css)}`;
        }
        if (inlined) {
          return `export default ${JSON.stringify(css)}`;
        }
        const cssContent = await getContentWithSourcemap(css);
        const code2 = [
          `import { updateStyle as __vite__updateStyle, removeStyle as __vite__removeStyle } from ${JSON.stringify(import_node_path2.default.posix.join(config2.base, CLIENT_PUBLIC_PATH))}`,
          `const __vite__id = ${JSON.stringify(id)}`,
          `const __vite__css = ${JSON.stringify(cssContent)}`,
          `__vite__updateStyle(__vite__id, __vite__css)`,
          `${modulesCode || `import.meta.hot.accept()
export default __vite__css`}`,
          `import.meta.hot.prune(() => __vite__removeStyle(__vite__id))`
        ].join("\n");
        return { code: code2, map: { mappings: "" } };
      }
      const inlineCSS = inlineCSSRE.test(id);
      const isHTMLProxy2 = htmlProxyRE.test(id);
      const query = parseRequest(id);
      if (inlineCSS && isHTMLProxy2) {
        addToHTMLProxyTransformResult(`${getHash(cleanUrl(id))}_${Number.parseInt(query.index)}`, css);
        return `export default ''`;
      }
      if (!inlined) {
        styles.set(id, css);
      }
      let code;
      if (usedRE.test(id)) {
        if (modulesCode) {
          code = modulesCode;
        } else {
          let content = css;
          if (config2.build.minify) {
            content = await minifyCSS(content, config2);
          }
          code = `export default ${JSON.stringify(content)}`;
        }
      } else {
        code = modulesCode || `export default ''`;
      }
      return {
        code,
        map: { mappings: "" },
        moduleSideEffects: inlined ? false : "no-treeshake"
      };
    },
    async renderChunk(code, chunk, opts) {
      var _a2;
      let chunkCSS = "";
      let isPureCssChunk = true;
      const ids = Object.keys(chunk.modules);
      for (const id of ids) {
        if (!isCSSRequest(id) || cssModuleRE.test(id) || commonjsProxyRE.test(id)) {
          isPureCssChunk = false;
        }
        if (styles.has(id)) {
          chunkCSS += styles.get(id);
        }
      }
      if (!chunkCSS) {
        return null;
      }
      const cssEntryFiles = cssEntryFilesCache.get(config2);
      const publicAssetUrlMap = publicAssetUrlCache.get(config2);
      function resolveAssetUrlsInCss(chunkCSS2, cssAssetName) {
        const encodedPublicUrls = encodePublicUrlsInCSS(config2);
        const relative2 = config2.base === "./" || config2.base === "";
        const cssAssetDirname = encodedPublicUrls || relative2 ? getCssAssetDirname(cssAssetName) : void 0;
        const toRelative = (filename, importer) => {
          const relativePath = import_node_path2.default.posix.relative(cssAssetDirname, filename);
          return relativePath.startsWith(".") ? relativePath : "./" + relativePath;
        };
        chunkCSS2 = chunkCSS2.replace(assetUrlRE, (_, fileHash, postfix = "") => {
          const filename = getAssetFilename(fileHash, config2) + postfix;
          chunk.viteMetadata.importedAssets.add(cleanUrl(filename));
          return toOutputFilePathInCss(filename, "asset", cssAssetName, "css", config2, toRelative);
        });
        if (encodedPublicUrls) {
          const relativePathToPublicFromCSS = import_node_path2.default.posix.relative(cssAssetDirname, "");
          chunkCSS2 = chunkCSS2.replace(publicAssetUrlRE, (_, hash) => {
            const publicUrl = publicAssetUrlMap.get(hash).slice(1);
            return toOutputFilePathInCss(publicUrl, "public", cssAssetName, "css", config2, () => `${relativePathToPublicFromCSS}/${publicUrl}`);
          });
        }
        return chunkCSS2;
      }
      function ensureFileExt(name, ext2) {
        return normalizePath$3(import_node_path2.default.format({ ...import_node_path2.default.parse(name), base: void 0, ext: ext2 }));
      }
      if (config2.build.cssCodeSplit) {
        if (isPureCssChunk) {
          pureCssChunks.add(chunk.fileName);
        }
        if (opts.format === "es" || opts.format === "cjs") {
          const cssAssetName = chunk.facadeModuleId ? normalizePath$3(import_node_path2.default.relative(config2.root, chunk.facadeModuleId)) : chunk.name;
          const lang = import_node_path2.default.extname(cssAssetName).slice(1);
          const cssFileName = ensureFileExt(cssAssetName, ".css");
          if (chunk.isEntry && isPureCssChunk)
            cssEntryFiles.add(cssAssetName);
          chunkCSS = resolveAssetUrlsInCss(chunkCSS, cssAssetName);
          chunkCSS = await finalizeCss(chunkCSS, true, config2);
          const fileHandle = this.emitFile({
            name: isPreProcessor(lang) ? cssAssetName : cssFileName,
            fileName: assetFileNamesToFileName(resolveAssetFileNames(config2), cssFileName, getHash(chunkCSS), chunkCSS),
            type: "asset",
            source: chunkCSS
          });
          chunk.viteMetadata.importedCss.add(this.getFileName(fileHandle));
        } else if (!config2.build.ssr) {
          chunkCSS = await finalizeCss(chunkCSS, true, config2);
          let cssString = JSON.stringify(chunkCSS);
          cssString = ((_a2 = renderAssetUrlInJS(this, config2, chunk, opts, cssString)) == null ? void 0 : _a2.toString()) || cssString;
          const style = `__vite_style__`;
          const injectCode = `var ${style} = document.createElement('style');${style}.textContent = ${cssString};document.head.appendChild(${style});`;
          const wrapIdx = code.indexOf("System.register");
          const insertMark = "'use strict';";
          const insertIdx = code.indexOf(insertMark, wrapIdx);
          const s = new MagicString(code);
          s.appendLeft(insertIdx + insertMark.length, injectCode);
          if (config2.build.sourcemap) {
            return {
              code: s.toString(),
              map: s.generateMap({ hires: true })
            };
          } else {
            return { code: s.toString() };
          }
        }
      } else {
        chunkCSS = resolveAssetUrlsInCss(chunkCSS, cssBundleName);
        outputToExtractedCSSMap.set(opts, (outputToExtractedCSSMap.get(opts) || "") + chunkCSS);
      }
      return null;
    },
    async generateBundle(opts, bundle) {
      if (opts.__vite_skip_asset_emit__) {
        return;
      }
      if (pureCssChunks.size) {
        const emptyChunkFiles = [...pureCssChunks].map((file) => import_node_path2.default.basename(file)).join("|").replace(/\./g, "\\.");
        const emptyChunkRE = new RegExp(opts.format === "es" ? `\\bimport\\s*["'][^"']*(?:${emptyChunkFiles})["'];
?` : `\\brequire\\(\\s*["'][^"']*(?:${emptyChunkFiles})["']\\);
?`, "g");
        for (const file in bundle) {
          const chunk = bundle[file];
          if (chunk.type === "chunk") {
            chunk.imports = chunk.imports.filter((file2) => {
              if (pureCssChunks.has(file2)) {
                const { viteMetadata: { importedCss } } = bundle[file2];
                importedCss.forEach((file3) => chunk.viteMetadata.importedCss.add(file3));
                return false;
              }
              return true;
            });
            chunk.code = chunk.code.replace(
              emptyChunkRE,
              (m) => `/* empty css ${"".padEnd(m.length - 15)}*/`
            );
          }
        }
        const removedPureCssFiles = removedPureCssFilesCache.get(config2);
        pureCssChunks.forEach((fileName) => {
          removedPureCssFiles.set(fileName, bundle[fileName]);
          delete bundle[fileName];
        });
      }
      let extractedCss = outputToExtractedCSSMap.get(opts);
      if (extractedCss && !hasEmitted) {
        hasEmitted = true;
        extractedCss = await finalizeCss(extractedCss, true, config2);
        this.emitFile({
          name: cssBundleName,
          type: "asset",
          source: extractedCss
        });
      }
    }
  };
}
function createCSSResolvers(config2) {
  let cssResolve;
  let sassResolve;
  let lessResolve;
  return {
    get css() {
      return cssResolve || (cssResolve = config2.createResolver({
        extensions: [".css"],
        mainFields: ["style"],
        tryIndex: false,
        preferRelative: true
      }));
    },
    get sass() {
      return sassResolve || (sassResolve = config2.createResolver({
        extensions: [".scss", ".sass", ".css"],
        mainFields: ["sass", "style"],
        tryIndex: true,
        tryPrefix: "_",
        preferRelative: true
      }));
    },
    get less() {
      return lessResolve || (lessResolve = config2.createResolver({
        extensions: [".less", ".css"],
        mainFields: ["less", "style"],
        tryIndex: false,
        preferRelative: true
      }));
    }
  };
}
function getCssResolversKeys(resolvers) {
  return Object.keys(resolvers);
}
var configToAtImportResolvers = /* @__PURE__ */ new WeakMap();
async function compileCSS(id, code, config2, urlReplacer) {
  var _a, _b;
  const { modules: modulesOptions, preprocessorOptions, devSourcemap } = config2.css || {};
  const isModule = modulesOptions !== false && cssModuleRE.test(id);
  const needInlineImport = code.includes("@import");
  const hasUrl = cssUrlRE.test(code) || cssImageSetRE.test(code);
  const lang = (_a = id.match(cssLangRE)) == null ? void 0 : _a[1];
  const postcssConfig = await resolvePostcssConfig(config2, getCssDialect(lang));
  if (lang === "css" && !postcssConfig && !isModule && !needInlineImport && !hasUrl) {
    return { code, map: null };
  }
  let preprocessorMap;
  let modules;
  const deps = /* @__PURE__ */ new Set();
  let atImportResolvers = configToAtImportResolvers.get(config2);
  if (!atImportResolvers) {
    atImportResolvers = createCSSResolvers(config2);
    configToAtImportResolvers.set(config2, atImportResolvers);
  }
  if (isPreProcessor(lang)) {
    const preProcessor = preProcessors[lang];
    let opts = preprocessorOptions && preprocessorOptions[lang] || {};
    switch (lang) {
      case "scss":
      case "sass":
        opts = {
          includePaths: ["node_modules"],
          alias: config2.resolve.alias,
          ...opts
        };
        break;
      case "less":
      case "styl":
      case "stylus":
        opts = {
          paths: ["node_modules"],
          alias: config2.resolve.alias,
          ...opts
        };
    }
    opts.filename = cleanUrl(id);
    opts.enableSourcemap = devSourcemap != null ? devSourcemap : false;
    const preprocessResult = await preProcessor(code, config2.root, opts, atImportResolvers);
    if (preprocessResult.error) {
      throw preprocessResult.error;
    }
    code = preprocessResult.code;
    preprocessorMap = combineSourcemapsIfExists(opts.filename, preprocessResult.map, preprocessResult.additionalMap);
    if (preprocessResult.deps) {
      preprocessResult.deps.forEach((dep) => {
        if (normalizePath$3(dep) !== normalizePath$3(opts.filename)) {
          deps.add(dep);
        }
      });
    }
  }
  const postcssOptions = postcssConfig && postcssConfig.options || {};
  if (lang === "sss") {
    postcssOptions.parser = loadPreprocessor("sugarss", config2.root);
  }
  const postcssPlugins = postcssConfig && postcssConfig.plugins ? postcssConfig.plugins.slice() : [];
  if (needInlineImport) {
    postcssPlugins.unshift((await import("./dep-9deb2354-HJ7OGEW3.js").then(function(n2) {
      return n2.i;
    })).default({
      async resolve(id2, basedir) {
        const publicFile = checkPublicFile(id2, config2);
        if (publicFile) {
          return publicFile;
        }
        const resolved = await atImportResolvers.css(id2, import_node_path2.default.join(basedir, "*"));
        if (resolved) {
          return import_node_path2.default.resolve(resolved);
        }
        return id2;
      },
      nameLayer(index2) {
        return `vite--anon-layer-${getHash(id)}-${index2}`;
      }
    }));
  }
  if (urlReplacer) {
    postcssPlugins.push(UrlRewritePostcssPlugin({
      replacer: urlReplacer,
      logger: config2.logger
    }));
  }
  if (isModule) {
    postcssPlugins.unshift((await import("./dep-4d50f047-O73JNVEJ.js").then(function(n2) {
      return n2.i;
    })).default({
      ...modulesOptions,
      localsConvention: (_b = modulesOptions == null ? void 0 : modulesOptions.localsConvention) != null ? _b : void 0,
      getJSON(cssFileName, _modules, outputFileName) {
        modules = _modules;
        if (modulesOptions && typeof modulesOptions.getJSON === "function") {
          modulesOptions.getJSON(cssFileName, _modules, outputFileName);
        }
      },
      async resolve(id2, importer) {
        for (const key2 of getCssResolversKeys(atImportResolvers)) {
          const resolved = await atImportResolvers[key2](id2, importer);
          if (resolved) {
            return import_node_path2.default.resolve(resolved);
          }
        }
        return id2;
      }
    }));
  }
  if (!postcssPlugins.length) {
    return {
      code,
      map: preprocessorMap
    };
  }
  let postcssResult;
  try {
    const source2 = removeDirectQuery(id);
    postcssResult = await (await import("./postcss-TMBBAAUU.js")).default(postcssPlugins).process(code, {
      ...postcssOptions,
      to: source2,
      from: source2,
      ...devSourcemap ? {
        map: {
          inline: false,
          annotation: false,
          sourcesContent: true
        }
      } : {}
    });
    for (const message of postcssResult.messages) {
      if (message.type === "dependency") {
        deps.add(normalizePath$3(message.file));
      } else if (message.type === "dir-dependency") {
        const { dir, glob: globPattern = "**" } = message;
        const pattern2 = out.escapePath(normalizePath$3(import_node_path2.default.resolve(import_node_path2.default.dirname(id), dir))) + `/` + globPattern;
        const files = out.sync(pattern2, {
          ignore: ["**/node_modules/**"]
        });
        for (let i = 0; i < files.length; i++) {
          deps.add(files[i]);
        }
      } else if (message.type === "warning") {
        let msg = `[vite:css] ${message.text}`;
        if (message.line && message.column) {
          msg += `
${generateCodeFrame(code, {
            line: message.line,
            column: message.column
          })}`;
        }
        config2.logger.warn(picocolors.exports.yellow(msg));
      }
    }
  } catch (e) {
    e.message = `[postcss] ${e.message}`;
    e.code = code;
    e.loc = {
      column: e.column,
      line: e.line
    };
    throw e;
  }
  if (!devSourcemap) {
    return {
      ast: postcssResult,
      code: postcssResult.css,
      map: { mappings: "" },
      modules,
      deps
    };
  }
  const rawPostcssMap = postcssResult.map.toJSON();
  const postcssMap = await formatPostcssSourceMap(
    rawPostcssMap,
    cleanUrl(id)
  );
  return {
    ast: postcssResult,
    code: postcssResult.css,
    map: combineSourcemapsIfExists(cleanUrl(id), postcssMap, preprocessorMap),
    modules,
    deps
  };
}
async function preprocessCSS(code, filename, config2) {
  return await compileCSS(filename, code, config2);
}
async function formatPostcssSourceMap(rawMap, file) {
  const inputFileDir = import_node_path2.default.dirname(file);
  const sources = rawMap.sources.map((source2) => {
    const cleanSource = cleanUrl(decodeURIComponent(source2));
    if (/^<.+>$/.test(cleanSource)) {
      return `\0${cleanSource}`;
    }
    return normalizePath$3(import_node_path2.default.resolve(inputFileDir, cleanSource));
  });
  return {
    file,
    mappings: rawMap.mappings,
    names: rawMap.names,
    sources,
    sourcesContent: rawMap.sourcesContent,
    version: rawMap.version
  };
}
function combineSourcemapsIfExists(filename, map1, map2) {
  return map1 && map2 ? combineSourcemaps(filename, [
    map1,
    map2
  ]) : map1;
}
async function finalizeCss(css, minify, config2) {
  if (css.includes("@import") || css.includes("@charset")) {
    css = await hoistAtRules(css);
  }
  if (minify && config2.build.minify) {
    css = await minifyCSS(css, config2);
  }
  return css;
}
async function resolvePostcssConfig(config2, dialect = "css") {
  var _a, _b;
  (_a = postcssConfigCache[dialect]) != null ? _a : postcssConfigCache[dialect] = /* @__PURE__ */ new WeakMap();
  let result = postcssConfigCache[dialect].get(config2);
  if (result !== void 0) {
    return result;
  }
  const inlineOptions = (_b = config2.css) == null ? void 0 : _b.postcss;
  if (isObject$1(inlineOptions)) {
    const options3 = { ...inlineOptions };
    delete options3.plugins;
    result = {
      options: options3,
      plugins: inlineOptions.plugins || []
    };
  } else {
    const searchPath = typeof inlineOptions === "string" ? inlineOptions : config2.root;
    try {
      result = await src$1({}, searchPath);
    } catch (e) {
      if (!/No PostCSS Config found/.test(e.message)) {
        if (e instanceof Error) {
          const { name, message, stack: stack2 } = e;
          e.name = "Failed to load PostCSS config";
          e.message = `Failed to load PostCSS config (searchPath: ${searchPath}): [${name}] ${message}
${stack2}`;
          e.stack = "";
          throw e;
        } else {
          throw new Error(`Failed to load PostCSS config: ${e}`);
        }
      }
      result = null;
    }
  }
  postcssConfigCache[dialect].set(config2, result);
  return result;
}
var cssUrlRE = new RegExp(`(?<=^|[^\\w\\-\\u0080-\\uffff])url\\(\\s*('[^']+'|"[^"]+"|[^'")]+)\\s*\\)`);
var cssDataUriRE = new RegExp(`(?<=^|[^\\w\\-\\u0080-\\uffff])data-uri\\(\\s*('[^']+'|"[^"]+"|[^'")]+)\\s*\\)`);
var importCssRE = /@import ('[^']+\.css'|"[^"]+\.css"|[^'")]+\.css)/;
var cssImageSetRE = new RegExp("(?<=image-set\\()((?:[\\w\\-]+\\([^\\)]*\\)|[^)])*)(?=\\))");
var UrlRewritePostcssPlugin = (opts) => {
  if (!opts) {
    throw new Error("base or replace is required");
  }
  return {
    postcssPlugin: "vite-url-rewrite",
    Once(root2) {
      const promises2 = [];
      root2.walkDecls((declaration) => {
        var _a;
        const importer = (_a = declaration.source) == null ? void 0 : _a.input.file;
        if (!importer) {
          opts.logger.warnOnce("\nA PostCSS plugin did not pass the `from` option to `postcss.parse`. This may cause imported assets to be incorrectly transformed. If you've recently added a PostCSS plugin that raised this warning, please contact the package author to fix the issue.");
        }
        const isCssUrl = cssUrlRE.test(declaration.value);
        const isCssImageSet = cssImageSetRE.test(declaration.value);
        if (isCssUrl || isCssImageSet) {
          const replacerForDeclaration = (rawUrl) => {
            return opts.replacer(rawUrl, importer);
          };
          const rewriterToUse = isCssImageSet ? rewriteCssImageSet : rewriteCssUrls;
          promises2.push(rewriterToUse(declaration.value, replacerForDeclaration).then((url2) => {
            declaration.value = url2;
          }));
        }
      });
      if (promises2.length) {
        return Promise.all(promises2);
      }
    }
  };
};
UrlRewritePostcssPlugin.postcss = true;
function rewriteCssUrls(css, replacer) {
  return asyncReplace(css, cssUrlRE, async (match) => {
    const [matched, rawUrl] = match;
    return await doUrlReplace(rawUrl, matched, replacer);
  });
}
function rewriteCssDataUris(css, replacer) {
  return asyncReplace(css, cssDataUriRE, async (match) => {
    const [matched, rawUrl] = match;
    return await doUrlReplace(rawUrl, matched, replacer, "data-uri");
  });
}
function rewriteImportCss(css, replacer) {
  return asyncReplace(css, importCssRE, async (match) => {
    const [matched, rawUrl] = match;
    return await doImportCSSReplace(rawUrl, matched, replacer);
  });
}
var cssNotProcessedRE = /(gradient|element|cross-fade|image)\(/;
async function rewriteCssImageSet(css, replacer) {
  return await asyncReplace(css, cssImageSetRE, async (match) => {
    const [, rawUrl] = match;
    const url2 = await processSrcSet(rawUrl, async ({ url: url3 }) => {
      if (cssUrlRE.test(url3)) {
        return await rewriteCssUrls(url3, replacer);
      }
      if (!cssNotProcessedRE.test(url3)) {
        return await doUrlReplace(url3, url3, replacer);
      }
      return url3;
    });
    return url2;
  });
}
async function doUrlReplace(rawUrl, matched, replacer, funcName = "url") {
  let wrap2 = "";
  const first2 = rawUrl[0];
  if (first2 === `"` || first2 === `'`) {
    wrap2 = first2;
    rawUrl = rawUrl.slice(1, -1);
  }
  if (isExternalUrl(rawUrl) || isDataUrl(rawUrl) || rawUrl.startsWith("#") || varRE.test(rawUrl)) {
    return matched;
  }
  const newUrl = await replacer(rawUrl);
  if (wrap2 === "" && newUrl !== encodeURI(newUrl)) {
    wrap2 = "'";
  }
  return `${funcName}(${wrap2}${newUrl}${wrap2})`;
}
async function doImportCSSReplace(rawUrl, matched, replacer) {
  let wrap2 = "";
  const first2 = rawUrl[0];
  if (first2 === `"` || first2 === `'`) {
    wrap2 = first2;
    rawUrl = rawUrl.slice(1, -1);
  }
  if (isExternalUrl(rawUrl) || isDataUrl(rawUrl) || rawUrl.startsWith("#")) {
    return matched;
  }
  return `@import ${wrap2}${await replacer(rawUrl)}${wrap2}`;
}
async function minifyCSS(css, config2) {
  try {
    const { code, warnings } = await (0, import_esbuild.transform)(css, {
      loader: "css",
      target: config2.build.cssTarget || void 0,
      ...resolveEsbuildMinifyOptions(config2.esbuild || {})
    });
    if (warnings.length) {
      const msgs = await (0, import_esbuild.formatMessages)(warnings, { kind: "warning" });
      config2.logger.warn(picocolors.exports.yellow(`warnings when minifying css:
${msgs.join("\n")}`));
    }
    return code;
  } catch (e) {
    if (e.errors) {
      e.message = "[esbuild css minify] " + e.message;
      const msgs = await (0, import_esbuild.formatMessages)(e.errors, { kind: "error" });
      e.frame = "\n" + msgs.join("\n");
      e.loc = e.errors[0].location;
    }
    throw e;
  }
}
function resolveEsbuildMinifyOptions(options3) {
  var _a, _b, _c;
  const base2 = {
    logLevel: options3.logLevel,
    logLimit: options3.logLimit,
    logOverride: options3.logOverride
  };
  if (options3.minifyIdentifiers != null || options3.minifySyntax != null || options3.minifyWhitespace != null) {
    return {
      ...base2,
      minifyIdentifiers: (_a = options3.minifyIdentifiers) != null ? _a : true,
      minifySyntax: (_b = options3.minifySyntax) != null ? _b : true,
      minifyWhitespace: (_c = options3.minifyWhitespace) != null ? _c : true
    };
  } else {
    return { ...base2, minify: true };
  }
}
async function hoistAtRules(css) {
  const s = new MagicString(css);
  const cleanCss = emptyCssComments(css);
  let match;
  const atImportRE = new RegExp(`@import\\s*(?:url\\([^\\)]*\\)|"([^"]|(?<=\\\\)")*"|'([^']|(?<=\\\\)')*'|[^;]*).*?;`, "gm");
  while (match = atImportRE.exec(cleanCss)) {
    s.remove(match.index, match.index + match[0].length);
    s.appendLeft(0, match[0]);
  }
  const atCharsetRE = new RegExp(`@charset\\s*(?:"([^"]|(?<=\\\\)")*"|'([^']|(?<=\\\\)')*'|[^;]*).*?;`, "gm");
  let foundCharset = false;
  while (match = atCharsetRE.exec(cleanCss)) {
    s.remove(match.index, match.index + match[0].length);
    if (!foundCharset) {
      s.prepend(match[0]);
      foundCharset = true;
    }
  }
  return s.toString();
}
var loadedPreprocessors = {};
var _require$1 = (0, import_node_module.createRequire)(import.meta.url);
function loadPreprocessor(lang, root2) {
  if (lang in loadedPreprocessors) {
    return loadedPreprocessors[lang];
  }
  try {
    const resolved = requireResolveFromRootWithFallback(root2, lang);
    return loadedPreprocessors[lang] = _require$1(resolved);
  } catch (e) {
    if (e.code === "MODULE_NOT_FOUND") {
      throw new Error(`Preprocessor dependency "${lang}" not found. Did you install it?`);
    } else {
      const message = new Error(`Preprocessor dependency "${lang}" failed to load:
${e.message}`);
      message.stack = e.stack + "\n" + message.stack;
      throw message;
    }
  }
}
var scss = async (source2, root2, options3, resolvers) => {
  const render = loadPreprocessor("sass", root2).render;
  const internalImporter = (url2, importer2, done) => {
    resolvers.sass(url2, importer2).then((resolved) => {
      if (resolved) {
        rebaseUrls(resolved, options3.filename, options3.alias, "$").then((data3) => done == null ? void 0 : done(data3)).catch((data3) => done == null ? void 0 : done(data3));
      } else {
        done == null ? void 0 : done(null);
      }
    });
  };
  const importer = [internalImporter];
  if (options3.importer) {
    Array.isArray(options3.importer) ? importer.unshift(...options3.importer) : importer.unshift(options3.importer);
  }
  const { content: data2, map: additionalMap } = await getSource(source2, options3.filename, options3.additionalData, options3.enableSourcemap);
  const finalOptions = {
    ...options3,
    data: data2,
    file: options3.filename,
    outFile: options3.filename,
    importer,
    ...options3.enableSourcemap ? {
      sourceMap: true,
      omitSourceMapUrl: true,
      sourceMapRoot: import_node_path2.default.dirname(options3.filename)
    } : {}
  };
  try {
    const result = await new Promise((resolve3, reject) => {
      render(finalOptions, (err, res) => {
        if (err) {
          reject(err);
        } else {
          resolve3(res);
        }
      });
    });
    const deps = result.stats.includedFiles;
    const map2 = result.map ? JSON.parse(result.map.toString()) : void 0;
    return {
      code: result.css.toString(),
      map: map2,
      additionalMap,
      deps
    };
  } catch (e) {
    e.message = `[sass] ${e.message}`;
    e.id = e.file;
    e.frame = e.formatted;
    return { code: "", error: e, deps: [] };
  }
};
var sass = (source2, root2, options3, aliasResolver) => scss(source2, root2, {
  ...options3,
  indentedSyntax: true
}, aliasResolver);
async function rebaseUrls(file, rootFile, alias2, variablePrefix) {
  file = import_node_path2.default.resolve(file);
  const fileDir = import_node_path2.default.dirname(file);
  const rootDir = import_node_path2.default.dirname(rootFile);
  if (fileDir === rootDir) {
    return { file };
  }
  const content = import_node_fs.default.readFileSync(file, "utf-8");
  const hasUrls = cssUrlRE.test(content);
  const hasDataUris = cssDataUriRE.test(content);
  const hasImportCss = importCssRE.test(content);
  if (!hasUrls && !hasDataUris && !hasImportCss) {
    return { file };
  }
  let rebased;
  const rebaseFn = (url2) => {
    if (url2.startsWith("/"))
      return url2;
    if (url2.startsWith(variablePrefix))
      return url2;
    for (const { find: find2 } of alias2) {
      const matches2 = typeof find2 === "string" ? url2.startsWith(find2) : find2.test(url2);
      if (matches2) {
        return url2;
      }
    }
    const absolute = import_node_path2.default.resolve(fileDir, url2);
    const relative2 = import_node_path2.default.relative(rootDir, absolute);
    return normalizePath$3(relative2);
  };
  if (hasImportCss) {
    rebased = await rewriteImportCss(content, rebaseFn);
  }
  if (hasUrls) {
    rebased = await rewriteCssUrls(rebased || content, rebaseFn);
  }
  if (hasDataUris) {
    rebased = await rewriteCssDataUris(rebased || content, rebaseFn);
  }
  return {
    file,
    contents: rebased
  };
}
var less = async (source2, root2, options3, resolvers) => {
  const nodeLess = loadPreprocessor("less", root2);
  const viteResolverPlugin = createViteLessPlugin(nodeLess, options3.filename, options3.alias, resolvers);
  const { content, map: additionalMap } = await getSource(source2, options3.filename, options3.additionalData, options3.enableSourcemap);
  let result;
  try {
    result = await nodeLess.render(content, {
      ...options3,
      plugins: [viteResolverPlugin, ...options3.plugins || []],
      ...options3.enableSourcemap ? {
        sourceMap: {
          outputSourceFiles: true,
          sourceMapFileInline: false
        }
      } : {}
    });
  } catch (e) {
    const error2 = e;
    const normalizedError = new Error(`[less] ${error2.message || error2.type}`);
    normalizedError.loc = {
      file: error2.filename || options3.filename,
      line: error2.line,
      column: error2.column
    };
    return { code: "", error: normalizedError, deps: [] };
  }
  const map2 = result.map && JSON.parse(result.map);
  if (map2) {
    delete map2.sourcesContent;
  }
  return {
    code: result.css.toString(),
    map: map2,
    additionalMap,
    deps: result.imports
  };
};
var ViteLessManager;
function createViteLessPlugin(less2, rootFile, alias2, resolvers) {
  if (!ViteLessManager) {
    ViteLessManager = class ViteManager extends less2.FileManager {
      constructor(rootFile2, resolvers2, alias3) {
        super();
        this.rootFile = rootFile2;
        this.resolvers = resolvers2;
        this.alias = alias3;
      }
      supports() {
        return true;
      }
      supportsSync() {
        return false;
      }
      async loadFile(filename, dir, opts, env2) {
        const resolved = await this.resolvers.less(filename, import_node_path2.default.join(dir, "*"));
        if (resolved) {
          const result = await rebaseUrls(resolved, this.rootFile, this.alias, "@");
          let contents;
          if (result && "contents" in result) {
            contents = result.contents;
          } else {
            contents = import_node_fs.default.readFileSync(resolved, "utf-8");
          }
          return {
            filename: import_node_path2.default.resolve(resolved),
            contents
          };
        } else {
          return super.loadFile(filename, dir, opts, env2);
        }
      }
    };
  }
  return {
    install(_, pluginManager) {
      pluginManager.addFileManager(new ViteLessManager(rootFile, resolvers, alias2));
    },
    minVersion: [3, 0, 0]
  };
}
var styl = async (source2, root2, options3) => {
  var _a;
  const nodeStylus = loadPreprocessor("stylus", root2);
  const { content, map: additionalMap } = await getSource(source2, options3.filename, options3.additionalData, options3.enableSourcemap, "\n");
  const importsDeps = ((_a = options3.imports) != null ? _a : []).map((dep) => import_node_path2.default.resolve(dep));
  try {
    const ref2 = nodeStylus(content, options3);
    if (options3.enableSourcemap) {
      ref2.set("sourcemap", {
        comment: false,
        inline: false,
        basePath: root2
      });
    }
    const result = ref2.render();
    const deps = [...ref2.deps(), ...importsDeps];
    const map2 = ref2.sourcemap;
    return {
      code: result,
      map: formatStylusSourceMap(map2, root2),
      additionalMap,
      deps
    };
  } catch (e) {
    e.message = `[stylus] ${e.message}`;
    return { code: "", error: e, deps: [] };
  }
};
function formatStylusSourceMap(mapBefore, root2) {
  if (!mapBefore)
    return void 0;
  const map2 = { ...mapBefore };
  const resolveFromRoot = (p) => normalizePath$3(import_node_path2.default.resolve(root2, p));
  if (map2.file) {
    map2.file = resolveFromRoot(map2.file);
  }
  map2.sources = map2.sources.map(resolveFromRoot);
  return map2;
}
async function getSource(source2, filename, additionalData, enableSourcemap, sep2 = "") {
  if (!additionalData)
    return { content: source2 };
  if (typeof additionalData === "function") {
    const newContent = await additionalData(source2, filename);
    if (typeof newContent === "string") {
      return { content: newContent };
    }
    return newContent;
  }
  if (!enableSourcemap) {
    return { content: additionalData + sep2 + source2 };
  }
  const ms2 = new MagicString(source2);
  ms2.appendLeft(0, sep2);
  ms2.appendLeft(0, additionalData);
  const map2 = ms2.generateMap({ hires: true });
  map2.file = filename;
  map2.sources = [filename];
  return {
    content: ms2.toString(),
    map: map2
  };
}
var preProcessors = Object.freeze({
  ["less"]: less,
  ["sass"]: sass,
  ["scss"]: scss,
  ["styl"]: styl,
  ["stylus"]: styl
});
function isPreProcessor(lang) {
  return lang && lang in preProcessors;
}
function getCssDialect(lang) {
  return lang === "sss" ? "sss" : "css";
}
function manifestPlugin(config2) {
  const manifest = {};
  let outputCount;
  return {
    name: "vite:manifest",
    buildStart() {
      outputCount = 0;
    },
    generateBundle({ format: format2 }, bundle) {
      var _a;
      function getChunkName(chunk) {
        if (chunk.facadeModuleId) {
          let name = normalizePath$3(import_node_path2.default.relative(config2.root, chunk.facadeModuleId));
          if (format2 === "system" && !chunk.name.includes("-legacy")) {
            const ext2 = import_node_path2.default.extname(name);
            const endPos = ext2.length !== 0 ? -ext2.length : void 0;
            name = name.slice(0, endPos) + `-legacy` + ext2;
          }
          return name.replace(/\0/g, "");
        } else {
          return `_` + import_node_path2.default.basename(chunk.fileName);
        }
      }
      function getInternalImports(imports) {
        const filteredImports = [];
        for (const file of imports) {
          if (bundle[file] === void 0) {
            continue;
          }
          filteredImports.push(getChunkName(bundle[file]));
        }
        return filteredImports;
      }
      function createChunk(chunk) {
        const manifestChunk = {
          file: chunk.fileName
        };
        if (chunk.facadeModuleId) {
          manifestChunk.src = getChunkName(chunk);
        }
        if (chunk.isEntry) {
          manifestChunk.isEntry = true;
        }
        if (chunk.isDynamicEntry) {
          manifestChunk.isDynamicEntry = true;
        }
        if (chunk.imports.length) {
          const internalImports = getInternalImports(chunk.imports);
          if (internalImports.length > 0) {
            manifestChunk.imports = internalImports;
          }
        }
        if (chunk.dynamicImports.length) {
          const internalImports = getInternalImports(chunk.dynamicImports);
          if (internalImports.length > 0) {
            manifestChunk.dynamicImports = internalImports;
          }
        }
        if (chunk.viteMetadata.importedCss.size) {
          manifestChunk.css = [...chunk.viteMetadata.importedCss];
        }
        if (chunk.viteMetadata.importedAssets.size) {
          manifestChunk.assets = [...chunk.viteMetadata.importedAssets];
        }
        return manifestChunk;
      }
      function createAsset(chunk) {
        const manifestChunk = {
          file: chunk.fileName,
          src: chunk.name
        };
        if (cssEntryFiles.has(chunk.name))
          manifestChunk.isEntry = true;
        return manifestChunk;
      }
      const cssEntryFiles = cssEntryFilesCache.get(config2);
      for (const file in bundle) {
        const chunk = bundle[file];
        if (chunk.type === "chunk") {
          manifest[getChunkName(chunk)] = createChunk(chunk);
        } else if (chunk.type === "asset" && typeof chunk.name === "string") {
          manifest[chunk.name] = createAsset(chunk);
        }
      }
      duplicateAssets.get(config2).forEach((asset) => {
        const chunk = createAsset(asset);
        manifest[asset.name] = chunk;
      });
      outputCount++;
      const output = (_a = config2.build.rollupOptions) == null ? void 0 : _a.output;
      const outputLength = Array.isArray(output) ? output.length : 1;
      if (outputCount >= outputLength) {
        this.emitFile({
          fileName: typeof config2.build.manifest === "string" ? config2.build.manifest : "manifest.json",
          type: "asset",
          source: JSON.stringify(manifest, null, 2)
        });
      }
    }
  };
}
var dataUriRE = /^([^/]+\/[^;,]+)(;base64)?,([\s\S]*)$/;
var dataUriPrefix = `/@data-uri/`;
function dataURIPlugin() {
  let resolved;
  return {
    name: "vite:data-uri",
    buildStart() {
      resolved = {};
    },
    resolveId(id) {
      if (!dataUriRE.test(id)) {
        return null;
      }
      const uri = new import_node_url2.URL(id);
      if (uri.protocol !== "data:") {
        return null;
      }
      const match = uri.pathname.match(dataUriRE);
      if (!match) {
        return null;
      }
      const [, mime, format2, data2] = match;
      if (mime !== "text/javascript") {
        throw new Error(`data URI with non-JavaScript mime type is not supported.`);
      }
      const base64 = format2 && /base64/i.test(format2.substring(1));
      const content = base64 ? Buffer.from(data2, "base64").toString("utf-8") : data2;
      resolved[id] = content;
      return dataUriPrefix + id;
    },
    load(id) {
      if (id.startsWith(dataUriPrefix)) {
        id = id.slice(dataUriPrefix.length);
        return resolved[id] || null;
      }
    }
  };
}
function ssrManifestPlugin(config2) {
  const ssrManifest = {};
  const base2 = config2.base;
  return {
    name: "vite:ssr-manifest",
    generateBundle(_options, bundle) {
      var _a;
      for (const file in bundle) {
        const chunk = bundle[file];
        if (chunk.type === "chunk") {
          for (const id in chunk.modules) {
            const normalizedId = normalizePath$3((0, import_node_path2.relative)(config2.root, id));
            const mappedChunks = (_a = ssrManifest[normalizedId]) != null ? _a : ssrManifest[normalizedId] = [];
            if (!chunk.isEntry) {
              mappedChunks.push(joinUrlSegments(base2, chunk.fileName));
              chunk.viteMetadata.importedCss.forEach((file2) => {
                mappedChunks.push(joinUrlSegments(base2, file2));
              });
            }
            chunk.viteMetadata.importedAssets.forEach((file2) => {
              mappedChunks.push(joinUrlSegments(base2, file2));
            });
          }
          if (chunk.code.includes(preloadMethod)) {
            const code = chunk.code;
            let imports;
            try {
              imports = parse$b(code)[0].filter((i) => i.n && i.d > -1);
            } catch (e) {
              this.error(e, e.idx);
            }
            if (imports.length) {
              for (let index2 = 0; index2 < imports.length; index2++) {
                const { s: start, e: end, n: name } = imports[index2];
                const url2 = code.slice(start, end);
                const deps = [];
                const ownerFilename = chunk.fileName;
                const analyzed = /* @__PURE__ */ new Set();
                const addDeps = (filename) => {
                  if (filename === ownerFilename)
                    return;
                  if (analyzed.has(filename))
                    return;
                  analyzed.add(filename);
                  const chunk2 = bundle[filename];
                  if (chunk2) {
                    chunk2.viteMetadata.importedCss.forEach((file2) => {
                      deps.push(joinUrlSegments(base2, file2));
                    });
                    chunk2.imports.forEach(addDeps);
                  }
                };
                const normalizedFile = normalizePath$3((0, import_node_path2.join)((0, import_node_path2.dirname)(chunk.fileName), url2.slice(1, -1)));
                addDeps(normalizedFile);
                ssrManifest[(0, import_node_path2.basename)(name)] = deps;
              }
            }
          }
        }
      }
      this.emitFile({
        fileName: typeof config2.build.ssrManifest === "string" ? config2.build.ssrManifest : "ssr-manifest.json",
        type: "asset",
        source: JSON.stringify(ssrManifest, null, 2)
      });
    }
  };
}
function loadFallbackPlugin() {
  return {
    name: "vite:load-fallback",
    async load(id) {
      try {
        return await import_node_fs.promises.readFile(cleanUrl(id), "utf-8");
      } catch (e) {
        return import_node_fs.promises.readFile(id, "utf-8");
      }
    }
  };
}
function resolveChokidarOptions(options3) {
  const { ignored = [], ...otherOptions } = options3 != null ? options3 : {};
  const resolvedWatchOptions = {
    ignored: [
      "**/.git/**",
      "**/node_modules/**",
      "**/test-results/**",
      ...Array.isArray(ignored) ? ignored : [ignored]
    ],
    ignoreInitial: true,
    ignorePermissionErrors: true,
    ...otherOptions
  };
  return resolvedWatchOptions;
}
function completeSystemWrapPlugin() {
  const SystemJSWrapRE = /System.register\(.*(\(exports\)|\(\))/g;
  return {
    name: "vite:force-systemjs-wrap-complete",
    renderChunk(code, chunk, opts) {
      if (opts.format === "system") {
        return {
          code: code.replace(SystemJSWrapRE, (s, s1) => s.replace(s1, "(exports, module)")),
          map: null
        };
      }
    }
  };
}
var alias = {
  js: "application/javascript",
  css: "text/css",
  html: "text/html",
  json: "application/json"
};
function send$1(req2, res, content, type, options3) {
  const { etag: etag2 = etag_1(content, { weak: true }), cacheControl = "no-cache", headers, map: map2 } = options3;
  if (res.writableEnded) {
    return;
  }
  if (req2.headers["if-none-match"] === etag2) {
    res.statusCode = 304;
    res.end();
    return;
  }
  res.setHeader("Content-Type", alias[type] || type);
  res.setHeader("Cache-Control", cacheControl);
  res.setHeader("Etag", etag2);
  if (headers) {
    for (const name in headers) {
      res.setHeader(name, headers[name]);
    }
  }
  if (map2 && map2.mappings) {
    if (type === "js" || type === "css") {
      content = getCodeWithSourcemap(type, content.toString(), map2);
    }
  }
  res.statusCode = 200;
  res.end(content);
  return;
}
var ROOT_FILES = [
  "pnpm-workspace.yaml",
  "lerna.json"
];
function hasWorkspacePackageJSON(root2) {
  const path4 = (0, import_node_path2.join)(root2, "package.json");
  if (!isFileReadable(path4)) {
    return false;
  }
  const content = JSON.parse(import_node_fs.default.readFileSync(path4, "utf-8")) || {};
  return !!content.workspaces;
}
function hasRootFile(root2) {
  return ROOT_FILES.some((file) => import_node_fs.default.existsSync((0, import_node_path2.join)(root2, file)));
}
function hasPackageJSON(root2) {
  const path4 = (0, import_node_path2.join)(root2, "package.json");
  return import_node_fs.default.existsSync(path4);
}
function searchForPackageRoot(current2, root2 = current2) {
  if (hasPackageJSON(current2))
    return current2;
  const dir = (0, import_node_path2.dirname)(current2);
  if (!dir || dir === current2)
    return root2;
  return searchForPackageRoot(dir, root2);
}
function searchForWorkspaceRoot(current2, root2 = searchForPackageRoot(current2)) {
  if (hasRootFile(current2))
    return current2;
  if (hasWorkspacePackageJSON(current2))
    return current2;
  const dir = (0, import_node_path2.dirname)(current2);
  if (!dir || dir === current2)
    return root2;
  return searchForWorkspaceRoot(dir, root2);
}
var main$1 = { exports: {} };
var fs$9 = import_fs.default;
var path$9 = import_path.default;
var os$2 = import_os.default;
function log(message) {
  console.log(`[dotenv][DEBUG] ${message}`);
}
var NEWLINE = "\n";
var RE_INI_KEY_VAL = /^\s*([\w.-]+)\s*=\s*("[^"]*"|'[^']*'|.*?)(\s+#.*)?$/;
var RE_NEWLINES = /\\n/g;
var NEWLINES_MATCH = /\r\n|\n|\r/;
function parse$8(src2, options3) {
  const debug2 = Boolean(options3 && options3.debug);
  const multiline = Boolean(options3 && options3.multiline);
  const obj = {};
  const lines = src2.toString().split(NEWLINES_MATCH);
  for (let idx = 0; idx < lines.length; idx++) {
    let line2 = lines[idx];
    const keyValueArr = line2.match(RE_INI_KEY_VAL);
    if (keyValueArr != null) {
      const key2 = keyValueArr[1];
      let val = keyValueArr[2] || "";
      let end = val.length - 1;
      const isDoubleQuoted = val[0] === '"' && val[end] === '"';
      const isSingleQuoted = val[0] === "'" && val[end] === "'";
      const isMultilineDoubleQuoted = val[0] === '"' && val[end] !== '"';
      const isMultilineSingleQuoted = val[0] === "'" && val[end] !== "'";
      if (multiline && (isMultilineDoubleQuoted || isMultilineSingleQuoted)) {
        const quoteChar = isMultilineDoubleQuoted ? '"' : "'";
        val = val.substring(1);
        while (idx++ < lines.length - 1) {
          line2 = lines[idx];
          end = line2.length - 1;
          if (line2[end] === quoteChar) {
            val += NEWLINE + line2.substring(0, end);
            break;
          }
          val += NEWLINE + line2;
        }
      } else if (isSingleQuoted || isDoubleQuoted) {
        val = val.substring(1, end);
        if (isDoubleQuoted) {
          val = val.replace(RE_NEWLINES, NEWLINE);
        }
      } else {
        val = val.trim();
      }
      obj[key2] = val;
    } else if (debug2) {
      const trimmedLine = line2.trim();
      if (trimmedLine.length && trimmedLine[0] !== "#") {
        log(`Failed to match key and value when parsing line ${idx + 1}: ${line2}`);
      }
    }
  }
  return obj;
}
function resolveHome(envPath) {
  return envPath[0] === "~" ? path$9.join(os$2.homedir(), envPath.slice(1)) : envPath;
}
function config(options3) {
  let dotenvPath = path$9.resolve(process.cwd(), ".env");
  let encoding = "utf8";
  const debug2 = Boolean(options3 && options3.debug);
  const override = Boolean(options3 && options3.override);
  const multiline = Boolean(options3 && options3.multiline);
  if (options3) {
    if (options3.path != null) {
      dotenvPath = resolveHome(options3.path);
    }
    if (options3.encoding != null) {
      encoding = options3.encoding;
    }
  }
  try {
    const parsed = DotenvModule.parse(fs$9.readFileSync(dotenvPath, { encoding }), { debug: debug2, multiline });
    Object.keys(parsed).forEach(function(key2) {
      if (!Object.prototype.hasOwnProperty.call(process.env, key2)) {
        process.env[key2] = parsed[key2];
      } else {
        if (override === true) {
          process.env[key2] = parsed[key2];
        }
        if (debug2) {
          if (override === true) {
            log(`"${key2}" is already defined in \`process.env\` and WAS overwritten`);
          } else {
            log(`"${key2}" is already defined in \`process.env\` and was NOT overwritten`);
          }
        }
      }
    });
    return { parsed };
  } catch (e) {
    if (debug2) {
      log(`Failed to load ${dotenvPath} ${e.message}`);
    }
    return { error: e };
  }
}
var DotenvModule = {
  config,
  parse: parse$8
};
main$1.exports.config = DotenvModule.config;
main$1.exports.parse = DotenvModule.parse;
main$1.exports = DotenvModule;
var dotenvExpand = function(config2) {
  var environment = config2.ignoreProcessEnv ? {} : process.env;
  var interpolate = function(envValue) {
    var matches2 = envValue.match(/(.?\${?(?:[a-zA-Z0-9_]+)?}?)/g) || [];
    return matches2.reduce(function(newEnv, match) {
      var parts = /(.?)\${?([a-zA-Z0-9_]+)?}?/g.exec(match);
      var prefix = parts[1];
      var value3, replacePart;
      if (prefix === "\\") {
        replacePart = parts[0];
        value3 = replacePart.replace("\\$", "$");
      } else {
        var key2 = parts[2];
        replacePart = parts[0].substring(prefix.length);
        value3 = environment.hasOwnProperty(key2) ? environment[key2] : config2.parsed[key2] || "";
        value3 = interpolate(value3);
      }
      return newEnv.replace(replacePart, value3);
    }, envValue);
  };
  for (var configKey in config2.parsed) {
    var value2 = environment.hasOwnProperty(configKey) ? environment[configKey] : config2.parsed[configKey];
    config2.parsed[configKey] = interpolate(value2);
  }
  for (var processKey in config2.parsed) {
    environment[processKey] = config2.parsed[processKey];
  }
  return config2;
};
var main = dotenvExpand;
function loadEnv(mode2, envDir, prefixes = "VITE_") {
  if (mode2 === "local") {
    throw new Error(`"local" cannot be used as a mode name because it conflicts with the .local postfix for .env files.`);
  }
  prefixes = arraify(prefixes);
  const env2 = {};
  const envFiles = [
    `.env`,
    `.env.local`,
    `.env.${mode2}`,
    `.env.${mode2}.local`
  ];
  const parsed = Object.fromEntries(envFiles.flatMap((file) => {
    var _a;
    const path4 = lookupFile(envDir, [file], {
      pathOnly: true,
      rootDir: envDir
    });
    if (!path4)
      return [];
    return Object.entries(main$1.exports.parse(import_node_fs.default.readFileSync(path4), {
      debug: (_a = process.env.DEBUG) == null ? void 0 : _a.includes("vite:dotenv")
    }));
  }));
  main({
    parsed,
    ignoreProcessEnv: true
  });
  for (const [key2, value2] of Object.entries(parsed)) {
    if (prefixes.some((prefix) => key2.startsWith(prefix))) {
      env2[key2] = value2;
    } else if (key2 === "NODE_ENV" && process.env.VITE_USER_NODE_ENV === void 0) {
      process.env.VITE_USER_NODE_ENV = value2;
    }
  }
  for (const key2 in process.env) {
    if (prefixes.some((prefix) => key2.startsWith(prefix))) {
      env2[key2] = process.env[key2];
    }
  }
  return env2;
}
function resolveEnvPrefix({ envPrefix = "VITE_" }) {
  envPrefix = arraify(envPrefix);
  if (envPrefix.some((prefix) => prefix === "")) {
    throw new Error(`envPrefix option contains value '', which could lead unexpected exposure of sensitive information.`);
  }
  return envPrefix;
}
function resolveBuildOptions(raw, logger) {
  const deprecatedPolyfillModulePreload = raw == null ? void 0 : raw.polyfillModulePreload;
  if (raw) {
    const { polyfillModulePreload, ...rest } = raw;
    raw = rest;
    if (deprecatedPolyfillModulePreload !== void 0) {
      logger.warn("polyfillModulePreload is deprecated. Use modulePreload.polyfill instead.");
    }
    if (deprecatedPolyfillModulePreload === false && raw.modulePreload === void 0) {
      raw.modulePreload = { polyfill: false };
    }
  }
  const modulePreload = raw == null ? void 0 : raw.modulePreload;
  const defaultModulePreload = {
    polyfill: true
  };
  const defaultBuildOptions = {
    outDir: "dist",
    assetsDir: "assets",
    assetsInlineLimit: 4096,
    cssCodeSplit: !(raw == null ? void 0 : raw.lib),
    sourcemap: false,
    rollupOptions: {},
    minify: (raw == null ? void 0 : raw.ssr) ? false : "esbuild",
    terserOptions: {},
    write: true,
    emptyOutDir: null,
    copyPublicDir: true,
    manifest: false,
    lib: false,
    ssr: false,
    ssrManifest: false,
    reportCompressedSize: true,
    chunkSizeWarningLimit: 500,
    watch: null
  };
  const userBuildOptions = raw ? mergeConfig(defaultBuildOptions, raw) : defaultBuildOptions;
  const resolved = {
    target: "modules",
    cssTarget: false,
    ...userBuildOptions,
    commonjsOptions: {
      include: [/node_modules/],
      extensions: [".js", ".cjs"],
      ...userBuildOptions.commonjsOptions
    },
    dynamicImportVarsOptions: {
      warnOnError: true,
      exclude: [/node_modules/],
      ...userBuildOptions.dynamicImportVarsOptions
    },
    modulePreload: modulePreload === false ? false : typeof modulePreload === "object" ? {
      ...defaultModulePreload,
      ...modulePreload
    } : defaultModulePreload
  };
  if (resolved.target === "modules") {
    resolved.target = ESBUILD_MODULES_TARGET;
  } else if (resolved.target === "esnext" && resolved.minify === "terser") {
    resolved.target = "es2021";
  }
  if (!resolved.cssTarget) {
    resolved.cssTarget = resolved.target;
  }
  if (resolved.minify === "false") {
    resolved.minify = false;
  }
  if (resolved.minify === true) {
    resolved.minify = "esbuild";
  }
  return resolved;
}
function resolveBuildPlugins(config2) {
  const options3 = config2.build;
  const { commonjsOptions } = options3;
  const usePluginCommonjs = !Array.isArray(commonjsOptions == null ? void 0 : commonjsOptions.include) || (commonjsOptions == null ? void 0 : commonjsOptions.include.length) !== 0;
  return {
    pre: [
      completeSystemWrapPlugin(),
      ...options3.watch ? [ensureWatchPlugin()] : [],
      watchPackageDataPlugin(config2),
      ...usePluginCommonjs ? [commonjs(options3.commonjsOptions)] : [],
      dataURIPlugin(),
      ...options3.rollupOptions.plugins ? options3.rollupOptions.plugins.filter(Boolean) : []
    ],
    post: [
      buildImportAnalysisPlugin(config2),
      ...config2.esbuild !== false ? [buildEsbuildPlugin(config2)] : [],
      ...options3.minify ? [terserPlugin(config2)] : [],
      ...options3.manifest ? [manifestPlugin(config2)] : [],
      ...options3.ssrManifest ? [ssrManifestPlugin(config2)] : [],
      buildReporterPlugin(config2),
      loadFallbackPlugin()
    ]
  };
}
var parallelCallCounts = 0;
var parallelBuilds = [];
async function build(inlineConfig = {}) {
  parallelCallCounts++;
  try {
    return await doBuild(inlineConfig);
  } finally {
    parallelCallCounts--;
    if (parallelCallCounts <= 0) {
      await Promise.all(parallelBuilds.map((bundle) => bundle.close()));
      parallelBuilds.length = 0;
    }
  }
}
async function doBuild(inlineConfig = {}) {
  var _a, _b, _c, _d, _e;
  const config2 = await resolveConfig(inlineConfig, "build", "production");
  const options3 = config2.build;
  const ssr = !!options3.ssr;
  const libOptions = options3.lib;
  config2.logger.info(picocolors.exports.cyan(`vite v${VERSION} ${picocolors.exports.green(`building ${ssr ? `SSR bundle ` : ``}for ${config2.mode}...`)}`));
  const resolve3 = (p) => import_node_path2.default.resolve(config2.root, p);
  const input = libOptions ? ((_a = options3.rollupOptions) == null ? void 0 : _a.input) || (typeof libOptions.entry === "string" ? resolve3(libOptions.entry) : Array.isArray(libOptions.entry) ? libOptions.entry.map(resolve3) : Object.fromEntries(Object.entries(libOptions.entry).map(([alias2, file]) => [
    alias2,
    resolve3(file)
  ]))) : typeof options3.ssr === "string" ? resolve3(options3.ssr) : ((_b = options3.rollupOptions) == null ? void 0 : _b.input) || resolve3("index.html");
  if (ssr && typeof input === "string" && input.endsWith(".html")) {
    throw new Error(`rollupOptions.input should not be an html file when building for SSR. Please specify a dedicated SSR entry.`);
  }
  const outDir = resolve3(options3.outDir);
  const plugins2 = ssr ? config2.plugins.map((p) => injectSsrFlagToHooks(p)) : config2.plugins;
  const userExternal = (_c = options3.rollupOptions) == null ? void 0 : _c.external;
  let external = userExternal;
  if (ssr && ((_d = config2.legacy) == null ? void 0 : _d.buildSsrCjsExternalHeuristics)) {
    external = await cjsSsrResolveExternal(config2, userExternal);
  }
  if (isDepsOptimizerEnabled(config2, ssr)) {
    await initDepsOptimizer(config2);
  }
  const rollupOptions = {
    context: "globalThis",
    preserveEntrySignatures: ssr ? "allow-extension" : libOptions ? "strict" : false,
    ...options3.rollupOptions,
    input,
    plugins: plugins2,
    external,
    onwarn(warning, warn2) {
      onRollupWarning(warning, warn2, config2);
    }
  };
  const outputBuildError = (e) => {
    let msg = picocolors.exports.red((e.plugin ? `[${e.plugin}] ` : "") + e.message);
    if (e.id) {
      msg += `
file: ${picocolors.exports.cyan(e.id + (e.loc ? `:${e.loc.line}:${e.loc.column}` : ""))}`;
    }
    if (e.frame) {
      msg += `
` + picocolors.exports.yellow(e.frame);
    }
    config2.logger.error(msg, { error: e });
  };
  try {
    const buildOutputOptions = (output = {}) => {
      var _a2;
      if (output.output) {
        config2.logger.warn(`You've set "rollupOptions.output.output" in your config. This is deprecated and will override all Vite.js default output options. Please use "rollupOptions.output" instead.`);
      }
      const ssrNodeBuild = ssr && config2.ssr.target === "node";
      const ssrWorkerBuild = ssr && config2.ssr.target === "webworker";
      const cjsSsrBuild = ssr && config2.ssr.format === "cjs";
      const format2 = output.format || (cjsSsrBuild ? "cjs" : "es");
      const jsExt = ssrNodeBuild || libOptions ? resolveOutputJsExtension(format2, (_a2 = getPkgJson(config2.root)) == null ? void 0 : _a2.type) : "js";
      return {
        dir: outDir,
        format: format2,
        exports: cjsSsrBuild ? "named" : "auto",
        sourcemap: options3.sourcemap,
        name: libOptions ? libOptions.name : void 0,
        generatedCode: "es2015",
        entryFileNames: ssr ? `[name].${jsExt}` : libOptions ? ({ name }) => resolveLibFilename(libOptions, format2, name, config2.root, jsExt) : import_node_path2.default.posix.join(options3.assetsDir, `[name].[hash].${jsExt}`),
        chunkFileNames: libOptions ? `[name].[hash].${jsExt}` : import_node_path2.default.posix.join(options3.assetsDir, `[name].[hash].${jsExt}`),
        assetFileNames: libOptions ? `[name].[ext]` : import_node_path2.default.posix.join(options3.assetsDir, `[name].[hash].[ext]`),
        inlineDynamicImports: output.format === "umd" || output.format === "iife" || ssrWorkerBuild && (typeof input === "string" || Object.keys(input).length === 1),
        ...output
      };
    };
    const outputs = resolveBuildOutputs((_e = options3.rollupOptions) == null ? void 0 : _e.output, libOptions, config2.logger);
    const normalizedOutputs = [];
    if (Array.isArray(outputs)) {
      for (const resolvedOutput of outputs) {
        normalizedOutputs.push(buildOutputOptions(resolvedOutput));
      }
    } else {
      normalizedOutputs.push(buildOutputOptions(outputs));
    }
    const outDirs = normalizedOutputs.map(({ dir }) => resolve3(dir));
    if (config2.build.watch) {
      config2.logger.info(picocolors.exports.cyan(`
watching for file changes...`));
      const resolvedChokidarOptions = resolveChokidarOptions(config2.build.watch.chokidar);
      const { watch: watch2 } = await import("./rollup.browser-ZYVR36BO.js");
      const watcher = watch2({
        ...rollupOptions,
        output: normalizedOutputs,
        watch: {
          ...config2.build.watch,
          chokidar: resolvedChokidarOptions
        }
      });
      watcher.on("event", (event) => {
        if (event.code === "BUNDLE_START") {
          config2.logger.info(picocolors.exports.cyan(`
build started...`));
          if (options3.write) {
            prepareOutDir(outDirs, options3.emptyOutDir, config2);
          }
        } else if (event.code === "BUNDLE_END") {
          event.result.close();
          config2.logger.info(picocolors.exports.cyan(`built in ${event.duration}ms.`));
        } else if (event.code === "ERROR") {
          outputBuildError(event.error);
        }
      });
      return watcher;
    }
    const { rollup } = await import("./rollup.browser-ZYVR36BO.js");
    const bundle = await rollup(rollupOptions);
    parallelBuilds.push(bundle);
    const generate2 = (output = {}) => {
      return bundle[options3.write ? "write" : "generate"](output);
    };
    if (options3.write) {
      prepareOutDir(outDirs, options3.emptyOutDir, config2);
    }
    const res = [];
    for (const output of normalizedOutputs) {
      res.push(await generate2(output));
    }
    return Array.isArray(outputs) ? res : res[0];
  } catch (e) {
    outputBuildError(e);
    throw e;
  }
}
function prepareOutDir(outDirs, emptyOutDir, config2) {
  const nonDuplicateDirs = new Set(outDirs);
  let outside = false;
  if (emptyOutDir == null) {
    for (const outDir of nonDuplicateDirs) {
      if (import_node_fs.default.existsSync(outDir) && !normalizePath$3(outDir).startsWith(config2.root + "/")) {
        config2.logger.warn(picocolors.exports.yellow(`
${picocolors.exports.bold(`(!)`)} outDir ${picocolors.exports.white(picocolors.exports.dim(outDir))} is not inside project root and will not be emptied.
Use --emptyOutDir to override.
`));
        outside = true;
        break;
      }
    }
  }
  for (const outDir of nonDuplicateDirs) {
    if (!outside && emptyOutDir !== false && import_node_fs.default.existsSync(outDir)) {
      const skipDirs = outDirs.map((dir) => {
        const relative2 = import_node_path2.default.relative(outDir, dir);
        if (relative2 && !relative2.startsWith("..") && !import_node_path2.default.isAbsolute(relative2)) {
          return relative2;
        }
        return "";
      }).filter(Boolean);
      emptyDir(outDir, [...skipDirs, ".git"]);
    }
    if (config2.build.copyPublicDir && config2.publicDir && import_node_fs.default.existsSync(config2.publicDir)) {
      copyDir(config2.publicDir, outDir);
    }
  }
}
function getPkgJson(root2) {
  return JSON.parse(lookupFile(root2, ["package.json"]) || `{}`);
}
function getPkgName(name) {
  return (name == null ? void 0 : name.startsWith("@")) ? name.split("/")[1] : name;
}
function resolveOutputJsExtension(format2, type = "commonjs") {
  if (type === "module") {
    return format2 === "cjs" || format2 === "umd" ? "cjs" : "js";
  } else {
    return format2 === "es" ? "mjs" : "js";
  }
}
function resolveLibFilename(libOptions, format2, entryName, root2, extension2) {
  if (typeof libOptions.fileName === "function") {
    return libOptions.fileName(format2, entryName);
  }
  const packageJson = getPkgJson(root2);
  const name = libOptions.fileName || (typeof libOptions.entry === "string" ? getPkgName(packageJson.name) : entryName);
  if (!name)
    throw new Error('Name in package.json is required if option "build.lib.fileName" is not provided.');
  extension2 != null ? extension2 : extension2 = resolveOutputJsExtension(format2, packageJson.type);
  if (format2 === "cjs" || format2 === "es") {
    return `${name}.${extension2}`;
  }
  return `${name}.${format2}.${extension2}`;
}
function resolveBuildOutputs(outputs, libOptions, logger) {
  if (libOptions) {
    const hasMultipleEntries = typeof libOptions.entry !== "string" && Object.values(libOptions.entry).length > 1;
    const formats = libOptions.formats || (hasMultipleEntries ? ["es", "cjs"] : ["es", "umd"]);
    if (formats.includes("umd") || formats.includes("iife")) {
      if (hasMultipleEntries) {
        throw new Error(`Multiple entry points are not supported when output formats include "umd" or "iife".`);
      }
      if (!libOptions.name) {
        throw new Error(`Option "build.lib.name" is required when output formats include "umd" or "iife".`);
      }
    }
    if (!outputs) {
      return formats.map((format2) => ({ format: format2 }));
    } else if (!Array.isArray(outputs)) {
      return formats.map((format2) => ({ ...outputs, format: format2 }));
    } else if (libOptions.formats) {
      logger.warn(picocolors.exports.yellow(`"build.lib.formats" will be ignored because "build.rollupOptions.output" is already an array format`));
    }
  }
  return outputs;
}
var warningIgnoreList = [`CIRCULAR_DEPENDENCY`, `THIS_IS_UNDEFINED`];
var dynamicImportWarningIgnoreList = [
  `Unsupported expression`,
  `statically analyzed`
];
function onRollupWarning(warning, warn2, config2) {
  var _a;
  if (warning.code === "UNRESOLVED_IMPORT") {
    const id = warning.source;
    const importer = warning.importer;
    if (!importer || !/\?commonjs-external$/.test(importer)) {
      throw new Error(`[vite]: Rollup failed to resolve import "${id}" from "${importer}".
This is most likely unintended because it can break your application at runtime.
If you do want to externalize this module explicitly add it to
\`build.rollupOptions.external\``);
    }
  }
  if (warning.plugin === "rollup-plugin-dynamic-import-variables" && dynamicImportWarningIgnoreList.some((msg) => warning.message.includes(msg))) {
    return;
  }
  if (!warningIgnoreList.includes(warning.code)) {
    const userOnWarn = (_a = config2.build.rollupOptions) == null ? void 0 : _a.onwarn;
    if (userOnWarn) {
      userOnWarn(warning, warn2);
    } else if (warning.code === "PLUGIN_WARNING") {
      config2.logger.warn(`${picocolors.exports.bold(picocolors.exports.yellow(`[plugin:${warning.plugin}]`))} ${picocolors.exports.yellow(warning.message)}`);
    } else {
      warn2(warning);
    }
  }
}
async function cjsSsrResolveExternal(config2, user) {
  let knownImports;
  const dataPath = import_node_path2.default.join(getDepsCacheDir(config2, false), "_metadata.json");
  try {
    const data2 = JSON.parse(import_node_fs.default.readFileSync(dataPath, "utf-8"));
    knownImports = Object.keys(data2.optimized);
  } catch (e) {
  }
  if (!knownImports) {
    knownImports = await findKnownImports(config2, false);
  }
  const ssrExternals = cjsSsrResolveExternals(config2, knownImports);
  return (id, parentId, isResolved) => {
    const isExternal2 = cjsShouldExternalizeForSSR(id, ssrExternals);
    if (isExternal2) {
      return true;
    }
    if (user) {
      return resolveUserExternal(user, id, parentId, isResolved);
    }
  };
}
function resolveUserExternal(user, id, parentId, isResolved) {
  if (typeof user === "function") {
    return user(id, parentId, isResolved);
  } else if (Array.isArray(user)) {
    return user.some((test) => isExternal(id, test));
  } else {
    return isExternal(id, user);
  }
}
function isExternal(id, test) {
  if (typeof test === "string") {
    return id === test;
  } else {
    return test.test(id);
  }
}
function injectSsrFlagToHooks(plugin) {
  const { resolveId, load: load2, transform: transform2 } = plugin;
  return {
    ...plugin,
    resolveId: wrapSsrResolveId(resolveId),
    load: wrapSsrLoad(load2),
    transform: wrapSsrTransform(transform2)
  };
}
function wrapSsrResolveId(hook) {
  if (!hook)
    return;
  const fn = "handler" in hook ? hook.handler : hook;
  const handler = function(id, importer, options3) {
    return fn.call(this, id, importer, injectSsrFlag(options3));
  };
  if ("handler" in hook) {
    return {
      ...hook,
      handler
    };
  } else {
    return handler;
  }
}
function wrapSsrLoad(hook) {
  if (!hook)
    return;
  const fn = "handler" in hook ? hook.handler : hook;
  const handler = function(id, ...args) {
    return fn.call(this, id, injectSsrFlag(args[0]));
  };
  if ("handler" in hook) {
    return {
      ...hook,
      handler
    };
  } else {
    return handler;
  }
}
function wrapSsrTransform(hook) {
  if (!hook)
    return;
  const fn = "handler" in hook ? hook.handler : hook;
  const handler = function(code, importer, ...args) {
    return fn.call(this, code, importer, injectSsrFlag(args[0]));
  };
  if ("handler" in hook) {
    return {
      ...hook,
      handler
    };
  } else {
    return handler;
  }
}
function injectSsrFlag(options3) {
  return { ...options3 != null ? options3 : {}, ssr: true };
}
var getResolveUrl = (path4, URL2 = "URL") => `new ${URL2}(${path4}).href`;
var getRelativeUrlFromDocument = (relativePath, umd = false) => getResolveUrl(`'${relativePath}', ${umd ? `typeof document === 'undefined' ? location.href : ` : ""}document.currentScript && document.currentScript.src || document.baseURI`);
var relativeUrlMechanisms = {
  amd: (relativePath) => {
    if (relativePath[0] !== ".")
      relativePath = "./" + relativePath;
    return getResolveUrl(`require.toUrl('${relativePath}'), document.baseURI`);
  },
  cjs: (relativePath) => `(typeof document === 'undefined' ? ${getResolveUrl(`'file:' + __dirname + '/${relativePath}'`, `(require('u' + 'rl').URL)`)} : ${getRelativeUrlFromDocument(relativePath)})`,
  es: (relativePath) => getResolveUrl(`'${relativePath}', import.meta.url`),
  iife: (relativePath) => getRelativeUrlFromDocument(relativePath),
  system: (relativePath) => getResolveUrl(`'${relativePath}', module.meta.url`),
  umd: (relativePath) => `(typeof document === 'undefined' && typeof location === 'undefined' ? ${getResolveUrl(`'file:' + __dirname + '/${relativePath}'`, `(require('u' + 'rl').URL)`)} : ${getRelativeUrlFromDocument(relativePath, true)})`
};
function toOutputFilePathInJS(filename, type, hostId, hostType, config2, toRelative) {
  const { renderBuiltUrl } = config2.experimental;
  let relative2 = config2.base === "" || config2.base === "./";
  if (renderBuiltUrl) {
    const result = renderBuiltUrl(filename, {
      hostId,
      hostType,
      type,
      ssr: !!config2.build.ssr
    });
    if (typeof result === "object") {
      if (result.runtime) {
        return { runtime: result.runtime };
      }
      if (typeof result.relative === "boolean") {
        relative2 = result.relative;
      }
    } else if (result) {
      return result;
    }
  }
  if (relative2 && !config2.build.ssr) {
    return toRelative(filename, hostId);
  }
  return joinUrlSegments(config2.base, filename);
}
function createToImportMetaURLBasedRelativeRuntime(format2) {
  const toRelativePath2 = relativeUrlMechanisms[format2];
  return (filename, importer) => ({
    runtime: toRelativePath2(import_node_path2.default.posix.relative(import_node_path2.default.dirname(importer), filename))
  });
}
function toOutputFilePathWithoutRuntime(filename, type, hostId, hostType, config2, toRelative) {
  const { renderBuiltUrl } = config2.experimental;
  let relative2 = config2.base === "" || config2.base === "./";
  if (renderBuiltUrl) {
    const result = renderBuiltUrl(filename, {
      hostId,
      hostType,
      type,
      ssr: !!config2.build.ssr
    });
    if (typeof result === "object") {
      if (result.runtime) {
        throw new Error(`{ runtime: "${result.runtime} }" is not supported for assets in ${hostType} files: ${filename}`);
      }
      if (typeof result.relative === "boolean") {
        relative2 = result.relative;
      }
    } else if (result) {
      return result;
    }
  }
  if (relative2 && !config2.build.ssr) {
    return toRelative(filename, hostId);
  } else {
    return config2.base + filename;
  }
}
var toOutputFilePathInCss = toOutputFilePathWithoutRuntime;
var toOutputFilePathInHtml = toOutputFilePathWithoutRuntime;
var build$1 = {
  __proto__: null,
  resolveBuildOptions,
  resolveBuildPlugins,
  build,
  resolveLibFilename,
  resolveBuildOutputs,
  onRollupWarning,
  toOutputFilePathInJS,
  createToImportMetaURLBasedRelativeRuntime,
  toOutputFilePathWithoutRuntime,
  toOutputFilePathInCss,
  toOutputFilePathInHtml
};
var src = { exports: {} };
var browser = { exports: {} };
var debug$6 = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;
  ms = function(val, options3) {
    options3 = options3 || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse6(val);
    } else if (type === "number" && isNaN(val) === false) {
      return options3.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse6(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n2 = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n2 * y;
      case "days":
      case "day":
      case "d":
        return n2 * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n2 * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n2 * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n2 * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n2;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    if (ms2 >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (ms2 >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (ms2 >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (ms2 >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    return plural(ms2, d, "day") || plural(ms2, h, "hour") || plural(ms2, m, "minute") || plural(ms2, s, "second") || ms2 + " ms";
  }
  function plural(ms2, n2, name) {
    if (ms2 < n2) {
      return;
    }
    if (ms2 < n2 * 1.5) {
      return Math.floor(ms2 / n2) + " " + name;
    }
    return Math.ceil(ms2 / n2) + " " + name + "s";
  }
  return ms;
}
var hasRequiredDebug;
function requireDebug() {
  if (hasRequiredDebug)
    return debug$6.exports;
  hasRequiredDebug = 1;
  (function(module2, exports) {
    exports = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = requireMs();
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports.colors[Math.abs(hash) % exports.colors.length];
    }
    function createDebug(namespace) {
      function debug2() {
        if (!debug2.enabled)
          return;
        var self2 = debug2;
        var curr = +new Date();
        var ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format2) {
          if (match === "%%")
            return match;
          index2++;
          var formatter2 = exports.formatters[format2];
          if ("function" === typeof formatter2) {
            var val = args[index2];
            match = formatter2.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match;
        });
        exports.formatArgs.call(self2, args);
        var logFn = debug2.log || exports.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.enabled = exports.enabled(namespace);
      debug2.useColors = exports.useColors();
      debug2.color = selectColor(namespace);
      if ("function" === typeof exports.init) {
        exports.init(debug2);
      }
      return debug2;
    }
    function enable(namespaces) {
      exports.save(namespaces);
      exports.names = [];
      exports.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  })(debug$6, debug$6.exports);
  return debug$6.exports;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser.exports;
  hasRequiredBrowser = 1;
  (function(module2, exports) {
    exports = module2.exports = requireDebug();
    exports.log = log2;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load2;
    exports.useColors = useColors;
    exports.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
      if (!useColors2)
        return;
      var c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      var index2 = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if ("%%" === match)
          return;
        index2++;
        if ("%c" === match) {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c2);
    }
    function log2() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports.storage.removeItem("debug");
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load2() {
      var r;
      try {
        r = exports.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports.enable(load2());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  })(browser, browser.exports);
  return browser.exports;
}
var node = { exports: {} };
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode)
    return node.exports;
  hasRequiredNode = 1;
  (function(module2, exports) {
    var tty2 = import_tty.default;
    var util2 = import_util.default;
    exports = module2.exports = requireDebug();
    exports.init = init2;
    exports.log = log2;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load2;
    exports.useColors = useColors;
    exports.colors = [6, 2, 3, 4, 5, 1];
    exports.inspectOpts = Object.keys(process.env).filter(function(key2) {
      return /^debug_/i.test(key2);
    }).reduce(function(obj, key2) {
      var prop = key2.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key2];
      if (/^(yes|on|true|enabled)$/i.test(val))
        val = true;
      else if (/^(no|off|false|disabled)$/i.test(val))
        val = false;
      else if (val === "null")
        val = null;
      else
        val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (1 !== fd && 2 !== fd) {
      util2.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream4 = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty2.isatty(fd);
    }
    exports.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map(function(str) {
        return str.trim();
      }).join(" ");
    };
    exports.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
    function formatArgs(args) {
      var name = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c2 = this.color;
        var prefix = "  \x1B[3" + c2 + ";1m" + name + " \x1B[0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("\x1B[3" + c2 + "m+" + exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = new Date().toUTCString() + " " + name + " " + args[0];
      }
    }
    function log2() {
      return stream4.write(util2.format.apply(util2, arguments) + "\n");
    }
    function save(namespaces) {
      if (null == namespaces) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream5;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream5 = new tty2.WriteStream(fd2);
          stream5._type = "tty";
          if (stream5._handle && stream5._handle.unref) {
            stream5._handle.unref();
          }
          break;
        case "FILE":
          var fs2 = import_fs.default;
          stream5 = new fs2.SyncWriteStream(fd2, { autoClose: false });
          stream5._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net2 = import_net.default;
          stream5 = new net2.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream5.readable = false;
          stream5.read = null;
          stream5._type = "pipe";
          if (stream5._handle && stream5._handle.unref) {
            stream5._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream5.fd = fd2;
      stream5._isStdio = true;
      return stream5;
    }
    function init2(debug2) {
      debug2.inspectOpts = {};
      var keys = Object.keys(exports.inspectOpts);
      for (var i = 0; i < keys.length; i++) {
        debug2.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    exports.enable(load2());
  })(node, node.exports);
  return node.exports;
}
(function(module2) {
  if (typeof process !== "undefined" && process.type === "renderer") {
    module2.exports = requireBrowser();
  } else {
    module2.exports = requireNode();
  }
})(src);
var encodeurl = encodeUrl$1;
var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
var UNMATCHED_SURROGATE_PAIR_REPLACE = "$1\uFFFD$2";
function encodeUrl$1(url2) {
  return String(url2).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
}
var matchHtmlRegExp = /["'&<>]/;
var escapeHtml_1 = escapeHtml$1;
function escapeHtml$1(string2) {
  var str = "" + string2;
  var match = matchHtmlRegExp.exec(str);
  if (!match) {
    return str;
  }
  var escape2;
  var html = "";
  var index2 = 0;
  var lastIndex = 0;
  for (index2 = match.index; index2 < str.length; index2++) {
    switch (str.charCodeAt(index2)) {
      case 34:
        escape2 = "&quot;";
        break;
      case 38:
        escape2 = "&amp;";
        break;
      case 39:
        escape2 = "&#39;";
        break;
      case 60:
        escape2 = "&lt;";
        break;
      case 62:
        escape2 = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index2) {
      html += str.substring(lastIndex, index2);
    }
    lastIndex = index2 + 1;
    html += escape2;
  }
  return lastIndex !== index2 ? html + str.substring(lastIndex, index2) : html;
}
var onFinished$2 = { exports: {} };
var eeFirst = first$1;
function first$1(stuff, done) {
  if (!Array.isArray(stuff))
    throw new TypeError("arg must be an array of [ee, events...] arrays");
  var cleanups = [];
  for (var i = 0; i < stuff.length; i++) {
    var arr = stuff[i];
    if (!Array.isArray(arr) || arr.length < 2)
      throw new TypeError("each array member must be [ee, events...]");
    var ee = arr[0];
    for (var j = 1; j < arr.length; j++) {
      var event = arr[j];
      var fn = listener(event, callback);
      ee.on(event, fn);
      cleanups.push({
        ee,
        event,
        fn
      });
    }
  }
  function callback() {
    cleanup();
    done.apply(null, arguments);
  }
  function cleanup() {
    var x;
    for (var i2 = 0; i2 < cleanups.length; i2++) {
      x = cleanups[i2];
      x.ee.removeListener(x.event, x.fn);
    }
  }
  function thunk(fn2) {
    done = fn2;
  }
  thunk.cancel = cleanup;
  return thunk;
}
function listener(event, done) {
  return function onevent(arg1) {
    var args = new Array(arguments.length);
    var ee = this;
    var err = event === "error" ? arg1 : null;
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    done(err, ee, event, args);
  };
}
onFinished$2.exports = onFinished$1;
onFinished$2.exports.isFinished = isFinished$1;
var first = eeFirst;
var defer$2 = typeof setImmediate === "function" ? setImmediate : function(fn) {
  process.nextTick(fn.bind.apply(fn, arguments));
};
function onFinished$1(msg, listener2) {
  if (isFinished$1(msg) !== false) {
    defer$2(listener2, null, msg);
    return msg;
  }
  attachListener(msg, listener2);
  return msg;
}
function isFinished$1(msg) {
  var socket = msg.socket;
  if (typeof msg.finished === "boolean") {
    return Boolean(msg.finished || socket && !socket.writable);
  }
  if (typeof msg.complete === "boolean") {
    return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
  }
  return void 0;
}
function attachFinishedListener(msg, callback) {
  var eeMsg;
  var eeSocket;
  var finished = false;
  function onFinish(error2) {
    eeMsg.cancel();
    eeSocket.cancel();
    finished = true;
    callback(error2);
  }
  eeMsg = eeSocket = first([[msg, "end", "finish"]], onFinish);
  function onSocket(socket) {
    msg.removeListener("socket", onSocket);
    if (finished)
      return;
    if (eeMsg !== eeSocket)
      return;
    eeSocket = first([[socket, "error", "close"]], onFinish);
  }
  if (msg.socket) {
    onSocket(msg.socket);
    return;
  }
  msg.on("socket", onSocket);
  if (msg.socket === void 0) {
    patchAssignSocket(msg, onSocket);
  }
}
function attachListener(msg, listener2) {
  var attached = msg.__onFinished;
  if (!attached || !attached.queue) {
    attached = msg.__onFinished = createListener(msg);
    attachFinishedListener(msg, attached);
  }
  attached.queue.push(listener2);
}
function createListener(msg) {
  function listener2(err) {
    if (msg.__onFinished === listener2)
      msg.__onFinished = null;
    if (!listener2.queue)
      return;
    var queue2 = listener2.queue;
    listener2.queue = null;
    for (var i = 0; i < queue2.length; i++) {
      queue2[i](err, msg);
    }
  }
  listener2.queue = [];
  return listener2;
}
function patchAssignSocket(res, callback) {
  var assignSocket = res.assignSocket;
  if (typeof assignSocket !== "function")
    return;
  res.assignSocket = function _assignSocket(socket) {
    assignSocket.call(this, socket);
    callback(socket);
  };
}
var parseurl$1 = { exports: {} };
var url$3 = import_url.default;
var parse$7 = url$3.parse;
var Url = url$3.Url;
parseurl$1.exports = parseurl;
parseurl$1.exports.original = originalurl;
function parseurl(req2) {
  var url2 = req2.url;
  if (url2 === void 0) {
    return void 0;
  }
  var parsed = req2._parsedUrl;
  if (fresh(url2, parsed)) {
    return parsed;
  }
  parsed = fastparse(url2);
  parsed._raw = url2;
  return req2._parsedUrl = parsed;
}
function originalurl(req2) {
  var url2 = req2.originalUrl;
  if (typeof url2 !== "string") {
    return parseurl(req2);
  }
  var parsed = req2._parsedOriginalUrl;
  if (fresh(url2, parsed)) {
    return parsed;
  }
  parsed = fastparse(url2);
  parsed._raw = url2;
  return req2._parsedOriginalUrl = parsed;
}
function fastparse(str) {
  if (typeof str !== "string" || str.charCodeAt(0) !== 47) {
    return parse$7(str);
  }
  var pathname = str;
  var query = null;
  var search = null;
  for (var i = 1; i < str.length; i++) {
    switch (str.charCodeAt(i)) {
      case 63:
        if (search === null) {
          pathname = str.substring(0, i);
          query = str.substring(i + 1);
          search = str.substring(i);
        }
        break;
      case 9:
      case 10:
      case 12:
      case 13:
      case 32:
      case 35:
      case 160:
      case 65279:
        return parse$7(str);
    }
  }
  var url2 = Url !== void 0 ? new Url() : {};
  url2.path = str;
  url2.href = str;
  url2.pathname = pathname;
  if (search !== null) {
    url2.query = query;
    url2.search = search;
  }
  return url2;
}
function fresh(url2, parsedUrl) {
  return typeof parsedUrl === "object" && parsedUrl !== null && (Url === void 0 || parsedUrl instanceof Url) && parsedUrl._raw === url2;
}
var require$$0$1 = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "103": "Early Hints",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "306": "(Unused)",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
};
var codes = require$$0$1;
var statuses$1 = status;
status.STATUS_CODES = codes;
status.codes = populateStatusesMap(status, codes);
status.redirect = {
  300: true,
  301: true,
  302: true,
  303: true,
  305: true,
  307: true,
  308: true
};
status.empty = {
  204: true,
  205: true,
  304: true
};
status.retry = {
  502: true,
  503: true,
  504: true
};
function populateStatusesMap(statuses2, codes2) {
  var arr = [];
  Object.keys(codes2).forEach(function forEachCode(code) {
    var message = codes2[code];
    var status2 = Number(code);
    statuses2[status2] = message;
    statuses2[message] = status2;
    statuses2[message.toLowerCase()] = status2;
    arr.push(status2);
  });
  return arr;
}
function status(code) {
  if (typeof code === "number") {
    if (!status[code])
      throw new Error("invalid status code: " + code);
    return code;
  }
  if (typeof code !== "string") {
    throw new TypeError("code must be a number or string");
  }
  var n2 = parseInt(code, 10);
  if (!isNaN(n2)) {
    if (!status[n2])
      throw new Error("invalid status code: " + n2);
    return n2;
  }
  n2 = status[code.toLowerCase()];
  if (!n2)
    throw new Error('invalid status message: "' + code + '"');
  return n2;
}
var unpipe_1 = unpipe$1;
function hasPipeDataListeners(stream4) {
  var listeners = stream4.listeners("data");
  for (var i = 0; i < listeners.length; i++) {
    if (listeners[i].name === "ondata") {
      return true;
    }
  }
  return false;
}
function unpipe$1(stream4) {
  if (!stream4) {
    throw new TypeError("argument stream is required");
  }
  if (typeof stream4.unpipe === "function") {
    stream4.unpipe();
    return;
  }
  if (!hasPipeDataListeners(stream4)) {
    return;
  }
  var listener2;
  var listeners = stream4.listeners("close");
  for (var i = 0; i < listeners.length; i++) {
    listener2 = listeners[i];
    if (listener2.name !== "cleanup" && listener2.name !== "onclose") {
      continue;
    }
    listener2.call(stream4);
  }
}
var debug$5 = src.exports("finalhandler");
var encodeUrl = encodeurl;
var escapeHtml = escapeHtml_1;
var onFinished = onFinished$2.exports;
var parseUrl$1 = parseurl$1.exports;
var statuses = statuses$1;
var unpipe = unpipe_1;
var DOUBLE_SPACE_REGEXP = /\x20{2}/g;
var NEWLINE_REGEXP = /\n/g;
var defer$1 = typeof setImmediate === "function" ? setImmediate : function(fn) {
  process.nextTick(fn.bind.apply(fn, arguments));
};
var isFinished = onFinished.isFinished;
function createHtmlDocument(message) {
  var body = escapeHtml(message).replace(NEWLINE_REGEXP, "<br>").replace(DOUBLE_SPACE_REGEXP, " &nbsp;");
  return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>Error</title>\n</head>\n<body>\n<pre>' + body + "</pre>\n</body>\n</html>\n";
}
var finalhandler_1 = finalhandler$1;
function finalhandler$1(req2, res, options3) {
  var opts = options3 || {};
  var env2 = opts.env || "development";
  var onerror = opts.onerror;
  return function(err) {
    var headers;
    var msg;
    var status2;
    if (!err && headersSent(res)) {
      debug$5("cannot 404 after headers sent");
      return;
    }
    if (err) {
      status2 = getErrorStatusCode(err);
      if (status2 === void 0) {
        status2 = getResponseStatusCode(res);
      } else {
        headers = getErrorHeaders(err);
      }
      msg = getErrorMessage(err, status2, env2);
    } else {
      status2 = 404;
      msg = "Cannot " + req2.method + " " + encodeUrl(getResourceName(req2));
    }
    debug$5("default %s", status2);
    if (err && onerror) {
      defer$1(onerror, err, req2, res);
    }
    if (headersSent(res)) {
      debug$5("cannot %d after headers sent", status2);
      req2.socket.destroy();
      return;
    }
    send(req2, res, status2, headers, msg);
  };
}
function getErrorHeaders(err) {
  if (!err.headers || typeof err.headers !== "object") {
    return void 0;
  }
  var headers = /* @__PURE__ */ Object.create(null);
  var keys = Object.keys(err.headers);
  for (var i = 0; i < keys.length; i++) {
    var key2 = keys[i];
    headers[key2] = err.headers[key2];
  }
  return headers;
}
function getErrorMessage(err, status2, env2) {
  var msg;
  if (env2 !== "production") {
    msg = err.stack;
    if (!msg && typeof err.toString === "function") {
      msg = err.toString();
    }
  }
  return msg || statuses[status2];
}
function getErrorStatusCode(err) {
  if (typeof err.status === "number" && err.status >= 400 && err.status < 600) {
    return err.status;
  }
  if (typeof err.statusCode === "number" && err.statusCode >= 400 && err.statusCode < 600) {
    return err.statusCode;
  }
  return void 0;
}
function getResourceName(req2) {
  try {
    return parseUrl$1.original(req2).pathname;
  } catch (e) {
    return "resource";
  }
}
function getResponseStatusCode(res) {
  var status2 = res.statusCode;
  if (typeof status2 !== "number" || status2 < 400 || status2 > 599) {
    status2 = 500;
  }
  return status2;
}
function headersSent(res) {
  return typeof res.headersSent !== "boolean" ? Boolean(res._header) : res.headersSent;
}
function send(req2, res, status2, headers, message) {
  function write() {
    var body = createHtmlDocument(message);
    res.statusCode = status2;
    res.statusMessage = statuses[status2];
    setHeaders(res, headers);
    res.setHeader("Content-Security-Policy", "default-src 'none'");
    res.setHeader("X-Content-Type-Options", "nosniff");
    res.setHeader("Content-Type", "text/html; charset=utf-8");
    res.setHeader("Content-Length", Buffer.byteLength(body, "utf8"));
    if (req2.method === "HEAD") {
      res.end();
      return;
    }
    res.end(body, "utf8");
  }
  if (isFinished(req2)) {
    write();
    return;
  }
  unpipe(req2);
  onFinished(req2, write);
  req2.resume();
}
function setHeaders(res, headers) {
  if (!headers) {
    return;
  }
  var keys = Object.keys(headers);
  for (var i = 0; i < keys.length; i++) {
    var key2 = keys[i];
    res.setHeader(key2, headers[key2]);
  }
}
var utilsMerge = { exports: {} };
(function(module2, exports) {
  module2.exports = function(a, b) {
    if (a && b) {
      for (var key2 in b) {
        a[key2] = b[key2];
      }
    }
    return a;
  };
})(utilsMerge);
var debug$4 = src.exports("connect:dispatcher");
var EventEmitter$3 = import_events.default.EventEmitter;
var finalhandler = finalhandler_1;
var http$4 = import_http.default;
var merge = utilsMerge.exports;
var parseUrl = parseurl$1.exports;
var connect = createServer$1;
var env = "development";
var proto = {};
var defer = typeof setImmediate === "function" ? setImmediate : function(fn) {
  process.nextTick(fn.bind.apply(fn, arguments));
};
function createServer$1() {
  function app(req2, res, next) {
    app.handle(req2, res, next);
  }
  merge(app, proto);
  merge(app, EventEmitter$3.prototype);
  app.route = "/";
  app.stack = [];
  return app;
}
proto.use = function use(route, fn) {
  var handle2 = fn;
  var path4 = route;
  if (typeof route !== "string") {
    handle2 = route;
    path4 = "/";
  }
  if (typeof handle2.handle === "function") {
    var server2 = handle2;
    server2.route = path4;
    handle2 = function(req2, res, next) {
      server2.handle(req2, res, next);
    };
  }
  if (handle2 instanceof http$4.Server) {
    handle2 = handle2.listeners("request")[0];
  }
  if (path4[path4.length - 1] === "/") {
    path4 = path4.slice(0, -1);
  }
  debug$4("use %s %s", path4 || "/", handle2.name || "anonymous");
  this.stack.push({ route: path4, handle: handle2 });
  return this;
};
proto.handle = function handle(req2, res, out2) {
  var index2 = 0;
  var protohost = getProtohost(req2.url) || "";
  var removed = "";
  var slashAdded = false;
  var stack2 = this.stack;
  var done = out2 || finalhandler(req2, res, {
    env,
    onerror: logerror
  });
  req2.originalUrl = req2.originalUrl || req2.url;
  function next(err) {
    if (slashAdded) {
      req2.url = req2.url.substr(1);
      slashAdded = false;
    }
    if (removed.length !== 0) {
      req2.url = protohost + removed + req2.url.substr(protohost.length);
      removed = "";
    }
    var layer = stack2[index2++];
    if (!layer) {
      defer(done, err);
      return;
    }
    var path4 = parseUrl(req2).pathname || "/";
    var route = layer.route;
    if (path4.toLowerCase().substr(0, route.length) !== route.toLowerCase()) {
      return next(err);
    }
    var c2 = path4.length > route.length && path4[route.length];
    if (c2 && c2 !== "/" && c2 !== ".") {
      return next(err);
    }
    if (route.length !== 0 && route !== "/") {
      removed = route;
      req2.url = protohost + req2.url.substr(protohost.length + removed.length);
      if (!protohost && req2.url[0] !== "/") {
        req2.url = "/" + req2.url;
        slashAdded = true;
      }
    }
    call(layer.handle, route, err, req2, res, next);
  }
  next();
};
proto.listen = function listen() {
  var server2 = http$4.createServer(this);
  return server2.listen.apply(server2, arguments);
};
function call(handle2, route, err, req2, res, next) {
  var arity = handle2.length;
  var error2 = err;
  var hasError = Boolean(err);
  debug$4("%s %s : %s", handle2.name || "<anonymous>", route, req2.originalUrl);
  try {
    if (hasError && arity === 4) {
      handle2(err, req2, res, next);
      return;
    } else if (!hasError && arity < 4) {
      handle2(req2, res, next);
      return;
    }
  } catch (e) {
    error2 = e;
  }
  next(error2);
}
function logerror(err) {
  if (env !== "test")
    console.error(err.stack || err.toString());
}
function getProtohost(url2) {
  if (url2.length === 0 || url2[0] === "/") {
    return void 0;
  }
  var fqdnIndex = url2.indexOf("://");
  return fqdnIndex !== -1 && url2.lastIndexOf("?", fqdnIndex) === -1 ? url2.substr(0, url2.indexOf("/", 3 + fqdnIndex)) : void 0;
}
var lib$1 = { exports: {} };
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i = 0; i < 10; i++) {
      test2["_" + String.fromCharCode(i)] = i;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
      return test2[n2];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
var objectAssign = shouldUseNative() ? Object.assign : function(target, source2) {
  var from;
  var to = toObject(target);
  var symbols;
  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);
    for (var key2 in from) {
      if (hasOwnProperty.call(from, key2)) {
        to[key2] = from[key2];
      }
    }
    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);
      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }
  return to;
};
var vary$1 = { exports: {} };
vary$1.exports = vary;
vary$1.exports.append = append;
var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
function append(header, field) {
  if (typeof header !== "string") {
    throw new TypeError("header argument is required");
  }
  if (!field) {
    throw new TypeError("field argument is required");
  }
  var fields = !Array.isArray(field) ? parse$6(String(field)) : field;
  for (var j = 0; j < fields.length; j++) {
    if (!FIELD_NAME_REGEXP.test(fields[j])) {
      throw new TypeError("field argument contains an invalid header name");
    }
  }
  if (header === "*") {
    return header;
  }
  var val = header;
  var vals = parse$6(header.toLowerCase());
  if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
    return "*";
  }
  for (var i = 0; i < fields.length; i++) {
    var fld = fields[i].toLowerCase();
    if (vals.indexOf(fld) === -1) {
      vals.push(fld);
      val = val ? val + ", " + fields[i] : fields[i];
    }
  }
  return val;
}
function parse$6(header) {
  var end = 0;
  var list = [];
  var start = 0;
  for (var i = 0, len = header.length; i < len; i++) {
    switch (header.charCodeAt(i)) {
      case 32:
        if (start === end) {
          start = end = i + 1;
        }
        break;
      case 44:
        list.push(header.substring(start, end));
        start = end = i + 1;
        break;
      default:
        end = i + 1;
        break;
    }
  }
  list.push(header.substring(start, end));
  return list;
}
function vary(res, field) {
  if (!res || !res.getHeader || !res.setHeader) {
    throw new TypeError("res argument is required");
  }
  var val = res.getHeader("Vary") || "";
  var header = Array.isArray(val) ? val.join(", ") : String(val);
  if (val = append(header, field)) {
    res.setHeader("Vary", val);
  }
}
(function() {
  var assign = objectAssign;
  var vary2 = vary$1.exports;
  var defaults = {
    origin: "*",
    methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
    preflightContinue: false,
    optionsSuccessStatus: 204
  };
  function isString2(s) {
    return typeof s === "string" || s instanceof String;
  }
  function isOriginAllowed(origin, allowedOrigin) {
    if (Array.isArray(allowedOrigin)) {
      for (var i = 0; i < allowedOrigin.length; ++i) {
        if (isOriginAllowed(origin, allowedOrigin[i])) {
          return true;
        }
      }
      return false;
    } else if (isString2(allowedOrigin)) {
      return origin === allowedOrigin;
    } else if (allowedOrigin instanceof RegExp) {
      return allowedOrigin.test(origin);
    } else {
      return !!allowedOrigin;
    }
  }
  function configureOrigin(options3, req2) {
    var requestOrigin = req2.headers.origin, headers = [], isAllowed;
    if (!options3.origin || options3.origin === "*") {
      headers.push([{
        key: "Access-Control-Allow-Origin",
        value: "*"
      }]);
    } else if (isString2(options3.origin)) {
      headers.push([{
        key: "Access-Control-Allow-Origin",
        value: options3.origin
      }]);
      headers.push([{
        key: "Vary",
        value: "Origin"
      }]);
    } else {
      isAllowed = isOriginAllowed(requestOrigin, options3.origin);
      headers.push([{
        key: "Access-Control-Allow-Origin",
        value: isAllowed ? requestOrigin : false
      }]);
      headers.push([{
        key: "Vary",
        value: "Origin"
      }]);
    }
    return headers;
  }
  function configureMethods(options3) {
    var methods = options3.methods;
    if (methods.join) {
      methods = options3.methods.join(",");
    }
    return {
      key: "Access-Control-Allow-Methods",
      value: methods
    };
  }
  function configureCredentials(options3) {
    if (options3.credentials === true) {
      return {
        key: "Access-Control-Allow-Credentials",
        value: "true"
      };
    }
    return null;
  }
  function configureAllowedHeaders(options3, req2) {
    var allowedHeaders = options3.allowedHeaders || options3.headers;
    var headers = [];
    if (!allowedHeaders) {
      allowedHeaders = req2.headers["access-control-request-headers"];
      headers.push([{
        key: "Vary",
        value: "Access-Control-Request-Headers"
      }]);
    } else if (allowedHeaders.join) {
      allowedHeaders = allowedHeaders.join(",");
    }
    if (allowedHeaders && allowedHeaders.length) {
      headers.push([{
        key: "Access-Control-Allow-Headers",
        value: allowedHeaders
      }]);
    }
    return headers;
  }
  function configureExposedHeaders(options3) {
    var headers = options3.exposedHeaders;
    if (!headers) {
      return null;
    } else if (headers.join) {
      headers = headers.join(",");
    }
    if (headers && headers.length) {
      return {
        key: "Access-Control-Expose-Headers",
        value: headers
      };
    }
    return null;
  }
  function configureMaxAge(options3) {
    var maxAge = (typeof options3.maxAge === "number" || options3.maxAge) && options3.maxAge.toString();
    if (maxAge && maxAge.length) {
      return {
        key: "Access-Control-Max-Age",
        value: maxAge
      };
    }
    return null;
  }
  function applyHeaders(headers, res) {
    for (var i = 0, n2 = headers.length; i < n2; i++) {
      var header = headers[i];
      if (header) {
        if (Array.isArray(header)) {
          applyHeaders(header, res);
        } else if (header.key === "Vary" && header.value) {
          vary2(res, header.value);
        } else if (header.value) {
          res.setHeader(header.key, header.value);
        }
      }
    }
  }
  function cors(options3, req2, res, next) {
    var headers = [], method = req2.method && req2.method.toUpperCase && req2.method.toUpperCase();
    if (method === "OPTIONS") {
      headers.push(configureOrigin(options3, req2));
      headers.push(configureCredentials(options3));
      headers.push(configureMethods(options3));
      headers.push(configureAllowedHeaders(options3, req2));
      headers.push(configureMaxAge(options3));
      headers.push(configureExposedHeaders(options3));
      applyHeaders(headers, res);
      if (options3.preflightContinue) {
        next();
      } else {
        res.statusCode = options3.optionsSuccessStatus;
        res.setHeader("Content-Length", "0");
        res.end();
      }
    } else {
      headers.push(configureOrigin(options3, req2));
      headers.push(configureCredentials(options3));
      headers.push(configureExposedHeaders(options3));
      applyHeaders(headers, res);
      next();
    }
  }
  function middlewareWrapper(o) {
    var optionsCallback = null;
    if (typeof o === "function") {
      optionsCallback = o;
    } else {
      optionsCallback = function(req2, cb) {
        cb(null, o);
      };
    }
    return function corsMiddleware(req2, res, next) {
      optionsCallback(req2, function(err, options3) {
        if (err) {
          next(err);
        } else {
          var corsOptions = assign({}, defaults, options3);
          var originCallback = null;
          if (corsOptions.origin && typeof corsOptions.origin === "function") {
            originCallback = corsOptions.origin;
          } else if (corsOptions.origin) {
            originCallback = function(origin, cb) {
              cb(null, corsOptions.origin);
            };
          }
          if (originCallback) {
            originCallback(req2.headers.origin, function(err2, origin) {
              if (err2 || !origin) {
                next(err2);
              } else {
                corsOptions.origin = origin;
                cors(corsOptions, req2, res, next);
              }
            });
          } else {
            next();
          }
        }
      });
    };
  }
  lib$1.exports = middlewareWrapper;
})();
var chokidar = {};
var fs$8 = import_fs.default;
var { Readable } = import_stream.default;
var sysPath$3 = import_path.default;
var { promisify: promisify$3 } = import_util.default;
var picomatch$1 = picomatch$5.exports;
var readdir$1 = promisify$3(fs$8.readdir);
var stat$3 = promisify$3(fs$8.stat);
var lstat$2 = promisify$3(fs$8.lstat);
var realpath$1 = promisify$3(fs$8.realpath);
var BANG$2 = "!";
var RECURSIVE_ERROR_CODE = "READDIRP_RECURSIVE_ERROR";
var NORMAL_FLOW_ERRORS = /* @__PURE__ */ new Set(["ENOENT", "EPERM", "EACCES", "ELOOP", RECURSIVE_ERROR_CODE]);
var FILE_TYPE = "files";
var DIR_TYPE = "directories";
var FILE_DIR_TYPE = "files_directories";
var EVERYTHING_TYPE = "all";
var ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];
var isNormalFlowError = (error2) => NORMAL_FLOW_ERRORS.has(error2.code);
var [maj, min] = process.versions.node.split(".").slice(0, 2).map((n2) => Number.parseInt(n2, 10));
var wantBigintFsStats = process.platform === "win32" && (maj > 10 || maj === 10 && min >= 5);
var normalizeFilter = (filter2) => {
  if (filter2 === void 0)
    return;
  if (typeof filter2 === "function")
    return filter2;
  if (typeof filter2 === "string") {
    const glob = picomatch$1(filter2.trim());
    return (entry2) => glob(entry2.basename);
  }
  if (Array.isArray(filter2)) {
    const positive = [];
    const negative = [];
    for (const item of filter2) {
      const trimmed = item.trim();
      if (trimmed.charAt(0) === BANG$2) {
        negative.push(picomatch$1(trimmed.slice(1)));
      } else {
        positive.push(picomatch$1(trimmed));
      }
    }
    if (negative.length > 0) {
      if (positive.length > 0) {
        return (entry2) => positive.some((f) => f(entry2.basename)) && !negative.some((f) => f(entry2.basename));
      }
      return (entry2) => !negative.some((f) => f(entry2.basename));
    }
    return (entry2) => positive.some((f) => f(entry2.basename));
  }
};
var ReaddirpStream = class extends Readable {
  static get defaultOptions() {
    return {
      root: ".",
      fileFilter: (path4) => true,
      directoryFilter: (path4) => true,
      type: FILE_TYPE,
      lstat: false,
      depth: 2147483648,
      alwaysStat: false
    };
  }
  constructor(options3 = {}) {
    super({
      objectMode: true,
      autoDestroy: true,
      highWaterMark: options3.highWaterMark || 4096
    });
    const opts = { ...ReaddirpStream.defaultOptions, ...options3 };
    const { root: root2, type } = opts;
    this._fileFilter = normalizeFilter(opts.fileFilter);
    this._directoryFilter = normalizeFilter(opts.directoryFilter);
    const statMethod = opts.lstat ? lstat$2 : stat$3;
    if (wantBigintFsStats) {
      this._stat = (path4) => statMethod(path4, { bigint: true });
    } else {
      this._stat = statMethod;
    }
    this._maxDepth = opts.depth;
    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
    this._wantsEverything = type === EVERYTHING_TYPE;
    this._root = sysPath$3.resolve(root2);
    this._isDirent = "Dirent" in fs$8 && !opts.alwaysStat;
    this._statsProp = this._isDirent ? "dirent" : "stats";
    this._rdOptions = { encoding: "utf8", withFileTypes: this._isDirent };
    this.parents = [this._exploreDir(root2, 1)];
    this.reading = false;
    this.parent = void 0;
  }
  async _read(batch) {
    if (this.reading)
      return;
    this.reading = true;
    try {
      while (!this.destroyed && batch > 0) {
        const { path: path4, depth: depth2, files = [] } = this.parent || {};
        if (files.length > 0) {
          const slice2 = files.splice(0, batch).map((dirent) => this._formatEntry(dirent, path4));
          for (const entry2 of await Promise.all(slice2)) {
            if (this.destroyed)
              return;
            const entryType = await this._getEntryType(entry2);
            if (entryType === "directory" && this._directoryFilter(entry2)) {
              if (depth2 <= this._maxDepth) {
                this.parents.push(this._exploreDir(entry2.fullPath, depth2 + 1));
              }
              if (this._wantsDir) {
                this.push(entry2);
                batch--;
              }
            } else if ((entryType === "file" || this._includeAsFile(entry2)) && this._fileFilter(entry2)) {
              if (this._wantsFile) {
                this.push(entry2);
                batch--;
              }
            }
          }
        } else {
          const parent = this.parents.pop();
          if (!parent) {
            this.push(null);
            break;
          }
          this.parent = await parent;
          if (this.destroyed)
            return;
        }
      }
    } catch (error2) {
      this.destroy(error2);
    } finally {
      this.reading = false;
    }
  }
  async _exploreDir(path4, depth2) {
    let files;
    try {
      files = await readdir$1(path4, this._rdOptions);
    } catch (error2) {
      this._onError(error2);
    }
    return { files, depth: depth2, path: path4 };
  }
  async _formatEntry(dirent, path4) {
    let entry2;
    try {
      const basename2 = this._isDirent ? dirent.name : dirent;
      const fullPath = sysPath$3.resolve(sysPath$3.join(path4, basename2));
      entry2 = { path: sysPath$3.relative(this._root, fullPath), fullPath, basename: basename2 };
      entry2[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
    } catch (err) {
      this._onError(err);
    }
    return entry2;
  }
  _onError(err) {
    if (isNormalFlowError(err) && !this.destroyed) {
      this.emit("warn", err);
    } else {
      this.destroy(err);
    }
  }
  async _getEntryType(entry2) {
    const stats = entry2 && entry2[this._statsProp];
    if (!stats) {
      return;
    }
    if (stats.isFile()) {
      return "file";
    }
    if (stats.isDirectory()) {
      return "directory";
    }
    if (stats && stats.isSymbolicLink()) {
      const full = entry2.fullPath;
      try {
        const entryRealPath = await realpath$1(full);
        const entryRealPathStats = await lstat$2(entryRealPath);
        if (entryRealPathStats.isFile()) {
          return "file";
        }
        if (entryRealPathStats.isDirectory()) {
          const len = entryRealPath.length;
          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath$3.sep) {
            const recursiveError = new Error(
              `Circular symlink detected: "${full}" points to "${entryRealPath}"`
            );
            recursiveError.code = RECURSIVE_ERROR_CODE;
            return this._onError(recursiveError);
          }
          return "directory";
        }
      } catch (error2) {
        this._onError(error2);
      }
    }
  }
  _includeAsFile(entry2) {
    const stats = entry2 && entry2[this._statsProp];
    return stats && this._wantsEverything && !stats.isDirectory();
  }
};
var readdirp$1 = (root2, options3 = {}) => {
  let type = options3.entryType || options3.type;
  if (type === "both")
    type = FILE_DIR_TYPE;
  if (type)
    options3.type = type;
  if (!root2) {
    throw new Error("readdirp: root argument is required. Usage: readdirp(root, options)");
  } else if (typeof root2 !== "string") {
    throw new TypeError("readdirp: root argument must be a string. Usage: readdirp(root, options)");
  } else if (type && !ALL_TYPES.includes(type)) {
    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(", ")}`);
  }
  options3.root = root2;
  return new ReaddirpStream(options3);
};
var readdirpPromise = (root2, options3 = {}) => {
  return new Promise((resolve3, reject) => {
    const files = [];
    readdirp$1(root2, options3).on("data", (entry2) => files.push(entry2)).on("end", () => resolve3(files)).on("error", (error2) => reject(error2));
  });
};
readdirp$1.promise = readdirpPromise;
readdirp$1.ReaddirpStream = ReaddirpStream;
readdirp$1.default = readdirp$1;
var readdirp_1 = readdirp$1;
var anymatch$2 = { exports: {} };
var normalizePath$2 = function(path4, stripTrailing) {
  if (typeof path4 !== "string") {
    throw new TypeError("expected path to be a string");
  }
  if (path4 === "\\" || path4 === "/")
    return "/";
  var len = path4.length;
  if (len <= 1)
    return path4;
  var prefix = "";
  if (len > 4 && path4[3] === "\\") {
    var ch = path4[2];
    if ((ch === "?" || ch === ".") && path4.slice(0, 2) === "\\\\") {
      path4 = path4.slice(2);
      prefix = "//";
    }
  }
  var segs = path4.split(/[/\\]+/);
  if (stripTrailing !== false && segs[segs.length - 1] === "") {
    segs.pop();
  }
  return prefix + segs.join("/");
};
Object.defineProperty(anymatch$2.exports, "__esModule", { value: true });
var picomatch = picomatch$5.exports;
var normalizePath$1 = normalizePath$2;
var BANG$1 = "!";
var DEFAULT_OPTIONS = { returnIndex: false };
var arrify$1 = (item) => Array.isArray(item) ? item : [item];
var createPattern = (matcher2, options3) => {
  if (typeof matcher2 === "function") {
    return matcher2;
  }
  if (typeof matcher2 === "string") {
    const glob = picomatch(matcher2, options3);
    return (string2) => matcher2 === string2 || glob(string2);
  }
  if (matcher2 instanceof RegExp) {
    return (string2) => matcher2.test(string2);
  }
  return (string2) => false;
};
var matchPatterns = (patterns2, negPatterns, args, returnIndex) => {
  const isList = Array.isArray(args);
  const _path = isList ? args[0] : args;
  if (!isList && typeof _path !== "string") {
    throw new TypeError("anymatch: second argument must be a string: got " + Object.prototype.toString.call(_path));
  }
  const path4 = normalizePath$1(_path);
  for (let index2 = 0; index2 < negPatterns.length; index2++) {
    const nglob = negPatterns[index2];
    if (nglob(path4)) {
      return returnIndex ? -1 : false;
    }
  }
  const applied = isList && [path4].concat(args.slice(1));
  for (let index2 = 0; index2 < patterns2.length; index2++) {
    const pattern2 = patterns2[index2];
    if (isList ? pattern2(...applied) : pattern2(path4)) {
      return returnIndex ? index2 : true;
    }
  }
  return returnIndex ? -1 : false;
};
var anymatch$1 = (matchers, testString, options3 = DEFAULT_OPTIONS) => {
  if (matchers == null) {
    throw new TypeError("anymatch: specify first argument");
  }
  const opts = typeof options3 === "boolean" ? { returnIndex: options3 } : options3;
  const returnIndex = opts.returnIndex || false;
  const mtchers = arrify$1(matchers);
  const negatedGlobs = mtchers.filter((item) => typeof item === "string" && item.charAt(0) === BANG$1).map((item) => item.slice(1)).map((item) => picomatch(item, opts));
  const patterns2 = mtchers.filter((item) => typeof item !== "string" || typeof item === "string" && item.charAt(0) !== BANG$1).map((matcher2) => createPattern(matcher2, opts));
  if (testString == null) {
    return (testString2, ri = false) => {
      const returnIndex2 = typeof ri === "boolean" ? ri : false;
      return matchPatterns(patterns2, negatedGlobs, testString2, returnIndex2);
    };
  }
  return matchPatterns(patterns2, negatedGlobs, testString, returnIndex);
};
anymatch$1.default = anymatch$1;
anymatch$2.exports = anymatch$1;
var binaryExtensions$1 = { exports: {} };
var require$$0 = [
  "3dm",
  "3ds",
  "3g2",
  "3gp",
  "7z",
  "a",
  "aac",
  "adp",
  "ai",
  "aif",
  "aiff",
  "alz",
  "ape",
  "apk",
  "appimage",
  "ar",
  "arj",
  "asf",
  "au",
  "avi",
  "bak",
  "baml",
  "bh",
  "bin",
  "bk",
  "bmp",
  "btif",
  "bz2",
  "bzip2",
  "cab",
  "caf",
  "cgm",
  "class",
  "cmx",
  "cpio",
  "cr2",
  "cur",
  "dat",
  "dcm",
  "deb",
  "dex",
  "djvu",
  "dll",
  "dmg",
  "dng",
  "doc",
  "docm",
  "docx",
  "dot",
  "dotm",
  "dra",
  "DS_Store",
  "dsk",
  "dts",
  "dtshd",
  "dvb",
  "dwg",
  "dxf",
  "ecelp4800",
  "ecelp7470",
  "ecelp9600",
  "egg",
  "eol",
  "eot",
  "epub",
  "exe",
  "f4v",
  "fbs",
  "fh",
  "fla",
  "flac",
  "flatpak",
  "fli",
  "flv",
  "fpx",
  "fst",
  "fvt",
  "g3",
  "gh",
  "gif",
  "graffle",
  "gz",
  "gzip",
  "h261",
  "h263",
  "h264",
  "icns",
  "ico",
  "ief",
  "img",
  "ipa",
  "iso",
  "jar",
  "jpeg",
  "jpg",
  "jpgv",
  "jpm",
  "jxr",
  "key",
  "ktx",
  "lha",
  "lib",
  "lvp",
  "lz",
  "lzh",
  "lzma",
  "lzo",
  "m3u",
  "m4a",
  "m4v",
  "mar",
  "mdi",
  "mht",
  "mid",
  "midi",
  "mj2",
  "mka",
  "mkv",
  "mmr",
  "mng",
  "mobi",
  "mov",
  "movie",
  "mp3",
  "mp4",
  "mp4a",
  "mpeg",
  "mpg",
  "mpga",
  "mxu",
  "nef",
  "npx",
  "numbers",
  "nupkg",
  "o",
  "odp",
  "ods",
  "odt",
  "oga",
  "ogg",
  "ogv",
  "otf",
  "ott",
  "pages",
  "pbm",
  "pcx",
  "pdb",
  "pdf",
  "pea",
  "pgm",
  "pic",
  "png",
  "pnm",
  "pot",
  "potm",
  "potx",
  "ppa",
  "ppam",
  "ppm",
  "pps",
  "ppsm",
  "ppsx",
  "ppt",
  "pptm",
  "pptx",
  "psd",
  "pya",
  "pyc",
  "pyo",
  "pyv",
  "qt",
  "rar",
  "ras",
  "raw",
  "resources",
  "rgb",
  "rip",
  "rlc",
  "rmf",
  "rmvb",
  "rpm",
  "rtf",
  "rz",
  "s3m",
  "s7z",
  "scpt",
  "sgi",
  "shar",
  "snap",
  "sil",
  "sketch",
  "slk",
  "smv",
  "snk",
  "so",
  "stl",
  "suo",
  "sub",
  "swf",
  "tar",
  "tbz",
  "tbz2",
  "tga",
  "tgz",
  "thmx",
  "tif",
  "tiff",
  "tlz",
  "ttc",
  "ttf",
  "txz",
  "udf",
  "uvh",
  "uvi",
  "uvm",
  "uvp",
  "uvs",
  "uvu",
  "viv",
  "vob",
  "war",
  "wav",
  "wax",
  "wbmp",
  "wdp",
  "weba",
  "webm",
  "webp",
  "whl",
  "wim",
  "wm",
  "wma",
  "wmv",
  "wmx",
  "woff",
  "woff2",
  "wrm",
  "wvx",
  "xbm",
  "xif",
  "xla",
  "xlam",
  "xls",
  "xlsb",
  "xlsm",
  "xlsx",
  "xlt",
  "xltm",
  "xltx",
  "xm",
  "xmind",
  "xpi",
  "xpm",
  "xwd",
  "xz",
  "z",
  "zip",
  "zipx"
];
(function(module2) {
  module2.exports = require$$0;
})(binaryExtensions$1);
var path$8 = import_path.default;
var binaryExtensions = binaryExtensions$1.exports;
var extensions = new Set(binaryExtensions);
var isBinaryPath$1 = (filePath) => extensions.has(path$8.extname(filePath).slice(1).toLowerCase());
var constants$1 = {};
(function(exports) {
  const { sep: sep2 } = import_path.default;
  const { platform: platform2 } = process;
  const os2 = import_os.default;
  exports.EV_ALL = "all";
  exports.EV_READY = "ready";
  exports.EV_ADD = "add";
  exports.EV_CHANGE = "change";
  exports.EV_ADD_DIR = "addDir";
  exports.EV_UNLINK = "unlink";
  exports.EV_UNLINK_DIR = "unlinkDir";
  exports.EV_RAW = "raw";
  exports.EV_ERROR = "error";
  exports.STR_DATA = "data";
  exports.STR_END = "end";
  exports.STR_CLOSE = "close";
  exports.FSEVENT_CREATED = "created";
  exports.FSEVENT_MODIFIED = "modified";
  exports.FSEVENT_DELETED = "deleted";
  exports.FSEVENT_MOVED = "moved";
  exports.FSEVENT_CLONED = "cloned";
  exports.FSEVENT_UNKNOWN = "unknown";
  exports.FSEVENT_TYPE_FILE = "file";
  exports.FSEVENT_TYPE_DIRECTORY = "directory";
  exports.FSEVENT_TYPE_SYMLINK = "symlink";
  exports.KEY_LISTENERS = "listeners";
  exports.KEY_ERR = "errHandlers";
  exports.KEY_RAW = "rawEmitters";
  exports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];
  exports.DOT_SLASH = `.${sep2}`;
  exports.BACK_SLASH_RE = /\\/g;
  exports.DOUBLE_SLASH_RE = /\/\//;
  exports.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
  exports.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
  exports.REPLACER_RE = /^\.[/\\]/;
  exports.SLASH = "/";
  exports.SLASH_SLASH = "//";
  exports.BRACE_START = "{";
  exports.BANG = "!";
  exports.ONE_DOT = ".";
  exports.TWO_DOTS = "..";
  exports.STAR = "*";
  exports.GLOBSTAR = "**";
  exports.ROOT_GLOBSTAR = "/**/*";
  exports.SLASH_GLOBSTAR = "/**";
  exports.DIR_SUFFIX = "Dir";
  exports.ANYMATCH_OPTS = { dot: true };
  exports.STRING_TYPE = "string";
  exports.FUNCTION_TYPE = "function";
  exports.EMPTY_STR = "";
  exports.EMPTY_FN = () => {
  };
  exports.IDENTITY_FN = (val) => val;
  exports.isWindows = platform2 === "win32";
  exports.isMacos = platform2 === "darwin";
  exports.isLinux = platform2 === "linux";
  exports.isIBMi = os2.type() === "OS400";
})(constants$1);
var fs$7 = import_fs.default;
var sysPath$2 = import_path.default;
var { promisify: promisify$2 } = import_util.default;
var isBinaryPath = isBinaryPath$1;
var {
  isWindows: isWindows$2,
  isLinux,
  EMPTY_FN: EMPTY_FN$2,
  EMPTY_STR: EMPTY_STR$1,
  KEY_LISTENERS,
  KEY_ERR,
  KEY_RAW,
  HANDLER_KEYS,
  EV_CHANGE: EV_CHANGE$2,
  EV_ADD: EV_ADD$2,
  EV_ADD_DIR: EV_ADD_DIR$2,
  EV_ERROR: EV_ERROR$2,
  STR_DATA: STR_DATA$1,
  STR_END: STR_END$2,
  BRACE_START: BRACE_START$1,
  STAR
} = constants$1;
var THROTTLE_MODE_WATCH = "watch";
var open$1 = promisify$2(fs$7.open);
var stat$2 = promisify$2(fs$7.stat);
var lstat$1 = promisify$2(fs$7.lstat);
var close = promisify$2(fs$7.close);
var fsrealpath = promisify$2(fs$7.realpath);
var statMethods$1 = { lstat: lstat$1, stat: stat$2 };
var foreach = (val, fn) => {
  if (val instanceof Set) {
    val.forEach(fn);
  } else {
    fn(val);
  }
};
var addAndConvert = (main2, prop, item) => {
  let container = main2[prop];
  if (!(container instanceof Set)) {
    main2[prop] = container = /* @__PURE__ */ new Set([container]);
  }
  container.add(item);
};
var clearItem = (cont) => (key2) => {
  const set2 = cont[key2];
  if (set2 instanceof Set) {
    set2.clear();
  } else {
    delete cont[key2];
  }
};
var delFromSet = (main2, prop, item) => {
  const container = main2[prop];
  if (container instanceof Set) {
    container.delete(item);
  } else if (container === item) {
    delete main2[prop];
  }
};
var isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;
var FsWatchInstances = /* @__PURE__ */ new Map();
function createFsWatchInstance(path4, options3, listener2, errHandler, emitRaw) {
  const handleEvent = (rawEvent, evPath) => {
    listener2(path4);
    emitRaw(rawEvent, evPath, { watchedPath: path4 });
    if (evPath && path4 !== evPath) {
      fsWatchBroadcast(
        sysPath$2.resolve(path4, evPath),
        KEY_LISTENERS,
        sysPath$2.join(path4, evPath)
      );
    }
  };
  try {
    return fs$7.watch(path4, options3, handleEvent);
  } catch (error2) {
    errHandler(error2);
  }
}
var fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {
  const cont = FsWatchInstances.get(fullPath);
  if (!cont)
    return;
  foreach(cont[type], (listener2) => {
    listener2(val1, val2, val3);
  });
};
var setFsWatchListener = (path4, fullPath, options3, handlers) => {
  const { listener: listener2, errHandler, rawEmitter } = handlers;
  let cont = FsWatchInstances.get(fullPath);
  let watcher;
  if (!options3.persistent) {
    watcher = createFsWatchInstance(
      path4,
      options3,
      listener2,
      errHandler,
      rawEmitter
    );
    return watcher.close.bind(watcher);
  }
  if (cont) {
    addAndConvert(cont, KEY_LISTENERS, listener2);
    addAndConvert(cont, KEY_ERR, errHandler);
    addAndConvert(cont, KEY_RAW, rawEmitter);
  } else {
    watcher = createFsWatchInstance(
      path4,
      options3,
      fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),
      errHandler,
      fsWatchBroadcast.bind(null, fullPath, KEY_RAW)
    );
    if (!watcher)
      return;
    watcher.on(EV_ERROR$2, async (error2) => {
      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
      cont.watcherUnusable = true;
      if (isWindows$2 && error2.code === "EPERM") {
        try {
          const fd = await open$1(path4, "r");
          await close(fd);
          broadcastErr(error2);
        } catch (err) {
        }
      } else {
        broadcastErr(error2);
      }
    });
    cont = {
      listeners: listener2,
      errHandlers: errHandler,
      rawEmitters: rawEmitter,
      watcher
    };
    FsWatchInstances.set(fullPath, cont);
  }
  return () => {
    delFromSet(cont, KEY_LISTENERS, listener2);
    delFromSet(cont, KEY_ERR, errHandler);
    delFromSet(cont, KEY_RAW, rawEmitter);
    if (isEmptySet(cont.listeners)) {
      cont.watcher.close();
      FsWatchInstances.delete(fullPath);
      HANDLER_KEYS.forEach(clearItem(cont));
      cont.watcher = void 0;
      Object.freeze(cont);
    }
  };
};
var FsWatchFileInstances = /* @__PURE__ */ new Map();
var setFsWatchFileListener = (path4, fullPath, options3, handlers) => {
  const { listener: listener2, rawEmitter } = handlers;
  let cont = FsWatchFileInstances.get(fullPath);
  const copts = cont && cont.options;
  if (copts && (copts.persistent < options3.persistent || copts.interval > options3.interval)) {
    fs$7.unwatchFile(fullPath);
    cont = void 0;
  }
  if (cont) {
    addAndConvert(cont, KEY_LISTENERS, listener2);
    addAndConvert(cont, KEY_RAW, rawEmitter);
  } else {
    cont = {
      listeners: listener2,
      rawEmitters: rawEmitter,
      options: options3,
      watcher: fs$7.watchFile(fullPath, options3, (curr, prev) => {
        foreach(cont.rawEmitters, (rawEmitter2) => {
          rawEmitter2(EV_CHANGE$2, fullPath, { curr, prev });
        });
        const currmtime = curr.mtimeMs;
        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
          foreach(cont.listeners, (listener3) => listener3(path4, curr));
        }
      })
    };
    FsWatchFileInstances.set(fullPath, cont);
  }
  return () => {
    delFromSet(cont, KEY_LISTENERS, listener2);
    delFromSet(cont, KEY_RAW, rawEmitter);
    if (isEmptySet(cont.listeners)) {
      FsWatchFileInstances.delete(fullPath);
      fs$7.unwatchFile(fullPath);
      cont.options = cont.watcher = void 0;
      Object.freeze(cont);
    }
  };
};
var NodeFsHandler$1 = class {
  constructor(fsW) {
    this.fsw = fsW;
    this._boundHandleError = (error2) => fsW._handleError(error2);
  }
  _watchWithNodeFs(path4, listener2) {
    const opts = this.fsw.options;
    const directory = sysPath$2.dirname(path4);
    const basename2 = sysPath$2.basename(path4);
    const parent = this.fsw._getWatchedDir(directory);
    parent.add(basename2);
    const absolutePath = sysPath$2.resolve(path4);
    const options3 = { persistent: opts.persistent };
    if (!listener2)
      listener2 = EMPTY_FN$2;
    let closer;
    if (opts.usePolling) {
      options3.interval = opts.enableBinaryInterval && isBinaryPath(basename2) ? opts.binaryInterval : opts.interval;
      closer = setFsWatchFileListener(path4, absolutePath, options3, {
        listener: listener2,
        rawEmitter: this.fsw._emitRaw
      });
    } else {
      closer = setFsWatchListener(path4, absolutePath, options3, {
        listener: listener2,
        errHandler: this._boundHandleError,
        rawEmitter: this.fsw._emitRaw
      });
    }
    return closer;
  }
  _handleFile(file, stats, initialAdd) {
    if (this.fsw.closed) {
      return;
    }
    const dirname2 = sysPath$2.dirname(file);
    const basename2 = sysPath$2.basename(file);
    const parent = this.fsw._getWatchedDir(dirname2);
    let prevStats = stats;
    if (parent.has(basename2))
      return;
    const listener2 = async (path4, newStats) => {
      if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5))
        return;
      if (!newStats || newStats.mtimeMs === 0) {
        try {
          const newStats2 = await stat$2(file);
          if (this.fsw.closed)
            return;
          const at2 = newStats2.atimeMs;
          const mt = newStats2.mtimeMs;
          if (!at2 || at2 <= mt || mt !== prevStats.mtimeMs) {
            this.fsw._emit(EV_CHANGE$2, file, newStats2);
          }
          if (isLinux && prevStats.ino !== newStats2.ino) {
            this.fsw._closeFile(path4);
            prevStats = newStats2;
            this.fsw._addPathCloser(path4, this._watchWithNodeFs(file, listener2));
          } else {
            prevStats = newStats2;
          }
        } catch (error2) {
          this.fsw._remove(dirname2, basename2);
        }
      } else if (parent.has(basename2)) {
        const at2 = newStats.atimeMs;
        const mt = newStats.mtimeMs;
        if (!at2 || at2 <= mt || mt !== prevStats.mtimeMs) {
          this.fsw._emit(EV_CHANGE$2, file, newStats);
        }
        prevStats = newStats;
      }
    };
    const closer = this._watchWithNodeFs(file, listener2);
    if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
      if (!this.fsw._throttle(EV_ADD$2, file, 0))
        return;
      this.fsw._emit(EV_ADD$2, file, stats);
    }
    return closer;
  }
  async _handleSymlink(entry2, directory, path4, item) {
    if (this.fsw.closed) {
      return;
    }
    const full = entry2.fullPath;
    const dir = this.fsw._getWatchedDir(directory);
    if (!this.fsw.options.followSymlinks) {
      this.fsw._incrReadyCount();
      let linkPath;
      try {
        linkPath = await fsrealpath(path4);
      } catch (e) {
        this.fsw._emitReady();
        return true;
      }
      if (this.fsw.closed)
        return;
      if (dir.has(item)) {
        if (this.fsw._symlinkPaths.get(full) !== linkPath) {
          this.fsw._symlinkPaths.set(full, linkPath);
          this.fsw._emit(EV_CHANGE$2, path4, entry2.stats);
        }
      } else {
        dir.add(item);
        this.fsw._symlinkPaths.set(full, linkPath);
        this.fsw._emit(EV_ADD$2, path4, entry2.stats);
      }
      this.fsw._emitReady();
      return true;
    }
    if (this.fsw._symlinkPaths.has(full)) {
      return true;
    }
    this.fsw._symlinkPaths.set(full, true);
  }
  _handleRead(directory, initialAdd, wh, target, dir, depth2, throttler) {
    directory = sysPath$2.join(directory, EMPTY_STR$1);
    if (!wh.hasGlob) {
      throttler = this.fsw._throttle("readdir", directory, 1e3);
      if (!throttler)
        return;
    }
    const previous = this.fsw._getWatchedDir(wh.path);
    const current2 = /* @__PURE__ */ new Set();
    let stream4 = this.fsw._readdirp(directory, {
      fileFilter: (entry2) => wh.filterPath(entry2),
      directoryFilter: (entry2) => wh.filterDir(entry2),
      depth: 0
    }).on(STR_DATA$1, async (entry2) => {
      if (this.fsw.closed) {
        stream4 = void 0;
        return;
      }
      const item = entry2.path;
      let path4 = sysPath$2.join(directory, item);
      current2.add(item);
      if (entry2.stats.isSymbolicLink() && await this._handleSymlink(entry2, directory, path4, item)) {
        return;
      }
      if (this.fsw.closed) {
        stream4 = void 0;
        return;
      }
      if (item === target || !target && !previous.has(item)) {
        this.fsw._incrReadyCount();
        path4 = sysPath$2.join(dir, sysPath$2.relative(dir, path4));
        this._addToNodeFs(path4, initialAdd, wh, depth2 + 1);
      }
    }).on(EV_ERROR$2, this._boundHandleError);
    return new Promise(
      (resolve3) => stream4.once(STR_END$2, () => {
        if (this.fsw.closed) {
          stream4 = void 0;
          return;
        }
        const wasThrottled = throttler ? throttler.clear() : false;
        resolve3();
        previous.getChildren().filter((item) => {
          return item !== directory && !current2.has(item) && (!wh.hasGlob || wh.filterPath({
            fullPath: sysPath$2.resolve(directory, item)
          }));
        }).forEach((item) => {
          this.fsw._remove(directory, item);
        });
        stream4 = void 0;
        if (wasThrottled)
          this._handleRead(directory, false, wh, target, dir, depth2, throttler);
      })
    );
  }
  async _handleDir(dir, stats, initialAdd, depth2, target, wh, realpath3) {
    const parentDir = this.fsw._getWatchedDir(sysPath$2.dirname(dir));
    const tracked = parentDir.has(sysPath$2.basename(dir));
    if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
      if (!wh.hasGlob || wh.globFilter(dir))
        this.fsw._emit(EV_ADD_DIR$2, dir, stats);
    }
    parentDir.add(sysPath$2.basename(dir));
    this.fsw._getWatchedDir(dir);
    let throttler;
    let closer;
    const oDepth = this.fsw.options.depth;
    if ((oDepth == null || depth2 <= oDepth) && !this.fsw._symlinkPaths.has(realpath3)) {
      if (!target) {
        await this._handleRead(dir, initialAdd, wh, target, dir, depth2, throttler);
        if (this.fsw.closed)
          return;
      }
      closer = this._watchWithNodeFs(dir, (dirPath, stats2) => {
        if (stats2 && stats2.mtimeMs === 0)
          return;
        this._handleRead(dirPath, false, wh, target, dir, depth2, throttler);
      });
    }
    return closer;
  }
  async _addToNodeFs(path4, initialAdd, priorWh, depth2, target) {
    const ready = this.fsw._emitReady;
    if (this.fsw._isIgnored(path4) || this.fsw.closed) {
      ready();
      return false;
    }
    const wh = this.fsw._getWatchHelpers(path4, depth2);
    if (!wh.hasGlob && priorWh) {
      wh.hasGlob = priorWh.hasGlob;
      wh.globFilter = priorWh.globFilter;
      wh.filterPath = (entry2) => priorWh.filterPath(entry2);
      wh.filterDir = (entry2) => priorWh.filterDir(entry2);
    }
    try {
      const stats = await statMethods$1[wh.statMethod](wh.watchPath);
      if (this.fsw.closed)
        return;
      if (this.fsw._isIgnored(wh.watchPath, stats)) {
        ready();
        return false;
      }
      const follow = this.fsw.options.followSymlinks && !path4.includes(STAR) && !path4.includes(BRACE_START$1);
      let closer;
      if (stats.isDirectory()) {
        const absPath = sysPath$2.resolve(path4);
        const targetPath = follow ? await fsrealpath(path4) : path4;
        if (this.fsw.closed)
          return;
        closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth2, target, wh, targetPath);
        if (this.fsw.closed)
          return;
        if (absPath !== targetPath && targetPath !== void 0) {
          this.fsw._symlinkPaths.set(absPath, targetPath);
        }
      } else if (stats.isSymbolicLink()) {
        const targetPath = follow ? await fsrealpath(path4) : path4;
        if (this.fsw.closed)
          return;
        const parent = sysPath$2.dirname(wh.watchPath);
        this.fsw._getWatchedDir(parent).add(wh.watchPath);
        this.fsw._emit(EV_ADD$2, wh.watchPath, stats);
        closer = await this._handleDir(parent, stats, initialAdd, depth2, path4, wh, targetPath);
        if (this.fsw.closed)
          return;
        if (targetPath !== void 0) {
          this.fsw._symlinkPaths.set(sysPath$2.resolve(path4), targetPath);
        }
      } else {
        closer = this._handleFile(wh.watchPath, stats, initialAdd);
      }
      ready();
      this.fsw._addPathCloser(path4, closer);
      return false;
    } catch (error2) {
      if (this.fsw._handleError(error2)) {
        ready();
        return path4;
      }
    }
  }
};
var nodefsHandler = NodeFsHandler$1;
var fseventsHandler = { exports: {} };
var fs$6 = import_fs.default;
var sysPath$1 = import_path.default;
var { promisify: promisify$1 } = import_util.default;
var fsevents;
try {
  fsevents = __require2("fsevents");
} catch (error2) {
  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR)
    console.error(error2);
}
if (fsevents) {
  const mtch = process.version.match(/v(\d+)\.(\d+)/);
  if (mtch && mtch[1] && mtch[2]) {
    const maj2 = Number.parseInt(mtch[1], 10);
    const min2 = Number.parseInt(mtch[2], 10);
    if (maj2 === 8 && min2 < 16) {
      fsevents = void 0;
    }
  }
}
var {
  EV_ADD: EV_ADD$1,
  EV_CHANGE: EV_CHANGE$1,
  EV_ADD_DIR: EV_ADD_DIR$1,
  EV_UNLINK: EV_UNLINK$1,
  EV_ERROR: EV_ERROR$1,
  STR_DATA,
  STR_END: STR_END$1,
  FSEVENT_CREATED,
  FSEVENT_MODIFIED,
  FSEVENT_DELETED,
  FSEVENT_MOVED,
  FSEVENT_UNKNOWN,
  FSEVENT_TYPE_FILE,
  FSEVENT_TYPE_DIRECTORY,
  FSEVENT_TYPE_SYMLINK,
  ROOT_GLOBSTAR,
  DIR_SUFFIX,
  DOT_SLASH,
  FUNCTION_TYPE: FUNCTION_TYPE$1,
  EMPTY_FN: EMPTY_FN$1,
  IDENTITY_FN
} = constants$1;
var Depth = (value2) => isNaN(value2) ? {} : { depth: value2 };
var stat$1 = promisify$1(fs$6.stat);
var lstat = promisify$1(fs$6.lstat);
var realpath2 = promisify$1(fs$6.realpath);
var statMethods = { stat: stat$1, lstat };
var FSEventsWatchers = /* @__PURE__ */ new Map();
var consolidateThreshhold = 10;
var wrongEventFlags = /* @__PURE__ */ new Set([
  69888,
  70400,
  71424,
  72704,
  73472,
  131328,
  131840,
  262912
]);
var createFSEventsInstance = (path4, callback) => {
  const stop = fsevents.watch(path4, callback);
  return { stop };
};
function setFSEventsListener(path4, realPath, listener2, rawEmitter) {
  let watchPath = sysPath$1.extname(realPath) ? sysPath$1.dirname(realPath) : realPath;
  const parentPath = sysPath$1.dirname(watchPath);
  let cont = FSEventsWatchers.get(watchPath);
  if (couldConsolidate(parentPath)) {
    watchPath = parentPath;
  }
  const resolvedPath = sysPath$1.resolve(path4);
  const hasSymlink = resolvedPath !== realPath;
  const filteredListener = (fullPath, flags, info) => {
    if (hasSymlink)
      fullPath = fullPath.replace(realPath, resolvedPath);
    if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath$1.sep))
      listener2(fullPath, flags, info);
  };
  let watchedParent = false;
  for (const watchedPath of FSEventsWatchers.keys()) {
    if (realPath.indexOf(sysPath$1.resolve(watchedPath) + sysPath$1.sep) === 0) {
      watchPath = watchedPath;
      cont = FSEventsWatchers.get(watchPath);
      watchedParent = true;
      break;
    }
  }
  if (cont || watchedParent) {
    cont.listeners.add(filteredListener);
  } else {
    cont = {
      listeners: /* @__PURE__ */ new Set([filteredListener]),
      rawEmitter,
      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {
        if (!cont.listeners.size)
          return;
        const info = fsevents.getInfo(fullPath, flags);
        cont.listeners.forEach((list) => {
          list(fullPath, flags, info);
        });
        cont.rawEmitter(info.event, fullPath, info);
      })
    };
    FSEventsWatchers.set(watchPath, cont);
  }
  return () => {
    const lst = cont.listeners;
    lst.delete(filteredListener);
    if (!lst.size) {
      FSEventsWatchers.delete(watchPath);
      if (cont.watcher)
        return cont.watcher.stop().then(() => {
          cont.rawEmitter = cont.watcher = void 0;
          Object.freeze(cont);
        });
    }
  };
}
var couldConsolidate = (path4) => {
  let count = 0;
  for (const watchPath of FSEventsWatchers.keys()) {
    if (watchPath.indexOf(path4) === 0) {
      count++;
      if (count >= consolidateThreshhold) {
        return true;
      }
    }
  }
  return false;
};
var canUse = () => fsevents && FSEventsWatchers.size < 128;
var calcDepth = (path4, root2) => {
  let i = 0;
  while (!path4.indexOf(root2) && (path4 = sysPath$1.dirname(path4)) !== root2)
    i++;
  return i;
};
var sameTypes = (info, stats) => info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();
var FsEventsHandler$1 = class {
  constructor(fsw) {
    this.fsw = fsw;
  }
  checkIgnored(path4, stats) {
    const ipaths = this.fsw._ignoredPaths;
    if (this.fsw._isIgnored(path4, stats)) {
      ipaths.add(path4);
      if (stats && stats.isDirectory()) {
        ipaths.add(path4 + ROOT_GLOBSTAR);
      }
      return true;
    }
    ipaths.delete(path4);
    ipaths.delete(path4 + ROOT_GLOBSTAR);
  }
  addOrChange(path4, fullPath, realPath, parent, watchedDir, item, info, opts) {
    const event = watchedDir.has(item) ? EV_CHANGE$1 : EV_ADD$1;
    this.handleEvent(event, path4, fullPath, realPath, parent, watchedDir, item, info, opts);
  }
  async checkExists(path4, fullPath, realPath, parent, watchedDir, item, info, opts) {
    try {
      const stats = await stat$1(path4);
      if (this.fsw.closed)
        return;
      if (sameTypes(info, stats)) {
        this.addOrChange(path4, fullPath, realPath, parent, watchedDir, item, info, opts);
      } else {
        this.handleEvent(EV_UNLINK$1, path4, fullPath, realPath, parent, watchedDir, item, info, opts);
      }
    } catch (error2) {
      if (error2.code === "EACCES") {
        this.addOrChange(path4, fullPath, realPath, parent, watchedDir, item, info, opts);
      } else {
        this.handleEvent(EV_UNLINK$1, path4, fullPath, realPath, parent, watchedDir, item, info, opts);
      }
    }
  }
  handleEvent(event, path4, fullPath, realPath, parent, watchedDir, item, info, opts) {
    if (this.fsw.closed || this.checkIgnored(path4))
      return;
    if (event === EV_UNLINK$1) {
      const isDirectory2 = info.type === FSEVENT_TYPE_DIRECTORY;
      if (isDirectory2 || watchedDir.has(item)) {
        this.fsw._remove(parent, item, isDirectory2);
      }
    } else {
      if (event === EV_ADD$1) {
        if (info.type === FSEVENT_TYPE_DIRECTORY)
          this.fsw._getWatchedDir(path4);
        if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {
          const curDepth = opts.depth === void 0 ? void 0 : calcDepth(fullPath, realPath) + 1;
          return this._addToFsEvents(path4, false, true, curDepth);
        }
        this.fsw._getWatchedDir(parent).add(item);
      }
      const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;
      this.fsw._emit(eventName, path4);
      if (eventName === EV_ADD_DIR$1)
        this._addToFsEvents(path4, false, true);
    }
  }
  _watchWithFsEvents(watchPath, realPath, transform2, globFilter) {
    if (this.fsw.closed || this.fsw._isIgnored(watchPath))
      return;
    const opts = this.fsw.options;
    const watchCallback = async (fullPath, flags, info) => {
      if (this.fsw.closed)
        return;
      if (opts.depth !== void 0 && calcDepth(fullPath, realPath) > opts.depth)
        return;
      const path4 = transform2(sysPath$1.join(
        watchPath,
        sysPath$1.relative(watchPath, fullPath)
      ));
      if (globFilter && !globFilter(path4))
        return;
      const parent = sysPath$1.dirname(path4);
      const item = sysPath$1.basename(path4);
      const watchedDir = this.fsw._getWatchedDir(
        info.type === FSEVENT_TYPE_DIRECTORY ? path4 : parent
      );
      if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {
        if (typeof opts.ignored === FUNCTION_TYPE$1) {
          let stats;
          try {
            stats = await stat$1(path4);
          } catch (error2) {
          }
          if (this.fsw.closed)
            return;
          if (this.checkIgnored(path4, stats))
            return;
          if (sameTypes(info, stats)) {
            this.addOrChange(path4, fullPath, realPath, parent, watchedDir, item, info, opts);
          } else {
            this.handleEvent(EV_UNLINK$1, path4, fullPath, realPath, parent, watchedDir, item, info, opts);
          }
        } else {
          this.checkExists(path4, fullPath, realPath, parent, watchedDir, item, info, opts);
        }
      } else {
        switch (info.event) {
          case FSEVENT_CREATED:
          case FSEVENT_MODIFIED:
            return this.addOrChange(path4, fullPath, realPath, parent, watchedDir, item, info, opts);
          case FSEVENT_DELETED:
          case FSEVENT_MOVED:
            return this.checkExists(path4, fullPath, realPath, parent, watchedDir, item, info, opts);
        }
      }
    };
    const closer = setFSEventsListener(
      watchPath,
      realPath,
      watchCallback,
      this.fsw._emitRaw
    );
    this.fsw._emitReady();
    return closer;
  }
  async _handleFsEventsSymlink(linkPath, fullPath, transform2, curDepth) {
    if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath))
      return;
    this.fsw._symlinkPaths.set(fullPath, true);
    this.fsw._incrReadyCount();
    try {
      const linkTarget = await realpath2(linkPath);
      if (this.fsw.closed)
        return;
      if (this.fsw._isIgnored(linkTarget)) {
        return this.fsw._emitReady();
      }
      this.fsw._incrReadyCount();
      this._addToFsEvents(linkTarget || linkPath, (path4) => {
        let aliasedPath = linkPath;
        if (linkTarget && linkTarget !== DOT_SLASH) {
          aliasedPath = path4.replace(linkTarget, linkPath);
        } else if (path4 !== DOT_SLASH) {
          aliasedPath = sysPath$1.join(linkPath, path4);
        }
        return transform2(aliasedPath);
      }, false, curDepth);
    } catch (error2) {
      if (this.fsw._handleError(error2)) {
        return this.fsw._emitReady();
      }
    }
  }
  emitAdd(newPath, stats, processPath, opts, forceAdd) {
    const pp2 = processPath(newPath);
    const isDir = stats.isDirectory();
    const dirObj = this.fsw._getWatchedDir(sysPath$1.dirname(pp2));
    const base2 = sysPath$1.basename(pp2);
    if (isDir)
      this.fsw._getWatchedDir(pp2);
    if (dirObj.has(base2))
      return;
    dirObj.add(base2);
    if (!opts.ignoreInitial || forceAdd === true) {
      this.fsw._emit(isDir ? EV_ADD_DIR$1 : EV_ADD$1, pp2, stats);
    }
  }
  initWatch(realPath, path4, wh, processPath) {
    if (this.fsw.closed)
      return;
    const closer = this._watchWithFsEvents(
      wh.watchPath,
      sysPath$1.resolve(realPath || wh.watchPath),
      processPath,
      wh.globFilter
    );
    this.fsw._addPathCloser(path4, closer);
  }
  async _addToFsEvents(path4, transform2, forceAdd, priorDepth) {
    if (this.fsw.closed) {
      return;
    }
    const opts = this.fsw.options;
    const processPath = typeof transform2 === FUNCTION_TYPE$1 ? transform2 : IDENTITY_FN;
    const wh = this.fsw._getWatchHelpers(path4);
    try {
      const stats = await statMethods[wh.statMethod](wh.watchPath);
      if (this.fsw.closed)
        return;
      if (this.fsw._isIgnored(wh.watchPath, stats)) {
        throw null;
      }
      if (stats.isDirectory()) {
        if (!wh.globFilter)
          this.emitAdd(processPath(path4), stats, processPath, opts, forceAdd);
        if (priorDepth && priorDepth > opts.depth)
          return;
        this.fsw._readdirp(wh.watchPath, {
          fileFilter: (entry2) => wh.filterPath(entry2),
          directoryFilter: (entry2) => wh.filterDir(entry2),
          ...Depth(opts.depth - (priorDepth || 0))
        }).on(STR_DATA, (entry2) => {
          if (this.fsw.closed) {
            return;
          }
          if (entry2.stats.isDirectory() && !wh.filterPath(entry2))
            return;
          const joinedPath = sysPath$1.join(wh.watchPath, entry2.path);
          const { fullPath } = entry2;
          if (wh.followSymlinks && entry2.stats.isSymbolicLink()) {
            const curDepth = opts.depth === void 0 ? void 0 : calcDepth(joinedPath, sysPath$1.resolve(wh.watchPath)) + 1;
            this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
          } else {
            this.emitAdd(joinedPath, entry2.stats, processPath, opts, forceAdd);
          }
        }).on(EV_ERROR$1, EMPTY_FN$1).on(STR_END$1, () => {
          this.fsw._emitReady();
        });
      } else {
        this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);
        this.fsw._emitReady();
      }
    } catch (error2) {
      if (!error2 || this.fsw._handleError(error2)) {
        this.fsw._emitReady();
        this.fsw._emitReady();
      }
    }
    if (opts.persistent && forceAdd !== true) {
      if (typeof transform2 === FUNCTION_TYPE$1) {
        this.initWatch(void 0, path4, wh, processPath);
      } else {
        let realPath;
        try {
          realPath = await realpath2(wh.watchPath);
        } catch (e) {
        }
        this.initWatch(realPath, path4, wh, processPath);
      }
    }
  }
};
fseventsHandler.exports = FsEventsHandler$1;
fseventsHandler.exports.canUse = canUse;
var { EventEmitter: EventEmitter$2 } = import_events.default;
var fs$5 = import_fs.default;
var sysPath = import_path.default;
var { promisify } = import_util.default;
var readdirp = readdirp_1;
var anymatch = anymatch$2.exports.default;
var globParent2 = globParent$2;
var isGlob2 = isGlob$2;
var braces = braces_1;
var normalizePath3 = normalizePath$2;
var NodeFsHandler = nodefsHandler;
var FsEventsHandler = fseventsHandler.exports;
var {
  EV_ALL,
  EV_READY,
  EV_ADD,
  EV_CHANGE,
  EV_UNLINK,
  EV_ADD_DIR,
  EV_UNLINK_DIR,
  EV_RAW,
  EV_ERROR,
  STR_CLOSE,
  STR_END,
  BACK_SLASH_RE,
  DOUBLE_SLASH_RE,
  SLASH_OR_BACK_SLASH_RE,
  DOT_RE,
  REPLACER_RE,
  SLASH,
  SLASH_SLASH,
  BRACE_START,
  BANG,
  ONE_DOT,
  TWO_DOTS,
  GLOBSTAR,
  SLASH_GLOBSTAR,
  ANYMATCH_OPTS,
  STRING_TYPE,
  FUNCTION_TYPE,
  EMPTY_STR,
  EMPTY_FN,
  isWindows: isWindows$1,
  isMacos,
  isIBMi
} = constants$1;
var stat = promisify(fs$5.stat);
var readdir = promisify(fs$5.readdir);
var arrify = (value2 = []) => Array.isArray(value2) ? value2 : [value2];
var flatten = (list, result = []) => {
  list.forEach((item) => {
    if (Array.isArray(item)) {
      flatten(item, result);
    } else {
      result.push(item);
    }
  });
  return result;
};
var unifyPaths = (paths_) => {
  const paths = flatten(arrify(paths_));
  if (!paths.every((p) => typeof p === STRING_TYPE)) {
    throw new TypeError(`Non-string provided as watch path: ${paths}`);
  }
  return paths.map(normalizePathToUnix);
};
var toUnix = (string2) => {
  let str = string2.replace(BACK_SLASH_RE, SLASH);
  let prepend = false;
  if (str.startsWith(SLASH_SLASH)) {
    prepend = true;
  }
  while (str.match(DOUBLE_SLASH_RE)) {
    str = str.replace(DOUBLE_SLASH_RE, SLASH);
  }
  if (prepend) {
    str = SLASH + str;
  }
  return str;
};
var normalizePathToUnix = (path4) => toUnix(sysPath.normalize(toUnix(path4)));
var normalizeIgnored = (cwd = EMPTY_STR) => (path4) => {
  if (typeof path4 !== STRING_TYPE)
    return path4;
  return normalizePathToUnix(sysPath.isAbsolute(path4) ? path4 : sysPath.join(cwd, path4));
};
var getAbsolutePath = (path4, cwd) => {
  if (sysPath.isAbsolute(path4)) {
    return path4;
  }
  if (path4.startsWith(BANG)) {
    return BANG + sysPath.join(cwd, path4.slice(1));
  }
  return sysPath.join(cwd, path4);
};
var undef = (opts, key2) => opts[key2] === void 0;
var DirEntry = class {
  constructor(dir, removeWatcher) {
    this.path = dir;
    this._removeWatcher = removeWatcher;
    this.items = /* @__PURE__ */ new Set();
  }
  add(item) {
    const { items } = this;
    if (!items)
      return;
    if (item !== ONE_DOT && item !== TWO_DOTS)
      items.add(item);
  }
  async remove(item) {
    const { items } = this;
    if (!items)
      return;
    items.delete(item);
    if (items.size > 0)
      return;
    const dir = this.path;
    try {
      await readdir(dir);
    } catch (err) {
      if (this._removeWatcher) {
        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
      }
    }
  }
  has(item) {
    const { items } = this;
    if (!items)
      return;
    return items.has(item);
  }
  getChildren() {
    const { items } = this;
    if (!items)
      return;
    return [...items.values()];
  }
  dispose() {
    this.items.clear();
    delete this.path;
    delete this._removeWatcher;
    delete this.items;
    Object.freeze(this);
  }
};
var STAT_METHOD_F = "stat";
var STAT_METHOD_L = "lstat";
var WatchHelper = class {
  constructor(path4, watchPath, follow, fsw) {
    this.fsw = fsw;
    this.path = path4 = path4.replace(REPLACER_RE, EMPTY_STR);
    this.watchPath = watchPath;
    this.fullWatchPath = sysPath.resolve(watchPath);
    this.hasGlob = watchPath !== path4;
    if (path4 === EMPTY_STR)
      this.hasGlob = false;
    this.globSymlink = this.hasGlob && follow ? void 0 : false;
    this.globFilter = this.hasGlob ? anymatch(path4, void 0, ANYMATCH_OPTS) : false;
    this.dirParts = this.getDirParts(path4);
    this.dirParts.forEach((parts) => {
      if (parts.length > 1)
        parts.pop();
    });
    this.followSymlinks = follow;
    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
  }
  checkGlobSymlink(entry2) {
    if (this.globSymlink === void 0) {
      this.globSymlink = entry2.fullParentDir === this.fullWatchPath ? false : { realPath: entry2.fullParentDir, linkPath: this.fullWatchPath };
    }
    if (this.globSymlink) {
      return entry2.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);
    }
    return entry2.fullPath;
  }
  entryPath(entry2) {
    return sysPath.join(
      this.watchPath,
      sysPath.relative(this.watchPath, this.checkGlobSymlink(entry2))
    );
  }
  filterPath(entry2) {
    const { stats } = entry2;
    if (stats && stats.isSymbolicLink())
      return this.filterDir(entry2);
    const resolvedPath = this.entryPath(entry2);
    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;
    return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
  }
  getDirParts(path4) {
    if (!this.hasGlob)
      return [];
    const parts = [];
    const expandedPath = path4.includes(BRACE_START) ? braces.expand(path4) : [path4];
    expandedPath.forEach((path5) => {
      parts.push(sysPath.relative(this.watchPath, path5).split(SLASH_OR_BACK_SLASH_RE));
    });
    return parts;
  }
  filterDir(entry2) {
    if (this.hasGlob) {
      const entryParts = this.getDirParts(this.checkGlobSymlink(entry2));
      let globstar = false;
      this.unmatchedGlob = !this.dirParts.some((parts) => {
        return parts.every((part, i) => {
          if (part === GLOBSTAR)
            globstar = true;
          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);
        });
      });
    }
    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry2), entry2.stats);
  }
};
var FSWatcher = class extends EventEmitter$2 {
  constructor(_opts) {
    super();
    const opts = {};
    if (_opts)
      Object.assign(opts, _opts);
    this._watched = /* @__PURE__ */ new Map();
    this._closers = /* @__PURE__ */ new Map();
    this._ignoredPaths = /* @__PURE__ */ new Set();
    this._throttled = /* @__PURE__ */ new Map();
    this._symlinkPaths = /* @__PURE__ */ new Map();
    this._streams = /* @__PURE__ */ new Set();
    this.closed = false;
    if (undef(opts, "persistent"))
      opts.persistent = true;
    if (undef(opts, "ignoreInitial"))
      opts.ignoreInitial = false;
    if (undef(opts, "ignorePermissionErrors"))
      opts.ignorePermissionErrors = false;
    if (undef(opts, "interval"))
      opts.interval = 100;
    if (undef(opts, "binaryInterval"))
      opts.binaryInterval = 300;
    if (undef(opts, "disableGlobbing"))
      opts.disableGlobbing = false;
    opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;
    if (undef(opts, "useFsEvents"))
      opts.useFsEvents = !opts.usePolling;
    const canUseFsEvents = FsEventsHandler.canUse();
    if (!canUseFsEvents)
      opts.useFsEvents = false;
    if (undef(opts, "usePolling") && !opts.useFsEvents) {
      opts.usePolling = isMacos;
    }
    if (isIBMi) {
      opts.usePolling = true;
    }
    const envPoll = process.env.CHOKIDAR_USEPOLLING;
    if (envPoll !== void 0) {
      const envLower = envPoll.toLowerCase();
      if (envLower === "false" || envLower === "0") {
        opts.usePolling = false;
      } else if (envLower === "true" || envLower === "1") {
        opts.usePolling = true;
      } else {
        opts.usePolling = !!envLower;
      }
    }
    const envInterval = process.env.CHOKIDAR_INTERVAL;
    if (envInterval) {
      opts.interval = Number.parseInt(envInterval, 10);
    }
    if (undef(opts, "atomic"))
      opts.atomic = !opts.usePolling && !opts.useFsEvents;
    if (opts.atomic)
      this._pendingUnlinks = /* @__PURE__ */ new Map();
    if (undef(opts, "followSymlinks"))
      opts.followSymlinks = true;
    if (undef(opts, "awaitWriteFinish"))
      opts.awaitWriteFinish = false;
    if (opts.awaitWriteFinish === true)
      opts.awaitWriteFinish = {};
    const awf = opts.awaitWriteFinish;
    if (awf) {
      if (!awf.stabilityThreshold)
        awf.stabilityThreshold = 2e3;
      if (!awf.pollInterval)
        awf.pollInterval = 100;
      this._pendingWrites = /* @__PURE__ */ new Map();
    }
    if (opts.ignored)
      opts.ignored = arrify(opts.ignored);
    let readyCalls = 0;
    this._emitReady = () => {
      readyCalls++;
      if (readyCalls >= this._readyCount) {
        this._emitReady = EMPTY_FN;
        this._readyEmitted = true;
        process.nextTick(() => this.emit(EV_READY));
      }
    };
    this._emitRaw = (...args) => this.emit(EV_RAW, ...args);
    this._readyEmitted = false;
    this.options = opts;
    if (opts.useFsEvents) {
      this._fsEventsHandler = new FsEventsHandler(this);
    } else {
      this._nodeFsHandler = new NodeFsHandler(this);
    }
    Object.freeze(opts);
  }
  add(paths_, _origAdd, _internal) {
    const { cwd, disableGlobbing } = this.options;
    this.closed = false;
    let paths = unifyPaths(paths_);
    if (cwd) {
      paths = paths.map((path4) => {
        const absPath = getAbsolutePath(path4, cwd);
        if (disableGlobbing || !isGlob2(path4)) {
          return absPath;
        }
        return normalizePath3(absPath);
      });
    }
    paths = paths.filter((path4) => {
      if (path4.startsWith(BANG)) {
        this._ignoredPaths.add(path4.slice(1));
        return false;
      }
      this._ignoredPaths.delete(path4);
      this._ignoredPaths.delete(path4 + SLASH_GLOBSTAR);
      this._userIgnored = void 0;
      return true;
    });
    if (this.options.useFsEvents && this._fsEventsHandler) {
      if (!this._readyCount)
        this._readyCount = paths.length;
      if (this.options.persistent)
        this._readyCount *= 2;
      paths.forEach((path4) => this._fsEventsHandler._addToFsEvents(path4));
    } else {
      if (!this._readyCount)
        this._readyCount = 0;
      this._readyCount += paths.length;
      Promise.all(
        paths.map(async (path4) => {
          const res = await this._nodeFsHandler._addToNodeFs(path4, !_internal, 0, 0, _origAdd);
          if (res)
            this._emitReady();
          return res;
        })
      ).then((results) => {
        if (this.closed)
          return;
        results.filter((item) => item).forEach((item) => {
          this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
        });
      });
    }
    return this;
  }
  unwatch(paths_) {
    if (this.closed)
      return this;
    const paths = unifyPaths(paths_);
    const { cwd } = this.options;
    paths.forEach((path4) => {
      if (!sysPath.isAbsolute(path4) && !this._closers.has(path4)) {
        if (cwd)
          path4 = sysPath.join(cwd, path4);
        path4 = sysPath.resolve(path4);
      }
      this._closePath(path4);
      this._ignoredPaths.add(path4);
      if (this._watched.has(path4)) {
        this._ignoredPaths.add(path4 + SLASH_GLOBSTAR);
      }
      this._userIgnored = void 0;
    });
    return this;
  }
  close() {
    if (this.closed)
      return this._closePromise;
    this.closed = true;
    this.removeAllListeners();
    const closers = [];
    this._closers.forEach((closerList) => closerList.forEach((closer) => {
      const promise2 = closer();
      if (promise2 instanceof Promise)
        closers.push(promise2);
    }));
    this._streams.forEach((stream4) => stream4.destroy());
    this._userIgnored = void 0;
    this._readyCount = 0;
    this._readyEmitted = false;
    this._watched.forEach((dirent) => dirent.dispose());
    ["closers", "watched", "streams", "symlinkPaths", "throttled"].forEach((key2) => {
      this[`_${key2}`].clear();
    });
    this._closePromise = closers.length ? Promise.all(closers).then(() => void 0) : Promise.resolve();
    return this._closePromise;
  }
  getWatched() {
    const watchList = {};
    this._watched.forEach((entry2, dir) => {
      const key2 = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
      watchList[key2 || ONE_DOT] = entry2.getChildren().sort();
    });
    return watchList;
  }
  emitWithAll(event, args) {
    this.emit(...args);
    if (event !== EV_ERROR)
      this.emit(EV_ALL, ...args);
  }
  async _emit(event, path4, val1, val2, val3) {
    if (this.closed)
      return;
    const opts = this.options;
    if (isWindows$1)
      path4 = sysPath.normalize(path4);
    if (opts.cwd)
      path4 = sysPath.relative(opts.cwd, path4);
    const args = [event, path4];
    if (val3 !== void 0)
      args.push(val1, val2, val3);
    else if (val2 !== void 0)
      args.push(val1, val2);
    else if (val1 !== void 0)
      args.push(val1);
    const awf = opts.awaitWriteFinish;
    let pw;
    if (awf && (pw = this._pendingWrites.get(path4))) {
      pw.lastChange = new Date();
      return this;
    }
    if (opts.atomic) {
      if (event === EV_UNLINK) {
        this._pendingUnlinks.set(path4, args);
        setTimeout(() => {
          this._pendingUnlinks.forEach((entry2, path5) => {
            this.emit(...entry2);
            this.emit(EV_ALL, ...entry2);
            this._pendingUnlinks.delete(path5);
          });
        }, typeof opts.atomic === "number" ? opts.atomic : 100);
        return this;
      }
      if (event === EV_ADD && this._pendingUnlinks.has(path4)) {
        event = args[0] = EV_CHANGE;
        this._pendingUnlinks.delete(path4);
      }
    }
    if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {
      const awfEmit = (err, stats) => {
        if (err) {
          event = args[0] = EV_ERROR;
          args[1] = err;
          this.emitWithAll(event, args);
        } else if (stats) {
          if (args.length > 2) {
            args[2] = stats;
          } else {
            args.push(stats);
          }
          this.emitWithAll(event, args);
        }
      };
      this._awaitWriteFinish(path4, awf.stabilityThreshold, event, awfEmit);
      return this;
    }
    if (event === EV_CHANGE) {
      const isThrottled = !this._throttle(EV_CHANGE, path4, 50);
      if (isThrottled)
        return this;
    }
    if (opts.alwaysStat && val1 === void 0 && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)) {
      const fullPath = opts.cwd ? sysPath.join(opts.cwd, path4) : path4;
      let stats;
      try {
        stats = await stat(fullPath);
      } catch (err) {
      }
      if (!stats || this.closed)
        return;
      args.push(stats);
    }
    this.emitWithAll(event, args);
    return this;
  }
  _handleError(error2) {
    const code = error2 && error2.code;
    if (error2 && code !== "ENOENT" && code !== "ENOTDIR" && (!this.options.ignorePermissionErrors || code !== "EPERM" && code !== "EACCES")) {
      this.emit(EV_ERROR, error2);
    }
    return error2 || this.closed;
  }
  _throttle(actionType, path4, timeout2) {
    if (!this._throttled.has(actionType)) {
      this._throttled.set(actionType, /* @__PURE__ */ new Map());
    }
    const action = this._throttled.get(actionType);
    const actionPath = action.get(path4);
    if (actionPath) {
      actionPath.count++;
      return false;
    }
    let timeoutObject;
    const clear = () => {
      const item = action.get(path4);
      const count = item ? item.count : 0;
      action.delete(path4);
      clearTimeout(timeoutObject);
      if (item)
        clearTimeout(item.timeoutObject);
      return count;
    };
    timeoutObject = setTimeout(clear, timeout2);
    const thr = { timeoutObject, clear, count: 0 };
    action.set(path4, thr);
    return thr;
  }
  _incrReadyCount() {
    return this._readyCount++;
  }
  _awaitWriteFinish(path4, threshold2, event, awfEmit) {
    let timeoutHandler;
    let fullPath = path4;
    if (this.options.cwd && !sysPath.isAbsolute(path4)) {
      fullPath = sysPath.join(this.options.cwd, path4);
    }
    const now = new Date();
    const awaitWriteFinish = (prevStat) => {
      fs$5.stat(fullPath, (err, curStat) => {
        if (err || !this._pendingWrites.has(path4)) {
          if (err && err.code !== "ENOENT")
            awfEmit(err);
          return;
        }
        const now2 = Number(new Date());
        if (prevStat && curStat.size !== prevStat.size) {
          this._pendingWrites.get(path4).lastChange = now2;
        }
        const pw = this._pendingWrites.get(path4);
        const df = now2 - pw.lastChange;
        if (df >= threshold2) {
          this._pendingWrites.delete(path4);
          awfEmit(void 0, curStat);
        } else {
          timeoutHandler = setTimeout(
            awaitWriteFinish,
            this.options.awaitWriteFinish.pollInterval,
            curStat
          );
        }
      });
    };
    if (!this._pendingWrites.has(path4)) {
      this._pendingWrites.set(path4, {
        lastChange: now,
        cancelWait: () => {
          this._pendingWrites.delete(path4);
          clearTimeout(timeoutHandler);
          return event;
        }
      });
      timeoutHandler = setTimeout(
        awaitWriteFinish,
        this.options.awaitWriteFinish.pollInterval
      );
    }
  }
  _getGlobIgnored() {
    return [...this._ignoredPaths.values()];
  }
  _isIgnored(path4, stats) {
    if (this.options.atomic && DOT_RE.test(path4))
      return true;
    if (!this._userIgnored) {
      const { cwd } = this.options;
      const ign = this.options.ignored;
      const ignored = ign && ign.map(normalizeIgnored(cwd));
      const paths = arrify(ignored).filter((path5) => typeof path5 === STRING_TYPE && !isGlob2(path5)).map((path5) => path5 + SLASH_GLOBSTAR);
      const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);
      this._userIgnored = anymatch(list, void 0, ANYMATCH_OPTS);
    }
    return this._userIgnored([path4, stats]);
  }
  _isntIgnored(path4, stat2) {
    return !this._isIgnored(path4, stat2);
  }
  _getWatchHelpers(path4, depth2) {
    const watchPath = depth2 || this.options.disableGlobbing || !isGlob2(path4) ? path4 : globParent2(path4);
    const follow = this.options.followSymlinks;
    return new WatchHelper(path4, watchPath, follow, this);
  }
  _getWatchedDir(directory) {
    if (!this._boundRemove)
      this._boundRemove = this._remove.bind(this);
    const dir = sysPath.resolve(directory);
    if (!this._watched.has(dir))
      this._watched.set(dir, new DirEntry(dir, this._boundRemove));
    return this._watched.get(dir);
  }
  _hasReadPermissions(stats) {
    if (this.options.ignorePermissionErrors)
      return true;
    const md = stats && Number.parseInt(stats.mode, 10);
    const st = md & 511;
    const it = Number.parseInt(st.toString(8)[0], 10);
    return Boolean(4 & it);
  }
  _remove(directory, item, isDirectory2) {
    const path4 = sysPath.join(directory, item);
    const fullPath = sysPath.resolve(path4);
    isDirectory2 = isDirectory2 != null ? isDirectory2 : this._watched.has(path4) || this._watched.has(fullPath);
    if (!this._throttle("remove", path4, 100))
      return;
    if (!isDirectory2 && !this.options.useFsEvents && this._watched.size === 1) {
      this.add(directory, item, true);
    }
    const wp = this._getWatchedDir(path4);
    const nestedDirectoryChildren = wp.getChildren();
    nestedDirectoryChildren.forEach((nested) => this._remove(path4, nested));
    const parent = this._getWatchedDir(directory);
    const wasTracked = parent.has(item);
    parent.remove(item);
    if (this._symlinkPaths.has(fullPath)) {
      this._symlinkPaths.delete(fullPath);
    }
    let relPath = path4;
    if (this.options.cwd)
      relPath = sysPath.relative(this.options.cwd, path4);
    if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
      const event = this._pendingWrites.get(relPath).cancelWait();
      if (event === EV_ADD)
        return;
    }
    this._watched.delete(path4);
    this._watched.delete(fullPath);
    const eventName = isDirectory2 ? EV_UNLINK_DIR : EV_UNLINK;
    if (wasTracked && !this._isIgnored(path4))
      this._emit(eventName, path4);
    if (!this.options.useFsEvents) {
      this._closePath(path4);
    }
  }
  _closePath(path4) {
    this._closeFile(path4);
    const dir = sysPath.dirname(path4);
    this._getWatchedDir(dir).remove(sysPath.basename(path4));
  }
  _closeFile(path4) {
    const closers = this._closers.get(path4);
    if (!closers)
      return;
    closers.forEach((closer) => closer());
    this._closers.delete(path4);
  }
  _addPathCloser(path4, closer) {
    if (!closer)
      return;
    let list = this._closers.get(path4);
    if (!list) {
      list = [];
      this._closers.set(path4, list);
    }
    list.push(closer);
  }
  _readdirp(root2, opts) {
    if (this.closed)
      return;
    const options3 = { type: EV_ALL, alwaysStat: true, lstat: true, ...opts };
    let stream4 = readdirp(root2, options3);
    this._streams.add(stream4);
    stream4.once(STR_CLOSE, () => {
      stream4 = void 0;
    });
    stream4.once(STR_END, () => {
      if (stream4) {
        this._streams.delete(stream4);
        stream4 = void 0;
      }
    });
    return stream4;
  }
};
chokidar.FSWatcher = FSWatcher;
var watch = (paths, options3) => {
  const watcher = new FSWatcher(options3);
  watcher.add(paths);
  return watcher;
};
chokidar.watch = watch;
var shellQuote$1 = {};
shellQuote$1.quote = function(xs) {
  return xs.map(function(s) {
    if (s && typeof s === "object") {
      return s.op.replace(/(.)/g, "\\$1");
    } else if (/["\s]/.test(s) && !/'/.test(s)) {
      return "'" + s.replace(/(['\\])/g, "\\$1") + "'";
    } else if (/["'\s]/.test(s)) {
      return '"' + s.replace(/(["\\$`!])/g, "\\$1") + '"';
    } else {
      return String(s).replace(/([A-Za-z]:)?([#!"$&'()*,:;<=>?@\[\\\]^`{|}])/g, "$1\\$2");
    }
  }).join(" ");
};
var CONTROL = "(?:" + [
  "\\|\\|",
  "\\&\\&",
  ";;",
  "\\|\\&",
  "\\<\\(",
  ">>",
  ">\\&",
  "[&;()|<>]"
].join("|") + ")";
var META = "|&;()<> \\t";
var BAREWORD = `(\\\\['"` + META + `]|[^\\s'"` + META + "])+";
var SINGLE_QUOTE = '"((\\\\"|[^"])*?)"';
var DOUBLE_QUOTE = "'((\\\\'|[^'])*?)'";
var TOKEN = "";
for (i = 0; i < 4; i++) {
  TOKEN += (Math.pow(16, 8) * Math.random()).toString(16);
}
var i;
shellQuote$1.parse = function(s, env2, opts) {
  var mapped = parse$5(s, env2, opts);
  if (typeof env2 !== "function")
    return mapped;
  return mapped.reduce(function(acc, s2) {
    if (typeof s2 === "object")
      return acc.concat(s2);
    var xs = s2.split(RegExp("(" + TOKEN + ".*?" + TOKEN + ")", "g"));
    if (xs.length === 1)
      return acc.concat(xs[0]);
    return acc.concat(xs.filter(Boolean).map(function(x) {
      if (RegExp("^" + TOKEN).test(x)) {
        return JSON.parse(x.split(TOKEN)[1]);
      } else
        return x;
    }));
  }, []);
};
function parse$5(s, env2, opts) {
  var chunker = new RegExp([
    "(" + CONTROL + ")",
    "(" + BAREWORD + "|" + SINGLE_QUOTE + "|" + DOUBLE_QUOTE + ")*"
  ].join("|"), "g");
  var match = s.match(chunker).filter(Boolean);
  var commented = false;
  if (!match)
    return [];
  if (!env2)
    env2 = {};
  if (!opts)
    opts = {};
  return match.map(function(s2, j) {
    if (commented) {
      return;
    }
    if (RegExp("^" + CONTROL + "$").test(s2)) {
      return { op: s2 };
    }
    var SQ = "'";
    var DQ = '"';
    var DS = "$";
    var BS = opts.escape || "\\";
    var quote = false;
    var esc = false;
    var out2 = "";
    var isGlob3 = false;
    for (var i = 0, len = s2.length; i < len; i++) {
      var c2 = s2.charAt(i);
      isGlob3 = isGlob3 || !quote && (c2 === "*" || c2 === "?");
      if (esc) {
        out2 += c2;
        esc = false;
      } else if (quote) {
        if (c2 === quote) {
          quote = false;
        } else if (quote == SQ) {
          out2 += c2;
        } else {
          if (c2 === BS) {
            i += 1;
            c2 = s2.charAt(i);
            if (c2 === DQ || c2 === BS || c2 === DS) {
              out2 += c2;
            } else {
              out2 += BS + c2;
            }
          } else if (c2 === DS) {
            out2 += parseEnvVar();
          } else {
            out2 += c2;
          }
        }
      } else if (c2 === DQ || c2 === SQ) {
        quote = c2;
      } else if (RegExp("^" + CONTROL + "$").test(c2)) {
        return { op: s2 };
      } else if (RegExp("^#$").test(c2)) {
        commented = true;
        if (out2.length) {
          return [out2, { comment: s2.slice(i + 1) + match.slice(j + 1).join(" ") }];
        }
        return [{ comment: s2.slice(i + 1) + match.slice(j + 1).join(" ") }];
      } else if (c2 === BS) {
        esc = true;
      } else if (c2 === DS) {
        out2 += parseEnvVar();
      } else
        out2 += c2;
    }
    if (isGlob3)
      return { op: "glob", pattern: out2 };
    return out2;
    function parseEnvVar() {
      i += 1;
      var varend, varname;
      if (s2.charAt(i) === "{") {
        i += 1;
        if (s2.charAt(i) === "}") {
          throw new Error("Bad substitution: " + s2.substr(i - 2, 3));
        }
        varend = s2.indexOf("}", i);
        if (varend < 0) {
          throw new Error("Bad substitution: " + s2.substr(i));
        }
        varname = s2.substr(i, varend - i);
        i = varend;
      } else if (/[*@#?$!_\-]/.test(s2.charAt(i))) {
        varname = s2.charAt(i);
        i += 1;
      } else {
        varend = s2.substr(i).match(/[^\w\d_]/);
        if (!varend) {
          varname = s2.substr(i);
          i = s2.length;
        } else {
          varname = s2.substr(i, varend.index);
          i += varend.index - 1;
        }
      }
      return getVar(null, "", varname);
    }
  }).reduce(function(prev, arg) {
    if (arg === void 0) {
      return prev;
    }
    return prev.concat(arg);
  }, []);
  function getVar(_, pre, key2) {
    var r = typeof env2 === "function" ? env2(key2) : env2[key2];
    if (r === void 0 && key2 != "")
      r = "";
    else if (r === void 0)
      r = "$";
    if (typeof r === "object") {
      return pre + TOKEN + JSON.stringify(r) + TOKEN;
    } else
      return pre + r;
  }
}
var osx = {
  "/Applications/Atom.app/Contents/MacOS/Atom": "atom",
  "/Applications/Atom Beta.app/Contents/MacOS/Atom Beta": "/Applications/Atom Beta.app/Contents/MacOS/Atom Beta",
  "/Applications/Brackets.app/Contents/MacOS/Brackets": "brackets",
  "/Applications/Sublime Text.app/Contents/MacOS/Sublime Text": "/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl",
  "/Applications/Sublime Text.app/Contents/MacOS/sublime_text": "/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl",
  "/Applications/Sublime Text 2.app/Contents/MacOS/Sublime Text 2": "/Applications/Sublime Text 2.app/Contents/SharedSupport/bin/subl",
  "/Applications/Sublime Text Dev.app/Contents/MacOS/Sublime Text": "/Applications/Sublime Text Dev.app/Contents/SharedSupport/bin/subl",
  "/Applications/Visual Studio Code.app/Contents/MacOS/Electron": "code",
  "/Applications/Visual Studio Code - Insiders.app/Contents/MacOS/Electron": "code-insiders",
  "/Applications/VSCodium.app/Contents/MacOS/Electron": "codium",
  "/Applications/AppCode.app/Contents/MacOS/appcode": "/Applications/AppCode.app/Contents/MacOS/appcode",
  "/Applications/CLion.app/Contents/MacOS/clion": "/Applications/CLion.app/Contents/MacOS/clion",
  "/Applications/IntelliJ IDEA.app/Contents/MacOS/idea": "/Applications/IntelliJ IDEA.app/Contents/MacOS/idea",
  "/Applications/PhpStorm.app/Contents/MacOS/phpstorm": "/Applications/PhpStorm.app/Contents/MacOS/phpstorm",
  "/Applications/PyCharm.app/Contents/MacOS/pycharm": "/Applications/PyCharm.app/Contents/MacOS/pycharm",
  "/Applications/PyCharm CE.app/Contents/MacOS/pycharm": "/Applications/PyCharm CE.app/Contents/MacOS/pycharm",
  "/Applications/RubyMine.app/Contents/MacOS/rubymine": "/Applications/RubyMine.app/Contents/MacOS/rubymine",
  "/Applications/WebStorm.app/Contents/MacOS/webstorm": "/Applications/WebStorm.app/Contents/MacOS/webstorm",
  "/Applications/MacVim.app/Contents/MacOS/MacVim": "mvim",
  "/Applications/GoLand.app/Contents/MacOS/goland": "/Applications/GoLand.app/Contents/MacOS/goland",
  "/Applications/Rider.app/Contents/MacOS/rider": "/Applications/Rider.app/Contents/MacOS/rider"
};
var linux = {
  atom: "atom",
  Brackets: "brackets",
  code: "code",
  "code-insiders": "code-insiders",
  codium: "codium",
  vscodium: "vscodium",
  emacs: "emacs",
  gvim: "gvim",
  "idea.sh": "idea",
  "phpstorm.sh": "phpstorm",
  "pycharm.sh": "pycharm",
  "rubymine.sh": "rubymine",
  sublime_text: "subl",
  vim: "vim",
  "webstorm.sh": "webstorm",
  "goland.sh": "goland",
  "rider.sh": "rider"
};
var windows$1 = [
  "Brackets.exe",
  "Code.exe",
  "Code - Insiders.exe",
  "VSCodium.exe",
  "atom.exe",
  "sublime_text.exe",
  "notepad++.exe",
  "clion.exe",
  "clion64.exe",
  "idea.exe",
  "idea64.exe",
  "phpstorm.exe",
  "phpstorm64.exe",
  "pycharm.exe",
  "pycharm64.exe",
  "rubymine.exe",
  "rubymine64.exe",
  "webstorm.exe",
  "webstorm64.exe",
  "goland.exe",
  "goland64.exe",
  "rider.exe",
  "rider64.exe"
];
var path$7 = import_path.default;
var shellQuote = shellQuote$1;
var childProcess$2 = import_child_process.default;
var COMMON_EDITORS_OSX = osx;
var COMMON_EDITORS_LINUX = linux;
var COMMON_EDITORS_WIN = windows$1;
var guess = function guessEditor(specifiedEditor) {
  if (specifiedEditor) {
    return shellQuote.parse(specifiedEditor);
  }
  if (process.env.LAUNCH_EDITOR) {
    return [process.env.LAUNCH_EDITOR];
  }
  if (process.versions.webcontainer) {
    return [process.env.EDITOR || "code"];
  }
  try {
    if (process.platform === "darwin") {
      const output = childProcess$2.execSync("ps x -o comm=", {
        stdio: ["pipe", "pipe", "ignore"]
      }).toString();
      const processNames = Object.keys(COMMON_EDITORS_OSX);
      const processList = output.split("\n");
      for (let i = 0; i < processNames.length; i++) {
        const processName = processNames[i];
        if (output.indexOf(processName) !== -1) {
          return [COMMON_EDITORS_OSX[processName]];
        }
        const processNameWithoutApplications = processName.replace("/Applications", "");
        if (output.indexOf(processNameWithoutApplications) !== -1) {
          if (processName !== COMMON_EDITORS_OSX[processName]) {
            return [COMMON_EDITORS_OSX[processName]];
          }
          const runningProcess = processList.find((procName) => procName.endsWith(processNameWithoutApplications));
          if (runningProcess !== void 0) {
            return [runningProcess];
          }
        }
      }
    } else if (process.platform === "win32") {
      const output = childProcess$2.execSync(
        'powershell -NoProfile -Command "Get-CimInstance -Query \\"select executablepath from win32_process where executablepath is not null\\" | % { $_.ExecutablePath }"',
        {
          stdio: ["pipe", "pipe", "ignore"]
        }
      ).toString();
      const runningProcesses = output.split("\r\n");
      for (let i = 0; i < runningProcesses.length; i++) {
        const fullProcessPath = runningProcesses[i].trim();
        const shortProcessName = path$7.basename(fullProcessPath);
        if (COMMON_EDITORS_WIN.indexOf(shortProcessName) !== -1) {
          return [fullProcessPath];
        }
      }
    } else if (process.platform === "linux") {
      const output = childProcess$2.execSync("ps x --no-heading -o comm --sort=comm", {
        stdio: ["pipe", "pipe", "ignore"]
      }).toString();
      const processNames = Object.keys(COMMON_EDITORS_LINUX);
      for (let i = 0; i < processNames.length; i++) {
        const processName = processNames[i];
        if (output.indexOf(processName) !== -1) {
          return [COMMON_EDITORS_LINUX[processName]];
        }
      }
    }
  } catch (error2) {
  }
  if (process.env.VISUAL) {
    return [process.env.VISUAL];
  } else if (process.env.EDITOR) {
    return [process.env.EDITOR];
  }
  return [null];
};
var path$6 = import_path.default;
var getArgs = function getArgumentsForPosition(editor, fileName, lineNumber, columnNumber = 1) {
  const editorBasename = path$6.basename(editor).replace(/\.(exe|cmd|bat)$/i, "");
  switch (editorBasename) {
    case "atom":
    case "Atom":
    case "Atom Beta":
    case "subl":
    case "sublime":
    case "sublime_text":
    case "wstorm":
    case "charm":
      return [`${fileName}:${lineNumber}:${columnNumber}`];
    case "notepad++":
      return ["-n" + lineNumber, "-c" + columnNumber, fileName];
    case "vim":
    case "mvim":
      return [`+call cursor(${lineNumber}, ${columnNumber})`, fileName];
    case "joe":
    case "gvim":
      return [`+${lineNumber}`, fileName];
    case "emacs":
    case "emacsclient":
      return [`+${lineNumber}:${columnNumber}`, fileName];
    case "rmate":
    case "mate":
    case "mine":
      return ["--line", lineNumber, fileName];
    case "code":
    case "Code":
    case "code-insiders":
    case "Code - Insiders":
    case "codium":
    case "vscodium":
    case "VSCodium":
      return ["-r", "-g", `${fileName}:${lineNumber}:${columnNumber}`];
    case "appcode":
    case "clion":
    case "clion64":
    case "idea":
    case "idea64":
    case "phpstorm":
    case "phpstorm64":
    case "pycharm":
    case "pycharm64":
    case "rubymine":
    case "rubymine64":
    case "webstorm":
    case "webstorm64":
    case "goland":
    case "goland64":
    case "rider":
    case "rider64":
      return ["--line", lineNumber, "--column", columnNumber, fileName];
  }
  if (process.env.LAUNCH_EDITOR) {
    return [fileName, lineNumber, columnNumber];
  }
  return [fileName];
};
var fs$4 = import_fs.default;
var os$1 = import_os.default;
var path$5 = import_path.default;
var colors = picocolors.exports;
var childProcess$1 = import_child_process.default;
var guessEditor2 = guess;
var getArgumentsForPosition2 = getArgs;
function wrapErrorCallback(cb) {
  return (fileName, errorMessage) => {
    console.log();
    console.log(
      colors.red("Could not open " + path$5.basename(fileName) + " in the editor.")
    );
    if (errorMessage) {
      if (errorMessage[errorMessage.length - 1] !== ".") {
        errorMessage += ".";
      }
      console.log(
        colors.red("The editor process exited with an error: " + errorMessage)
      );
    }
    console.log();
    if (cb)
      cb(fileName, errorMessage);
  };
}
function isTerminalEditor(editor) {
  switch (editor) {
    case "vim":
    case "emacs":
    case "nano":
      return true;
  }
  return false;
}
var positionRE = /:(\d+)(:(\d+))?$/;
function parseFile(file) {
  const fileName = file.replace(positionRE, "");
  const match = file.match(positionRE);
  const lineNumber = match && match[1];
  const columnNumber = match && match[3];
  return {
    fileName,
    lineNumber,
    columnNumber
  };
}
var _childProcess = null;
function launchEditor(file, specifiedEditor, onErrorCallback) {
  const parsed = parseFile(file);
  let { fileName } = parsed;
  const { lineNumber, columnNumber } = parsed;
  if (!fs$4.existsSync(fileName)) {
    return;
  }
  if (typeof specifiedEditor === "function") {
    onErrorCallback = specifiedEditor;
    specifiedEditor = void 0;
  }
  onErrorCallback = wrapErrorCallback(onErrorCallback);
  const [editor, ...args] = guessEditor2(specifiedEditor);
  if (!editor) {
    onErrorCallback(fileName, null);
    return;
  }
  if (process.platform === "linux" && fileName.startsWith("/mnt/") && /Microsoft/i.test(os$1.release())) {
    fileName = path$5.relative("", fileName);
  }
  if (lineNumber) {
    const extraArgs = getArgumentsForPosition2(editor, fileName, lineNumber, columnNumber);
    args.push.apply(args, extraArgs);
  } else {
    args.push(fileName);
  }
  if (_childProcess && isTerminalEditor(editor)) {
    _childProcess.kill("SIGKILL");
  }
  if (process.platform === "win32") {
    _childProcess = childProcess$1.spawn(
      "cmd.exe",
      ["/C", editor].concat(args),
      { stdio: "inherit" }
    );
  } else {
    _childProcess = childProcess$1.spawn(editor, args, { stdio: "inherit" });
  }
  _childProcess.on("exit", function(errorCode) {
    _childProcess = null;
    if (errorCode) {
      onErrorCallback(fileName, "(code " + errorCode + ")");
    }
  });
  _childProcess.on("error", function(error2) {
    onErrorCallback(fileName, error2.message);
  });
}
var launchEditor_1 = launchEditor;
var url$2 = import_url.default;
var path$4 = import_path.default;
var launch = launchEditor_1;
var launchEditorMiddleware = (specifiedEditor, srcRoot, onErrorCallback) => {
  if (typeof specifiedEditor === "function") {
    onErrorCallback = specifiedEditor;
    specifiedEditor = void 0;
  }
  if (typeof srcRoot === "function") {
    onErrorCallback = srcRoot;
    srcRoot = void 0;
  }
  srcRoot = srcRoot || process.cwd();
  return function launchEditorMiddleware2(req2, res, next) {
    const { file } = url$2.parse(req2.url, true).query || {};
    if (!file) {
      res.statusCode = 500;
      res.end(`launch-editor-middleware: required query param "file" is missing.`);
    } else {
      launch(path$4.resolve(srcRoot, file), specifiedEditor, onErrorCallback);
      res.end();
    }
  };
};
async function resolveHttpServer({ proxy }, app, httpsOptions) {
  if (!httpsOptions) {
    const { createServer: createServer2 } = await import("./node_http-KLMXT43K.js");
    return createServer2(app);
  }
  if (proxy) {
    const { createServer: createServer2 } = await import("./node_https-62Y3S77H.js");
    return createServer2(httpsOptions, app);
  } else {
    const { createSecureServer } = await import("./node_http2-37P2YQTT.js");
    return createSecureServer(
      {
        maxSessionMemory: 1e3,
        ...httpsOptions,
        allowHTTP1: true
      },
      app
    );
  }
}
async function resolveHttpsConfig(https2) {
  if (!https2)
    return void 0;
  const httpsOption = isObject$1(https2) ? { ...https2 } : {};
  const { ca, cert, key: key2, pfx } = httpsOption;
  Object.assign(httpsOption, {
    ca: readFileIfExists(ca),
    cert: readFileIfExists(cert),
    key: readFileIfExists(key2),
    pfx: readFileIfExists(pfx)
  });
  return httpsOption;
}
function readFileIfExists(value2) {
  if (typeof value2 === "string") {
    try {
      return import_node_fs.default.readFileSync(import_node_path2.default.resolve(value2));
    } catch (e) {
      return value2;
    }
  }
  return value2;
}
async function httpServerStart(httpServer, serverOptions) {
  let { port, strictPort, host, logger } = serverOptions;
  return new Promise((resolve3, reject) => {
    const onError = (e) => {
      if (e.code === "EADDRINUSE") {
        if (strictPort) {
          httpServer.removeListener("error", onError);
          reject(new Error(`Port ${port} is already in use`));
        } else {
          logger.info(`Port ${port} is in use, trying another one...`);
          httpServer.listen(++port, host);
        }
      } else {
        httpServer.removeListener("error", onError);
        reject(e);
      }
    };
    httpServer.on("error", onError);
    httpServer.listen(port, host, () => {
      httpServer.removeListener("error", onError);
      resolve3(port);
    });
  });
}
function setClientErrorHandler(server2, logger) {
  server2.on("clientError", (err, socket) => {
    let msg = "400 Bad Request";
    if (err.code === "HPE_HEADER_OVERFLOW") {
      msg = "431 Request Header Fields Too Large";
      logger.warn(picocolors.exports.yellow("Server responded with status code 431. See https://vitejs.dev/guide/troubleshooting.html#_431-request-header-fields-too-large."));
    }
    if (err.code === "ECONNRESET" || !socket.writable) {
      return;
    }
    socket.end(`HTTP/1.1 ${msg}\r
\r
`);
  });
}
var WalkerBase = class {
  constructor() {
    this.should_skip = false;
    this.should_remove = false;
    this.replacement = null;
    this.context = {
      skip: () => this.should_skip = true,
      remove: () => this.should_remove = true,
      replace: (node2) => this.replacement = node2
    };
  }
  replace(parent, prop, index2, node2) {
    if (parent) {
      if (index2 !== null) {
        parent[prop][index2] = node2;
      } else {
        parent[prop] = node2;
      }
    }
  }
  remove(parent, prop, index2) {
    if (parent) {
      if (index2 !== null) {
        parent[prop].splice(index2, 1);
      } else {
        delete parent[prop];
      }
    }
  }
};
var SyncWalker = class extends WalkerBase {
  constructor(enter, leave) {
    super();
    this.enter = enter;
    this.leave = leave;
  }
  visit(node2, parent, prop, index2) {
    if (node2) {
      if (this.enter) {
        const _should_skip = this.should_skip;
        const _should_remove = this.should_remove;
        const _replacement = this.replacement;
        this.should_skip = false;
        this.should_remove = false;
        this.replacement = null;
        this.enter.call(this.context, node2, parent, prop, index2);
        if (this.replacement) {
          node2 = this.replacement;
          this.replace(parent, prop, index2, node2);
        }
        if (this.should_remove) {
          this.remove(parent, prop, index2);
        }
        const skipped = this.should_skip;
        const removed = this.should_remove;
        this.should_skip = _should_skip;
        this.should_remove = _should_remove;
        this.replacement = _replacement;
        if (skipped)
          return node2;
        if (removed)
          return null;
      }
      for (const key2 in node2) {
        const value2 = node2[key2];
        if (typeof value2 !== "object") {
          continue;
        } else if (Array.isArray(value2)) {
          for (let i = 0; i < value2.length; i += 1) {
            if (value2[i] !== null && typeof value2[i].type === "string") {
              if (!this.visit(value2[i], node2, key2, i)) {
                i--;
              }
            }
          }
        } else if (value2 !== null && typeof value2.type === "string") {
          this.visit(value2, node2, key2, null);
        }
      }
      if (this.leave) {
        const _replacement = this.replacement;
        const _should_remove = this.should_remove;
        this.replacement = null;
        this.should_remove = false;
        this.leave.call(this.context, node2, parent, prop, index2);
        if (this.replacement) {
          node2 = this.replacement;
          this.replace(parent, prop, index2, node2);
        }
        if (this.should_remove) {
          this.remove(parent, prop, index2);
        }
        const removed = this.should_remove;
        this.replacement = _replacement;
        this.should_remove = _should_remove;
        if (removed)
          return null;
      }
    }
    return node2;
  }
};
function walk$1(ast, { enter, leave }) {
  const instance = new SyncWalker(enter, leave);
  return instance.visit(ast, null);
}
function extract_names(param) {
  return extract_identifiers(param).map((node2) => node2.name);
}
function extract_identifiers(param, nodes = []) {
  switch (param.type) {
    case "Identifier":
      nodes.push(param);
      break;
    case "MemberExpression":
      let object = param;
      while (object.type === "MemberExpression") {
        object = object.object;
      }
      nodes.push(object);
      break;
    case "ObjectPattern":
      const handle_prop = (prop) => {
        if (prop.type === "RestElement") {
          extract_identifiers(prop.argument, nodes);
        } else {
          extract_identifiers(prop.value, nodes);
        }
      };
      param.properties.forEach(handle_prop);
      break;
    case "ArrayPattern":
      const handle_element = (element) => {
        if (element)
          extract_identifiers(element, nodes);
      };
      param.elements.forEach(handle_element);
      break;
    case "RestElement":
      extract_identifiers(param.argument, nodes);
      break;
    case "AssignmentPattern":
      extract_identifiers(param.left, nodes);
      break;
  }
  return nodes;
}
var ssrModuleExportsKey = `__vite_ssr_exports__`;
var ssrImportKey = `__vite_ssr_import__`;
var ssrDynamicImportKey = `__vite_ssr_dynamic_import__`;
var ssrExportAllKey = `__vite_ssr_exportAll__`;
var ssrImportMetaKey = `__vite_ssr_import_meta__`;
async function ssrTransform(code, inMap, url2, originalCode, options3) {
  var _a;
  if (((_a = options3 == null ? void 0 : options3.json) == null ? void 0 : _a.stringify) && isJSONRequest(url2)) {
    return ssrTransformJSON(code, inMap);
  }
  return ssrTransformScript(code, inMap, url2, originalCode);
}
async function ssrTransformJSON(code, inMap) {
  return {
    code: code.replace("export default", `${ssrModuleExportsKey}.default =`),
    map: inMap,
    deps: [],
    dynamicDeps: []
  };
}
async function ssrTransformScript(code, inMap, url2, originalCode) {
  const s = new MagicString(code);
  let ast;
  try {
    ast = parser.parse(code, {
      sourceType: "module",
      ecmaVersion: "latest",
      locations: true,
      allowHashBang: true
    });
  } catch (err) {
    if (!err.loc || !err.loc.line)
      throw err;
    const line2 = err.loc.line;
    throw new Error(`Parse failure: ${err.message}
Contents of line ${line2}: ${code.split("\n")[line2 - 1]}`);
  }
  let uid = 0;
  const deps = /* @__PURE__ */ new Set();
  const dynamicDeps = /* @__PURE__ */ new Set();
  const idToImportMap = /* @__PURE__ */ new Map();
  const declaredConst = /* @__PURE__ */ new Set();
  function defineImport(node2, source2) {
    deps.add(source2);
    const importId = `__vite_ssr_import_${uid++}__`;
    s.appendRight(node2.start, `const ${importId} = await ${ssrImportKey}(${JSON.stringify(source2)});
`);
    return importId;
  }
  function defineExport(position, name, local = name) {
    s.appendLeft(position, `
Object.defineProperty(${ssrModuleExportsKey}, "${name}", { enumerable: true, configurable: true, get(){ return ${local} }});`);
  }
  for (const node2 of ast.body) {
    if (node2.type === "ImportDeclaration") {
      s.remove(node2.start, node2.end);
      const importId = defineImport(node2, node2.source.value);
      for (const spec of node2.specifiers) {
        if (spec.type === "ImportSpecifier") {
          idToImportMap.set(spec.local.name, `${importId}.${spec.imported.name}`);
        } else if (spec.type === "ImportDefaultSpecifier") {
          idToImportMap.set(spec.local.name, `${importId}.default`);
        } else {
          idToImportMap.set(spec.local.name, importId);
        }
      }
    }
  }
  for (const node2 of ast.body) {
    if (node2.type === "ExportNamedDeclaration") {
      if (node2.declaration) {
        if (node2.declaration.type === "FunctionDeclaration" || node2.declaration.type === "ClassDeclaration") {
          defineExport(node2.end, node2.declaration.id.name);
        } else {
          for (const declaration of node2.declaration.declarations) {
            const names = extract_names(declaration.id);
            for (const name of names) {
              defineExport(node2.end, name);
            }
          }
        }
        s.remove(node2.start, node2.declaration.start);
      } else {
        s.remove(node2.start, node2.end);
        if (node2.source) {
          const importId = defineImport(node2, node2.source.value);
          for (const spec of node2.specifiers) {
            defineExport(node2.end, spec.exported.name, `${importId}.${spec.local.name}`);
          }
        } else {
          for (const spec of node2.specifiers) {
            const local = spec.local.name;
            const binding = idToImportMap.get(local);
            defineExport(node2.end, spec.exported.name, binding || local);
          }
        }
      }
    }
    if (node2.type === "ExportDefaultDeclaration") {
      const expressionTypes = ["FunctionExpression", "ClassExpression"];
      if ("id" in node2.declaration && node2.declaration.id && !expressionTypes.includes(node2.declaration.type)) {
        const { name } = node2.declaration.id;
        s.remove(node2.start, node2.start + 15);
        s.append(`
Object.defineProperty(${ssrModuleExportsKey}, "default", { enumerable: true, configurable: true, value: ${name} });`);
      } else {
        s.update(node2.start, node2.start + 14, `${ssrModuleExportsKey}.default =`);
      }
    }
    if (node2.type === "ExportAllDeclaration") {
      s.remove(node2.start, node2.end);
      const importId = defineImport(node2, node2.source.value);
      if (node2.exported) {
        defineExport(node2.end, node2.exported.name, `${importId}`);
      } else {
        s.appendLeft(node2.end, `${ssrExportAllKey}(${importId});`);
      }
    }
  }
  walk(ast, {
    onIdentifier(id, parent, parentStack) {
      const grandparent = parentStack[1];
      const binding = idToImportMap.get(id.name);
      if (!binding) {
        return;
      }
      if (isStaticProperty(parent) && parent.shorthand) {
        if (!isNodeInPattern(parent) || isInDestructuringAssignment(parent, parentStack)) {
          s.appendLeft(id.end, `: ${binding}`);
        }
      } else if (parent.type === "PropertyDefinition" && (grandparent == null ? void 0 : grandparent.type) === "ClassBody" || parent.type === "ClassDeclaration" && id === parent.superClass) {
        if (!declaredConst.has(id.name)) {
          declaredConst.add(id.name);
          const topNode = parentStack[parentStack.length - 2];
          s.prependRight(topNode.start, `const ${id.name} = ${binding};
`);
        }
      } else {
        s.update(id.start, id.end, binding);
      }
    },
    onImportMeta(node2) {
      s.update(node2.start, node2.end, ssrImportMetaKey);
    },
    onDynamicImport(node2) {
      s.update(node2.start, node2.start + 6, ssrDynamicImportKey);
      if (node2.type === "ImportExpression" && node2.source.type === "Literal") {
        dynamicDeps.add(node2.source.value);
      }
    }
  });
  let map2 = s.generateMap({ hires: true });
  if (inMap && inMap.mappings && inMap.sources.length > 0) {
    map2 = combineSourcemaps(url2, [
      {
        ...map2,
        sources: inMap.sources,
        sourcesContent: inMap.sourcesContent
      },
      inMap
    ], false);
  } else {
    map2.sources = [url2];
    map2.sourcesContent = [originalCode];
  }
  return {
    code: s.toString(),
    map: map2,
    deps: [...deps],
    dynamicDeps: [...dynamicDeps]
  };
}
var isNodeInPatternWeakSet = /* @__PURE__ */ new WeakSet();
var setIsNodeInPattern = (node2) => isNodeInPatternWeakSet.add(node2);
var isNodeInPattern = (node2) => isNodeInPatternWeakSet.has(node2);
function walk(root2, { onIdentifier, onImportMeta, onDynamicImport }) {
  const parentStack = [];
  const varKindStack = [];
  const scopeMap = /* @__PURE__ */ new WeakMap();
  const identifiers = [];
  const setScope = (node2, name) => {
    let scopeIds = scopeMap.get(node2);
    if (scopeIds && scopeIds.has(name)) {
      return;
    }
    if (!scopeIds) {
      scopeIds = /* @__PURE__ */ new Set();
      scopeMap.set(node2, scopeIds);
    }
    scopeIds.add(name);
  };
  function isInScope(name, parents) {
    return parents.some((node2) => {
      var _a;
      return node2 && ((_a = scopeMap.get(node2)) == null ? void 0 : _a.has(name));
    });
  }
  function handlePattern(p, parentScope) {
    if (p.type === "Identifier") {
      setScope(parentScope, p.name);
    } else if (p.type === "RestElement") {
      handlePattern(p.argument, parentScope);
    } else if (p.type === "ObjectPattern") {
      p.properties.forEach((property) => {
        if (property.type === "RestElement") {
          setScope(parentScope, property.argument.name);
        } else {
          handlePattern(property.value, parentScope);
        }
      });
    } else if (p.type === "ArrayPattern") {
      p.elements.forEach((element) => {
        if (element) {
          handlePattern(element, parentScope);
        }
      });
    } else if (p.type === "AssignmentPattern") {
      handlePattern(p.left, parentScope);
    } else {
      setScope(parentScope, p.name);
    }
  }
  walk$1(root2, {
    enter(node2, parent) {
      if (node2.type === "ImportDeclaration") {
        return this.skip();
      }
      if (parent && !(parent.type === "IfStatement" && node2 === parent.alternate)) {
        parentStack.unshift(parent);
      }
      if (node2.type === "VariableDeclaration") {
        varKindStack.unshift(node2.kind);
      }
      if (node2.type === "MetaProperty" && node2.meta.name === "import") {
        onImportMeta(node2);
      } else if (node2.type === "ImportExpression") {
        onDynamicImport(node2);
      }
      if (node2.type === "Identifier") {
        if (!isInScope(node2.name, parentStack) && isRefIdentifier(node2, parent, parentStack)) {
          identifiers.push([node2, parentStack.slice(0)]);
        }
      } else if (isFunction(node2)) {
        if (node2.type === "FunctionDeclaration") {
          const parentScope = findParentScope(parentStack);
          if (parentScope) {
            setScope(parentScope, node2.id.name);
          }
        }
        node2.params.forEach((p) => {
          if (p.type === "ObjectPattern" || p.type === "ArrayPattern") {
            handlePattern(p, node2);
            return;
          }
          walk$1(p.type === "AssignmentPattern" ? p.left : p, {
            enter(child, parent2) {
              if ((parent2 == null ? void 0 : parent2.type) === "AssignmentPattern" && (parent2 == null ? void 0 : parent2.right) === child) {
                return this.skip();
              }
              if (child.type !== "Identifier")
                return;
              if (isStaticPropertyKey(child, parent2))
                return;
              if ((parent2 == null ? void 0 : parent2.type) === "TemplateLiteral" && (parent2 == null ? void 0 : parent2.expressions.includes(child)) || (parent2 == null ? void 0 : parent2.type) === "CallExpression" && (parent2 == null ? void 0 : parent2.callee) === child) {
                return;
              }
              setScope(node2, child.name);
            }
          });
        });
      } else if (node2.type === "Property" && parent.type === "ObjectPattern") {
        setIsNodeInPattern(node2);
      } else if (node2.type === "VariableDeclarator") {
        const parentFunction = findParentScope(parentStack, varKindStack[0] === "var");
        if (parentFunction) {
          handlePattern(node2.id, parentFunction);
        }
      }
    },
    leave(node2, parent) {
      if (parent && !(parent.type === "IfStatement" && node2 === parent.alternate)) {
        parentStack.shift();
      }
      if (node2.type === "VariableDeclaration") {
        varKindStack.shift();
      }
    }
  });
  identifiers.forEach(([node2, stack2]) => {
    if (!isInScope(node2.name, stack2))
      onIdentifier(node2, stack2[0], stack2);
  });
}
function isRefIdentifier(id, parent, parentStack) {
  if (parent.type === "CatchClause" || (parent.type === "VariableDeclarator" || parent.type === "ClassDeclaration") && parent.id === id) {
    return false;
  }
  if (isFunction(parent)) {
    if (parent.id === id) {
      return false;
    }
    if (parent.params.includes(id)) {
      return false;
    }
  }
  if (parent.type === "MethodDefinition" && !parent.computed) {
    return false;
  }
  if (isStaticPropertyKey(id, parent)) {
    return false;
  }
  if (isNodeInPattern(parent) && parent.value === id) {
    return false;
  }
  if (parent.type === "ArrayPattern" && !isInDestructuringAssignment(parent, parentStack)) {
    return false;
  }
  if (parent.type === "MemberExpression" && parent.property === id && !parent.computed) {
    return false;
  }
  if (parent.type === "ExportSpecifier") {
    return false;
  }
  if (id.name === "arguments") {
    return false;
  }
  return true;
}
var isStaticProperty = (node2) => node2 && node2.type === "Property" && !node2.computed;
var isStaticPropertyKey = (node2, parent) => isStaticProperty(parent) && parent.key === node2;
var functionNodeTypeRE = /Function(?:Expression|Declaration)$|Method$/;
function isFunction(node2) {
  return functionNodeTypeRE.test(node2.type);
}
var scopeNodeTypeRE = /(?:Function|Class)(?:Expression|Declaration)$|Method$|^IfStatement$/;
function findParentScope(parentStack, isVar = false) {
  const regex = isVar ? functionNodeTypeRE : scopeNodeTypeRE;
  return parentStack.find((i) => regex.test(i.type));
}
function isInDestructuringAssignment(parent, parentStack) {
  if (parent && (parent.type === "Property" || parent.type === "ArrayPattern")) {
    return parentStack.some((i) => i.type === "AssignmentExpression");
  }
  return false;
}
var offset2;
try {
  new Function("throw new Error(1)")();
} catch (e) {
  const match = /:(\d+):\d+\)$/.exec(e.stack.split("\n")[1]);
  offset2 = match ? +match[1] - 1 : 0;
}
function ssrRewriteStacktrace(stack2, moduleGraph) {
  return stack2.split("\n").map((line2) => {
    return line2.replace(/^ {4}at (?:(.+?)\s+\()?(?:(.+?):(\d+)(?::(\d+))?)\)?/, (input, varName, url2, line3, column2) => {
      var _a;
      if (!url2)
        return input;
      const mod = moduleGraph.urlToModuleMap.get(url2);
      const rawSourceMap = (_a = mod == null ? void 0 : mod.ssrTransformResult) == null ? void 0 : _a.map;
      if (!rawSourceMap) {
        return input;
      }
      const traced = new TraceMap(rawSourceMap);
      const pos2 = originalPositionFor$1(traced, {
        line: Number(line3) - offset2,
        column: Number(column2)
      });
      if (!pos2.source || pos2.line == null || pos2.column == null) {
        return input;
      }
      const source2 = `${pos2.source}:${pos2.line}:${pos2.column}`;
      if (!varName || varName === "eval") {
        return `    at ${source2}`;
      } else {
        return `    at ${varName} (${source2})`;
      }
    });
  }).join("\n");
}
function rebindErrorStacktrace(e, stacktrace) {
  const { configurable, writable } = Object.getOwnPropertyDescriptor(e, "stack");
  if (configurable) {
    Object.defineProperty(e, "stack", {
      value: stacktrace,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else if (writable) {
    e.stack = stacktrace;
  }
}
var pendingModules = /* @__PURE__ */ new Map();
var pendingImports = /* @__PURE__ */ new Map();
async function ssrLoadModule(url2, server2, context = { global }, urlStack = [], fixStacktrace) {
  url2 = unwrapId(url2);
  const pending = pendingModules.get(url2);
  if (pending) {
    return pending;
  }
  const modulePromise = instantiateModule(url2, server2, context, urlStack, fixStacktrace);
  pendingModules.set(url2, modulePromise);
  modulePromise.catch(() => {
    pendingImports.delete(url2);
  }).finally(() => {
    pendingModules.delete(url2);
  });
  return modulePromise;
}
async function instantiateModule(url2, server2, context = { global }, urlStack = [], fixStacktrace) {
  const { moduleGraph } = server2;
  const mod = await moduleGraph.ensureEntryFromUrl(url2, true);
  if (mod.ssrError) {
    throw mod.ssrError;
  }
  if (mod.ssrModule) {
    return mod.ssrModule;
  }
  const result = mod.ssrTransformResult || await transformRequest(url2, server2, { ssr: true });
  if (!result) {
    throw new Error(`failed to load module for ssr: ${url2}`);
  }
  const ssrModule = {
    [Symbol.toStringTag]: "Module"
  };
  Object.defineProperty(ssrModule, "__esModule", { value: true });
  mod.ssrModule = ssrModule;
  const ssrImportMeta = {
    url: (0, import_node_url2.pathToFileURL)(mod.file).toString()
  };
  urlStack = urlStack.concat(url2);
  const isCircular = (url3) => urlStack.includes(url3);
  const { isProduction, resolve: { dedupe, preserveSymlinks }, root: root2 } = server2.config;
  const resolveOptions = {
    mainFields: ["main"],
    browserField: true,
    conditions: [],
    extensions: [".js", ".cjs", ".json"],
    dedupe,
    preserveSymlinks,
    isBuild: true,
    isProduction,
    isRequire: true,
    root: root2,
    isHookNodeResolve: true
  };
  const pendingDeps = [];
  const ssrImport = async (dep) => {
    var _a, _b;
    if (dep[0] !== "." && dep[0] !== "/") {
      return nodeImport(dep, mod.file, resolveOptions);
    }
    dep = unwrapId(dep);
    if (!isCircular(dep) && !((_a = pendingImports.get(dep)) == null ? void 0 : _a.some(isCircular))) {
      pendingDeps.push(dep);
      if (pendingDeps.length === 1) {
        pendingImports.set(url2, pendingDeps);
      }
      const mod2 = await ssrLoadModule(dep, server2, context, urlStack, fixStacktrace);
      if (pendingDeps.length === 1) {
        pendingImports.delete(url2);
      } else {
        pendingDeps.splice(pendingDeps.indexOf(dep), 1);
      }
      return mod2;
    }
    return (_b = moduleGraph.urlToModuleMap.get(dep)) == null ? void 0 : _b.ssrModule;
  };
  const ssrDynamicImport = (dep) => {
    if (dep[0] === ".") {
      dep = import_node_path2.default.posix.resolve(import_node_path2.default.dirname(url2), dep);
    }
    return ssrImport(dep);
  };
  function ssrExportAll(sourceModule) {
    for (const key2 in sourceModule) {
      if (key2 !== "default") {
        Object.defineProperty(ssrModule, key2, {
          enumerable: true,
          configurable: true,
          get() {
            return sourceModule[key2];
          }
        });
      }
    }
  }
  try {
    const AsyncFunction = async function() {
    }.constructor;
    const initModule = new AsyncFunction(`global`, ssrModuleExportsKey, ssrImportMetaKey, ssrImportKey, ssrDynamicImportKey, ssrExportAllKey, '"use strict";' + result.code + `
//# sourceURL=${mod.url}`);
    await initModule(context.global, ssrModule, ssrImportMeta, ssrImport, ssrDynamicImport, ssrExportAll);
  } catch (e) {
    mod.ssrError = e;
    if (e.stack && fixStacktrace) {
      const stacktrace = ssrRewriteStacktrace(e.stack, moduleGraph);
      rebindErrorStacktrace(e, stacktrace);
      server2.config.logger.error(`Error when evaluating SSR module ${url2}:
${stacktrace}`, {
        timestamp: true,
        clear: server2.config.clearScreen,
        error: e
      });
    }
    throw e;
  }
  return Object.freeze(ssrModule);
}
var importingCount = 0;
var unhookNodeResolve;
async function nodeImport(id, importer, resolveOptions) {
  const viteResolve = (id2, importer2, options3 = resolveOptions) => {
    const resolved = tryNodeResolve(id2, importer2, options3, false);
    if (!resolved) {
      const err = new Error(`Cannot find module '${id2}' imported from '${importer2}'`);
      err.code = "ERR_MODULE_NOT_FOUND";
      throw err;
    }
    return resolved.id;
  };
  if (importingCount === 0) {
    unhookNodeResolve = hookNodeResolve((nodeResolve) => (id2, parent, isMain, options3) => {
      if (!bareImportRE.test(id2) || import_node_path2.default.isAbsolute(id2) || isBuiltin(id2) || id2.endsWith(".node")) {
        return nodeResolve(id2, parent, isMain, options3);
      }
      if (parent) {
        let resolved = viteResolve(id2, parent.id);
        if (resolved) {
          resolved = import_node_path2.default.normalize(resolved);
        }
        return resolved;
      }
      return id2;
    });
  }
  let url2;
  if (id.startsWith("node:") || isBuiltin(id)) {
    url2 = id;
  } else {
    url2 = viteResolve(
      id,
      importer,
      typeof jest === "undefined" ? { ...resolveOptions, tryEsmOnly: true } : resolveOptions
    );
    if (usingDynamicImport) {
      url2 = (0, import_node_url2.pathToFileURL)(url2).toString();
    }
  }
  try {
    importingCount++;
    const mod = await dynamicImport(url2);
    return proxyESM(mod);
  } finally {
    importingCount--;
    if (importingCount === 0) {
      unhookNodeResolve == null ? void 0 : unhookNodeResolve();
    }
  }
}
function proxyESM(mod) {
  if (isPrimitive(mod))
    return { default: mod };
  let defaultExport = "default" in mod ? mod.default : mod;
  if (!isPrimitive(defaultExport) && "__esModule" in defaultExport) {
    mod = defaultExport;
    if ("default" in defaultExport) {
      defaultExport = defaultExport.default;
    }
  }
  return new Proxy(mod, {
    get(mod2, prop) {
      var _a;
      if (prop === "default")
        return defaultExport;
      return (_a = mod2[prop]) != null ? _a : defaultExport == null ? void 0 : defaultExport[prop];
    }
  });
}
function isPrimitive(value2) {
  return !value2 || typeof value2 !== "object" && typeof value2 !== "function";
}
var bufferUtil$1 = { exports: {} };
var constants = {
  BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
  EMPTY_BUFFER: Buffer.alloc(0),
  GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
  kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
  kListener: Symbol("kListener"),
  kStatusCode: Symbol("status-code"),
  kWebSocket: Symbol("websocket"),
  NOOP: () => {
  }
};
var { EMPTY_BUFFER: EMPTY_BUFFER$3 } = constants;
function concat$1(list, totalLength) {
  if (list.length === 0)
    return EMPTY_BUFFER$3;
  if (list.length === 1)
    return list[0];
  const target = Buffer.allocUnsafe(totalLength);
  let offset3 = 0;
  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    target.set(buf, offset3);
    offset3 += buf.length;
  }
  if (offset3 < totalLength)
    return target.slice(0, offset3);
  return target;
}
function _mask(source2, mask, output, offset3, length) {
  for (let i = 0; i < length; i++) {
    output[offset3 + i] = source2[i] ^ mask[i & 3];
  }
}
function _unmask(buffer2, mask) {
  for (let i = 0; i < buffer2.length; i++) {
    buffer2[i] ^= mask[i & 3];
  }
}
function toArrayBuffer$1(buf) {
  if (buf.byteLength === buf.buffer.byteLength) {
    return buf.buffer;
  }
  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
}
function toBuffer$2(data2) {
  toBuffer$2.readOnly = true;
  if (Buffer.isBuffer(data2))
    return data2;
  let buf;
  if (data2 instanceof ArrayBuffer) {
    buf = Buffer.from(data2);
  } else if (ArrayBuffer.isView(data2)) {
    buf = Buffer.from(data2.buffer, data2.byteOffset, data2.byteLength);
  } else {
    buf = Buffer.from(data2);
    toBuffer$2.readOnly = false;
  }
  return buf;
}
bufferUtil$1.exports = {
  concat: concat$1,
  mask: _mask,
  toArrayBuffer: toArrayBuffer$1,
  toBuffer: toBuffer$2,
  unmask: _unmask
};
if (!process.env.WS_NO_BUFFER_UTIL) {
  try {
    const bufferUtil2 = require2("bufferutil");
    bufferUtil$1.exports.mask = function(source2, mask, output, offset3, length) {
      if (length < 48)
        _mask(source2, mask, output, offset3, length);
      else
        bufferUtil2.mask(source2, mask, output, offset3, length);
    };
    bufferUtil$1.exports.unmask = function(buffer2, mask) {
      if (buffer2.length < 32)
        _unmask(buffer2, mask);
      else
        bufferUtil2.unmask(buffer2, mask);
    };
  } catch (e) {
  }
}
var kDone = Symbol("kDone");
var kRun = Symbol("kRun");
var Limiter$1 = class {
  constructor(concurrency) {
    this[kDone] = () => {
      this.pending--;
      this[kRun]();
    };
    this.concurrency = concurrency || Infinity;
    this.jobs = [];
    this.pending = 0;
  }
  add(job) {
    this.jobs.push(job);
    this[kRun]();
  }
  [kRun]() {
    if (this.pending === this.concurrency)
      return;
    if (this.jobs.length) {
      const job = this.jobs.shift();
      this.pending++;
      job(this[kDone]);
    }
  }
};
var limiter = Limiter$1;
var zlib = import_zlib.default;
var bufferUtil = bufferUtil$1.exports;
var Limiter = limiter;
var { kStatusCode: kStatusCode$2 } = constants;
var TRAILER = Buffer.from([0, 0, 255, 255]);
var kPerMessageDeflate = Symbol("permessage-deflate");
var kTotalLength = Symbol("total-length");
var kCallback = Symbol("callback");
var kBuffers = Symbol("buffers");
var kError$1 = Symbol("error");
var zlibLimiter;
var PerMessageDeflate$4 = class {
  constructor(options3, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options3 || {};
    this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;
    this.params = null;
    if (!zlibLimiter) {
      const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
      zlibLimiter = new Limiter(concurrency);
    }
  }
  static get extensionName() {
    return "permessage-deflate";
  }
  offer() {
    const params = {};
    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }
    return params;
  }
  accept(configurations) {
    configurations = this.normalizeParams(configurations);
    this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
    return this.params;
  }
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }
    if (this._deflate) {
      const callback = this._deflate[kCallback];
      this._deflate.close();
      this._deflate = null;
      if (callback) {
        callback(
          new Error(
            "The deflate stream was closed while data was being processed"
          )
        );
      }
    }
  }
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
        return false;
      }
      return true;
    });
    if (!accepted) {
      throw new Error("None of the extension offers can be accepted");
    }
    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === "number") {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === "number") {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
      delete accepted.client_max_window_bits;
    }
    return accepted;
  }
  acceptAsClient(response) {
    const params = response[0];
    if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }
    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === "number") {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }
    return params;
  }
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key2) => {
        let value2 = params[key2];
        if (value2.length > 1) {
          throw new Error(`Parameter "${key2}" must have only a single value`);
        }
        value2 = value2[0];
        if (key2 === "client_max_window_bits") {
          if (value2 !== true) {
            const num = +value2;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key2}": ${value2}`
              );
            }
            value2 = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key2}": ${value2}`
            );
          }
        } else if (key2 === "server_max_window_bits") {
          const num = +value2;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key2}": ${value2}`
            );
          }
          value2 = num;
        } else if (key2 === "client_no_context_takeover" || key2 === "server_no_context_takeover") {
          if (value2 !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key2}": ${value2}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key2}"`);
        }
        params[key2] = value2;
      });
    });
    return configurations;
  }
  decompress(data2, fin, callback) {
    zlibLimiter.add((done) => {
      this._decompress(data2, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }
  compress(data2, fin, callback) {
    zlibLimiter.add((done) => {
      this._compress(data2, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }
  _decompress(data2, fin, callback) {
    const endpoint = this._isServer ? "client" : "server";
    if (!this._inflate) {
      const key2 = `${endpoint}_max_window_bits`;
      const windowBits = typeof this.params[key2] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key2];
      this._inflate = zlib.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits
      });
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on("error", inflateOnError);
      this._inflate.on("data", inflateOnData);
    }
    this._inflate[kCallback] = callback;
    this._inflate.write(data2);
    if (fin)
      this._inflate.write(TRAILER);
    this._inflate.flush(() => {
      const err = this._inflate[kError$1];
      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      }
      const data3 = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );
      if (this._inflate._readableState.endEmitted) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._inflate.reset();
        }
      }
      callback(null, data3);
    });
  }
  _compress(data2, fin, callback) {
    const endpoint = this._isServer ? "server" : "client";
    if (!this._deflate) {
      const key2 = `${endpoint}_max_window_bits`;
      const windowBits = typeof this.params[key2] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key2];
      this._deflate = zlib.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits
      });
      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];
      this._deflate.on("data", deflateOnData);
    }
    this._deflate[kCallback] = callback;
    this._deflate.write(data2);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        return;
      }
      let data3 = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );
      if (fin)
        data3 = data3.slice(0, data3.length - 4);
      this._deflate[kCallback] = null;
      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];
      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.reset();
      }
      callback(null, data3);
    });
  }
};
var permessageDeflate = PerMessageDeflate$4;
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;
  if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
    this[kBuffers].push(chunk);
    return;
  }
  this[kError$1] = new RangeError("Max payload size exceeded");
  this[kError$1].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
  this[kError$1][kStatusCode$2] = 1009;
  this.removeListener("data", inflateOnData);
  this.reset();
}
function inflateOnError(err) {
  this[kPerMessageDeflate]._inflate = null;
  err[kStatusCode$2] = 1007;
  this[kCallback](err);
}
var validation = { exports: {} };
var tokenChars$2 = [
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  0,
  1,
  0
];
function isValidStatusCode$2(code) {
  return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
}
function _isValidUTF8(buf) {
  const len = buf.length;
  let i = 0;
  while (i < len) {
    if ((buf[i] & 128) === 0) {
      i++;
    } else if ((buf[i] & 224) === 192) {
      if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
        return false;
      }
      i += 2;
    } else if ((buf[i] & 240) === 224) {
      if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
        return false;
      }
      i += 3;
    } else if ((buf[i] & 248) === 240) {
      if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
        return false;
      }
      i += 4;
    } else {
      return false;
    }
  }
  return true;
}
validation.exports = {
  isValidStatusCode: isValidStatusCode$2,
  isValidUTF8: _isValidUTF8,
  tokenChars: tokenChars$2
};
if (!process.env.WS_NO_UTF_8_VALIDATE) {
  try {
    const isValidUTF82 = require2("utf-8-validate");
    validation.exports.isValidUTF8 = function(buf) {
      return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF82(buf);
    };
  } catch (e) {
  }
}
var { Writable: Writable$1 } = import_stream.default;
var PerMessageDeflate$3 = permessageDeflate;
var {
  BINARY_TYPES: BINARY_TYPES$1,
  EMPTY_BUFFER: EMPTY_BUFFER$2,
  kStatusCode: kStatusCode$1,
  kWebSocket: kWebSocket$2
} = constants;
var { concat, toArrayBuffer, unmask } = bufferUtil$1.exports;
var { isValidStatusCode: isValidStatusCode$1, isValidUTF8 } = validation.exports;
var GET_INFO = 0;
var GET_PAYLOAD_LENGTH_16 = 1;
var GET_PAYLOAD_LENGTH_64 = 2;
var GET_MASK = 3;
var GET_DATA = 4;
var INFLATING = 5;
var Receiver$1 = class extends Writable$1 {
  constructor(options3 = {}) {
    super();
    this._binaryType = options3.binaryType || BINARY_TYPES$1[0];
    this._extensions = options3.extensions || {};
    this._isServer = !!options3.isServer;
    this._maxPayload = options3.maxPayload | 0;
    this._skipUTF8Validation = !!options3.skipUTF8Validation;
    this[kWebSocket$2] = void 0;
    this._bufferedBytes = 0;
    this._buffers = [];
    this._compressed = false;
    this._payloadLength = 0;
    this._mask = void 0;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;
    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];
    this._state = GET_INFO;
    this._loop = false;
  }
  _write(chunk, encoding, cb) {
    if (this._opcode === 8 && this._state == GET_INFO)
      return cb();
    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }
  consume(n2) {
    this._bufferedBytes -= n2;
    if (n2 === this._buffers[0].length)
      return this._buffers.shift();
    if (n2 < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = buf.slice(n2);
      return buf.slice(0, n2);
    }
    const dst = Buffer.allocUnsafe(n2);
    do {
      const buf = this._buffers[0];
      const offset3 = dst.length - n2;
      if (n2 >= buf.length) {
        dst.set(this._buffers.shift(), offset3);
      } else {
        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n2), offset3);
        this._buffers[0] = buf.slice(n2);
      }
      n2 -= buf.length;
    } while (n2 > 0);
    return dst;
  }
  startLoop(cb) {
    let err;
    this._loop = true;
    do {
      switch (this._state) {
        case GET_INFO:
          err = this.getInfo();
          break;
        case GET_PAYLOAD_LENGTH_16:
          err = this.getPayloadLength16();
          break;
        case GET_PAYLOAD_LENGTH_64:
          err = this.getPayloadLength64();
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          err = this.getData(cb);
          break;
        default:
          this._loop = false;
          return;
      }
    } while (this._loop);
    cb(err);
  }
  getInfo() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }
    const buf = this.consume(2);
    if ((buf[0] & 48) !== 0) {
      this._loop = false;
      return error(
        RangeError,
        "RSV2 and RSV3 must be clear",
        true,
        1002,
        "WS_ERR_UNEXPECTED_RSV_2_3"
      );
    }
    const compressed = (buf[0] & 64) === 64;
    if (compressed && !this._extensions[PerMessageDeflate$3.extensionName]) {
      this._loop = false;
      return error(
        RangeError,
        "RSV1 must be clear",
        true,
        1002,
        "WS_ERR_UNEXPECTED_RSV_1"
      );
    }
    this._fin = (buf[0] & 128) === 128;
    this._opcode = buf[0] & 15;
    this._payloadLength = buf[1] & 127;
    if (this._opcode === 0) {
      if (compressed) {
        this._loop = false;
        return error(
          RangeError,
          "RSV1 must be clear",
          true,
          1002,
          "WS_ERR_UNEXPECTED_RSV_1"
        );
      }
      if (!this._fragmented) {
        this._loop = false;
        return error(
          RangeError,
          "invalid opcode 0",
          true,
          1002,
          "WS_ERR_INVALID_OPCODE"
        );
      }
      this._opcode = this._fragmented;
    } else if (this._opcode === 1 || this._opcode === 2) {
      if (this._fragmented) {
        this._loop = false;
        return error(
          RangeError,
          `invalid opcode ${this._opcode}`,
          true,
          1002,
          "WS_ERR_INVALID_OPCODE"
        );
      }
      this._compressed = compressed;
    } else if (this._opcode > 7 && this._opcode < 11) {
      if (!this._fin) {
        this._loop = false;
        return error(
          RangeError,
          "FIN must be set",
          true,
          1002,
          "WS_ERR_EXPECTED_FIN"
        );
      }
      if (compressed) {
        this._loop = false;
        return error(
          RangeError,
          "RSV1 must be clear",
          true,
          1002,
          "WS_ERR_UNEXPECTED_RSV_1"
        );
      }
      if (this._payloadLength > 125) {
        this._loop = false;
        return error(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002,
          "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
        );
      }
    } else {
      this._loop = false;
      return error(
        RangeError,
        `invalid opcode ${this._opcode}`,
        true,
        1002,
        "WS_ERR_INVALID_OPCODE"
      );
    }
    if (!this._fin && !this._fragmented)
      this._fragmented = this._opcode;
    this._masked = (buf[1] & 128) === 128;
    if (this._isServer) {
      if (!this._masked) {
        this._loop = false;
        return error(
          RangeError,
          "MASK must be set",
          true,
          1002,
          "WS_ERR_EXPECTED_MASK"
        );
      }
    } else if (this._masked) {
      this._loop = false;
      return error(
        RangeError,
        "MASK must be clear",
        true,
        1002,
        "WS_ERR_UNEXPECTED_MASK"
      );
    }
    if (this._payloadLength === 126)
      this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127)
      this._state = GET_PAYLOAD_LENGTH_64;
    else
      return this.haveLength();
  }
  getPayloadLength16() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }
    this._payloadLength = this.consume(2).readUInt16BE(0);
    return this.haveLength();
  }
  getPayloadLength64() {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }
    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);
    if (num > Math.pow(2, 53 - 32) - 1) {
      this._loop = false;
      return error(
        RangeError,
        "Unsupported WebSocket frame: payload length > 2^53 - 1",
        false,
        1009,
        "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
      );
    }
    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    return this.haveLength();
  }
  haveLength() {
    if (this._payloadLength && this._opcode < 8) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        this._loop = false;
        return error(
          RangeError,
          "Max payload size exceeded",
          false,
          1009,
          "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
        );
      }
    }
    if (this._masked)
      this._state = GET_MASK;
    else
      this._state = GET_DATA;
  }
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }
    this._mask = this.consume(4);
    this._state = GET_DATA;
  }
  getData(cb) {
    let data2 = EMPTY_BUFFER$2;
    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }
      data2 = this.consume(this._payloadLength);
      if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
        unmask(data2, this._mask);
      }
    }
    if (this._opcode > 7)
      return this.controlMessage(data2);
    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data2, cb);
      return;
    }
    if (data2.length) {
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data2);
    }
    return this.dataMessage();
  }
  decompress(data2, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate$3.extensionName];
    perMessageDeflate.decompress(data2, this._fin, (err, buf) => {
      if (err)
        return cb(err);
      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          return cb(
            error(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            )
          );
        }
        this._fragments.push(buf);
      }
      const er = this.dataMessage();
      if (er)
        return cb(er);
      this.startLoop(cb);
    });
  }
  dataMessage() {
    if (this._fin) {
      const messageLength = this._messageLength;
      const fragments = this._fragments;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];
      if (this._opcode === 2) {
        let data2;
        if (this._binaryType === "nodebuffer") {
          data2 = concat(fragments, messageLength);
        } else if (this._binaryType === "arraybuffer") {
          data2 = toArrayBuffer(concat(fragments, messageLength));
        } else {
          data2 = fragments;
        }
        this.emit("message", data2, true);
      } else {
        const buf = concat(fragments, messageLength);
        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          this._loop = false;
          return error(
            Error,
            "invalid UTF-8 sequence",
            true,
            1007,
            "WS_ERR_INVALID_UTF8"
          );
        }
        this.emit("message", buf, false);
      }
    }
    this._state = GET_INFO;
  }
  controlMessage(data2) {
    if (this._opcode === 8) {
      this._loop = false;
      if (data2.length === 0) {
        this.emit("conclude", 1005, EMPTY_BUFFER$2);
        this.end();
      } else if (data2.length === 1) {
        return error(
          RangeError,
          "invalid payload length 1",
          true,
          1002,
          "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
        );
      } else {
        const code = data2.readUInt16BE(0);
        if (!isValidStatusCode$1(code)) {
          return error(
            RangeError,
            `invalid status code ${code}`,
            true,
            1002,
            "WS_ERR_INVALID_CLOSE_CODE"
          );
        }
        const buf = data2.slice(2);
        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          return error(
            Error,
            "invalid UTF-8 sequence",
            true,
            1007,
            "WS_ERR_INVALID_UTF8"
          );
        }
        this.emit("conclude", code, buf);
        this.end();
      }
    } else if (this._opcode === 9) {
      this.emit("ping", data2);
    } else {
      this.emit("pong", data2);
    }
    this._state = GET_INFO;
  }
};
var receiver = Receiver$1;
function error(ErrorCtor, message, prefix, statusCode, errorCode) {
  const err = new ErrorCtor(
    prefix ? `Invalid WebSocket frame: ${message}` : message
  );
  Error.captureStackTrace(err, error);
  err.code = errorCode;
  err[kStatusCode$1] = statusCode;
  return err;
}
var { randomFillSync } = import_crypto.default;
var PerMessageDeflate$2 = permessageDeflate;
var { EMPTY_BUFFER: EMPTY_BUFFER$1 } = constants;
var { isValidStatusCode } = validation.exports;
var { mask: applyMask, toBuffer: toBuffer$1 } = bufferUtil$1.exports;
var kByteLength = Symbol("kByteLength");
var maskBuffer = Buffer.alloc(4);
var Sender$1 = class {
  constructor(socket, extensions2, generateMask) {
    this._extensions = extensions2 || {};
    if (generateMask) {
      this._generateMask = generateMask;
      this._maskBuffer = Buffer.alloc(4);
    }
    this._socket = socket;
    this._firstFragment = true;
    this._compress = false;
    this._bufferedBytes = 0;
    this._deflating = false;
    this._queue = [];
  }
  static frame(data2, options3) {
    let mask;
    let merge3 = false;
    let offset3 = 2;
    let skipMasking = false;
    if (options3.mask) {
      mask = options3.maskBuffer || maskBuffer;
      if (options3.generateMask) {
        options3.generateMask(mask);
      } else {
        randomFillSync(mask, 0, 4);
      }
      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
      offset3 = 6;
    }
    let dataLength;
    if (typeof data2 === "string") {
      if ((!options3.mask || skipMasking) && options3[kByteLength] !== void 0) {
        dataLength = options3[kByteLength];
      } else {
        data2 = Buffer.from(data2);
        dataLength = data2.length;
      }
    } else {
      dataLength = data2.length;
      merge3 = options3.mask && options3.readOnly && !skipMasking;
    }
    let payloadLength = dataLength;
    if (dataLength >= 65536) {
      offset3 += 8;
      payloadLength = 127;
    } else if (dataLength > 125) {
      offset3 += 2;
      payloadLength = 126;
    }
    const target = Buffer.allocUnsafe(merge3 ? dataLength + offset3 : offset3);
    target[0] = options3.fin ? options3.opcode | 128 : options3.opcode;
    if (options3.rsv1)
      target[0] |= 64;
    target[1] = payloadLength;
    if (payloadLength === 126) {
      target.writeUInt16BE(dataLength, 2);
    } else if (payloadLength === 127) {
      target[2] = target[3] = 0;
      target.writeUIntBE(dataLength, 4, 6);
    }
    if (!options3.mask)
      return [target, data2];
    target[1] |= 128;
    target[offset3 - 4] = mask[0];
    target[offset3 - 3] = mask[1];
    target[offset3 - 2] = mask[2];
    target[offset3 - 1] = mask[3];
    if (skipMasking)
      return [target, data2];
    if (merge3) {
      applyMask(data2, mask, target, offset3, dataLength);
      return [target];
    }
    applyMask(data2, mask, data2, 0, dataLength);
    return [target, data2];
  }
  close(code, data2, mask, cb) {
    let buf;
    if (code === void 0) {
      buf = EMPTY_BUFFER$1;
    } else if (typeof code !== "number" || !isValidStatusCode(code)) {
      throw new TypeError("First argument must be a valid error code number");
    } else if (data2 === void 0 || !data2.length) {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      const length = Buffer.byteLength(data2);
      if (length > 123) {
        throw new RangeError("The message must not be greater than 123 bytes");
      }
      buf = Buffer.allocUnsafe(2 + length);
      buf.writeUInt16BE(code, 0);
      if (typeof data2 === "string") {
        buf.write(data2, 2);
      } else {
        buf.set(data2, 2);
      }
    }
    const options3 = {
      [kByteLength]: buf.length,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 8,
      readOnly: false,
      rsv1: false
    };
    if (this._deflating) {
      this.enqueue([this.dispatch, buf, false, options3, cb]);
    } else {
      this.sendFrame(Sender$1.frame(buf, options3), cb);
    }
  }
  ping(data2, mask, cb) {
    let byteLength;
    let readOnly;
    if (typeof data2 === "string") {
      byteLength = Buffer.byteLength(data2);
      readOnly = false;
    } else {
      data2 = toBuffer$1(data2);
      byteLength = data2.length;
      readOnly = toBuffer$1.readOnly;
    }
    if (byteLength > 125) {
      throw new RangeError("The data size must not be greater than 125 bytes");
    }
    const options3 = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 9,
      readOnly,
      rsv1: false
    };
    if (this._deflating) {
      this.enqueue([this.dispatch, data2, false, options3, cb]);
    } else {
      this.sendFrame(Sender$1.frame(data2, options3), cb);
    }
  }
  pong(data2, mask, cb) {
    let byteLength;
    let readOnly;
    if (typeof data2 === "string") {
      byteLength = Buffer.byteLength(data2);
      readOnly = false;
    } else {
      data2 = toBuffer$1(data2);
      byteLength = data2.length;
      readOnly = toBuffer$1.readOnly;
    }
    if (byteLength > 125) {
      throw new RangeError("The data size must not be greater than 125 bytes");
    }
    const options3 = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 10,
      readOnly,
      rsv1: false
    };
    if (this._deflating) {
      this.enqueue([this.dispatch, data2, false, options3, cb]);
    } else {
      this.sendFrame(Sender$1.frame(data2, options3), cb);
    }
  }
  send(data2, options3, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
    let opcode = options3.binary ? 2 : 1;
    let rsv1 = options3.compress;
    let byteLength;
    let readOnly;
    if (typeof data2 === "string") {
      byteLength = Buffer.byteLength(data2);
      readOnly = false;
    } else {
      data2 = toBuffer$1(data2);
      byteLength = data2.length;
      readOnly = toBuffer$1.readOnly;
    }
    if (this._firstFragment) {
      this._firstFragment = false;
      if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
        rsv1 = byteLength >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }
    if (options3.fin)
      this._firstFragment = true;
    if (perMessageDeflate) {
      const opts = {
        [kByteLength]: byteLength,
        fin: options3.fin,
        generateMask: this._generateMask,
        mask: options3.mask,
        maskBuffer: this._maskBuffer,
        opcode,
        readOnly,
        rsv1
      };
      if (this._deflating) {
        this.enqueue([this.dispatch, data2, this._compress, opts, cb]);
      } else {
        this.dispatch(data2, this._compress, opts, cb);
      }
    } else {
      this.sendFrame(
        Sender$1.frame(data2, {
          [kByteLength]: byteLength,
          fin: options3.fin,
          generateMask: this._generateMask,
          mask: options3.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1: false
        }),
        cb
      );
    }
  }
  dispatch(data2, compress, options3, cb) {
    if (!compress) {
      this.sendFrame(Sender$1.frame(data2, options3), cb);
      return;
    }
    const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
    this._bufferedBytes += options3[kByteLength];
    this._deflating = true;
    perMessageDeflate.compress(data2, options3.fin, (_, buf) => {
      if (this._socket.destroyed) {
        const err = new Error(
          "The socket was closed while data was being compressed"
        );
        if (typeof cb === "function")
          cb(err);
        for (let i = 0; i < this._queue.length; i++) {
          const params = this._queue[i];
          const callback = params[params.length - 1];
          if (typeof callback === "function")
            callback(err);
        }
        return;
      }
      this._bufferedBytes -= options3[kByteLength];
      this._deflating = false;
      options3.readOnly = false;
      this.sendFrame(Sender$1.frame(buf, options3), cb);
      this.dequeue();
    });
  }
  dequeue() {
    while (!this._deflating && this._queue.length) {
      const params = this._queue.shift();
      this._bufferedBytes -= params[3][kByteLength];
      Reflect.apply(params[0], this, params.slice(1));
    }
  }
  enqueue(params) {
    this._bufferedBytes += params[3][kByteLength];
    this._queue.push(params);
  }
  sendFrame(list, cb) {
    if (list.length === 2) {
      this._socket.cork();
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
      this._socket.uncork();
    } else {
      this._socket.write(list[0], cb);
    }
  }
};
var sender = Sender$1;
var { kForOnEventAttribute: kForOnEventAttribute$1, kListener: kListener$1 } = constants;
var kCode = Symbol("kCode");
var kData = Symbol("kData");
var kError = Symbol("kError");
var kMessage = Symbol("kMessage");
var kReason = Symbol("kReason");
var kTarget = Symbol("kTarget");
var kType = Symbol("kType");
var kWasClean = Symbol("kWasClean");
var Event = class {
  constructor(type) {
    this[kTarget] = null;
    this[kType] = type;
  }
  get target() {
    return this[kTarget];
  }
  get type() {
    return this[kType];
  }
};
Object.defineProperty(Event.prototype, "target", { enumerable: true });
Object.defineProperty(Event.prototype, "type", { enumerable: true });
var CloseEvent = class extends Event {
  constructor(type, options3 = {}) {
    super(type);
    this[kCode] = options3.code === void 0 ? 0 : options3.code;
    this[kReason] = options3.reason === void 0 ? "" : options3.reason;
    this[kWasClean] = options3.wasClean === void 0 ? false : options3.wasClean;
  }
  get code() {
    return this[kCode];
  }
  get reason() {
    return this[kReason];
  }
  get wasClean() {
    return this[kWasClean];
  }
};
Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
var ErrorEvent = class extends Event {
  constructor(type, options3 = {}) {
    super(type);
    this[kError] = options3.error === void 0 ? null : options3.error;
    this[kMessage] = options3.message === void 0 ? "" : options3.message;
  }
  get error() {
    return this[kError];
  }
  get message() {
    return this[kMessage];
  }
};
Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
var MessageEvent = class extends Event {
  constructor(type, options3 = {}) {
    super(type);
    this[kData] = options3.data === void 0 ? null : options3.data;
  }
  get data() {
    return this[kData];
  }
};
Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
var EventTarget = {
  addEventListener(type, listener2, options3 = {}) {
    let wrapper;
    if (type === "message") {
      wrapper = function onMessage(data2, isBinary) {
        const event = new MessageEvent("message", {
          data: isBinary ? data2 : data2.toString()
        });
        event[kTarget] = this;
        listener2.call(this, event);
      };
    } else if (type === "close") {
      wrapper = function onClose(code, message) {
        const event = new CloseEvent("close", {
          code,
          reason: message.toString(),
          wasClean: this._closeFrameReceived && this._closeFrameSent
        });
        event[kTarget] = this;
        listener2.call(this, event);
      };
    } else if (type === "error") {
      wrapper = function onError(error2) {
        const event = new ErrorEvent("error", {
          error: error2,
          message: error2.message
        });
        event[kTarget] = this;
        listener2.call(this, event);
      };
    } else if (type === "open") {
      wrapper = function onOpen() {
        const event = new Event("open");
        event[kTarget] = this;
        listener2.call(this, event);
      };
    } else {
      return;
    }
    wrapper[kForOnEventAttribute$1] = !!options3[kForOnEventAttribute$1];
    wrapper[kListener$1] = listener2;
    if (options3.once) {
      this.once(type, wrapper);
    } else {
      this.on(type, wrapper);
    }
  },
  removeEventListener(type, handler) {
    for (const listener2 of this.listeners(type)) {
      if (listener2[kListener$1] === handler && !listener2[kForOnEventAttribute$1]) {
        this.removeListener(type, listener2);
        break;
      }
    }
  }
};
var eventTarget = {
  CloseEvent,
  ErrorEvent,
  Event,
  EventTarget,
  MessageEvent
};
var { tokenChars: tokenChars$1 } = validation.exports;
function push(dest, name, elem) {
  if (dest[name] === void 0)
    dest[name] = [elem];
  else
    dest[name].push(elem);
}
function parse$4(header) {
  const offers = /* @__PURE__ */ Object.create(null);
  let params = /* @__PURE__ */ Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let code = -1;
  let end = -1;
  let i = 0;
  for (; i < header.length; i++) {
    code = header.charCodeAt(i);
    if (extensionName === void 0) {
      if (end === -1 && tokenChars$1[code] === 1) {
        if (start === -1)
          start = i;
      } else if (i !== 0 && (code === 32 || code === 9)) {
        if (end === -1 && start !== -1)
          end = i;
      } else if (code === 59 || code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (end === -1)
          end = i;
        const name = header.slice(start, end);
        if (code === 44) {
          push(offers, name, params);
          params = /* @__PURE__ */ Object.create(null);
        } else {
          extensionName = name;
        }
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === void 0) {
      if (end === -1 && tokenChars$1[code] === 1) {
        if (start === -1)
          start = i;
      } else if (code === 32 || code === 9) {
        if (end === -1 && start !== -1)
          end = i;
      } else if (code === 59 || code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (end === -1)
          end = i;
        push(params, header.slice(start, end), true);
        if (code === 44) {
          push(offers, extensionName, params);
          params = /* @__PURE__ */ Object.create(null);
          extensionName = void 0;
        }
        start = end = -1;
      } else if (code === 61 && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      if (isEscaping) {
        if (tokenChars$1[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1)
          start = i;
        else if (!mustUnescape)
          mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars$1[code] === 1) {
          if (start === -1)
            start = i;
        } else if (code === 34 && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 92) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
        inQuotes = true;
      } else if (end === -1 && tokenChars$1[code] === 1) {
        if (start === -1)
          start = i;
      } else if (start !== -1 && (code === 32 || code === 9)) {
        if (end === -1)
          end = i;
      } else if (code === 59 || code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (end === -1)
          end = i;
        let value2 = header.slice(start, end);
        if (mustUnescape) {
          value2 = value2.replace(/\\/g, "");
          mustUnescape = false;
        }
        push(params, paramName, value2);
        if (code === 44) {
          push(offers, extensionName, params);
          params = /* @__PURE__ */ Object.create(null);
          extensionName = void 0;
        }
        paramName = void 0;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }
  if (start === -1 || inQuotes || code === 32 || code === 9) {
    throw new SyntaxError("Unexpected end of input");
  }
  if (end === -1)
    end = i;
  const token2 = header.slice(start, end);
  if (extensionName === void 0) {
    push(offers, token2, params);
  } else {
    if (paramName === void 0) {
      push(params, token2, true);
    } else if (mustUnescape) {
      push(params, paramName, token2.replace(/\\/g, ""));
    } else {
      push(params, paramName, token2);
    }
    push(offers, extensionName, params);
  }
  return offers;
}
function format$1(extensions2) {
  return Object.keys(extensions2).map((extension2) => {
    let configurations = extensions2[extension2];
    if (!Array.isArray(configurations))
      configurations = [configurations];
    return configurations.map((params) => {
      return [extension2].concat(
        Object.keys(params).map((k) => {
          let values = params[k];
          if (!Array.isArray(values))
            values = [values];
          return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
        })
      ).join("; ");
    }).join(", ");
  }).join(", ");
}
var extension$1 = { format: format$1, parse: parse$4 };
var EventEmitter$1 = import_events.default;
var https$2 = import_https.default;
var http$3 = import_http.default;
var net = import_net.default;
var tls = import_tls.default;
var { randomBytes, createHash: createHash$1 } = import_crypto.default;
var { URL: URL$2 } = import_url.default;
var PerMessageDeflate$1 = permessageDeflate;
var Receiver = receiver;
var Sender = sender;
var {
  BINARY_TYPES,
  EMPTY_BUFFER,
  GUID: GUID$1,
  kForOnEventAttribute,
  kListener,
  kStatusCode,
  kWebSocket: kWebSocket$1,
  NOOP
} = constants;
var {
  EventTarget: { addEventListener, removeEventListener }
} = eventTarget;
var { format, parse: parse$3 } = extension$1;
var { toBuffer } = bufferUtil$1.exports;
var closeTimeout = 30 * 1e3;
var kAborted = Symbol("kAborted");
var protocolVersions = [8, 13];
var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
var WebSocket$1 = class extends EventEmitter$1 {
  constructor(address, protocols, options3) {
    super();
    this._binaryType = BINARY_TYPES[0];
    this._closeCode = 1006;
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = EMPTY_BUFFER;
    this._closeTimer = null;
    this._extensions = {};
    this._paused = false;
    this._protocol = "";
    this._readyState = WebSocket$1.CONNECTING;
    this._receiver = null;
    this._sender = null;
    this._socket = null;
    if (address !== null) {
      this._bufferedAmount = 0;
      this._isServer = false;
      this._redirects = 0;
      if (protocols === void 0) {
        protocols = [];
      } else if (!Array.isArray(protocols)) {
        if (typeof protocols === "object" && protocols !== null) {
          options3 = protocols;
          protocols = [];
        } else {
          protocols = [protocols];
        }
      }
      initAsClient(this, address, protocols, options3);
    } else {
      this._isServer = true;
    }
  }
  get binaryType() {
    return this._binaryType;
  }
  set binaryType(type) {
    if (!BINARY_TYPES.includes(type))
      return;
    this._binaryType = type;
    if (this._receiver)
      this._receiver._binaryType = type;
  }
  get bufferedAmount() {
    if (!this._socket)
      return this._bufferedAmount;
    return this._socket._writableState.length + this._sender._bufferedBytes;
  }
  get extensions() {
    return Object.keys(this._extensions).join();
  }
  get isPaused() {
    return this._paused;
  }
  get onclose() {
    return null;
  }
  get onerror() {
    return null;
  }
  get onopen() {
    return null;
  }
  get onmessage() {
    return null;
  }
  get protocol() {
    return this._protocol;
  }
  get readyState() {
    return this._readyState;
  }
  get url() {
    return this._url;
  }
  setSocket(socket, head, options3) {
    const receiver2 = new Receiver({
      binaryType: this.binaryType,
      extensions: this._extensions,
      isServer: this._isServer,
      maxPayload: options3.maxPayload,
      skipUTF8Validation: options3.skipUTF8Validation
    });
    this._sender = new Sender(socket, this._extensions, options3.generateMask);
    this._receiver = receiver2;
    this._socket = socket;
    receiver2[kWebSocket$1] = this;
    socket[kWebSocket$1] = this;
    receiver2.on("conclude", receiverOnConclude);
    receiver2.on("drain", receiverOnDrain);
    receiver2.on("error", receiverOnError);
    receiver2.on("message", receiverOnMessage);
    receiver2.on("ping", receiverOnPing);
    receiver2.on("pong", receiverOnPong);
    socket.setTimeout(0);
    socket.setNoDelay();
    if (head.length > 0)
      socket.unshift(head);
    socket.on("close", socketOnClose);
    socket.on("data", socketOnData);
    socket.on("end", socketOnEnd);
    socket.on("error", socketOnError$1);
    this._readyState = WebSocket$1.OPEN;
    this.emit("open");
  }
  emitClose() {
    if (!this._socket) {
      this._readyState = WebSocket$1.CLOSED;
      this.emit("close", this._closeCode, this._closeMessage);
      return;
    }
    if (this._extensions[PerMessageDeflate$1.extensionName]) {
      this._extensions[PerMessageDeflate$1.extensionName].cleanup();
    }
    this._receiver.removeAllListeners();
    this._readyState = WebSocket$1.CLOSED;
    this.emit("close", this._closeCode, this._closeMessage);
  }
  close(code, data2) {
    if (this.readyState === WebSocket$1.CLOSED)
      return;
    if (this.readyState === WebSocket$1.CONNECTING) {
      const msg = "WebSocket was closed before the connection was established";
      return abortHandshake$1(this, this._req, msg);
    }
    if (this.readyState === WebSocket$1.CLOSING) {
      if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
        this._socket.end();
      }
      return;
    }
    this._readyState = WebSocket$1.CLOSING;
    this._sender.close(code, data2, !this._isServer, (err) => {
      if (err)
        return;
      this._closeFrameSent = true;
      if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
        this._socket.end();
      }
    });
    this._closeTimer = setTimeout(
      this._socket.destroy.bind(this._socket),
      closeTimeout
    );
  }
  pause() {
    if (this.readyState === WebSocket$1.CONNECTING || this.readyState === WebSocket$1.CLOSED) {
      return;
    }
    this._paused = true;
    this._socket.pause();
  }
  ping(data2, mask, cb) {
    if (this.readyState === WebSocket$1.CONNECTING) {
      throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
    }
    if (typeof data2 === "function") {
      cb = data2;
      data2 = mask = void 0;
    } else if (typeof mask === "function") {
      cb = mask;
      mask = void 0;
    }
    if (typeof data2 === "number")
      data2 = data2.toString();
    if (this.readyState !== WebSocket$1.OPEN) {
      sendAfterClose(this, data2, cb);
      return;
    }
    if (mask === void 0)
      mask = !this._isServer;
    this._sender.ping(data2 || EMPTY_BUFFER, mask, cb);
  }
  pong(data2, mask, cb) {
    if (this.readyState === WebSocket$1.CONNECTING) {
      throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
    }
    if (typeof data2 === "function") {
      cb = data2;
      data2 = mask = void 0;
    } else if (typeof mask === "function") {
      cb = mask;
      mask = void 0;
    }
    if (typeof data2 === "number")
      data2 = data2.toString();
    if (this.readyState !== WebSocket$1.OPEN) {
      sendAfterClose(this, data2, cb);
      return;
    }
    if (mask === void 0)
      mask = !this._isServer;
    this._sender.pong(data2 || EMPTY_BUFFER, mask, cb);
  }
  resume() {
    if (this.readyState === WebSocket$1.CONNECTING || this.readyState === WebSocket$1.CLOSED) {
      return;
    }
    this._paused = false;
    if (!this._receiver._writableState.needDrain)
      this._socket.resume();
  }
  send(data2, options3, cb) {
    if (this.readyState === WebSocket$1.CONNECTING) {
      throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
    }
    if (typeof options3 === "function") {
      cb = options3;
      options3 = {};
    }
    if (typeof data2 === "number")
      data2 = data2.toString();
    if (this.readyState !== WebSocket$1.OPEN) {
      sendAfterClose(this, data2, cb);
      return;
    }
    const opts = {
      binary: typeof data2 !== "string",
      mask: !this._isServer,
      compress: true,
      fin: true,
      ...options3
    };
    if (!this._extensions[PerMessageDeflate$1.extensionName]) {
      opts.compress = false;
    }
    this._sender.send(data2 || EMPTY_BUFFER, opts, cb);
  }
  terminate() {
    if (this.readyState === WebSocket$1.CLOSED)
      return;
    if (this.readyState === WebSocket$1.CONNECTING) {
      const msg = "WebSocket was closed before the connection was established";
      return abortHandshake$1(this, this._req, msg);
    }
    if (this._socket) {
      this._readyState = WebSocket$1.CLOSING;
      this._socket.destroy();
    }
  }
};
Object.defineProperty(WebSocket$1, "CONNECTING", {
  enumerable: true,
  value: readyStates.indexOf("CONNECTING")
});
Object.defineProperty(WebSocket$1.prototype, "CONNECTING", {
  enumerable: true,
  value: readyStates.indexOf("CONNECTING")
});
Object.defineProperty(WebSocket$1, "OPEN", {
  enumerable: true,
  value: readyStates.indexOf("OPEN")
});
Object.defineProperty(WebSocket$1.prototype, "OPEN", {
  enumerable: true,
  value: readyStates.indexOf("OPEN")
});
Object.defineProperty(WebSocket$1, "CLOSING", {
  enumerable: true,
  value: readyStates.indexOf("CLOSING")
});
Object.defineProperty(WebSocket$1.prototype, "CLOSING", {
  enumerable: true,
  value: readyStates.indexOf("CLOSING")
});
Object.defineProperty(WebSocket$1, "CLOSED", {
  enumerable: true,
  value: readyStates.indexOf("CLOSED")
});
Object.defineProperty(WebSocket$1.prototype, "CLOSED", {
  enumerable: true,
  value: readyStates.indexOf("CLOSED")
});
[
  "binaryType",
  "bufferedAmount",
  "extensions",
  "isPaused",
  "protocol",
  "readyState",
  "url"
].forEach((property) => {
  Object.defineProperty(WebSocket$1.prototype, property, { enumerable: true });
});
["open", "error", "close", "message"].forEach((method) => {
  Object.defineProperty(WebSocket$1.prototype, `on${method}`, {
    enumerable: true,
    get() {
      for (const listener2 of this.listeners(method)) {
        if (listener2[kForOnEventAttribute])
          return listener2[kListener];
      }
      return null;
    },
    set(handler) {
      for (const listener2 of this.listeners(method)) {
        if (listener2[kForOnEventAttribute]) {
          this.removeListener(method, listener2);
          break;
        }
      }
      if (typeof handler !== "function")
        return;
      this.addEventListener(method, handler, {
        [kForOnEventAttribute]: true
      });
    }
  });
});
WebSocket$1.prototype.addEventListener = addEventListener;
WebSocket$1.prototype.removeEventListener = removeEventListener;
var websocket = WebSocket$1;
function initAsClient(websocket2, address, protocols, options3) {
  const opts = {
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    skipUTF8Validation: false,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options3,
    createConnection: void 0,
    socketPath: void 0,
    hostname: void 0,
    protocol: void 0,
    timeout: void 0,
    method: "GET",
    host: void 0,
    path: void 0,
    port: void 0
  };
  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
    );
  }
  let parsedUrl;
  if (address instanceof URL$2) {
    parsedUrl = address;
    websocket2._url = address.href;
  } else {
    try {
      parsedUrl = new URL$2(address);
    } catch (e) {
      throw new SyntaxError(`Invalid URL: ${address}`);
    }
    websocket2._url = address;
  }
  const isSecure = parsedUrl.protocol === "wss:";
  const isIpcUrl = parsedUrl.protocol === "ws+unix:";
  let invalidUrlMessage;
  if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
    invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"`;
  } else if (isIpcUrl && !parsedUrl.pathname) {
    invalidUrlMessage = "The URL's pathname is empty";
  } else if (parsedUrl.hash) {
    invalidUrlMessage = "The URL contains a fragment identifier";
  }
  if (invalidUrlMessage) {
    const err = new SyntaxError(invalidUrlMessage);
    if (websocket2._redirects === 0) {
      throw err;
    } else {
      emitErrorAndClose(websocket2, err);
      return;
    }
  }
  const defaultPort = isSecure ? 443 : 80;
  const key2 = randomBytes(16).toString("base64");
  const request = isSecure ? https$2.request : http$3.request;
  const protocolSet = /* @__PURE__ */ new Set();
  let perMessageDeflate;
  opts.createConnection = isSecure ? tlsConnect : netConnect;
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
  opts.headers = {
    ...opts.headers,
    "Sec-WebSocket-Version": opts.protocolVersion,
    "Sec-WebSocket-Key": key2,
    Connection: "Upgrade",
    Upgrade: "websocket"
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;
  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate$1(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers["Sec-WebSocket-Extensions"] = format({
      [PerMessageDeflate$1.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols.length) {
    for (const protocol of protocols) {
      if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
        throw new SyntaxError(
          "An invalid or duplicated subprotocol was specified"
        );
      }
      protocolSet.add(protocol);
    }
    opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers["Sec-WebSocket-Origin"] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }
  if (isIpcUrl) {
    const parts = opts.path.split(":");
    opts.socketPath = parts[0];
    opts.path = parts[1];
  }
  let req2;
  if (opts.followRedirects) {
    if (websocket2._redirects === 0) {
      websocket2._originalIpc = isIpcUrl;
      websocket2._originalSecure = isSecure;
      websocket2._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
      const headers = options3 && options3.headers;
      options3 = { ...options3, headers: {} };
      if (headers) {
        for (const [key3, value2] of Object.entries(headers)) {
          options3.headers[key3.toLowerCase()] = value2;
        }
      }
    } else if (websocket2.listenerCount("redirect") === 0) {
      const isSameHost = isIpcUrl ? websocket2._originalIpc ? opts.socketPath === websocket2._originalHostOrSocketPath : false : websocket2._originalIpc ? false : parsedUrl.host === websocket2._originalHostOrSocketPath;
      if (!isSameHost || websocket2._originalSecure && !isSecure) {
        delete opts.headers.authorization;
        delete opts.headers.cookie;
        if (!isSameHost)
          delete opts.headers.host;
        opts.auth = void 0;
      }
    }
    if (opts.auth && !options3.headers.authorization) {
      options3.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
    }
    req2 = websocket2._req = request(opts);
    if (websocket2._redirects) {
      websocket2.emit("redirect", websocket2.url, req2);
    }
  } else {
    req2 = websocket2._req = request(opts);
  }
  if (opts.timeout) {
    req2.on("timeout", () => {
      abortHandshake$1(websocket2, req2, "Opening handshake has timed out");
    });
  }
  req2.on("error", (err) => {
    if (req2 === null || req2[kAborted])
      return;
    req2 = websocket2._req = null;
    emitErrorAndClose(websocket2, err);
  });
  req2.on("response", (res) => {
    const location = res.headers.location;
    const statusCode = res.statusCode;
    if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
      if (++websocket2._redirects > opts.maxRedirects) {
        abortHandshake$1(websocket2, req2, "Maximum redirects exceeded");
        return;
      }
      req2.abort();
      let addr;
      try {
        addr = new URL$2(location, address);
      } catch (e) {
        const err = new SyntaxError(`Invalid URL: ${location}`);
        emitErrorAndClose(websocket2, err);
        return;
      }
      initAsClient(websocket2, addr, protocols, options3);
    } else if (!websocket2.emit("unexpected-response", req2, res)) {
      abortHandshake$1(
        websocket2,
        req2,
        `Unexpected server response: ${res.statusCode}`
      );
    }
  });
  req2.on("upgrade", (res, socket, head) => {
    websocket2.emit("upgrade", res);
    if (websocket2.readyState !== WebSocket$1.CONNECTING)
      return;
    req2 = websocket2._req = null;
    if (res.headers.upgrade.toLowerCase() !== "websocket") {
      abortHandshake$1(websocket2, socket, "Invalid Upgrade header");
      return;
    }
    const digest = createHash$1("sha1").update(key2 + GUID$1).digest("base64");
    if (res.headers["sec-websocket-accept"] !== digest) {
      abortHandshake$1(websocket2, socket, "Invalid Sec-WebSocket-Accept header");
      return;
    }
    const serverProt = res.headers["sec-websocket-protocol"];
    let protError;
    if (serverProt !== void 0) {
      if (!protocolSet.size) {
        protError = "Server sent a subprotocol but none was requested";
      } else if (!protocolSet.has(serverProt)) {
        protError = "Server sent an invalid subprotocol";
      }
    } else if (protocolSet.size) {
      protError = "Server sent no subprotocol";
    }
    if (protError) {
      abortHandshake$1(websocket2, socket, protError);
      return;
    }
    if (serverProt)
      websocket2._protocol = serverProt;
    const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
    if (secWebSocketExtensions !== void 0) {
      if (!perMessageDeflate) {
        const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
        abortHandshake$1(websocket2, socket, message);
        return;
      }
      let extensions2;
      try {
        extensions2 = parse$3(secWebSocketExtensions);
      } catch (err) {
        const message = "Invalid Sec-WebSocket-Extensions header";
        abortHandshake$1(websocket2, socket, message);
        return;
      }
      const extensionNames = Object.keys(extensions2);
      if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate$1.extensionName) {
        const message = "Server indicated an extension that was not requested";
        abortHandshake$1(websocket2, socket, message);
        return;
      }
      try {
        perMessageDeflate.accept(extensions2[PerMessageDeflate$1.extensionName]);
      } catch (err) {
        const message = "Invalid Sec-WebSocket-Extensions header";
        abortHandshake$1(websocket2, socket, message);
        return;
      }
      websocket2._extensions[PerMessageDeflate$1.extensionName] = perMessageDeflate;
    }
    websocket2.setSocket(socket, head, {
      generateMask: opts.generateMask,
      maxPayload: opts.maxPayload,
      skipUTF8Validation: opts.skipUTF8Validation
    });
  });
  req2.end();
}
function emitErrorAndClose(websocket2, err) {
  websocket2._readyState = WebSocket$1.CLOSING;
  websocket2.emit("error", err);
  websocket2.emitClose();
}
function netConnect(options3) {
  options3.path = options3.socketPath;
  return net.connect(options3);
}
function tlsConnect(options3) {
  options3.path = void 0;
  if (!options3.servername && options3.servername !== "") {
    options3.servername = net.isIP(options3.host) ? "" : options3.host;
  }
  return tls.connect(options3);
}
function abortHandshake$1(websocket2, stream4, message) {
  websocket2._readyState = WebSocket$1.CLOSING;
  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake$1);
  if (stream4.setHeader) {
    stream4[kAborted] = true;
    stream4.abort();
    if (stream4.socket && !stream4.socket.destroyed) {
      stream4.socket.destroy();
    }
    process.nextTick(emitErrorAndClose, websocket2, err);
  } else {
    stream4.destroy(err);
    stream4.once("error", websocket2.emit.bind(websocket2, "error"));
    stream4.once("close", websocket2.emitClose.bind(websocket2));
  }
}
function sendAfterClose(websocket2, data2, cb) {
  if (data2) {
    const length = toBuffer(data2).length;
    if (websocket2._socket)
      websocket2._sender._bufferedBytes += length;
    else
      websocket2._bufferedAmount += length;
  }
  if (cb) {
    const err = new Error(
      `WebSocket is not open: readyState ${websocket2.readyState} (${readyStates[websocket2.readyState]})`
    );
    cb(err);
  }
}
function receiverOnConclude(code, reason) {
  const websocket2 = this[kWebSocket$1];
  websocket2._closeFrameReceived = true;
  websocket2._closeMessage = reason;
  websocket2._closeCode = code;
  if (websocket2._socket[kWebSocket$1] === void 0)
    return;
  websocket2._socket.removeListener("data", socketOnData);
  process.nextTick(resume, websocket2._socket);
  if (code === 1005)
    websocket2.close();
  else
    websocket2.close(code, reason);
}
function receiverOnDrain() {
  const websocket2 = this[kWebSocket$1];
  if (!websocket2.isPaused)
    websocket2._socket.resume();
}
function receiverOnError(err) {
  const websocket2 = this[kWebSocket$1];
  if (websocket2._socket[kWebSocket$1] !== void 0) {
    websocket2._socket.removeListener("data", socketOnData);
    process.nextTick(resume, websocket2._socket);
    websocket2.close(err[kStatusCode]);
  }
  websocket2.emit("error", err);
}
function receiverOnFinish() {
  this[kWebSocket$1].emitClose();
}
function receiverOnMessage(data2, isBinary) {
  this[kWebSocket$1].emit("message", data2, isBinary);
}
function receiverOnPing(data2) {
  const websocket2 = this[kWebSocket$1];
  websocket2.pong(data2, !websocket2._isServer, NOOP);
  websocket2.emit("ping", data2);
}
function receiverOnPong(data2) {
  this[kWebSocket$1].emit("pong", data2);
}
function resume(stream4) {
  stream4.resume();
}
function socketOnClose() {
  const websocket2 = this[kWebSocket$1];
  this.removeListener("close", socketOnClose);
  this.removeListener("data", socketOnData);
  this.removeListener("end", socketOnEnd);
  websocket2._readyState = WebSocket$1.CLOSING;
  let chunk;
  if (!this._readableState.endEmitted && !websocket2._closeFrameReceived && !websocket2._receiver._writableState.errorEmitted && (chunk = websocket2._socket.read()) !== null) {
    websocket2._receiver.write(chunk);
  }
  websocket2._receiver.end();
  this[kWebSocket$1] = void 0;
  clearTimeout(websocket2._closeTimer);
  if (websocket2._receiver._writableState.finished || websocket2._receiver._writableState.errorEmitted) {
    websocket2.emitClose();
  } else {
    websocket2._receiver.on("error", receiverOnFinish);
    websocket2._receiver.on("finish", receiverOnFinish);
  }
}
function socketOnData(chunk) {
  if (!this[kWebSocket$1]._receiver.write(chunk)) {
    this.pause();
  }
}
function socketOnEnd() {
  const websocket2 = this[kWebSocket$1];
  websocket2._readyState = WebSocket$1.CLOSING;
  websocket2._receiver.end();
  this.end();
}
function socketOnError$1() {
  const websocket2 = this[kWebSocket$1];
  this.removeListener("error", socketOnError$1);
  this.on("error", NOOP);
  if (websocket2) {
    websocket2._readyState = WebSocket$1.CLOSING;
    this.destroy();
  }
}
var { tokenChars } = validation.exports;
function parse$2(header) {
  const protocols = /* @__PURE__ */ new Set();
  let start = -1;
  let end = -1;
  let i = 0;
  for (i; i < header.length; i++) {
    const code = header.charCodeAt(i);
    if (end === -1 && tokenChars[code] === 1) {
      if (start === -1)
        start = i;
    } else if (i !== 0 && (code === 32 || code === 9)) {
      if (end === -1 && start !== -1)
        end = i;
    } else if (code === 44) {
      if (start === -1) {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
      if (end === -1)
        end = i;
      const protocol2 = header.slice(start, end);
      if (protocols.has(protocol2)) {
        throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
      }
      protocols.add(protocol2);
      start = end = -1;
    } else {
      throw new SyntaxError(`Unexpected character at index ${i}`);
    }
  }
  if (start === -1 || end !== -1) {
    throw new SyntaxError("Unexpected end of input");
  }
  const protocol = header.slice(start, i);
  if (protocols.has(protocol)) {
    throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
  }
  protocols.add(protocol);
  return protocols;
}
var subprotocol$1 = { parse: parse$2 };
var EventEmitter = import_events.default;
var http$2 = import_http.default;
var { createHash } = import_crypto.default;
var extension = extension$1;
var PerMessageDeflate = permessageDeflate;
var subprotocol = subprotocol$1;
var WebSocket = websocket;
var { GUID, kWebSocket } = constants;
var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
var RUNNING = 0;
var CLOSING = 1;
var CLOSED = 2;
var WebSocketServer = class extends EventEmitter {
  constructor(options3, callback) {
    super();
    options3 = {
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null,
      server: null,
      host: null,
      path: null,
      port: null,
      WebSocket,
      ...options3
    };
    if (options3.port == null && !options3.server && !options3.noServer || options3.port != null && (options3.server || options3.noServer) || options3.server && options3.noServer) {
      throw new TypeError(
        'One and only one of the "port", "server", or "noServer" options must be specified'
      );
    }
    if (options3.port != null) {
      this._server = http$2.createServer((req2, res) => {
        const body = http$2.STATUS_CODES[426];
        res.writeHead(426, {
          "Content-Length": body.length,
          "Content-Type": "text/plain"
        });
        res.end(body);
      });
      this._server.listen(
        options3.port,
        options3.host,
        options3.backlog,
        callback
      );
    } else if (options3.server) {
      this._server = options3.server;
    }
    if (this._server) {
      const emitConnection = this.emit.bind(this, "connection");
      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, "listening"),
        error: this.emit.bind(this, "error"),
        upgrade: (req2, socket, head) => {
          this.handleUpgrade(req2, socket, head, emitConnection);
        }
      });
    }
    if (options3.perMessageDeflate === true)
      options3.perMessageDeflate = {};
    if (options3.clientTracking) {
      this.clients = /* @__PURE__ */ new Set();
      this._shouldEmitClose = false;
    }
    this.options = options3;
    this._state = RUNNING;
  }
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }
    if (!this._server)
      return null;
    return this._server.address();
  }
  close(cb) {
    if (this._state === CLOSED) {
      if (cb) {
        this.once("close", () => {
          cb(new Error("The server is not running"));
        });
      }
      process.nextTick(emitClose, this);
      return;
    }
    if (cb)
      this.once("close", cb);
    if (this._state === CLOSING)
      return;
    this._state = CLOSING;
    if (this.options.noServer || this.options.server) {
      if (this._server) {
        this._removeListeners();
        this._removeListeners = this._server = null;
      }
      if (this.clients) {
        if (!this.clients.size) {
          process.nextTick(emitClose, this);
        } else {
          this._shouldEmitClose = true;
        }
      } else {
        process.nextTick(emitClose, this);
      }
    } else {
      const server2 = this._server;
      this._removeListeners();
      this._removeListeners = this._server = null;
      server2.close(() => {
        emitClose(this);
      });
    }
  }
  shouldHandle(req2) {
    if (this.options.path) {
      const index2 = req2.url.indexOf("?");
      const pathname = index2 !== -1 ? req2.url.slice(0, index2) : req2.url;
      if (pathname !== this.options.path)
        return false;
    }
    return true;
  }
  handleUpgrade(req2, socket, head, cb) {
    socket.on("error", socketOnError);
    const key2 = req2.headers["sec-websocket-key"];
    const version3 = +req2.headers["sec-websocket-version"];
    if (req2.method !== "GET") {
      const message = "Invalid HTTP method";
      abortHandshakeOrEmitwsClientError(this, req2, socket, 405, message);
      return;
    }
    if (req2.headers.upgrade.toLowerCase() !== "websocket") {
      const message = "Invalid Upgrade header";
      abortHandshakeOrEmitwsClientError(this, req2, socket, 400, message);
      return;
    }
    if (!key2 || !keyRegex.test(key2)) {
      const message = "Missing or invalid Sec-WebSocket-Key header";
      abortHandshakeOrEmitwsClientError(this, req2, socket, 400, message);
      return;
    }
    if (version3 !== 8 && version3 !== 13) {
      const message = "Missing or invalid Sec-WebSocket-Version header";
      abortHandshakeOrEmitwsClientError(this, req2, socket, 400, message);
      return;
    }
    if (!this.shouldHandle(req2)) {
      abortHandshake(socket, 400);
      return;
    }
    const secWebSocketProtocol = req2.headers["sec-websocket-protocol"];
    let protocols = /* @__PURE__ */ new Set();
    if (secWebSocketProtocol !== void 0) {
      try {
        protocols = subprotocol.parse(secWebSocketProtocol);
      } catch (err) {
        const message = "Invalid Sec-WebSocket-Protocol header";
        abortHandshakeOrEmitwsClientError(this, req2, socket, 400, message);
        return;
      }
    }
    const secWebSocketExtensions = req2.headers["sec-websocket-extensions"];
    const extensions2 = {};
    if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
      const perMessageDeflate = new PerMessageDeflate(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );
      try {
        const offers = extension.parse(secWebSocketExtensions);
        if (offers[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
          extensions2[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
        abortHandshakeOrEmitwsClientError(this, req2, socket, 400, message);
        return;
      }
    }
    if (this.options.verifyClient) {
      const info = {
        origin: req2.headers[`${version3 === 8 ? "sec-websocket-origin" : "origin"}`],
        secure: !!(req2.socket.authorized || req2.socket.encrypted),
        req: req2
      };
      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake(socket, code || 401, message, headers);
          }
          this.completeUpgrade(
            extensions2,
            key2,
            protocols,
            req2,
            socket,
            head,
            cb
          );
        });
        return;
      }
      if (!this.options.verifyClient(info))
        return abortHandshake(socket, 401);
    }
    this.completeUpgrade(extensions2, key2, protocols, req2, socket, head, cb);
  }
  completeUpgrade(extensions2, key2, protocols, req2, socket, head, cb) {
    if (!socket.readable || !socket.writable)
      return socket.destroy();
    if (socket[kWebSocket]) {
      throw new Error(
        "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
      );
    }
    if (this._state > RUNNING)
      return abortHandshake(socket, 503);
    const digest = createHash("sha1").update(key2 + GUID).digest("base64");
    const headers = [
      "HTTP/1.1 101 Switching Protocols",
      "Upgrade: websocket",
      "Connection: Upgrade",
      `Sec-WebSocket-Accept: ${digest}`
    ];
    const ws = new this.options.WebSocket(null);
    if (protocols.size) {
      const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req2) : protocols.values().next().value;
      if (protocol) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
        ws._protocol = protocol;
      }
    }
    if (extensions2[PerMessageDeflate.extensionName]) {
      const params = extensions2[PerMessageDeflate.extensionName].params;
      const value2 = extension.format({
        [PerMessageDeflate.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value2}`);
      ws._extensions = extensions2;
    }
    this.emit("headers", headers, req2);
    socket.write(headers.concat("\r\n").join("\r\n"));
    socket.removeListener("error", socketOnError);
    ws.setSocket(socket, head, {
      maxPayload: this.options.maxPayload,
      skipUTF8Validation: this.options.skipUTF8Validation
    });
    if (this.clients) {
      this.clients.add(ws);
      ws.on("close", () => {
        this.clients.delete(ws);
        if (this._shouldEmitClose && !this.clients.size) {
          process.nextTick(emitClose, this);
        }
      });
    }
    cb(ws, req2);
  }
};
var websocketServer = WebSocketServer;
function addListeners(server2, map2) {
  for (const event of Object.keys(map2))
    server2.on(event, map2[event]);
  return function removeListeners() {
    for (const event of Object.keys(map2)) {
      server2.removeListener(event, map2[event]);
    }
  };
}
function emitClose(server2) {
  server2._state = CLOSED;
  server2.emit("close");
}
function socketOnError() {
  this.destroy();
}
function abortHandshake(socket, code, message, headers) {
  message = message || http$2.STATUS_CODES[code];
  headers = {
    Connection: "close",
    "Content-Type": "text/html",
    "Content-Length": Buffer.byteLength(message),
    ...headers
  };
  socket.once("finish", socket.destroy);
  socket.end(
    `HTTP/1.1 ${code} ${http$2.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
  );
}
function abortHandshakeOrEmitwsClientError(server2, req2, socket, code, message) {
  if (server2.listenerCount("wsClientError")) {
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
    server2.emit("wsClientError", err, socket, req2);
  } else {
    abortHandshake(socket, code, message);
  }
}
var HMR_HEADER = "vite-hmr";
var wsServerEvents = [
  "connection",
  "error",
  "headers",
  "listening",
  "message"
];
function createWebSocketServer(server2, config2, httpsOptions) {
  let wss;
  let httpsServer = void 0;
  const hmr = isObject$1(config2.server.hmr) && config2.server.hmr;
  const hmrServer = hmr && hmr.server;
  const hmrPort = hmr && hmr.port;
  const portsAreCompatible = !hmrPort || hmrPort === config2.server.port;
  const wsServer = hmrServer || portsAreCompatible && server2;
  const customListeners = /* @__PURE__ */ new Map();
  const clientsMap = /* @__PURE__ */ new WeakMap();
  if (wsServer) {
    wss = new websocketServer({ noServer: true });
    wsServer.on("upgrade", (req2, socket, head) => {
      if (req2.headers["sec-websocket-protocol"] === HMR_HEADER) {
        wss.handleUpgrade(req2, socket, head, (ws) => {
          wss.emit("connection", ws, req2);
        });
      }
    });
  } else {
    const websocketServerOptions = {};
    const port = hmrPort || 24678;
    const host = hmr && hmr.host || void 0;
    if (httpsOptions) {
      httpsServer = (0, import_node_https.createServer)(httpsOptions, (req2, res) => {
        const statusCode = 426;
        const body = import_node_http.STATUS_CODES[statusCode];
        if (!body)
          throw new Error(`No body text found for the ${statusCode} status code`);
        res.writeHead(statusCode, {
          "Content-Length": body.length,
          "Content-Type": "text/plain"
        });
        res.end(body);
      });
      httpsServer.listen(port, host);
      websocketServerOptions.server = httpsServer;
    } else {
      websocketServerOptions.port = port;
      if (host) {
        websocketServerOptions.host = host;
      }
    }
    wss = new websocketServer(websocketServerOptions);
  }
  wss.on("connection", (socket) => {
    socket.on("message", (raw) => {
      if (!customListeners.size)
        return;
      let parsed;
      try {
        parsed = JSON.parse(String(raw));
      } catch {
      }
      if (!parsed || parsed.type !== "custom" || !parsed.event)
        return;
      const listeners = customListeners.get(parsed.event);
      if (!(listeners == null ? void 0 : listeners.size))
        return;
      const client = getSocketClient(socket);
      listeners.forEach((listener2) => listener2(parsed.data, client));
    });
    socket.send(JSON.stringify({ type: "connected" }));
    if (bufferedError) {
      socket.send(JSON.stringify(bufferedError));
      bufferedError = null;
    }
  });
  wss.on("error", (e) => {
    if (e.code === "EADDRINUSE") {
      config2.logger.error(picocolors.exports.red(`WebSocket server error: Port is already in use`), { error: e });
    } else {
      config2.logger.error(picocolors.exports.red(`WebSocket server error:
${e.stack || e.message}`), { error: e });
    }
  });
  function getSocketClient(socket) {
    if (!clientsMap.has(socket)) {
      clientsMap.set(socket, {
        send: (...args) => {
          let payload;
          if (typeof args[0] === "string") {
            payload = {
              type: "custom",
              event: args[0],
              data: args[1]
            };
          } else {
            payload = args[0];
          }
          socket.send(JSON.stringify(payload));
        },
        socket
      });
    }
    return clientsMap.get(socket);
  }
  let bufferedError = null;
  return {
    on: (event, fn) => {
      if (wsServerEvents.includes(event))
        wss.on(event, fn);
      else {
        if (!customListeners.has(event)) {
          customListeners.set(event, /* @__PURE__ */ new Set());
        }
        customListeners.get(event).add(fn);
      }
    },
    off: (event, fn) => {
      var _a;
      if (wsServerEvents.includes(event)) {
        wss.off(event, fn);
      } else {
        (_a = customListeners.get(event)) == null ? void 0 : _a.delete(fn);
      }
    },
    get clients() {
      return new Set(Array.from(wss.clients).map(getSocketClient));
    },
    send(...args) {
      let payload;
      if (typeof args[0] === "string") {
        payload = {
          type: "custom",
          event: args[0],
          data: args[1]
        };
      } else {
        payload = args[0];
      }
      if (payload.type === "error" && !wss.clients.size) {
        bufferedError = payload;
        return;
      }
      const stringified = JSON.stringify(payload);
      wss.clients.forEach((client) => {
        if (client.readyState === 1) {
          client.send(stringified);
        }
      });
    },
    close() {
      return new Promise((resolve3, reject) => {
        wss.clients.forEach((client) => {
          client.terminate();
        });
        wss.close((err) => {
          if (err) {
            reject(err);
          } else {
            if (httpsServer) {
              httpsServer.close((err2) => {
                if (err2) {
                  reject(err2);
                } else {
                  resolve3();
                }
              });
            } else {
              resolve3();
            }
          }
        });
      });
    }
  };
}
function baseMiddleware({ config: config2 }) {
  const devBase = config2.base.endsWith("/") ? config2.base : config2.base + "/";
  return function viteBaseMiddleware(req2, res, next) {
    var _a;
    const url2 = req2.url;
    const parsed = new URL(url2, "http://vitejs.dev");
    const path4 = parsed.pathname || "/";
    if (path4.startsWith(devBase)) {
      req2.url = url2.replace(devBase, "/");
      return next();
    }
    if (config2.server.middlewareMode) {
      return next();
    }
    if (path4 === "/" || path4 === "/index.html") {
      res.writeHead(302, {
        Location: config2.base + (parsed.search || "") + (parsed.hash || "")
      });
      res.end();
      return;
    } else if ((_a = req2.headers.accept) == null ? void 0 : _a.includes("text/html")) {
      const redirectPath = joinUrlSegments(config2.base, url2);
      res.writeHead(404, {
        "Content-Type": "text/html"
      });
      res.end(`The server is configured with a public base URL of ${config2.base} - did you mean to visit <a href="${redirectPath}">${redirectPath}</a> instead?`);
      return;
    }
    next();
  };
}
var httpProxy$3 = { exports: {} };
var httpProxy$2 = { exports: {} };
var eventemitter3 = { exports: {} };
(function(module2) {
  var has = Object.prototype.hasOwnProperty, prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE(fn, context, once2) {
    this.fn = fn;
    this.context = context;
    this.once = once2 || false;
  }
  function addListener(emitter, event, fn, context, once2) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener2 = new EE(fn, context || emitter, once2), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener2, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener2);
    else
      emitter._events[evt] = [emitter._events[evt], listener2];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events();
    else
      delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames() {
    var names = [], events2, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events2 = this._events) {
      if (has.call(events2, name))
        names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events2));
    }
    return names;
  };
  EventEmitter2.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i = 0; i < length; i++) {
        if (listeners[i].once)
          this.removeListener(event, listeners[i].fn, void 0, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter2.prototype.once = function once2(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once2) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once2 || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events2 = [], length = listeners.length; i < length; i++) {
        if (listeners[i].fn !== fn || once2 && !listeners[i].once || context && listeners[i].context !== context) {
          events2.push(listeners[i]);
        }
      }
      if (events2.length)
        this._events[evt] = events2.length === 1 ? events2[0] : events2;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module2.exports = EventEmitter2;
  }
})(eventemitter3);
var common$3 = {};
var requiresPort = function required(port, protocol) {
  protocol = protocol.split(":")[0];
  port = +port;
  if (!port)
    return false;
  switch (protocol) {
    case "http":
    case "ws":
      return port !== 80;
    case "https":
    case "wss":
      return port !== 443;
    case "ftp":
      return port !== 21;
    case "gopher":
      return port !== 70;
    case "file":
      return false;
  }
  return port !== 0;
};
(function(exports) {
  var common2 = exports, url2 = import_url.default, extend2 = import_util.default._extend, required2 = requiresPort;
  var upgradeHeader = /(^|,)\s*upgrade\s*($|,)/i, isSSL = /^https|wss/;
  common2.isSSL = isSSL;
  common2.setupOutgoing = function(outgoing, options3, req2, forward) {
    outgoing.port = options3[forward || "target"].port || (isSSL.test(options3[forward || "target"].protocol) ? 443 : 80);
    [
      "host",
      "hostname",
      "socketPath",
      "pfx",
      "key",
      "passphrase",
      "cert",
      "ca",
      "ciphers",
      "secureProtocol"
    ].forEach(
      function(e) {
        outgoing[e] = options3[forward || "target"][e];
      }
    );
    outgoing.method = options3.method || req2.method;
    outgoing.headers = extend2({}, req2.headers);
    if (options3.headers) {
      extend2(outgoing.headers, options3.headers);
    }
    if (options3.auth) {
      outgoing.auth = options3.auth;
    }
    if (options3.ca) {
      outgoing.ca = options3.ca;
    }
    if (isSSL.test(options3[forward || "target"].protocol)) {
      outgoing.rejectUnauthorized = typeof options3.secure === "undefined" ? true : options3.secure;
    }
    outgoing.agent = options3.agent || false;
    outgoing.localAddress = options3.localAddress;
    if (!outgoing.agent) {
      outgoing.headers = outgoing.headers || {};
      if (typeof outgoing.headers.connection !== "string" || !upgradeHeader.test(outgoing.headers.connection)) {
        outgoing.headers.connection = "close";
      }
    }
    var target = options3[forward || "target"];
    var targetPath = target && options3.prependPath !== false ? target.path || "" : "";
    var outgoingPath = !options3.toProxy ? url2.parse(req2.url).path || "" : req2.url;
    outgoingPath = !options3.ignorePath ? outgoingPath : "";
    outgoing.path = common2.urlJoin(targetPath, outgoingPath);
    if (options3.changeOrigin) {
      outgoing.headers.host = required2(outgoing.port, options3[forward || "target"].protocol) && !hasPort(outgoing.host) ? outgoing.host + ":" + outgoing.port : outgoing.host;
    }
    return outgoing;
  };
  common2.setupSocket = function(socket) {
    socket.setTimeout(0);
    socket.setNoDelay(true);
    socket.setKeepAlive(true, 0);
    return socket;
  };
  common2.getPort = function(req2) {
    var res = req2.headers.host ? req2.headers.host.match(/:(\d+)/) : "";
    return res ? res[1] : common2.hasEncryptedConnection(req2) ? "443" : "80";
  };
  common2.hasEncryptedConnection = function(req2) {
    return Boolean(req2.connection.encrypted || req2.connection.pair);
  };
  common2.urlJoin = function() {
    var args = Array.prototype.slice.call(arguments), lastIndex = args.length - 1, last = args[lastIndex], lastSegs = last.split("?"), retSegs;
    args[lastIndex] = lastSegs.shift();
    retSegs = [
      args.filter(Boolean).join("/").replace(/\/+/g, "/").replace("http:/", "http://").replace("https:/", "https://")
    ];
    retSegs.push.apply(retSegs, lastSegs);
    return retSegs.join("?");
  };
  common2.rewriteCookieProperty = function rewriteCookieProperty(header, config2, property) {
    if (Array.isArray(header)) {
      return header.map(function(headerElement) {
        return rewriteCookieProperty(headerElement, config2, property);
      });
    }
    return header.replace(new RegExp("(;\\s*" + property + "=)([^;]+)", "i"), function(match, prefix, previousValue) {
      var newValue;
      if (previousValue in config2) {
        newValue = config2[previousValue];
      } else if ("*" in config2) {
        newValue = config2["*"];
      } else {
        return match;
      }
      if (newValue) {
        return prefix + newValue;
      } else {
        return "";
      }
    });
  };
  function hasPort(host) {
    return !!~host.indexOf(":");
  }
})(common$3);
var url$1 = import_url.default;
var common$2 = common$3;
var redirectRegex = /^201|30(1|2|7|8)$/;
var webOutgoing = {
  removeChunked: function removeChunked(req2, res, proxyRes) {
    if (req2.httpVersion === "1.0") {
      delete proxyRes.headers["transfer-encoding"];
    }
  },
  setConnection: function setConnection(req2, res, proxyRes) {
    if (req2.httpVersion === "1.0") {
      proxyRes.headers.connection = req2.headers.connection || "close";
    } else if (req2.httpVersion !== "2.0" && !proxyRes.headers.connection) {
      proxyRes.headers.connection = req2.headers.connection || "keep-alive";
    }
  },
  setRedirectHostRewrite: function setRedirectHostRewrite(req2, res, proxyRes, options3) {
    if ((options3.hostRewrite || options3.autoRewrite || options3.protocolRewrite) && proxyRes.headers["location"] && redirectRegex.test(proxyRes.statusCode)) {
      var target = url$1.parse(options3.target);
      var u = url$1.parse(proxyRes.headers["location"]);
      if (target.host != u.host) {
        return;
      }
      if (options3.hostRewrite) {
        u.host = options3.hostRewrite;
      } else if (options3.autoRewrite) {
        u.host = req2.headers["host"];
      }
      if (options3.protocolRewrite) {
        u.protocol = options3.protocolRewrite;
      }
      proxyRes.headers["location"] = u.format();
    }
  },
  writeHeaders: function writeHeaders(req2, res, proxyRes, options3) {
    var rewriteCookieDomainConfig = options3.cookieDomainRewrite, rewriteCookiePathConfig = options3.cookiePathRewrite, preserveHeaderKeyCase = options3.preserveHeaderKeyCase, rawHeaderKeyMap, setHeader = function(key3, header) {
      if (header == void 0)
        return;
      if (rewriteCookieDomainConfig && key3.toLowerCase() === "set-cookie") {
        header = common$2.rewriteCookieProperty(header, rewriteCookieDomainConfig, "domain");
      }
      if (rewriteCookiePathConfig && key3.toLowerCase() === "set-cookie") {
        header = common$2.rewriteCookieProperty(header, rewriteCookiePathConfig, "path");
      }
      res.setHeader(String(key3).trim(), header);
    };
    if (typeof rewriteCookieDomainConfig === "string") {
      rewriteCookieDomainConfig = { "*": rewriteCookieDomainConfig };
    }
    if (typeof rewriteCookiePathConfig === "string") {
      rewriteCookiePathConfig = { "*": rewriteCookiePathConfig };
    }
    if (preserveHeaderKeyCase && proxyRes.rawHeaders != void 0) {
      rawHeaderKeyMap = {};
      for (var i = 0; i < proxyRes.rawHeaders.length; i += 2) {
        var key2 = proxyRes.rawHeaders[i];
        rawHeaderKeyMap[key2.toLowerCase()] = key2;
      }
    }
    Object.keys(proxyRes.headers).forEach(function(key3) {
      var header = proxyRes.headers[key3];
      if (preserveHeaderKeyCase && rawHeaderKeyMap) {
        key3 = rawHeaderKeyMap[key3] || key3;
      }
      setHeader(key3, header);
    });
  },
  writeStatusCode: function writeStatusCode(req2, res, proxyRes) {
    if (proxyRes.statusMessage) {
      res.statusCode = proxyRes.statusCode;
      res.statusMessage = proxyRes.statusMessage;
    } else {
      res.statusCode = proxyRes.statusCode;
    }
  }
};
var followRedirects$1 = { exports: {} };
var debug$3;
var debug_1 = function() {
  if (!debug$3) {
    try {
      debug$3 = require2("debug")("follow-redirects");
    } catch (error2) {
    }
    if (typeof debug$3 !== "function") {
      debug$3 = function() {
      };
    }
  }
  debug$3.apply(null, arguments);
};
var url = import_url.default;
var URL$1 = url.URL;
var http$1 = import_http.default;
var https$1 = import_https.default;
var Writable = import_stream.default.Writable;
var assert = import_assert.default;
var debug$2 = debug_1;
var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
var eventHandlers = /* @__PURE__ */ Object.create(null);
events.forEach(function(event) {
  eventHandlers[event] = function(arg1, arg2, arg3) {
    this._redirectable.emit(event, arg1, arg2, arg3);
  };
});
var RedirectionError = createErrorType(
  "ERR_FR_REDIRECTION_FAILURE",
  "Redirected request failed"
);
var TooManyRedirectsError = createErrorType(
  "ERR_FR_TOO_MANY_REDIRECTS",
  "Maximum number of redirects exceeded"
);
var MaxBodyLengthExceededError = createErrorType(
  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
  "Request body larger than maxBodyLength limit"
);
var WriteAfterEndError = createErrorType(
  "ERR_STREAM_WRITE_AFTER_END",
  "write after end"
);
function RedirectableRequest(options3, responseCallback) {
  Writable.call(this);
  this._sanitizeOptions(options3);
  this._options = options3;
  this._ended = false;
  this._ending = false;
  this._redirectCount = 0;
  this._redirects = [];
  this._requestBodyLength = 0;
  this._requestBodyBuffers = [];
  if (responseCallback) {
    this.on("response", responseCallback);
  }
  var self2 = this;
  this._onNativeResponse = function(response) {
    self2._processResponse(response);
  };
  this._performRequest();
}
RedirectableRequest.prototype = Object.create(Writable.prototype);
RedirectableRequest.prototype.abort = function() {
  abortRequest(this._currentRequest);
  this.emit("abort");
};
RedirectableRequest.prototype.write = function(data2, encoding, callback) {
  if (this._ending) {
    throw new WriteAfterEndError();
  }
  if (!(typeof data2 === "string" || typeof data2 === "object" && "length" in data2)) {
    throw new TypeError("data should be a string, Buffer or Uint8Array");
  }
  if (typeof encoding === "function") {
    callback = encoding;
    encoding = null;
  }
  if (data2.length === 0) {
    if (callback) {
      callback();
    }
    return;
  }
  if (this._requestBodyLength + data2.length <= this._options.maxBodyLength) {
    this._requestBodyLength += data2.length;
    this._requestBodyBuffers.push({ data: data2, encoding });
    this._currentRequest.write(data2, encoding, callback);
  } else {
    this.emit("error", new MaxBodyLengthExceededError());
    this.abort();
  }
};
RedirectableRequest.prototype.end = function(data2, encoding, callback) {
  if (typeof data2 === "function") {
    callback = data2;
    data2 = encoding = null;
  } else if (typeof encoding === "function") {
    callback = encoding;
    encoding = null;
  }
  if (!data2) {
    this._ended = this._ending = true;
    this._currentRequest.end(null, null, callback);
  } else {
    var self2 = this;
    var currentRequest = this._currentRequest;
    this.write(data2, encoding, function() {
      self2._ended = true;
      currentRequest.end(null, null, callback);
    });
    this._ending = true;
  }
};
RedirectableRequest.prototype.setHeader = function(name, value2) {
  this._options.headers[name] = value2;
  this._currentRequest.setHeader(name, value2);
};
RedirectableRequest.prototype.removeHeader = function(name) {
  delete this._options.headers[name];
  this._currentRequest.removeHeader(name);
};
RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
  var self2 = this;
  function destroyOnTimeout(socket) {
    socket.setTimeout(msecs);
    socket.removeListener("timeout", socket.destroy);
    socket.addListener("timeout", socket.destroy);
  }
  function startTimer(socket) {
    if (self2._timeout) {
      clearTimeout(self2._timeout);
    }
    self2._timeout = setTimeout(function() {
      self2.emit("timeout");
      clearTimer();
    }, msecs);
    destroyOnTimeout(socket);
  }
  function clearTimer() {
    if (self2._timeout) {
      clearTimeout(self2._timeout);
      self2._timeout = null;
    }
    self2.removeListener("abort", clearTimer);
    self2.removeListener("error", clearTimer);
    self2.removeListener("response", clearTimer);
    if (callback) {
      self2.removeListener("timeout", callback);
    }
    if (!self2.socket) {
      self2._currentRequest.removeListener("socket", startTimer);
    }
  }
  if (callback) {
    this.on("timeout", callback);
  }
  if (this.socket) {
    startTimer(this.socket);
  } else {
    this._currentRequest.once("socket", startTimer);
  }
  this.on("socket", destroyOnTimeout);
  this.on("abort", clearTimer);
  this.on("error", clearTimer);
  this.on("response", clearTimer);
  return this;
};
[
  "flushHeaders",
  "getHeader",
  "setNoDelay",
  "setSocketKeepAlive"
].forEach(function(method) {
  RedirectableRequest.prototype[method] = function(a, b) {
    return this._currentRequest[method](a, b);
  };
});
["aborted", "connection", "socket"].forEach(function(property) {
  Object.defineProperty(RedirectableRequest.prototype, property, {
    get: function() {
      return this._currentRequest[property];
    }
  });
});
RedirectableRequest.prototype._sanitizeOptions = function(options3) {
  if (!options3.headers) {
    options3.headers = {};
  }
  if (options3.host) {
    if (!options3.hostname) {
      options3.hostname = options3.host;
    }
    delete options3.host;
  }
  if (!options3.pathname && options3.path) {
    var searchPos = options3.path.indexOf("?");
    if (searchPos < 0) {
      options3.pathname = options3.path;
    } else {
      options3.pathname = options3.path.substring(0, searchPos);
      options3.search = options3.path.substring(searchPos);
    }
  }
};
RedirectableRequest.prototype._performRequest = function() {
  var protocol = this._options.protocol;
  var nativeProtocol = this._options.nativeProtocols[protocol];
  if (!nativeProtocol) {
    this.emit("error", new TypeError("Unsupported protocol " + protocol));
    return;
  }
  if (this._options.agents) {
    var scheme = protocol.slice(0, -1);
    this._options.agent = this._options.agents[scheme];
  }
  var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
  this._currentUrl = url.format(this._options);
  request._redirectable = this;
  for (var e = 0; e < events.length; e++) {
    request.on(events[e], eventHandlers[events[e]]);
  }
  if (this._isRedirect) {
    var i = 0;
    var self2 = this;
    var buffers = this._requestBodyBuffers;
    (function writeNext(error2) {
      if (request === self2._currentRequest) {
        if (error2) {
          self2.emit("error", error2);
        } else if (i < buffers.length) {
          var buffer2 = buffers[i++];
          if (!request.finished) {
            request.write(buffer2.data, buffer2.encoding, writeNext);
          }
        } else if (self2._ended) {
          request.end();
        }
      }
    })();
  }
};
RedirectableRequest.prototype._processResponse = function(response) {
  var statusCode = response.statusCode;
  if (this._options.trackRedirects) {
    this._redirects.push({
      url: this._currentUrl,
      headers: response.headers,
      statusCode
    });
  }
  var location = response.headers.location;
  if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
    response.responseUrl = this._currentUrl;
    response.redirects = this._redirects;
    this.emit("response", response);
    this._requestBodyBuffers = [];
    return;
  }
  abortRequest(this._currentRequest);
  response.destroy();
  if (++this._redirectCount > this._options.maxRedirects) {
    this.emit("error", new TooManyRedirectsError());
    return;
  }
  var requestHeaders;
  var beforeRedirect = this._options.beforeRedirect;
  if (beforeRedirect) {
    requestHeaders = Object.assign({
      Host: response.req.getHeader("host")
    }, this._options.headers);
  }
  var method = this._options.method;
  if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
    this._options.method = "GET";
    this._requestBodyBuffers = [];
    removeMatchingHeaders(/^content-/i, this._options.headers);
  }
  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
  var currentUrlParts = url.parse(this._currentUrl);
  var currentHost = currentHostHeader || currentUrlParts.host;
  var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
  var redirectUrl;
  try {
    redirectUrl = url.resolve(currentUrl, location);
  } catch (cause) {
    this.emit("error", new RedirectionError(cause));
    return;
  }
  debug$2("redirecting to", redirectUrl);
  this._isRedirect = true;
  var redirectUrlParts = url.parse(redirectUrl);
  Object.assign(this._options, redirectUrlParts);
  if (redirectUrlParts.protocol !== currentUrlParts.protocol && redirectUrlParts.protocol !== "https:" || redirectUrlParts.host !== currentHost && !isSubdomain(redirectUrlParts.host, currentHost)) {
    removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);
  }
  if (typeof beforeRedirect === "function") {
    var responseDetails = {
      headers: response.headers,
      statusCode
    };
    var requestDetails = {
      url: currentUrl,
      method,
      headers: requestHeaders
    };
    try {
      beforeRedirect(this._options, responseDetails, requestDetails);
    } catch (err) {
      this.emit("error", err);
      return;
    }
    this._sanitizeOptions(this._options);
  }
  try {
    this._performRequest();
  } catch (cause) {
    this.emit("error", new RedirectionError(cause));
  }
};
function wrap(protocols) {
  var exports = {
    maxRedirects: 21,
    maxBodyLength: 10 * 1024 * 1024
  };
  var nativeProtocols = {};
  Object.keys(protocols).forEach(function(scheme) {
    var protocol = scheme + ":";
    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);
    function request(input, options3, callback) {
      if (typeof input === "string") {
        var urlStr = input;
        try {
          input = urlToOptions(new URL$1(urlStr));
        } catch (err) {
          input = url.parse(urlStr);
        }
      } else if (URL$1 && input instanceof URL$1) {
        input = urlToOptions(input);
      } else {
        callback = options3;
        options3 = input;
        input = { protocol };
      }
      if (typeof options3 === "function") {
        callback = options3;
        options3 = null;
      }
      options3 = Object.assign({
        maxRedirects: exports.maxRedirects,
        maxBodyLength: exports.maxBodyLength
      }, input, options3);
      options3.nativeProtocols = nativeProtocols;
      assert.equal(options3.protocol, protocol, "protocol mismatch");
      debug$2("options", options3);
      return new RedirectableRequest(options3, callback);
    }
    function get2(input, options3, callback) {
      var wrappedRequest = wrappedProtocol.request(input, options3, callback);
      wrappedRequest.end();
      return wrappedRequest;
    }
    Object.defineProperties(wrappedProtocol, {
      request: { value: request, configurable: true, enumerable: true, writable: true },
      get: { value: get2, configurable: true, enumerable: true, writable: true }
    });
  });
  return exports;
}
function noop$1() {
}
function urlToOptions(urlObject) {
  var options3 = {
    protocol: urlObject.protocol,
    hostname: urlObject.hostname.startsWith("[") ? urlObject.hostname.slice(1, -1) : urlObject.hostname,
    hash: urlObject.hash,
    search: urlObject.search,
    pathname: urlObject.pathname,
    path: urlObject.pathname + urlObject.search,
    href: urlObject.href
  };
  if (urlObject.port !== "") {
    options3.port = Number(urlObject.port);
  }
  return options3;
}
function removeMatchingHeaders(regex, headers) {
  var lastValue;
  for (var header in headers) {
    if (regex.test(header)) {
      lastValue = headers[header];
      delete headers[header];
    }
  }
  return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
}
function createErrorType(code, defaultMessage) {
  function CustomError(cause) {
    Error.captureStackTrace(this, this.constructor);
    if (!cause) {
      this.message = defaultMessage;
    } else {
      this.message = defaultMessage + ": " + cause.message;
      this.cause = cause;
    }
  }
  CustomError.prototype = new Error();
  CustomError.prototype.constructor = CustomError;
  CustomError.prototype.name = "Error [" + code + "]";
  CustomError.prototype.code = code;
  return CustomError;
}
function abortRequest(request) {
  for (var e = 0; e < events.length; e++) {
    request.removeListener(events[e], eventHandlers[events[e]]);
  }
  request.on("error", noop$1);
  request.abort();
}
function isSubdomain(subdomain, domain) {
  const dot = subdomain.length - domain.length - 1;
  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
}
followRedirects$1.exports = wrap({ http: http$1, https: https$1 });
followRedirects$1.exports.wrap = wrap;
var httpNative = import_http.default;
var httpsNative = import_https.default;
var web_o = webOutgoing;
var common$1 = common$3;
var followRedirects = followRedirects$1.exports;
web_o = Object.keys(web_o).map(function(pass) {
  return web_o[pass];
});
var nativeAgents = { http: httpNative, https: httpsNative };
var webIncoming = {
  deleteLength: function deleteLength(req2, res, options3) {
    if ((req2.method === "DELETE" || req2.method === "OPTIONS") && !req2.headers["content-length"]) {
      req2.headers["content-length"] = "0";
      delete req2.headers["transfer-encoding"];
    }
  },
  timeout: function timeout(req2, res, options3) {
    if (options3.timeout) {
      req2.socket.setTimeout(options3.timeout);
    }
  },
  XHeaders: function XHeaders(req2, res, options3) {
    if (!options3.xfwd)
      return;
    var encrypted = req2.isSpdy || common$1.hasEncryptedConnection(req2);
    var values = {
      for: req2.connection.remoteAddress || req2.socket.remoteAddress,
      port: common$1.getPort(req2),
      proto: encrypted ? "https" : "http"
    };
    ["for", "port", "proto"].forEach(function(header) {
      req2.headers["x-forwarded-" + header] = (req2.headers["x-forwarded-" + header] || "") + (req2.headers["x-forwarded-" + header] ? "," : "") + values[header];
    });
    req2.headers["x-forwarded-host"] = req2.headers["x-forwarded-host"] || req2.headers["host"] || "";
  },
  stream: function stream2(req2, res, options3, _, server2, clb) {
    server2.emit("start", req2, res, options3.target || options3.forward);
    var agents = options3.followRedirects ? followRedirects : nativeAgents;
    var http2 = agents.http;
    var https2 = agents.https;
    if (options3.forward) {
      var forwardReq = (options3.forward.protocol === "https:" ? https2 : http2).request(
        common$1.setupOutgoing(options3.ssl || {}, options3, req2, "forward")
      );
      var forwardError = createErrorHandler(forwardReq, options3.forward);
      req2.on("error", forwardError);
      forwardReq.on("error", forwardError);
      (options3.buffer || req2).pipe(forwardReq);
      if (!options3.target) {
        return res.end();
      }
    }
    var proxyReq = (options3.target.protocol === "https:" ? https2 : http2).request(
      common$1.setupOutgoing(options3.ssl || {}, options3, req2)
    );
    proxyReq.on("socket", function(socket) {
      if (server2 && !proxyReq.getHeader("expect")) {
        server2.emit("proxyReq", proxyReq, req2, res, options3);
      }
    });
    if (options3.proxyTimeout) {
      proxyReq.setTimeout(options3.proxyTimeout, function() {
        proxyReq.abort();
      });
    }
    req2.on("aborted", function() {
      proxyReq.abort();
    });
    var proxyError = createErrorHandler(proxyReq, options3.target);
    req2.on("error", proxyError);
    proxyReq.on("error", proxyError);
    function createErrorHandler(proxyReq2, url2) {
      return function proxyError2(err) {
        if (req2.socket.destroyed && err.code === "ECONNRESET") {
          server2.emit("econnreset", err, req2, res, url2);
          return proxyReq2.abort();
        }
        if (clb) {
          clb(err, req2, res, url2);
        } else {
          server2.emit("error", err, req2, res, url2);
        }
      };
    }
    (options3.buffer || req2).pipe(proxyReq);
    proxyReq.on("response", function(proxyRes) {
      if (server2) {
        server2.emit("proxyRes", proxyRes, req2, res);
      }
      if (!res.headersSent && !options3.selfHandleResponse) {
        for (var i = 0; i < web_o.length; i++) {
          if (web_o[i](req2, res, proxyRes, options3)) {
            break;
          }
        }
      }
      if (!res.finished) {
        proxyRes.on("end", function() {
          if (server2)
            server2.emit("end", req2, res, proxyRes);
        });
        if (!options3.selfHandleResponse)
          proxyRes.pipe(res);
      } else {
        if (server2)
          server2.emit("end", req2, res, proxyRes);
      }
    });
  }
};
var http = import_http.default;
var https = import_https.default;
var common = common$3;
var wsIncoming = {
  checkMethodAndHeader: function checkMethodAndHeader(req2, socket) {
    if (req2.method !== "GET" || !req2.headers.upgrade) {
      socket.destroy();
      return true;
    }
    if (req2.headers.upgrade.toLowerCase() !== "websocket") {
      socket.destroy();
      return true;
    }
  },
  XHeaders: function XHeaders2(req2, socket, options3) {
    if (!options3.xfwd)
      return;
    var values = {
      for: req2.connection.remoteAddress || req2.socket.remoteAddress,
      port: common.getPort(req2),
      proto: common.hasEncryptedConnection(req2) ? "wss" : "ws"
    };
    ["for", "port", "proto"].forEach(function(header) {
      req2.headers["x-forwarded-" + header] = (req2.headers["x-forwarded-" + header] || "") + (req2.headers["x-forwarded-" + header] ? "," : "") + values[header];
    });
  },
  stream: function stream3(req2, socket, options3, head, server2, clb) {
    var createHttpHeader = function(line2, headers) {
      return Object.keys(headers).reduce(function(head2, key2) {
        var value2 = headers[key2];
        if (!Array.isArray(value2)) {
          head2.push(key2 + ": " + value2);
          return head2;
        }
        for (var i = 0; i < value2.length; i++) {
          head2.push(key2 + ": " + value2[i]);
        }
        return head2;
      }, [line2]).join("\r\n") + "\r\n\r\n";
    };
    common.setupSocket(socket);
    if (head && head.length)
      socket.unshift(head);
    var proxyReq = (common.isSSL.test(options3.target.protocol) ? https : http).request(
      common.setupOutgoing(options3.ssl || {}, options3, req2)
    );
    if (server2) {
      server2.emit("proxyReqWs", proxyReq, req2, socket, options3, head);
    }
    proxyReq.on("error", onOutgoingError);
    proxyReq.on("response", function(res) {
      if (!res.upgrade) {
        socket.write(createHttpHeader("HTTP/" + res.httpVersion + " " + res.statusCode + " " + res.statusMessage, res.headers));
        res.pipe(socket);
      }
    });
    proxyReq.on("upgrade", function(proxyRes, proxySocket, proxyHead) {
      proxySocket.on("error", onOutgoingError);
      proxySocket.on("end", function() {
        server2.emit("close", proxyRes, proxySocket, proxyHead);
      });
      socket.on("error", function() {
        proxySocket.end();
      });
      common.setupSocket(proxySocket);
      if (proxyHead && proxyHead.length)
        proxySocket.unshift(proxyHead);
      socket.write(createHttpHeader("HTTP/1.1 101 Switching Protocols", proxyRes.headers));
      proxySocket.pipe(socket).pipe(proxySocket);
      server2.emit("open", proxySocket);
      server2.emit("proxySocket", proxySocket);
    });
    return proxyReq.end();
    function onOutgoingError(err) {
      if (clb) {
        clb(err, req2, socket);
      } else {
        server2.emit("error", err, req2, socket);
      }
      socket.end();
    }
  }
};
(function(module2) {
  var httpProxy2 = module2.exports, extend2 = import_util.default._extend, parse_url = import_url.default.parse, EE3 = eventemitter3.exports, http2 = import_http.default, https2 = import_https.default, web = webIncoming, ws = wsIncoming;
  httpProxy2.Server = ProxyServer2;
  function createRightProxy(type) {
    return function(options3) {
      return function(req2, res) {
        var passes = type === "ws" ? this.wsPasses : this.webPasses, args = [].slice.call(arguments), cntr = args.length - 1, head, cbl;
        if (typeof args[cntr] === "function") {
          cbl = args[cntr];
          cntr--;
        }
        var requestOptions = options3;
        if (!(args[cntr] instanceof Buffer) && args[cntr] !== res) {
          requestOptions = extend2({}, options3);
          extend2(requestOptions, args[cntr]);
          cntr--;
        }
        if (args[cntr] instanceof Buffer) {
          head = args[cntr];
        }
        ["target", "forward"].forEach(function(e) {
          if (typeof requestOptions[e] === "string")
            requestOptions[e] = parse_url(requestOptions[e]);
        });
        if (!requestOptions.target && !requestOptions.forward) {
          return this.emit("error", new Error("Must provide a proper URL as target"));
        }
        for (var i = 0; i < passes.length; i++) {
          if (passes[i](req2, res, requestOptions, head, this, cbl)) {
            break;
          }
        }
      };
    };
  }
  httpProxy2.createRightProxy = createRightProxy;
  function ProxyServer2(options3) {
    EE3.call(this);
    options3 = options3 || {};
    options3.prependPath = options3.prependPath === false ? false : true;
    this.web = this.proxyRequest = createRightProxy("web")(options3);
    this.ws = this.proxyWebsocketRequest = createRightProxy("ws")(options3);
    this.options = options3;
    this.webPasses = Object.keys(web).map(function(pass) {
      return web[pass];
    });
    this.wsPasses = Object.keys(ws).map(function(pass) {
      return ws[pass];
    });
    this.on("error", this.onError, this);
  }
  import_util.default.inherits(ProxyServer2, EE3);
  ProxyServer2.prototype.onError = function(err) {
    if (this.listeners("error").length === 1) {
      throw err;
    }
  };
  ProxyServer2.prototype.listen = function(port, hostname) {
    var self2 = this, closure = function(req2, res) {
      self2.web(req2, res);
    };
    this._server = this.options.ssl ? https2.createServer(this.options.ssl, closure) : http2.createServer(closure);
    if (this.options.ws) {
      this._server.on("upgrade", function(req2, socket, head) {
        self2.ws(req2, socket, head);
      });
    }
    this._server.listen(port, hostname);
    return this;
  };
  ProxyServer2.prototype.close = function(callback) {
    var self2 = this;
    if (this._server) {
      this._server.close(done);
    }
    function done() {
      self2._server = null;
      if (callback) {
        callback.apply(null, arguments);
      }
    }
  };
  ProxyServer2.prototype.before = function(type, passName, callback) {
    if (type !== "ws" && type !== "web") {
      throw new Error("type must be `web` or `ws`");
    }
    var passes = type === "ws" ? this.wsPasses : this.webPasses, i = false;
    passes.forEach(function(v, idx) {
      if (v.name === passName)
        i = idx;
    });
    if (i === false)
      throw new Error("No such pass");
    passes.splice(i, 0, callback);
  };
  ProxyServer2.prototype.after = function(type, passName, callback) {
    if (type !== "ws" && type !== "web") {
      throw new Error("type must be `web` or `ws`");
    }
    var passes = type === "ws" ? this.wsPasses : this.webPasses, i = false;
    passes.forEach(function(v, idx) {
      if (v.name === passName)
        i = idx;
    });
    if (i === false)
      throw new Error("No such pass");
    passes.splice(i++, 0, callback);
  };
})(httpProxy$2);
var ProxyServer = httpProxy$2.exports.Server;
function createProxyServer(options3) {
  return new ProxyServer(options3);
}
ProxyServer.createProxyServer = createProxyServer;
ProxyServer.createServer = createProxyServer;
ProxyServer.createProxy = createProxyServer;
var httpProxy$1 = ProxyServer;
(function(module2) {
  module2.exports = httpProxy$1;
})(httpProxy$3);
var httpProxy = getDefaultExportFromCjs(httpProxy$3.exports);
var debug$1 = createDebugger("vite:proxy");
function proxyMiddleware(httpServer, options3, config2) {
  const proxies = {};
  Object.keys(options3).forEach((context) => {
    let opts = options3[context];
    if (!opts) {
      return;
    }
    if (typeof opts === "string") {
      opts = { target: opts, changeOrigin: true };
    }
    const proxy = httpProxy.createProxyServer(opts);
    proxy.on("error", (err, req2, originalRes) => {
      const res = originalRes;
      if ("req" in res) {
        config2.logger.error(`${picocolors.exports.red(`http proxy error at ${originalRes.req.url}:`)}
${err.stack}`, {
          timestamp: true,
          error: err
        });
        if (!res.headersSent && !res.writableEnded) {
          res.writeHead(500, {
            "Content-Type": "text/plain"
          }).end();
        }
      } else {
        config2.logger.error(`${picocolors.exports.red(`ws proxy error:`)}
${err.stack}`, {
          timestamp: true,
          error: err
        });
        res.end();
      }
    });
    if (opts.configure) {
      opts.configure(proxy, opts);
    }
    proxies[context] = [proxy, { ...opts }];
  });
  if (httpServer) {
    httpServer.on("upgrade", (req2, socket, head) => {
      var _a, _b;
      const url2 = req2.url;
      for (const context in proxies) {
        if (doesProxyContextMatchUrl(context, url2)) {
          const [proxy, opts] = proxies[context];
          if ((opts.ws || ((_a = opts.target) == null ? void 0 : _a.toString().startsWith("ws:")) || ((_b = opts.target) == null ? void 0 : _b.toString().startsWith("wss:"))) && req2.headers["sec-websocket-protocol"] !== HMR_HEADER) {
            if (opts.rewrite) {
              req2.url = opts.rewrite(url2);
            }
            debug$1(`${req2.url} -> ws ${opts.target}`);
            proxy.ws(req2, socket, head);
            return;
          }
        }
      }
    });
  }
  return function viteProxyMiddleware(req2, res, next) {
    const url2 = req2.url;
    for (const context in proxies) {
      if (doesProxyContextMatchUrl(context, url2)) {
        const [proxy, opts] = proxies[context];
        const options4 = {};
        if (opts.bypass) {
          const bypassResult = opts.bypass(req2, res, opts);
          if (typeof bypassResult === "string") {
            req2.url = bypassResult;
            debug$1(`bypass: ${req2.url} -> ${bypassResult}`);
            return next();
          } else if (isObject$1(bypassResult)) {
            Object.assign(options4, bypassResult);
            debug$1(`bypass: ${req2.url} use modified options: %O`, options4);
            return next();
          } else if (bypassResult === false) {
            debug$1(`bypass: ${req2.url} -> 404`);
            return res.end(404);
          }
        }
        debug$1(`${req2.url} -> ${opts.target || opts.forward}`);
        if (opts.rewrite) {
          req2.url = opts.rewrite(req2.url);
        }
        proxy.web(req2, res, options4);
        return;
      }
    }
    next();
  };
}
function doesProxyContextMatchUrl(context, url2) {
  return context.startsWith("^") && new RegExp(context).test(url2) || url2.startsWith(context);
}
var lib = { exports: {} };
(function(module2, exports) {
  var url2 = import_url.default;
  module2.exports = function historyApiFallback(options3) {
    options3 = options3 || {};
    var logger = getLogger(options3);
    return function(req2, res, next) {
      var headers = req2.headers;
      if (req2.method !== "GET" && req2.method !== "HEAD") {
        logger(
          "Not rewriting",
          req2.method,
          req2.url,
          "because the method is not GET or HEAD."
        );
        return next();
      } else if (!headers || typeof headers.accept !== "string") {
        logger(
          "Not rewriting",
          req2.method,
          req2.url,
          "because the client did not send an HTTP accept header."
        );
        return next();
      } else if (headers.accept.indexOf("application/json") === 0) {
        logger(
          "Not rewriting",
          req2.method,
          req2.url,
          "because the client prefers JSON."
        );
        return next();
      } else if (!acceptsHtml(headers.accept, options3)) {
        logger(
          "Not rewriting",
          req2.method,
          req2.url,
          "because the client does not accept HTML."
        );
        return next();
      }
      var parsedUrl = url2.parse(req2.url);
      var rewriteTarget;
      options3.rewrites = options3.rewrites || [];
      for (var i = 0; i < options3.rewrites.length; i++) {
        var rewrite = options3.rewrites[i];
        var match = parsedUrl.pathname.match(rewrite.from);
        if (match !== null) {
          rewriteTarget = evaluateRewriteRule(parsedUrl, match, rewrite.to, req2);
          if (rewriteTarget.charAt(0) !== "/") {
            logger(
              "We recommend using an absolute path for the rewrite target.",
              "Received a non-absolute rewrite target",
              rewriteTarget,
              "for URL",
              req2.url
            );
          }
          logger("Rewriting", req2.method, req2.url, "to", rewriteTarget);
          req2.url = rewriteTarget;
          return next();
        }
      }
      var pathname = parsedUrl.pathname;
      if (pathname.lastIndexOf(".") > pathname.lastIndexOf("/") && options3.disableDotRule !== true) {
        logger(
          "Not rewriting",
          req2.method,
          req2.url,
          "because the path includes a dot (.) character."
        );
        return next();
      }
      rewriteTarget = options3.index || "/index.html";
      logger("Rewriting", req2.method, req2.url, "to", rewriteTarget);
      req2.url = rewriteTarget;
      next();
    };
  };
  function evaluateRewriteRule(parsedUrl, match, rule, req2) {
    if (typeof rule === "string") {
      return rule;
    } else if (typeof rule !== "function") {
      throw new Error("Rewrite rule can only be of type string or function.");
    }
    return rule({
      parsedUrl,
      match,
      request: req2
    });
  }
  function acceptsHtml(header, options3) {
    options3.htmlAcceptHeaders = options3.htmlAcceptHeaders || ["text/html", "*/*"];
    for (var i = 0; i < options3.htmlAcceptHeaders.length; i++) {
      if (header.indexOf(options3.htmlAcceptHeaders[i]) !== -1) {
        return true;
      }
    }
    return false;
  }
  function getLogger(options3) {
    if (options3 && options3.logger) {
      return options3.logger;
    } else if (options3 && options3.verbose) {
      return console.log.bind(console);
    }
    return function() {
    };
  }
})(lib);
var history = lib.exports;
function htmlFallbackMiddleware(root2, spaFallback) {
  const historyHtmlFallbackMiddleware = history({
    logger: createDebugger("vite:html-fallback"),
    rewrites: [
      {
        from: /\/$/,
        to({ parsedUrl, request }) {
          const rewritten = decodeURIComponent(parsedUrl.pathname) + "index.html";
          if (import_node_fs.default.existsSync(import_node_path2.default.join(root2, rewritten))) {
            return rewritten;
          }
          return spaFallback ? `/index.html` : request.url;
        }
      }
    ]
  });
  return function viteHtmlFallbackMiddleware(req2, res, next) {
    return historyHtmlFallbackMiddleware(req2, res, next);
  };
}
var debugCache = createDebugger("vite:cache");
var isDebug = !!process.env.DEBUG;
var knownIgnoreList = /* @__PURE__ */ new Set(["/", "/favicon.ico"]);
function transformMiddleware(server2) {
  const { config: { root: root2, logger }, moduleGraph } = server2;
  return async function viteTransformMiddleware(req2, res, next) {
    var _a, _b, _c, _d, _e, _f;
    if (req2.method !== "GET" || knownIgnoreList.has(req2.url)) {
      return next();
    }
    let url2;
    try {
      url2 = decodeURI(removeTimestampQuery(req2.url)).replace(NULL_BYTE_PLACEHOLDER, "\0");
    } catch (e) {
      return next(e);
    }
    const withoutQuery = cleanUrl(url2);
    try {
      const isSourceMap = withoutQuery.endsWith(".map");
      if (isSourceMap) {
        const depsOptimizer = getDepsOptimizer(server2.config, false);
        if (depsOptimizer == null ? void 0 : depsOptimizer.isOptimizedDepUrl(url2)) {
          const mapFile = url2.startsWith(FS_PREFIX) ? fsPathFromId(url2) : normalizePath$3(ensureVolumeInPath(import_node_path2.default.resolve(root2, url2.slice(1))));
          try {
            const map2 = await import_node_fs.promises.readFile(mapFile, "utf-8");
            return send$1(req2, res, map2, "json", {
              headers: server2.config.server.headers
            });
          } catch (e) {
            const dummySourceMap = {
              version: 3,
              file: mapFile.replace(/\.map$/, ""),
              sources: [],
              sourcesContent: [],
              names: [],
              mappings: ";;;;;;;;;"
            };
            return send$1(req2, res, JSON.stringify(dummySourceMap), "json", {
              cacheControl: "no-cache",
              headers: server2.config.server.headers
            });
          }
        } else {
          const originalUrl = url2.replace(/\.map($|\?)/, "$1");
          const map2 = (_b = (_a = await moduleGraph.getModuleByUrl(originalUrl, false)) == null ? void 0 : _a.transformResult) == null ? void 0 : _b.map;
          if (map2) {
            return send$1(req2, res, JSON.stringify(map2), "json", {
              headers: server2.config.server.headers
            });
          } else {
            return next();
          }
        }
      }
      const publicDir = normalizePath$3(server2.config.publicDir);
      const rootDir = normalizePath$3(server2.config.root);
      if (publicDir.startsWith(rootDir)) {
        const publicPath = `${publicDir.slice(rootDir.length)}/`;
        if (url2.startsWith(publicPath)) {
          let warning;
          if (isImportRequest(url2)) {
            const rawUrl = removeImportQuery(url2);
            warning = `Assets in public cannot be imported from JavaScript.
Instead of ${picocolors.exports.cyan(rawUrl)}, put the file in the src directory, and use ${picocolors.exports.cyan(rawUrl.replace(publicPath, "/src/"))} instead.`;
          } else {
            warning = `files in the public directory are served at the root path.
Instead of ${picocolors.exports.cyan(url2)}, use ${picocolors.exports.cyan(url2.replace(publicPath, "/"))}.`;
          }
          logger.warn(picocolors.exports.yellow(warning));
        }
      }
      if (isJSRequest(url2) || isImportRequest(url2) || isCSSRequest(url2) || isHTMLProxy(url2)) {
        url2 = removeImportQuery(url2);
        url2 = unwrapId(url2);
        if (isCSSRequest(url2) && !isDirectRequest(url2) && ((_c = req2.headers.accept) == null ? void 0 : _c.includes("text/css"))) {
          url2 = injectQuery(url2, "direct");
        }
        const ifNoneMatch = req2.headers["if-none-match"];
        if (ifNoneMatch && ((_e = (_d = await moduleGraph.getModuleByUrl(url2, false)) == null ? void 0 : _d.transformResult) == null ? void 0 : _e.etag) === ifNoneMatch) {
          isDebug && debugCache(`[304] ${prettifyUrl(url2, root2)}`);
          res.statusCode = 304;
          return res.end();
        }
        const result = await transformRequest(url2, server2, {
          html: (_f = req2.headers.accept) == null ? void 0 : _f.includes("text/html")
        });
        if (result) {
          const depsOptimizer = getDepsOptimizer(server2.config, false);
          const type = isDirectCSSRequest(url2) ? "css" : "js";
          const isDep = DEP_VERSION_RE.test(url2) || (depsOptimizer == null ? void 0 : depsOptimizer.isOptimizedDepUrl(url2));
          return send$1(req2, res, result.code, type, {
            etag: result.etag,
            cacheControl: isDep ? "max-age=31536000,immutable" : "no-cache",
            headers: server2.config.server.headers,
            map: result.map
          });
        }
      }
    } catch (e) {
      if ((e == null ? void 0 : e.code) === ERR_OPTIMIZE_DEPS_PROCESSING_ERROR) {
        if (!res.writableEnded) {
          res.statusCode = 504;
          res.end();
        }
        logger.error(e.message);
        return;
      }
      if ((e == null ? void 0 : e.code) === ERR_OUTDATED_OPTIMIZED_DEP) {
        if (!res.writableEnded) {
          res.statusCode = 504;
          res.end();
        }
        return;
      }
      return next(e);
    }
    next();
  };
}
function createDevHtmlTransformFn(server2) {
  const [preHooks, postHooks] = resolveHtmlTransforms(server2.config.plugins);
  return (url2, html, originalUrl) => {
    return applyHtmlTransforms(html, [
      preImportMapHook(server2.config),
      ...preHooks,
      devHtmlHook,
      ...postHooks,
      postImportMapHook()
    ], {
      path: url2,
      filename: getHtmlFilename(url2, server2),
      server: server2,
      originalUrl
    });
  };
}
function getHtmlFilename(url2, server2) {
  if (url2.startsWith(FS_PREFIX)) {
    return decodeURIComponent(fsPathFromId(url2));
  } else {
    return decodeURIComponent(normalizePath$3(import_node_path2.default.join(server2.config.root, url2.slice(1))));
  }
}
var startsWithSingleSlashRE = /^\/(?!\/)/;
var processNodeUrl = (attr, sourceCodeLocation, s, config2, htmlPath, originalUrl, moduleGraph) => {
  let url2 = attr.value || "";
  if (moduleGraph) {
    const mod = moduleGraph.urlToModuleMap.get(url2);
    if (mod && mod.lastHMRTimestamp > 0) {
      url2 = injectQuery(url2, `t=${mod.lastHMRTimestamp}`);
    }
  }
  const devBase = config2.base;
  if (startsWithSingleSlashRE.test(url2)) {
    const fullUrl = joinUrlSegments(devBase, url2);
    overwriteAttrValue(s, sourceCodeLocation, fullUrl);
  } else if (url2.startsWith(".") && originalUrl && originalUrl !== "/" && htmlPath === "/index.html") {
    const replacer = (url3) => import_node_path2.default.posix.join(devBase, import_node_path2.default.posix.relative(originalUrl, devBase), url3.slice(1));
    const processedUrl = attr.name === "srcset" && attr.prefix === void 0 ? processSrcSetSync(url2, ({ url: url3 }) => replacer(url3)) : replacer(url2);
    overwriteAttrValue(s, sourceCodeLocation, processedUrl);
  }
};
var devHtmlHook = async (html, { path: htmlPath, filename, server: server2, originalUrl }) => {
  const { config: config2, moduleGraph, watcher } = server2;
  const base2 = config2.base || "/";
  let proxyModulePath;
  let proxyModuleUrl;
  const trailingSlash = htmlPath.endsWith("/");
  if (!trailingSlash && import_node_fs.default.existsSync(filename)) {
    proxyModulePath = htmlPath;
    proxyModuleUrl = joinUrlSegments(base2, htmlPath);
  } else {
    const validPath = `${htmlPath}${trailingSlash ? "index.html" : ""}`;
    proxyModulePath = `\0${validPath}`;
    proxyModuleUrl = wrapId(proxyModulePath);
  }
  const s = new MagicString(html);
  let inlineModuleIndex = -1;
  const proxyCacheUrl = cleanUrl(proxyModulePath).replace(normalizePath$3(config2.root), "");
  const styleUrl = [];
  const addInlineModule = (node2, ext2) => {
    inlineModuleIndex++;
    const contentNode = node2.childNodes[0];
    const code = contentNode.value;
    let map2;
    if (!proxyModulePath.startsWith("\0")) {
      map2 = new MagicString(html).snip(contentNode.sourceCodeLocation.startOffset, contentNode.sourceCodeLocation.endOffset).generateMap({ hires: true });
      map2.sources = [filename];
      map2.file = filename;
    }
    addToHTMLProxyCache(config2, proxyCacheUrl, inlineModuleIndex, { code, map: map2 });
    const modulePath = `${proxyModuleUrl}?html-proxy&index=${inlineModuleIndex}.${ext2}`;
    const module2 = server2 == null ? void 0 : server2.moduleGraph.getModuleById(modulePath);
    if (module2) {
      server2 == null ? void 0 : server2.moduleGraph.invalidateModule(module2);
    }
    s.update(node2.sourceCodeLocation.startOffset, node2.sourceCodeLocation.endOffset, `<script type="module" src="${modulePath}"><\/script>`);
  };
  await traverseHtml(html, htmlPath, (node2) => {
    if (!nodeIsElement(node2)) {
      return;
    }
    if (node2.nodeName === "script") {
      const { src: src2, sourceCodeLocation, isModule } = getScriptInfo(node2);
      if (src2) {
        processNodeUrl(src2, sourceCodeLocation, s, config2, htmlPath, originalUrl, moduleGraph);
      } else if (isModule && node2.childNodes.length) {
        addInlineModule(node2, "js");
      }
    }
    if (node2.nodeName === "style" && node2.childNodes.length) {
      const children = node2.childNodes[0];
      styleUrl.push({
        start: children.sourceCodeLocation.startOffset,
        end: children.sourceCodeLocation.endOffset,
        code: children.value
      });
    }
    const assetAttrs = assetAttrsConfig[node2.nodeName];
    if (assetAttrs) {
      for (const p of node2.attrs) {
        const attrKey = getAttrKey(p);
        if (p.value && assetAttrs.includes(attrKey)) {
          processNodeUrl(p, node2.sourceCodeLocation.attrs[attrKey], s, config2, htmlPath, originalUrl);
        }
      }
    }
  });
  await Promise.all(styleUrl.map(async ({ start, end, code }, index2) => {
    const url2 = `${proxyModulePath}?html-proxy&direct&index=${index2}.css`;
    const mod = await moduleGraph.ensureEntryFromUrl(url2, false);
    ensureWatchedFile(watcher, mod.file, config2.root);
    const result = await server2.pluginContainer.transform(code, mod.id);
    s.overwrite(start, end, (result == null ? void 0 : result.code) || "");
  }));
  html = s.toString();
  return {
    html,
    tags: [
      {
        tag: "script",
        attrs: {
          type: "module",
          src: import_node_path2.default.posix.join(base2, CLIENT_PUBLIC_PATH)
        },
        injectTo: "head-prepend"
      }
    ]
  };
};
function indexHtmlMiddleware(server2) {
  return async function viteIndexHtmlMiddleware(req2, res, next) {
    if (res.writableEnded) {
      return next();
    }
    const url2 = req2.url && cleanUrl(req2.url);
    if ((url2 == null ? void 0 : url2.endsWith(".html")) && req2.headers["sec-fetch-dest"] !== "script") {
      const filename = getHtmlFilename(url2, server2);
      if (import_node_fs.default.existsSync(filename)) {
        try {
          let html = import_node_fs.default.readFileSync(filename, "utf-8");
          html = await server2.transformIndexHtml(url2, html, req2.originalUrl);
          return send$1(req2, res, html, "html", {
            headers: server2.config.server.headers
          });
        } catch (e) {
          return next(e);
        }
      }
    }
    next();
  };
}
var logTime = createDebugger("vite:time");
function timeMiddleware(root2) {
  return function viteTimeMiddleware(req2, res, next) {
    const start = import_node_perf_hooks.performance.now();
    const end = res.end;
    res.end = (...args) => {
      logTime(`${timeFrom(start)} ${prettifyUrl(req2.url, root2)}`);
      return end.call(res, ...args);
    };
    next();
  };
}
var ModuleNode = class {
  constructor(url2, setIsSelfAccepting = true) {
    this.id = null;
    this.file = null;
    this.importers = /* @__PURE__ */ new Set();
    this.importedModules = /* @__PURE__ */ new Set();
    this.acceptedHmrDeps = /* @__PURE__ */ new Set();
    this.acceptedHmrExports = null;
    this.importedBindings = null;
    this.transformResult = null;
    this.ssrTransformResult = null;
    this.ssrModule = null;
    this.ssrError = null;
    this.lastHMRTimestamp = 0;
    this.lastInvalidationTimestamp = 0;
    this.url = url2;
    this.type = isDirectCSSRequest(url2) ? "css" : "js";
    if (setIsSelfAccepting) {
      this.isSelfAccepting = false;
    }
  }
};
function invalidateSSRModule(mod, seen2) {
  if (seen2.has(mod)) {
    return;
  }
  seen2.add(mod);
  mod.ssrModule = null;
  mod.ssrError = null;
  mod.importers.forEach((importer) => invalidateSSRModule(importer, seen2));
}
var ModuleGraph = class {
  constructor(resolveId) {
    this.resolveId = resolveId;
    this.urlToModuleMap = /* @__PURE__ */ new Map();
    this.idToModuleMap = /* @__PURE__ */ new Map();
    this.fileToModulesMap = /* @__PURE__ */ new Map();
    this.safeModulesPath = /* @__PURE__ */ new Set();
  }
  async getModuleByUrl(rawUrl, ssr) {
    const [url2] = await this.resolveUrl(rawUrl, ssr);
    return this.urlToModuleMap.get(url2);
  }
  getModuleById(id) {
    return this.idToModuleMap.get(removeTimestampQuery(id));
  }
  getModulesByFile(file) {
    return this.fileToModulesMap.get(file);
  }
  onFileChange(file) {
    const mods = this.getModulesByFile(file);
    if (mods) {
      const seen2 = /* @__PURE__ */ new Set();
      mods.forEach((mod) => {
        this.invalidateModule(mod, seen2);
      });
    }
  }
  invalidateModule(mod, seen2 = /* @__PURE__ */ new Set(), timestamp2 = Date.now()) {
    mod.lastInvalidationTimestamp = timestamp2;
    mod.transformResult = null;
    mod.ssrTransformResult = null;
    invalidateSSRModule(mod, seen2);
  }
  invalidateAll() {
    const timestamp2 = Date.now();
    const seen2 = /* @__PURE__ */ new Set();
    this.idToModuleMap.forEach((mod) => {
      this.invalidateModule(mod, seen2, timestamp2);
    });
  }
  async updateModuleInfo(mod, importedModules, importedBindings, acceptedModules, acceptedExports, isSelfAccepting, ssr) {
    mod.isSelfAccepting = isSelfAccepting;
    const prevImports = mod.importedModules;
    const nextImports = mod.importedModules = /* @__PURE__ */ new Set();
    let noLongerImported;
    for (const imported of importedModules) {
      const dep = typeof imported === "string" ? await this.ensureEntryFromUrl(imported, ssr) : imported;
      dep.importers.add(mod);
      nextImports.add(dep);
    }
    prevImports.forEach((dep) => {
      if (!nextImports.has(dep)) {
        dep.importers.delete(mod);
        if (!dep.importers.size) {
          (noLongerImported || (noLongerImported = /* @__PURE__ */ new Set())).add(dep);
        }
      }
    });
    const deps = mod.acceptedHmrDeps = /* @__PURE__ */ new Set();
    for (const accepted of acceptedModules) {
      const dep = typeof accepted === "string" ? await this.ensureEntryFromUrl(accepted, ssr) : accepted;
      deps.add(dep);
    }
    mod.acceptedHmrExports = acceptedExports;
    mod.importedBindings = importedBindings;
    return noLongerImported;
  }
  async ensureEntryFromUrl(rawUrl, ssr, setIsSelfAccepting = true) {
    const [url2, resolvedId, meta] = await this.resolveUrl(rawUrl, ssr);
    let mod = this.idToModuleMap.get(resolvedId);
    if (!mod) {
      mod = new ModuleNode(url2, setIsSelfAccepting);
      if (meta)
        mod.meta = meta;
      this.urlToModuleMap.set(url2, mod);
      mod.id = resolvedId;
      this.idToModuleMap.set(resolvedId, mod);
      const file = mod.file = cleanUrl(resolvedId);
      let fileMappedModules = this.fileToModulesMap.get(file);
      if (!fileMappedModules) {
        fileMappedModules = /* @__PURE__ */ new Set();
        this.fileToModulesMap.set(file, fileMappedModules);
      }
      fileMappedModules.add(mod);
    } else if (!this.urlToModuleMap.has(url2)) {
      this.urlToModuleMap.set(url2, mod);
    }
    return mod;
  }
  createFileOnlyEntry(file) {
    file = normalizePath$3(file);
    let fileMappedModules = this.fileToModulesMap.get(file);
    if (!fileMappedModules) {
      fileMappedModules = /* @__PURE__ */ new Set();
      this.fileToModulesMap.set(file, fileMappedModules);
    }
    const url2 = `${FS_PREFIX}${file}`;
    for (const m of fileMappedModules) {
      if (m.url === url2 || m.id === file) {
        return m;
      }
    }
    const mod = new ModuleNode(url2);
    mod.file = file;
    fileMappedModules.add(mod);
    return mod;
  }
  async resolveUrl(url2, ssr) {
    url2 = removeImportQuery(removeTimestampQuery(url2));
    const resolved = await this.resolveId(url2, !!ssr);
    const resolvedId = (resolved == null ? void 0 : resolved.id) || url2;
    if (url2 !== resolvedId && !url2.includes("\0") && !url2.startsWith(`virtual:`)) {
      const ext2 = (0, import_node_path2.extname)(cleanUrl(resolvedId));
      const { pathname, search, hash } = new URL(url2, "relative://");
      if (ext2 && !pathname.endsWith(ext2)) {
        url2 = pathname + ext2 + search + hash;
      }
    }
    return [url2, resolvedId, resolved == null ? void 0 : resolved.meta];
  }
};
var isWsl$2 = { exports: {} };
var fs$3 = import_fs.default;
var isDocker$2;
function hasDockerEnv() {
  try {
    fs$3.statSync("/.dockerenv");
    return true;
  } catch (_) {
    return false;
  }
}
function hasDockerCGroup() {
  try {
    return fs$3.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
  } catch (_) {
    return false;
  }
}
var isDocker_1 = () => {
  if (isDocker$2 === void 0) {
    isDocker$2 = hasDockerEnv() || hasDockerCGroup();
  }
  return isDocker$2;
};
var os = import_os.default;
var fs$2 = import_fs.default;
var isDocker$1 = isDocker_1;
var isWsl$1 = () => {
  if (process.platform !== "linux") {
    return false;
  }
  if (os.release().toLowerCase().includes("microsoft")) {
    if (isDocker$1()) {
      return false;
    }
    return true;
  }
  try {
    return fs$2.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isDocker$1() : false;
  } catch (_) {
    return false;
  }
};
if (process.env.__IS_WSL_TEST__) {
  isWsl$2.exports = isWsl$1;
} else {
  isWsl$2.exports = isWsl$1();
}
var defineLazyProp = (object, propertyName, fn) => {
  const define = (value2) => Object.defineProperty(object, propertyName, { value: value2, enumerable: true, writable: true });
  Object.defineProperty(object, propertyName, {
    configurable: true,
    enumerable: true,
    get() {
      const result = fn();
      define(result);
      return result;
    },
    set(value2) {
      define(value2);
    }
  });
  return object;
};
var path$3 = import_path.default;
var childProcess = import_child_process.default;
var { promises: fs$1, constants: fsConstants } = import_fs.default;
var isWsl = isWsl$2.exports;
var isDocker = isDocker_1;
var defineLazyProperty = defineLazyProp;
var localXdgOpenPath = path$3.join(__dirname2, "xdg-open");
var { platform, arch } = process;
var getWslDrivesMountPoint = (() => {
  const defaultMountPoint = "/mnt/";
  let mountPoint;
  return async function() {
    if (mountPoint) {
      return mountPoint;
    }
    const configFilePath = "/etc/wsl.conf";
    let isConfigFileExists = false;
    try {
      await fs$1.access(configFilePath, fsConstants.F_OK);
      isConfigFileExists = true;
    } catch {
    }
    if (!isConfigFileExists) {
      return defaultMountPoint;
    }
    const configContent = await fs$1.readFile(configFilePath, { encoding: "utf8" });
    const configMountPoint = new RegExp("(?<!#.*)root\\s*=\\s*(?<mountPoint>.*)", "g").exec(configContent);
    if (!configMountPoint) {
      return defaultMountPoint;
    }
    mountPoint = configMountPoint.groups.mountPoint.trim();
    mountPoint = mountPoint.endsWith("/") ? mountPoint : `${mountPoint}/`;
    return mountPoint;
  };
})();
var pTryEach = async (array2, mapper) => {
  let latestError;
  for (const item of array2) {
    try {
      return await mapper(item);
    } catch (error2) {
      latestError = error2;
    }
  }
  throw latestError;
};
var baseOpen = async (options3) => {
  options3 = {
    wait: false,
    background: false,
    newInstance: false,
    allowNonzeroExitCode: false,
    ...options3
  };
  if (Array.isArray(options3.app)) {
    return pTryEach(options3.app, (singleApp) => baseOpen({
      ...options3,
      app: singleApp
    }));
  }
  let { name: app, arguments: appArguments = [] } = options3.app || {};
  appArguments = [...appArguments];
  if (Array.isArray(app)) {
    return pTryEach(app, (appName) => baseOpen({
      ...options3,
      app: {
        name: appName,
        arguments: appArguments
      }
    }));
  }
  let command;
  const cliArguments = [];
  const childProcessOptions = {};
  if (platform === "darwin") {
    command = "open";
    if (options3.wait) {
      cliArguments.push("--wait-apps");
    }
    if (options3.background) {
      cliArguments.push("--background");
    }
    if (options3.newInstance) {
      cliArguments.push("--new");
    }
    if (app) {
      cliArguments.push("-a", app);
    }
  } else if (platform === "win32" || isWsl && !isDocker()) {
    const mountPoint = await getWslDrivesMountPoint();
    command = isWsl ? `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`;
    cliArguments.push(
      "-NoProfile",
      "-NonInteractive",
      "\u2013ExecutionPolicy",
      "Bypass",
      "-EncodedCommand"
    );
    if (!isWsl) {
      childProcessOptions.windowsVerbatimArguments = true;
    }
    const encodedArguments = ["Start"];
    if (options3.wait) {
      encodedArguments.push("-Wait");
    }
    if (app) {
      encodedArguments.push(`"\`"${app}\`""`, "-ArgumentList");
      if (options3.target) {
        appArguments.unshift(options3.target);
      }
    } else if (options3.target) {
      encodedArguments.push(`"${options3.target}"`);
    }
    if (appArguments.length > 0) {
      appArguments = appArguments.map((arg) => `"\`"${arg}\`""`);
      encodedArguments.push(appArguments.join(","));
    }
    options3.target = Buffer.from(encodedArguments.join(" "), "utf16le").toString("base64");
  } else {
    if (app) {
      command = app;
    } else {
      const isBundled = !__dirname2 || __dirname2 === "/";
      let exeLocalXdgOpen = false;
      try {
        await fs$1.access(localXdgOpenPath, fsConstants.X_OK);
        exeLocalXdgOpen = true;
      } catch {
      }
      const useSystemXdgOpen = process.versions.electron || platform === "android" || isBundled || !exeLocalXdgOpen;
      command = useSystemXdgOpen ? "xdg-open" : localXdgOpenPath;
    }
    if (appArguments.length > 0) {
      cliArguments.push(...appArguments);
    }
    if (!options3.wait) {
      childProcessOptions.stdio = "ignore";
      childProcessOptions.detached = true;
    }
  }
  if (options3.target) {
    cliArguments.push(options3.target);
  }
  if (platform === "darwin" && appArguments.length > 0) {
    cliArguments.push("--args", ...appArguments);
  }
  const subprocess = childProcess.spawn(command, cliArguments, childProcessOptions);
  if (options3.wait) {
    return new Promise((resolve3, reject) => {
      subprocess.once("error", reject);
      subprocess.once("close", (exitCode) => {
        if (options3.allowNonzeroExitCode && exitCode > 0) {
          reject(new Error(`Exited with code ${exitCode}`));
          return;
        }
        resolve3(subprocess);
      });
    });
  }
  subprocess.unref();
  return subprocess;
};
var open = (target, options3) => {
  if (typeof target !== "string") {
    throw new TypeError("Expected a `target`");
  }
  return baseOpen({
    ...options3,
    target
  });
};
var openApp = (name, options3) => {
  if (typeof name !== "string") {
    throw new TypeError("Expected a `name`");
  }
  const { arguments: appArguments = [] } = options3 || {};
  if (appArguments !== void 0 && appArguments !== null && !Array.isArray(appArguments)) {
    throw new TypeError("Expected `appArguments` as Array type");
  }
  return baseOpen({
    ...options3,
    app: {
      name,
      arguments: appArguments
    }
  });
};
function detectArchBinary(binary2) {
  if (typeof binary2 === "string" || Array.isArray(binary2)) {
    return binary2;
  }
  const { [arch]: archBinary } = binary2;
  if (!archBinary) {
    throw new Error(`${arch} is not supported`);
  }
  return archBinary;
}
function detectPlatformBinary({ [platform]: platformBinary }, { wsl }) {
  if (wsl && isWsl) {
    return detectArchBinary(wsl);
  }
  if (!platformBinary) {
    throw new Error(`${platform} is not supported`);
  }
  return detectArchBinary(platformBinary);
}
var apps = {};
defineLazyProperty(apps, "chrome", () => detectPlatformBinary({
  darwin: "google chrome",
  win32: "chrome",
  linux: ["google-chrome", "google-chrome-stable", "chromium"]
}, {
  wsl: {
    ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
    x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
  }
}));
defineLazyProperty(apps, "firefox", () => detectPlatformBinary({
  darwin: "firefox",
  win32: "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
  linux: "firefox"
}, {
  wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe"
}));
defineLazyProperty(apps, "edge", () => detectPlatformBinary({
  darwin: "microsoft edge",
  win32: "msedge",
  linux: ["microsoft-edge", "microsoft-edge-dev"]
}, {
  wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"
}));
open.apps = apps;
open.openApp = openApp;
var open_1 = open;
var crossSpawn = { exports: {} };
var windows;
var hasRequiredWindows;
function requireWindows() {
  if (hasRequiredWindows)
    return windows;
  hasRequiredWindows = 1;
  windows = isexe2;
  isexe2.sync = sync2;
  var fs2 = import_fs.default;
  function checkPathExt(path4, options3) {
    var pathext = options3.pathExt !== void 0 ? options3.pathExt : process.env.PATHEXT;
    if (!pathext) {
      return true;
    }
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) {
      return true;
    }
    for (var i = 0; i < pathext.length; i++) {
      var p = pathext[i].toLowerCase();
      if (p && path4.substr(-p.length).toLowerCase() === p) {
        return true;
      }
    }
    return false;
  }
  function checkStat(stat2, path4, options3) {
    if (!stat2.isSymbolicLink() && !stat2.isFile()) {
      return false;
    }
    return checkPathExt(path4, options3);
  }
  function isexe2(path4, options3, cb) {
    fs2.stat(path4, function(er, stat2) {
      cb(er, er ? false : checkStat(stat2, path4, options3));
    });
  }
  function sync2(path4, options3) {
    return checkStat(fs2.statSync(path4), path4, options3);
  }
  return windows;
}
var mode;
var hasRequiredMode;
function requireMode() {
  if (hasRequiredMode)
    return mode;
  hasRequiredMode = 1;
  mode = isexe2;
  isexe2.sync = sync2;
  var fs2 = import_fs.default;
  function isexe2(path4, options3, cb) {
    fs2.stat(path4, function(er, stat2) {
      cb(er, er ? false : checkStat(stat2, options3));
    });
  }
  function sync2(path4, options3) {
    return checkStat(fs2.statSync(path4), options3);
  }
  function checkStat(stat2, options3) {
    return stat2.isFile() && checkMode(stat2, options3);
  }
  function checkMode(stat2, options3) {
    var mod = stat2.mode;
    var uid = stat2.uid;
    var gid = stat2.gid;
    var myUid = options3.uid !== void 0 ? options3.uid : process.getuid && process.getuid();
    var myGid = options3.gid !== void 0 ? options3.gid : process.getgid && process.getgid();
    var u = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o = parseInt("001", 8);
    var ug = u | g;
    var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret;
  }
  return mode;
}
var core;
if (process.platform === "win32" || commonjsGlobal.TESTING_WINDOWS) {
  core = requireWindows();
} else {
  core = requireMode();
}
var isexe_1 = isexe$1;
isexe$1.sync = sync;
function isexe$1(path4, options3, cb) {
  if (typeof options3 === "function") {
    cb = options3;
    options3 = {};
  }
  if (!cb) {
    if (typeof Promise !== "function") {
      throw new TypeError("callback not provided");
    }
    return new Promise(function(resolve3, reject) {
      isexe$1(path4, options3 || {}, function(er, is) {
        if (er) {
          reject(er);
        } else {
          resolve3(is);
        }
      });
    });
  }
  core(path4, options3 || {}, function(er, is) {
    if (er) {
      if (er.code === "EACCES" || options3 && options3.ignoreErrors) {
        er = null;
        is = false;
      }
    }
    cb(er, is);
  });
}
function sync(path4, options3) {
  try {
    return core.sync(path4, options3 || {});
  } catch (er) {
    if (options3 && options3.ignoreErrors || er.code === "EACCES") {
      return false;
    } else {
      throw er;
    }
  }
}
var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
var path$2 = import_path.default;
var COLON = isWindows ? ";" : ":";
var isexe = isexe_1;
var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
var getPathInfo = (cmd, opt) => {
  const colon = opt.colon || COLON;
  const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
    ...isWindows ? [process.cwd()] : [],
    ...(opt.path || process.env.PATH || "").split(colon)
  ];
  const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
  const pathExt = isWindows ? pathExtExe.split(colon) : [""];
  if (isWindows) {
    if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
      pathExt.unshift("");
  }
  return {
    pathEnv,
    pathExt,
    pathExtExe
  };
};
var which$1 = (cmd, opt, cb) => {
  if (typeof opt === "function") {
    cb = opt;
    opt = {};
  }
  if (!opt)
    opt = {};
  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
  const found2 = [];
  const step = (i) => new Promise((resolve3, reject) => {
    if (i === pathEnv.length)
      return opt.all && found2.length ? resolve3(found2) : reject(getNotFoundError(cmd));
    const ppRaw = pathEnv[i];
    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
    const pCmd = path$2.join(pathPart, cmd);
    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
    resolve3(subStep(p, i, 0));
  });
  const subStep = (p, i, ii) => new Promise((resolve3, reject) => {
    if (ii === pathExt.length)
      return resolve3(step(i + 1));
    const ext2 = pathExt[ii];
    isexe(p + ext2, { pathExt: pathExtExe }, (er, is) => {
      if (!er && is) {
        if (opt.all)
          found2.push(p + ext2);
        else
          return resolve3(p + ext2);
      }
      return resolve3(subStep(p, i, ii + 1));
    });
  });
  return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
};
var whichSync = (cmd, opt) => {
  opt = opt || {};
  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
  const found2 = [];
  for (let i = 0; i < pathEnv.length; i++) {
    const ppRaw = pathEnv[i];
    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
    const pCmd = path$2.join(pathPart, cmd);
    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
    for (let j = 0; j < pathExt.length; j++) {
      const cur = p + pathExt[j];
      try {
        const is = isexe.sync(cur, { pathExt: pathExtExe });
        if (is) {
          if (opt.all)
            found2.push(cur);
          else
            return cur;
        }
      } catch (ex) {
      }
    }
  }
  if (opt.all && found2.length)
    return found2;
  if (opt.nothrow)
    return null;
  throw getNotFoundError(cmd);
};
var which_1 = which$1;
which$1.sync = whichSync;
var pathKey$1 = { exports: {} };
var pathKey = (options3 = {}) => {
  const environment = options3.env || process.env;
  const platform2 = options3.platform || process.platform;
  if (platform2 !== "win32") {
    return "PATH";
  }
  return Object.keys(environment).reverse().find((key2) => key2.toUpperCase() === "PATH") || "Path";
};
pathKey$1.exports = pathKey;
pathKey$1.exports.default = pathKey;
var path$1 = import_path.default;
var which = which_1;
var getPathKey = pathKey$1.exports;
function resolveCommandAttempt(parsed, withoutPathExt) {
  const env2 = parsed.options.env || process.env;
  const cwd = process.cwd();
  const hasCustomCwd = parsed.options.cwd != null;
  const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
  if (shouldSwitchCwd) {
    try {
      process.chdir(parsed.options.cwd);
    } catch (err) {
    }
  }
  let resolved;
  try {
    resolved = which.sync(parsed.command, {
      path: env2[getPathKey({ env: env2 })],
      pathExt: withoutPathExt ? path$1.delimiter : void 0
    });
  } catch (e) {
  } finally {
    if (shouldSwitchCwd) {
      process.chdir(cwd);
    }
  }
  if (resolved) {
    resolved = path$1.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
  }
  return resolved;
}
function resolveCommand$1(parsed) {
  return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
}
var resolveCommand_1 = resolveCommand$1;
var _escape = {};
var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
function escapeCommand(arg) {
  arg = arg.replace(metaCharsRegExp, "^$1");
  return arg;
}
function escapeArgument(arg, doubleEscapeMetaChars) {
  arg = `${arg}`;
  arg = arg.replace(/(\\*)"/g, '$1$1\\"');
  arg = arg.replace(/(\\*)$/, "$1$1");
  arg = `"${arg}"`;
  arg = arg.replace(metaCharsRegExp, "^$1");
  if (doubleEscapeMetaChars) {
    arg = arg.replace(metaCharsRegExp, "^$1");
  }
  return arg;
}
_escape.command = escapeCommand;
_escape.argument = escapeArgument;
var shebangRegex$1 = /^#!(.*)/;
var shebangRegex = shebangRegex$1;
var shebangCommand$1 = (string2 = "") => {
  const match = string2.match(shebangRegex);
  if (!match) {
    return null;
  }
  const [path4, argument] = match[0].replace(/#! ?/, "").split(" ");
  const binary2 = path4.split("/").pop();
  if (binary2 === "env") {
    return argument;
  }
  return argument ? `${binary2} ${argument}` : binary2;
};
var fs = import_fs.default;
var shebangCommand = shebangCommand$1;
function readShebang$1(command) {
  const size = 150;
  const buffer2 = Buffer.alloc(size);
  let fd;
  try {
    fd = fs.openSync(command, "r");
    fs.readSync(fd, buffer2, 0, size, 0);
    fs.closeSync(fd);
  } catch (e) {
  }
  return shebangCommand(buffer2.toString());
}
var readShebang_1 = readShebang$1;
var path3 = import_path.default;
var resolveCommand = resolveCommand_1;
var escape$1 = _escape;
var readShebang = readShebang_1;
var isWin$1 = process.platform === "win32";
var isExecutableRegExp = /\.(?:com|exe)$/i;
var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
function detectShebang(parsed) {
  parsed.file = resolveCommand(parsed);
  const shebang = parsed.file && readShebang(parsed.file);
  if (shebang) {
    parsed.args.unshift(parsed.file);
    parsed.command = shebang;
    return resolveCommand(parsed);
  }
  return parsed.file;
}
function parseNonShell(parsed) {
  if (!isWin$1) {
    return parsed;
  }
  const commandFile = detectShebang(parsed);
  const needsShell = !isExecutableRegExp.test(commandFile);
  if (parsed.options.forceShell || needsShell) {
    const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
    parsed.command = path3.normalize(parsed.command);
    parsed.command = escape$1.command(parsed.command);
    parsed.args = parsed.args.map((arg) => escape$1.argument(arg, needsDoubleEscapeMetaChars));
    const shellCommand = [parsed.command].concat(parsed.args).join(" ");
    parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
    parsed.command = process.env.comspec || "cmd.exe";
    parsed.options.windowsVerbatimArguments = true;
  }
  return parsed;
}
function parse$1(command, args, options3) {
  if (args && !Array.isArray(args)) {
    options3 = args;
    args = null;
  }
  args = args ? args.slice(0) : [];
  options3 = Object.assign({}, options3);
  const parsed = {
    command,
    args,
    options: options3,
    file: void 0,
    original: {
      command,
      args
    }
  };
  return options3.shell ? parsed : parseNonShell(parsed);
}
var parse_1 = parse$1;
var isWin = process.platform === "win32";
function notFoundError(original, syscall) {
  return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
    code: "ENOENT",
    errno: "ENOENT",
    syscall: `${syscall} ${original.command}`,
    path: original.command,
    spawnargs: original.args
  });
}
function hookChildProcess(cp2, parsed) {
  if (!isWin) {
    return;
  }
  const originalEmit = cp2.emit;
  cp2.emit = function(name, arg1) {
    if (name === "exit") {
      const err = verifyENOENT(arg1, parsed);
      if (err) {
        return originalEmit.call(cp2, "error", err);
      }
    }
    return originalEmit.apply(cp2, arguments);
  };
}
function verifyENOENT(status2, parsed) {
  if (isWin && status2 === 1 && !parsed.file) {
    return notFoundError(parsed.original, "spawn");
  }
  return null;
}
function verifyENOENTSync(status2, parsed) {
  if (isWin && status2 === 1 && !parsed.file) {
    return notFoundError(parsed.original, "spawnSync");
  }
  return null;
}
var enoent$1 = {
  hookChildProcess,
  verifyENOENT,
  verifyENOENTSync,
  notFoundError
};
var cp = import_child_process.default;
var parse5 = parse_1;
var enoent = enoent$1;
function spawn(command, args, options3) {
  const parsed = parse5(command, args, options3);
  const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
  enoent.hookChildProcess(spawned, parsed);
  return spawned;
}
function spawnSync(command, args, options3) {
  const parsed = parse5(command, args, options3);
  const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
  result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
  return result;
}
crossSpawn.exports = spawn;
crossSpawn.exports.spawn = spawn;
crossSpawn.exports.sync = spawnSync;
crossSpawn.exports._parse = parse5;
crossSpawn.exports._enoent = enoent;
function openBrowser(url2, opt, logger) {
  const browser2 = typeof opt === "string" ? opt : process.env.BROWSER || "";
  if (browser2.toLowerCase().endsWith(".js")) {
    return executeNodeScript(browser2, url2, logger);
  } else if (browser2.toLowerCase() !== "none") {
    return startBrowserProcess(browser2, url2);
  }
  return false;
}
function executeNodeScript(scriptPath, url2, logger) {
  const extraArgs = process.argv.slice(2);
  const child = crossSpawn.exports(process.execPath, [scriptPath, ...extraArgs, url2], {
    stdio: "inherit"
  });
  child.on("close", (code) => {
    if (code !== 0) {
      logger.error(picocolors.exports.red(`
The script specified as BROWSER environment variable failed.

${picocolors.exports.cyan(scriptPath)} exited with code ${code}.`), { error: null });
    }
  });
  return true;
}
var supportedChromiumBrowsers = [
  "Google Chrome Canary",
  "Google Chrome Dev",
  "Google Chrome Beta",
  "Google Chrome",
  "Microsoft Edge",
  "Brave Browser",
  "Vivaldi",
  "Chromium"
];
function startBrowserProcess(browser2, url2) {
  const preferredOSXBrowser = browser2 === "google chrome" ? "Google Chrome" : browser2;
  const shouldTryOpenChromeWithAppleScript = process.platform === "darwin" && (!preferredOSXBrowser || supportedChromiumBrowsers.includes(preferredOSXBrowser));
  if (shouldTryOpenChromeWithAppleScript) {
    try {
      const ps = (0, import_node_child_process.execSync)("ps cax").toString();
      const openedBrowser = preferredOSXBrowser && ps.includes(preferredOSXBrowser) ? preferredOSXBrowser : supportedChromiumBrowsers.find((b) => ps.includes(b));
      (0, import_node_child_process.execSync)(`osascript openChrome.applescript "${encodeURI(url2)}" "${openedBrowser}"`, {
        cwd: (0, import_node_path2.join)(VITE_PACKAGE_DIR, "bin"),
        stdio: "ignore"
      });
      return true;
    } catch (err) {
    }
  }
  if (process.platform === "darwin" && browser2 === "open") {
    browser2 = void 0;
  }
  try {
    const options3 = browser2 ? { app: { name: browser2 } } : {};
    open_1(url2, options3).catch(() => {
    });
    return true;
  } catch (err) {
    return false;
  }
}
async function createServer(inlineConfig = {}) {
  const config2 = await resolveConfig(inlineConfig, "serve", "development");
  const { root: root2, server: serverConfig } = config2;
  const httpsOptions = await resolveHttpsConfig(config2.server.https);
  const { middlewareMode } = serverConfig;
  const resolvedWatchOptions = resolveChokidarOptions({
    disableGlobbing: true,
    ...serverConfig.watch
  });
  const middlewares = connect();
  const httpServer = middlewareMode ? null : await resolveHttpServer(serverConfig, middlewares, httpsOptions);
  const ws = createWebSocketServer(httpServer, config2, httpsOptions);
  if (httpServer) {
    setClientErrorHandler(httpServer, config2.logger);
  }
  const watcher = chokidar.watch(import_node_path2.default.resolve(root2), resolvedWatchOptions);
  const moduleGraph = new ModuleGraph((url2, ssr) => container.resolveId(url2, void 0, { ssr }));
  const container = await createPluginContainer(config2, moduleGraph, watcher);
  const closeHttpServer = createServerCloseFn(httpServer);
  let exitProcess;
  const server2 = {
    config: config2,
    middlewares,
    httpServer,
    watcher,
    pluginContainer: container,
    ws,
    moduleGraph,
    resolvedUrls: null,
    ssrTransform(code, inMap, url2, originalCode = code) {
      return ssrTransform(code, inMap, url2, originalCode, server2.config);
    },
    transformRequest(url2, options3) {
      return transformRequest(url2, server2, options3);
    },
    transformIndexHtml: null,
    async ssrLoadModule(url2, opts) {
      if (isDepsOptimizerEnabled(config2, true)) {
        await initDevSsrDepsOptimizer(config2, server2);
      }
      await updateCjsSsrExternals(server2);
      return ssrLoadModule(url2, server2, void 0, void 0, opts == null ? void 0 : opts.fixStacktrace);
    },
    ssrFixStacktrace(e) {
      if (e.stack) {
        const stacktrace = ssrRewriteStacktrace(e.stack, moduleGraph);
        rebindErrorStacktrace(e, stacktrace);
      }
    },
    ssrRewriteStacktrace(stack2) {
      return ssrRewriteStacktrace(stack2, moduleGraph);
    },
    async reloadModule(module2) {
      if (serverConfig.hmr !== false && module2.file) {
        updateModules(module2.file, [module2], Date.now(), server2);
      }
    },
    async listen(port, isRestart) {
      await startServer(server2, port, isRestart);
      if (httpServer) {
        server2.resolvedUrls = await resolveServerUrls(httpServer, config2.server, config2);
      }
      return server2;
    },
    async close() {
      var _a, _b;
      if (!middlewareMode) {
        process.off("SIGTERM", exitProcess);
        if (process.env.CI !== "true") {
          process.stdin.off("end", exitProcess);
        }
      }
      await Promise.all([
        watcher.close(),
        ws.close(),
        container.close(),
        (_a = getDepsOptimizer(server2.config)) == null ? void 0 : _a.close(),
        (_b = getDepsOptimizer(server2.config, true)) == null ? void 0 : _b.close(),
        closeHttpServer()
      ]);
      server2.resolvedUrls = null;
    },
    printUrls() {
      if (server2.resolvedUrls) {
        printServerUrls(server2.resolvedUrls, serverConfig.host, config2.logger.info);
      } else if (middlewareMode) {
        throw new Error("cannot print server URLs in middleware mode.");
      } else {
        throw new Error("cannot print server URLs before server.listen is called.");
      }
    },
    async restart(forceOptimize) {
      if (!server2._restartPromise) {
        server2._forceOptimizeOnRestart = !!forceOptimize;
        server2._restartPromise = restartServer(server2).finally(() => {
          server2._restartPromise = null;
          server2._forceOptimizeOnRestart = false;
        });
      }
      return server2._restartPromise;
    },
    _ssrExternals: null,
    _restartPromise: null,
    _importGlobMap: /* @__PURE__ */ new Map(),
    _forceOptimizeOnRestart: false,
    _pendingRequests: /* @__PURE__ */ new Map(),
    _fsDenyGlob: picomatch$3(config2.server.fs.deny, { matchBase: true })
  };
  server2.transformIndexHtml = createDevHtmlTransformFn(server2);
  if (!middlewareMode) {
    exitProcess = async () => {
      try {
        await server2.close();
      } finally {
        process.exit();
      }
    };
    process.once("SIGTERM", exitProcess);
    if (process.env.CI !== "true") {
      process.stdin.on("end", exitProcess);
    }
  }
  const { packageCache } = config2;
  const setPackageData = packageCache.set.bind(packageCache);
  packageCache.set = (id, pkg) => {
    if (id.endsWith(".json")) {
      watcher.add(id);
    }
    return setPackageData(id, pkg);
  };
  watcher.on("change", async (file) => {
    file = normalizePath$3(file);
    if (file.endsWith("/package.json")) {
      return invalidatePackageData(packageCache, file);
    }
    moduleGraph.onFileChange(file);
    if (serverConfig.hmr !== false) {
      try {
        await handleHMRUpdate(file, server2);
      } catch (err) {
        ws.send({
          type: "error",
          err: prepareError(err)
        });
      }
    }
  });
  watcher.on("add", (file) => {
    handleFileAddUnlink(normalizePath$3(file), server2);
  });
  watcher.on("unlink", (file) => {
    handleFileAddUnlink(normalizePath$3(file), server2);
  });
  ws.on("vite:invalidate", async ({ path: path4 }) => {
    const mod = moduleGraph.urlToModuleMap.get(path4);
    if (mod && mod.isSelfAccepting && mod.lastHMRTimestamp > 0) {
      const file = getShortName(mod.file, config2.root);
      updateModules(file, [...mod.importers], mod.lastHMRTimestamp, server2);
    }
  });
  if (!middlewareMode && httpServer) {
    httpServer.once("listening", () => {
      serverConfig.port = httpServer.address().port;
    });
  }
  const postHooks = [];
  for (const hook of config2.getSortedPluginHooks("configureServer")) {
    postHooks.push(await hook(server2));
  }
  if (process.env.DEBUG) {
    middlewares.use(timeMiddleware(root2));
  }
  const { cors } = serverConfig;
  if (cors !== false) {
    middlewares.use(lib$1.exports(typeof cors === "boolean" ? {} : cors));
  }
  const { proxy } = serverConfig;
  if (proxy) {
    middlewares.use(proxyMiddleware(httpServer, proxy, config2));
  }
  if (config2.base !== "/") {
    middlewares.use(baseMiddleware(server2));
  }
  middlewares.use("/__open-in-editor", launchEditorMiddleware());
  if (config2.publicDir) {
    middlewares.use(servePublicMiddleware(config2.publicDir, config2.server.headers));
  }
  middlewares.use(transformMiddleware(server2));
  middlewares.use(serveRawFsMiddleware(server2));
  middlewares.use(serveStaticMiddleware(root2, server2));
  if (config2.appType === "spa" || config2.appType === "mpa") {
    middlewares.use(htmlFallbackMiddleware(root2, config2.appType === "spa"));
  }
  postHooks.forEach((fn) => fn && fn());
  if (config2.appType === "spa" || config2.appType === "mpa") {
    middlewares.use(indexHtmlMiddleware(server2));
    middlewares.use(function vite404Middleware(_, res) {
      res.statusCode = 404;
      res.end();
    });
  }
  middlewares.use(errorMiddleware(server2, middlewareMode));
  let initingServer;
  let serverInited = false;
  const initServer = async () => {
    if (serverInited) {
      return;
    }
    if (initingServer) {
      return initingServer;
    }
    initingServer = async function() {
      await container.buildStart({});
      if (isDepsOptimizerEnabled(config2, false)) {
        await initDepsOptimizer(config2, server2);
      }
      initingServer = void 0;
      serverInited = true;
    }();
    return initingServer;
  };
  if (!middlewareMode && httpServer) {
    const listen2 = httpServer.listen.bind(httpServer);
    httpServer.listen = async (port, ...args) => {
      try {
        await initServer();
      } catch (e) {
        httpServer.emit("error", e);
        return;
      }
      return listen2(port, ...args);
    };
  } else {
    await initServer();
  }
  return server2;
}
async function startServer(server2, inlinePort, isRestart = false) {
  var _a;
  const httpServer = server2.httpServer;
  if (!httpServer) {
    throw new Error("Cannot call server.listen in middleware mode.");
  }
  const options3 = server2.config.server;
  const port = (_a = inlinePort != null ? inlinePort : options3.port) != null ? _a : 5173;
  const hostname = await resolveHostname(options3.host);
  const protocol = options3.https ? "https" : "http";
  const info = server2.config.logger.info;
  const serverPort = await httpServerStart(httpServer, {
    port,
    strictPort: options3.strictPort,
    host: hostname.host,
    logger: server2.config.logger
  });
  const profileSession = global.__vite_profile_session;
  if (profileSession) {
    profileSession.post("Profiler.stop", (err, { profile }) => {
      if (!err) {
        const outPath = import_node_path2.default.resolve("./vite-profile.cpuprofile");
        import_node_fs.default.writeFileSync(outPath, JSON.stringify(profile));
        info(picocolors.exports.yellow(`  CPU profile written to ${picocolors.exports.white(picocolors.exports.dim(outPath))}
`));
      } else {
        throw err;
      }
    });
  }
  if (options3.open && !isRestart) {
    const path4 = typeof options3.open === "string" ? options3.open : server2.config.base;
    openBrowser(path4.startsWith("http") ? path4 : `${protocol}://${hostname.name}:${serverPort}${path4}`, true, server2.config.logger);
  }
}
function createServerCloseFn(server2) {
  if (!server2) {
    return () => {
    };
  }
  let hasListened = false;
  const openSockets = /* @__PURE__ */ new Set();
  server2.on("connection", (socket) => {
    openSockets.add(socket);
    socket.on("close", () => {
      openSockets.delete(socket);
    });
  });
  server2.once("listening", () => {
    hasListened = true;
  });
  return () => new Promise((resolve3, reject) => {
    openSockets.forEach((s) => s.destroy());
    if (hasListened) {
      server2.close((err) => {
        if (err) {
          reject(err);
        } else {
          resolve3();
        }
      });
    } else {
      resolve3();
    }
  });
}
function resolvedAllowDir(root2, dir) {
  return normalizePath$3(import_node_path2.default.resolve(root2, dir));
}
function resolveServerOptions(root2, raw, logger) {
  var _a, _b, _c, _d, _e;
  const server2 = {
    preTransformRequests: true,
    ...raw,
    middlewareMode: !!(raw == null ? void 0 : raw.middlewareMode)
  };
  let allowDirs = (_a = server2.fs) == null ? void 0 : _a.allow;
  const deny = ((_b = server2.fs) == null ? void 0 : _b.deny) || [".env", ".env.*", "*.{crt,pem}"];
  if (!allowDirs) {
    allowDirs = [searchForWorkspaceRoot(root2)];
  }
  allowDirs = allowDirs.map((i) => resolvedAllowDir(root2, i));
  const resolvedClientDir = resolvedAllowDir(root2, CLIENT_DIR);
  if (!allowDirs.some((dir) => isParentDirectory(dir, resolvedClientDir))) {
    allowDirs.push(resolvedClientDir);
  }
  server2.fs = {
    strict: (_d = (_c = server2.fs) == null ? void 0 : _c.strict) != null ? _d : true,
    allow: allowDirs,
    deny
  };
  if ((_e = server2.origin) == null ? void 0 : _e.endsWith("/")) {
    server2.origin = server2.origin.slice(0, -1);
    logger.warn(picocolors.exports.yellow(`${picocolors.exports.bold("(!)")} server.origin should not end with "/". Using "${server2.origin}" instead.`));
  }
  return server2;
}
async function restartServer(server2) {
  global.__vite_start_time = import_node_perf_hooks.performance.now();
  const { port: prevPort, host: prevHost } = server2.config.server;
  await server2.close();
  let inlineConfig = server2.config.inlineConfig;
  if (server2._forceOptimizeOnRestart) {
    inlineConfig = mergeConfig(inlineConfig, {
      optimizeDeps: {
        force: true
      }
    });
  }
  let newServer = null;
  try {
    newServer = await createServer(inlineConfig);
  } catch (err) {
    server2.config.logger.error(err.message, {
      timestamp: true
    });
    return;
  }
  for (const key2 in newServer) {
    if (key2 === "_restartPromise") {
      newServer[key2] = server2[key2];
    } else {
      server2[key2] = newServer[key2];
    }
  }
  const { logger, server: { port, host, middlewareMode } } = server2.config;
  if (!middlewareMode) {
    await server2.listen(port, true);
    logger.info("server restarted.", { timestamp: true });
    if (port !== prevPort || host !== prevHost) {
      logger.info("");
      server2.printUrls();
    }
  } else {
    logger.info("server restarted.", { timestamp: true });
  }
  newServer._restartPromise = null;
}
async function updateCjsSsrExternals(server2) {
  if (!server2._ssrExternals) {
    let knownImports = [];
    const depsOptimizer = getDepsOptimizer(server2.config, false);
    if (depsOptimizer) {
      await depsOptimizer.scanProcessing;
      knownImports = [
        ...Object.keys(depsOptimizer.metadata.optimized),
        ...Object.keys(depsOptimizer.metadata.discovered)
      ];
    }
    server2._ssrExternals = cjsSsrResolveExternals(server2.config, knownImports);
  }
}
var index = {
  __proto__: null,
  createServer,
  resolveServerOptions,
  searchForWorkspaceRoot
};
var noop = () => {
};
var mimes = /text|javascript|\/json|xml/i;
var threshold = 1024;
var level = -1;
var brotli = false;
var getChunkSize = (chunk, enc) => chunk ? Buffer.byteLength(chunk, enc) : 0;
function compression() {
  const brotliOpts = typeof brotli === "object" && brotli || {};
  const gzipOpts = {};
  if (!import_node_zlib.default.createBrotliCompress)
    brotli = false;
  return (req2, res, next = noop) => {
    const accept = req2.headers["accept-encoding"] + "";
    const encoding = (brotli && accept.match(/\bbr\b/) || accept.match(/\bgzip\b/) || [])[0];
    if (req2.method === "HEAD" || !encoding)
      return next();
    let compress;
    let pendingStatus;
    let pendingListeners = [];
    let started = false;
    let size = 0;
    function start() {
      started = true;
      size = res.getHeader("Content-Length") | 0 || size;
      const compressible = mimes.test(String(res.getHeader("Content-Type") || "text/plain"));
      const cleartext = !res.getHeader("Content-Encoding");
      const listeners = pendingListeners || [];
      if (compressible && cleartext && size >= threshold) {
        res.setHeader("Content-Encoding", encoding);
        res.removeHeader("Content-Length");
        if (encoding === "br") {
          const params = {
            [import_node_zlib.default.constants.BROTLI_PARAM_QUALITY]: level,
            [import_node_zlib.default.constants.BROTLI_PARAM_SIZE_HINT]: size
          };
          compress = import_node_zlib.default.createBrotliCompress({
            params: Object.assign(params, brotliOpts)
          });
        } else {
          compress = import_node_zlib.default.createGzip(Object.assign({ level }, gzipOpts));
        }
        compress.on("data", (chunk) => write.call(res, chunk) === false && compress.pause());
        on.call(res, "drain", () => compress.resume());
        compress.on("end", () => end.call(res));
        listeners.forEach((p) => compress.on.apply(compress, p));
      } else {
        pendingListeners = null;
        listeners.forEach((p) => on.apply(res, p));
      }
      writeHead.call(res, pendingStatus || res.statusCode);
    }
    const { end, write, on, writeHead } = res;
    res.writeHead = function(status2, reason, headers) {
      if (typeof reason !== "string")
        [headers, reason] = [reason, headers];
      if (headers)
        for (let i in headers)
          res.setHeader(i, headers[i]);
      pendingStatus = status2;
      return this;
    };
    res.write = function(chunk, enc, cb) {
      size += getChunkSize(chunk, enc);
      if (!started)
        start();
      if (!compress)
        return write.apply(this, arguments);
      return compress.write.apply(compress, arguments);
    };
    res.end = function(chunk, enc, cb) {
      if (arguments.length > 0 && typeof chunk !== "function") {
        size += getChunkSize(chunk, enc);
      }
      if (!started)
        start();
      if (!compress)
        return end.apply(this, arguments);
      return compress.end.apply(compress, arguments);
    };
    res.on = function(type, listener2) {
      if (!pendingListeners || type !== "drain")
        on.call(this, type, listener2);
      else if (compress)
        compress.on(type, listener2);
      else
        pendingListeners.push([type, listener2]);
      return this;
    };
    next();
  };
}
function resolvePreviewOptions(preview2, server2) {
  var _a, _b, _c, _d, _e, _f, _g;
  return {
    port: preview2 == null ? void 0 : preview2.port,
    strictPort: (_a = preview2 == null ? void 0 : preview2.strictPort) != null ? _a : server2.strictPort,
    host: (_b = preview2 == null ? void 0 : preview2.host) != null ? _b : server2.host,
    https: (_c = preview2 == null ? void 0 : preview2.https) != null ? _c : server2.https,
    open: (_d = preview2 == null ? void 0 : preview2.open) != null ? _d : server2.open,
    proxy: (_e = preview2 == null ? void 0 : preview2.proxy) != null ? _e : server2.proxy,
    cors: (_f = preview2 == null ? void 0 : preview2.cors) != null ? _f : server2.cors,
    headers: (_g = preview2 == null ? void 0 : preview2.headers) != null ? _g : server2.headers
  };
}
async function preview(inlineConfig = {}) {
  var _a, _b;
  const config2 = await resolveConfig(inlineConfig, "serve", "production");
  const app = connect();
  const httpServer = await resolveHttpServer(config2.preview, app, await resolveHttpsConfig((_a = config2.preview) == null ? void 0 : _a.https));
  setClientErrorHandler(httpServer, config2.logger);
  const postHooks = [];
  for (const hook of config2.getSortedPluginHooks("configurePreviewServer")) {
    postHooks.push(await hook({ middlewares: app, httpServer }));
  }
  const { cors } = config2.preview;
  if (cors !== false) {
    app.use(lib$1.exports(typeof cors === "boolean" ? {} : cors));
  }
  const { proxy } = config2.preview;
  if (proxy) {
    app.use(proxyMiddleware(httpServer, proxy, config2));
  }
  app.use(compression());
  const previewBase = config2.base === "./" || config2.base === "" ? "/" : config2.base;
  const distDir = import_node_path2.default.resolve(config2.root, config2.build.outDir);
  const headers = config2.preview.headers;
  app.use(previewBase, sirv(distDir, {
    etag: true,
    dev: true,
    single: config2.appType === "spa",
    setHeaders(res) {
      if (headers) {
        for (const name in headers) {
          res.setHeader(name, headers[name]);
        }
      }
    }
  }));
  postHooks.forEach((fn) => fn && fn());
  const options3 = config2.preview;
  const hostname = await resolveHostname(options3.host);
  const port = (_b = options3.port) != null ? _b : 4173;
  const protocol = options3.https ? "https" : "http";
  const logger = config2.logger;
  const serverPort = await httpServerStart(httpServer, {
    port,
    strictPort: options3.strictPort,
    host: hostname.host,
    logger
  });
  const resolvedUrls = await resolveServerUrls(httpServer, config2.preview, config2);
  if (options3.open) {
    const path4 = typeof options3.open === "string" ? options3.open : previewBase;
    openBrowser(path4.startsWith("http") ? path4 : `${protocol}://${hostname.name}:${serverPort}${path4}`, true, logger);
  }
  return {
    config: config2,
    httpServer,
    resolvedUrls,
    printUrls() {
      printServerUrls(resolvedUrls, options3.host, logger.info);
    }
  };
}
var preview$1 = {
  __proto__: null,
  resolvePreviewOptions,
  preview
};
function resolveSSROptions(ssr, preserveSymlinks, buildSsrCjsExternalHeuristics) {
  var _a;
  ssr != null ? ssr : ssr = {};
  const optimizeDeps2 = (_a = ssr.optimizeDeps) != null ? _a : {};
  let format2 = "esm";
  let target = "node";
  if (buildSsrCjsExternalHeuristics) {
    if (ssr) {
      format2 = "cjs";
    } else {
      target = "node";
      format2 = "cjs";
    }
  }
  return {
    format: format2,
    target,
    ...ssr,
    optimizeDeps: {
      disabled: true,
      ...optimizeDeps2,
      esbuildOptions: {
        preserveSymlinks,
        ...optimizeDeps2.esbuildOptions
      }
    }
  };
}
var debug = createDebugger("vite:config");
function defineConfig(config2) {
  return config2;
}
async function resolveConfig(inlineConfig, command, defaultMode = "development") {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C;
  let config2 = inlineConfig;
  let configFileDependencies = [];
  let mode2 = inlineConfig.mode || defaultMode;
  if (mode2 === "production") {
    "development" = "production";
  }
  if (command === "serve" && false) {
    "development" = "development";
  }
  const configEnv = {
    mode: mode2,
    command,
    ssrBuild: !!((_a = config2.build) == null ? void 0 : _a.ssr)
  };
  let { configFile: configFile2 } = config2;
  if (configFile2 !== false) {
    const loadResult = await loadConfigFromFile(configEnv, configFile2, config2.root, config2.logLevel);
    if (loadResult) {
      config2 = mergeConfig(loadResult.config, config2);
      configFile2 = loadResult.path;
      configFileDependencies = loadResult.dependencies;
    }
  }
  mode2 = inlineConfig.mode || config2.mode || mode2;
  configEnv.mode = mode2;
  const filterPlugin = (p) => {
    if (!p) {
      return false;
    } else if (!p.apply) {
      return true;
    } else if (typeof p.apply === "function") {
      return p.apply({ ...config2, mode: mode2 }, configEnv);
    } else {
      return p.apply === command;
    }
  };
  const rawWorkerUserPlugins = (await asyncFlatten(((_b = config2.worker) == null ? void 0 : _b.plugins) || [])).filter(filterPlugin);
  const rawUserPlugins = (await asyncFlatten(config2.plugins || [])).filter(filterPlugin);
  const [prePlugins, normalPlugins, postPlugins] = sortUserPlugins(rawUserPlugins);
  const userPlugins = [...prePlugins, ...normalPlugins, ...postPlugins];
  config2 = await runConfigHook(config2, userPlugins, configEnv);
  if (process.env.VITE_TEST_WITHOUT_PLUGIN_COMMONJS) {
    config2 = mergeConfig(config2, {
      optimizeDeps: { disabled: false },
      ssr: { optimizeDeps: { disabled: false } }
    });
    (_c = config2.build) != null ? _c : config2.build = {};
    config2.build.commonjsOptions = { include: [] };
  }
  const logger = createLogger(config2.logLevel, {
    allowClearScreen: config2.clearScreen,
    customLogger: config2.customLogger
  });
  const resolvedRoot = normalizePath$3(config2.root ? import_node_path2.default.resolve(config2.root) : process.cwd());
  const clientAlias = [
    { find: /^[\/]?@vite\/env/, replacement: () => ENV_ENTRY },
    { find: /^[\/]?@vite\/client/, replacement: () => CLIENT_ENTRY }
  ];
  const resolvedAlias = normalizeAlias(mergeAlias(
    clientAlias,
    ((_d = config2.resolve) == null ? void 0 : _d.alias) || []
  ));
  const resolveOptions = {
    mainFields: (_f = (_e = config2.resolve) == null ? void 0 : _e.mainFields) != null ? _f : DEFAULT_MAIN_FIELDS,
    browserField: (_h = (_g = config2.resolve) == null ? void 0 : _g.browserField) != null ? _h : true,
    conditions: (_j = (_i = config2.resolve) == null ? void 0 : _i.conditions) != null ? _j : [],
    extensions: (_l = (_k = config2.resolve) == null ? void 0 : _k.extensions) != null ? _l : DEFAULT_EXTENSIONS,
    dedupe: (_n = (_m = config2.resolve) == null ? void 0 : _m.dedupe) != null ? _n : [],
    preserveSymlinks: (_p = (_o = config2.resolve) == null ? void 0 : _o.preserveSymlinks) != null ? _p : false,
    alias: resolvedAlias
  };
  const envDir = config2.envDir ? normalizePath$3(import_node_path2.default.resolve(resolvedRoot, config2.envDir)) : resolvedRoot;
  const userEnv = inlineConfig.envFile !== false && loadEnv(mode2, envDir, resolveEnvPrefix(config2));
  const isProduction = false;
  if (isProduction) {
    "development" = "production";
  }
  const isBuild = command === "build";
  const relativeBaseShortcut = config2.base === "" || config2.base === "./";
  const resolvedBase = relativeBaseShortcut ? !isBuild || ((_q = config2.build) == null ? void 0 : _q.ssr) ? "/" : "./" : (_r = resolveBaseUrl(config2.base, isBuild, logger)) != null ? _r : "/";
  const resolvedBuildOptions = resolveBuildOptions(config2.build, logger);
  const pkgPath = lookupFile(resolvedRoot, [`package.json`], { pathOnly: true });
  const cacheDir = config2.cacheDir ? import_node_path2.default.resolve(resolvedRoot, config2.cacheDir) : pkgPath ? import_node_path2.default.join(import_node_path2.default.dirname(pkgPath), `node_modules/.vite`) : import_node_path2.default.join(resolvedRoot, `.vite`);
  const assetsFilter = config2.assetsInclude && (!(config2.assetsInclude instanceof Array) || config2.assetsInclude.length) ? createFilter3(config2.assetsInclude) : () => false;
  const createResolver = (options3) => {
    let aliasContainer;
    let resolverContainer;
    return async (id, importer, aliasOnly, ssr2) => {
      var _a2;
      let container;
      if (aliasOnly) {
        container = aliasContainer || (aliasContainer = await createPluginContainer({
          ...resolved,
          plugins: [alias$1({ entries: resolved.resolve.alias })]
        }));
      } else {
        container = resolverContainer || (resolverContainer = await createPluginContainer({
          ...resolved,
          plugins: [
            alias$1({ entries: resolved.resolve.alias }),
            resolvePlugin({
              ...resolved.resolve,
              root: resolvedRoot,
              isProduction,
              isBuild: command === "build",
              ssrConfig: resolved.ssr,
              asSrc: true,
              preferRelative: false,
              tryIndex: true,
              ...options3
            })
          ]
        }));
      }
      return (_a2 = await container.resolveId(id, importer, { ssr: ssr2, scan: options3 == null ? void 0 : options3.scan })) == null ? void 0 : _a2.id;
    };
  };
  const { publicDir } = config2;
  const resolvedPublicDir = publicDir !== false && publicDir !== "" ? import_node_path2.default.resolve(resolvedRoot, typeof publicDir === "string" ? publicDir : "public") : "";
  const server2 = resolveServerOptions(resolvedRoot, config2.server, logger);
  const ssr = resolveSSROptions(config2.ssr, resolveOptions.preserveSymlinks, (_s = config2.legacy) == null ? void 0 : _s.buildSsrCjsExternalHeuristics);
  const middlewareMode = (_t = config2 == null ? void 0 : config2.server) == null ? void 0 : _t.middlewareMode;
  const optimizeDeps2 = config2.optimizeDeps || {};
  const BASE_URL = resolvedBase;
  let workerConfig = mergeConfig({}, config2);
  const [workerPrePlugins, workerNormalPlugins, workerPostPlugins] = sortUserPlugins(rawWorkerUserPlugins);
  const workerUserPlugins = [
    ...workerPrePlugins,
    ...workerNormalPlugins,
    ...workerPostPlugins
  ];
  workerConfig = await runConfigHook(workerConfig, workerUserPlugins, configEnv);
  const resolvedWorkerOptions = {
    format: ((_u = workerConfig.worker) == null ? void 0 : _u.format) || "iife",
    plugins: [],
    rollupOptions: ((_v = workerConfig.worker) == null ? void 0 : _v.rollupOptions) || {},
    getSortedPlugins: void 0,
    getSortedPluginHooks: void 0
  };
  const resolvedConfig = {
    configFile: configFile2 ? normalizePath$3(configFile2) : void 0,
    configFileDependencies: configFileDependencies.map((name) => normalizePath$3(import_node_path2.default.resolve(name))),
    inlineConfig,
    root: resolvedRoot,
    base: resolvedBase,
    resolve: resolveOptions,
    publicDir: resolvedPublicDir,
    cacheDir,
    command,
    mode: mode2,
    ssr,
    isWorker: false,
    mainConfig: null,
    isProduction,
    plugins: userPlugins,
    server: server2,
    build: resolvedBuildOptions,
    preview: resolvePreviewOptions(config2.preview, server2),
    env: {
      ...userEnv,
      BASE_URL,
      MODE: mode2,
      DEV: !isProduction,
      PROD: isProduction
    },
    assetsInclude(file) {
      return DEFAULT_ASSETS_RE.test(file) || assetsFilter(file);
    },
    logger,
    packageCache: /* @__PURE__ */ new Map(),
    createResolver,
    optimizeDeps: {
      disabled: "build",
      ...optimizeDeps2,
      esbuildOptions: {
        preserveSymlinks: resolveOptions.preserveSymlinks,
        ...optimizeDeps2.esbuildOptions
      }
    },
    worker: resolvedWorkerOptions,
    appType: (_w = config2.appType) != null ? _w : middlewareMode === "ssr" ? "custom" : "spa",
    experimental: {
      importGlobRestoreExtension: false,
      hmrPartialAccept: false,
      ...config2.experimental
    },
    getSortedPlugins: void 0,
    getSortedPluginHooks: void 0
  };
  const resolved = {
    ...config2,
    ...resolvedConfig
  };
  resolved.plugins = await resolvePlugins(resolved, prePlugins, normalPlugins, postPlugins);
  Object.assign(resolved, createPluginHookUtils(resolved.plugins));
  const workerResolved = {
    ...workerConfig,
    ...resolvedConfig,
    isWorker: true,
    mainConfig: resolved
  };
  resolvedConfig.worker.plugins = await resolvePlugins(workerResolved, workerPrePlugins, workerNormalPlugins, workerPostPlugins);
  Object.assign(resolvedConfig.worker, createPluginHookUtils(resolvedConfig.worker.plugins));
  await Promise.all([
    ...resolved.getSortedPluginHooks("configResolved").map((hook) => hook(resolved)),
    ...resolvedConfig.worker.getSortedPluginHooks("configResolved").map((hook) => hook(workerResolved))
  ]);
  if (middlewareMode === "ssr") {
    logger.warn(picocolors.exports.yellow(`Setting server.middlewareMode to 'ssr' is deprecated, set server.middlewareMode to \`true\`${config2.appType === "custom" ? "" : ` and appType to 'custom'`} instead`));
  }
  if (middlewareMode === "html") {
    logger.warn(picocolors.exports.yellow(`Setting server.middlewareMode to 'html' is deprecated, set server.middlewareMode to \`true\` instead`));
  }
  if (((_x = config2.server) == null ? void 0 : _x.force) && !isBuild && ((_y = config2.optimizeDeps) == null ? void 0 : _y.force) === void 0) {
    resolved.optimizeDeps.force = true;
    logger.warn(picocolors.exports.yellow(`server.force is deprecated, use optimizeDeps.force instead`));
  }
  if (process.env.DEBUG) {
    debug(`using resolved config: %O`, {
      ...resolved,
      plugins: resolved.plugins.map((p) => p.name),
      worker: {
        ...resolved.worker,
        plugins: resolved.worker.plugins.map((p) => p.name)
      }
    });
  }
  if (((_z = config2.build) == null ? void 0 : _z.terserOptions) && config2.build.minify !== "terser") {
    logger.warn(picocolors.exports.yellow(`build.terserOptions is specified but build.minify is not set to use Terser. Note Vite now defaults to use esbuild for minification. If you still prefer Terser, set build.minify to "terser".`));
  }
  const outputOption = (_C = (_B = (_A = config2.build) == null ? void 0 : _A.rollupOptions) == null ? void 0 : _B.output) != null ? _C : [];
  if (Array.isArray(outputOption)) {
    const assetFileNamesList = outputOption.map((output) => output.assetFileNames);
    if (assetFileNamesList.length > 1) {
      const firstAssetFileNames = assetFileNamesList[0];
      const hasDifferentReference = assetFileNamesList.some((assetFileNames) => assetFileNames !== firstAssetFileNames);
      if (hasDifferentReference) {
        resolved.logger.warn(picocolors.exports.yellow(`
assetFileNames isn't equal for every build.rollupOptions.output. A single pattern across all outputs is supported by Vite.
`));
      }
    }
  }
  return resolved;
}
function resolveBaseUrl(base2 = "/", isBuild, logger) {
  if (base2.startsWith(".")) {
    logger.warn(picocolors.exports.yellow(picocolors.exports.bold(`(!) invalid "base" option: ${base2}. The value can only be an absolute URL, ./, or an empty string.`)));
    base2 = "/";
  }
  if (isExternalUrl(base2)) {
    if (!isBuild) {
      const parsed = (0, import_node_url2.parse)(base2);
      base2 = parsed.pathname || "/";
    }
  } else {
    if (!base2.startsWith("/")) {
      logger.warn(picocolors.exports.yellow(picocolors.exports.bold(`(!) "base" option should start with a slash.`)));
      base2 = "/" + base2;
    }
  }
  if (!base2.endsWith("/")) {
    logger.warn(picocolors.exports.yellow(picocolors.exports.bold(`(!) "base" option should end with a slash.`)));
    base2 += "/";
  }
  return base2;
}
function sortUserPlugins(plugins2) {
  const prePlugins = [];
  const postPlugins = [];
  const normalPlugins = [];
  if (plugins2) {
    plugins2.flat().forEach((p) => {
      if (p.enforce === "pre")
        prePlugins.push(p);
      else if (p.enforce === "post")
        postPlugins.push(p);
      else
        normalPlugins.push(p);
    });
  }
  return [prePlugins, normalPlugins, postPlugins];
}
async function loadConfigFromFile(configEnv, configFile2, configRoot = process.cwd(), logLevel) {
  const start = import_node_perf_hooks.performance.now();
  const getTime = () => `${(import_node_perf_hooks.performance.now() - start).toFixed(2)}ms`;
  let resolvedPath;
  if (configFile2) {
    resolvedPath = import_node_path2.default.resolve(configFile2);
  } else {
    for (const filename of DEFAULT_CONFIG_FILES) {
      const filePath = import_node_path2.default.resolve(configRoot, filename);
      if (!import_node_fs.default.existsSync(filePath))
        continue;
      resolvedPath = filePath;
      break;
    }
  }
  if (!resolvedPath) {
    debug("no config file found.");
    return null;
  }
  let isESM = false;
  if (/\.m[jt]s$/.test(resolvedPath)) {
    isESM = true;
  } else if (/\.c[jt]s$/.test(resolvedPath)) {
    isESM = false;
  } else {
    try {
      const pkg = lookupFile(configRoot, ["package.json"]);
      isESM = !!pkg && JSON.parse(pkg).type === "module";
    } catch (e) {
    }
  }
  try {
    const bundled = await bundleConfigFile(resolvedPath, isESM);
    const userConfig = await loadConfigFromBundledFile(resolvedPath, bundled.code, isESM);
    debug(`bundled config file loaded in ${getTime()}`);
    const config2 = await (typeof userConfig === "function" ? userConfig(configEnv) : userConfig);
    if (!isObject$1(config2)) {
      throw new Error(`config must export or return an object.`);
    }
    return {
      path: normalizePath$3(resolvedPath),
      config: config2,
      dependencies: bundled.dependencies
    };
  } catch (e) {
    createLogger(logLevel).error(picocolors.exports.red(`failed to load config from ${resolvedPath}`), { error: e });
    throw e;
  }
}
async function bundleConfigFile(fileName, isESM) {
  const dirnameVarName = "__vite_injected_original_dirname";
  const filenameVarName = "__vite_injected_original_filename";
  const importMetaUrlVarName = "__vite_injected_original_import_meta_url";
  const result = await (0, import_esbuild.build)({
    absWorkingDir: process.cwd(),
    entryPoints: [fileName],
    outfile: "out.js",
    write: false,
    target: ["node14.18", "node16"],
    platform: "node",
    bundle: true,
    format: isESM ? "esm" : "cjs",
    mainFields: ["main"],
    sourcemap: "inline",
    metafile: true,
    define: {
      __dirname: dirnameVarName,
      __filename: filenameVarName,
      "import.meta.url": importMetaUrlVarName
    },
    plugins: [
      {
        name: "externalize-deps",
        setup(build2) {
          const options3 = {
            root: import_node_path2.default.dirname(fileName),
            isBuild: true,
            isProduction: true,
            isRequire: !isESM,
            preferRelative: false,
            tryIndex: true,
            mainFields: [],
            browserField: false,
            conditions: [],
            overrideConditions: ["node"],
            dedupe: [],
            extensions: DEFAULT_EXTENSIONS,
            preserveSymlinks: false
          };
          build2.onResolve({ filter: /^[^.].*/ }, async ({ path: id, importer, kind }) => {
            var _a;
            if (kind === "entry-point" || import_node_path2.default.isAbsolute(id) || isBuiltin(id)) {
              return;
            }
            if (id.startsWith("npm:")) {
              return { external: true };
            }
            let idFsPath = (_a = tryNodeResolve(id, importer, options3, false)) == null ? void 0 : _a.id;
            if (idFsPath && (isESM || kind === "dynamic-import")) {
              idFsPath = (0, import_node_url2.pathToFileURL)(idFsPath).href;
            }
            return {
              path: idFsPath,
              external: true
            };
          });
        }
      },
      {
        name: "inject-file-scope-variables",
        setup(build2) {
          build2.onLoad({ filter: /\.[cm]?[jt]s$/ }, async (args) => {
            const contents = await import_node_fs.default.promises.readFile(args.path, "utf8");
            const injectValues = `const ${dirnameVarName} = ${JSON.stringify(import_node_path2.default.dirname(args.path))};const ${filenameVarName} = ${JSON.stringify(args.path)};const ${importMetaUrlVarName} = ${JSON.stringify((0, import_node_url2.pathToFileURL)(args.path).href)};`;
            return {
              loader: args.path.endsWith("ts") ? "ts" : "js",
              contents: injectValues + contents
            };
          });
        }
      }
    ]
  });
  const { text } = result.outputFiles[0];
  return {
    code: text,
    dependencies: result.metafile ? Object.keys(result.metafile.inputs) : []
  };
}
var _require = (0, import_node_module.createRequire)(import.meta.url);
async function loadConfigFromBundledFile(fileName, bundledCode, isESM) {
  if (isESM) {
    const fileBase = `${fileName}.timestamp-${Date.now()}`;
    const fileNameTmp = `${fileBase}.mjs`;
    const fileUrl = `${(0, import_node_url2.pathToFileURL)(fileBase)}.mjs`;
    import_node_fs.default.writeFileSync(fileNameTmp, bundledCode);
    try {
      return (await dynamicImport(fileUrl)).default;
    } finally {
      try {
        import_node_fs.default.unlinkSync(fileNameTmp);
      } catch {
      }
    }
  } else {
    const extension2 = import_node_path2.default.extname(fileName);
    const realFileName = import_node_fs.default.realpathSync(fileName);
    const loaderExt = extension2 in _require.extensions ? extension2 : ".js";
    const defaultLoader = _require.extensions[loaderExt];
    _require.extensions[loaderExt] = (module2, filename) => {
      if (filename === realFileName) {
        module2._compile(bundledCode, filename);
      } else {
        defaultLoader(module2, filename);
      }
    };
    delete _require.cache[_require.resolve(fileName)];
    const raw = _require(fileName);
    _require.extensions[loaderExt] = defaultLoader;
    return raw.__esModule ? raw.default : raw;
  }
}
async function runConfigHook(config2, plugins2, configEnv) {
  let conf = config2;
  for (const p of getSortedPluginsByHook("config", plugins2)) {
    const hook = p.config;
    const handler = hook && "handler" in hook ? hook.handler : hook;
    if (handler) {
      const res = await handler(conf, configEnv);
      if (res) {
        conf = mergeConfig(conf, res);
      }
    }
  }
  return conf;
}
function getDepOptimizationConfig(config2, ssr) {
  return ssr ? config2.ssr.optimizeDeps : config2.optimizeDeps;
}
function isDepsOptimizerEnabled(config2, ssr) {
  const { command } = config2;
  const { disabled } = getDepOptimizationConfig(config2, ssr);
  return !(disabled === true || command === "build" && disabled === "build" || command === "serve" && disabled === "dev");
}

export {
  require_node_fs,
  require_node_perf_hooks,
  require_tty,
  require_child_process,
  require_crypto,
  require_worker_threads,
  require_main,
  require_events,
  require_assert,
  require_util,
  require_net,
  require_http,
  require_stream,
  require_node_os,
  require_node_crypto,
  require_node_util,
  require_node_dns,
  VERSION,
  require_node_buffer,
  require_module,
  require_zlib,
  require_https,
  require_tls,
  require_querystring,
  require_node_readline,
  require_node_child_process,
  require_node_zlib,
  commonjsGlobal,
  createFilter3 as createFilter,
  normalizePath$3,
  mergeConfig,
  mergeAlias,
  createLogger,
  transformWithEsbuild,
  resolvePackageData,
  resolvePackageEntry,
  optimizeDeps,
  preprocessCSS,
  formatPostcssSourceMap,
  send$1,
  searchForWorkspaceRoot,
  loadEnv,
  resolveEnvPrefix,
  build,
  createServer,
  preview,
  defineConfig,
  resolveConfig,
  resolveBaseUrl,
  sortUserPlugins,
  loadConfigFromFile,
  getDepOptimizationConfig,
  isDepsOptimizerEnabled
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/*!
 * Array of passes.
 *
 * A `pass` is just a function that is executed on `req, res, options`
 * so that you can easily add new checks while still keeping the base
 * flexible.
 */
/*!
 * Array of passes.
 *
 * A `pass` is just a function that is executed on `req, socket, options`
 * so that you can easily add new checks while still keeping the base
 * flexible.
 */
/*!
 * Caron dimonio, con occhi di bragia
 * loro accennando, tutte le raccoglie;
 * batte col remo qualunque sadagia 
 *
 * Charon the demon, with the eyes of glede,
 * Beckoning to them, collects them all together,
 * Beats with his oar whoever lags behind
 *          
 *          Dante - The Divine Comedy (Canto III)
 */
/*!
 * connect
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
/*!
 * etag
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * finalhandler
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * unpipe
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * Autoload Config for PostCSS
 *
 * @author Michael Ciniawsky @michael-ciniawsky <michael.ciniawsky@gmail.com>
 * @license MIT
 *
 * @module postcss-load-config
 * @version 2.1.0
 *
 * @requires comsiconfig
 * @requires ./options
 * @requires ./plugins
 */
//# sourceMappingURL=chunk-PVBCDMQY.js.map
